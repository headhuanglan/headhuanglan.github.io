<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="L&#39;s Tech Blog">
<meta name="description" content="回忆未来">
<meta name="theme-color" content="#dee2e6">
<title>Lan&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1640590213489">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/obsidian.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Lan&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Welcome to Lan&#39;s Blog</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
      <div
        class="section-layout gemini ">
        <div class="section-layout-wrapper">
          <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Lan</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>My Coding Journey </p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">34</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
            <div class="section-box gemini box-shadow-wrapper">
              <section class="friends-section bg-color slide-down-in">
                <div class="firends-box" align="center">
                  <h1 class="firends-title" itemprop="name headline">
                    友情链接
                  </h1>
                  
                    
                        
                </div>
                <hr>
                <div style="text-align:center">
                  <span class="with-love">
                    <i class="fa fa-heart"></i>
                  </span>
                  <span class="language" data-lan="leave-message">如需添加友链,可以在关于中找到我的联系方式告知我</span>
                  <span class="with-love">
                    <i class="fa fa-heart"></i>
                  </span>
                </div>
                <hr>
                <div class="friends-note">
                  <p><strong class="language" data-lan="format">友链格式：</strong></p>
                  <ul>
                    <li><span class="language" data-lan="site-name">网站名称：</span>
                      Lan&#39;s Blog
                    </li>
                    <li><span class="language" data-lan="site-link">网站地址：</span><a href="https://www.yuzhang.wang/"
                        data-pjax-state="">https://www.yuzhang.wang</a></li>
                    <li><span class="language" data-lan="site-desc">网站描述：</span>
                      回忆未来
                    </li>
                    <li><span class="language" data-lan="site-img">网站头像：</span>
                      <a
                        href="https://cdn.jsdelivr.net/gh/YuZhangWang/Creative_pictures01@main/img/20210907012640.png">https://cdn.jsdelivr.net/gh/YuZhangWang/Creative_pictures01@main/img/20210907012640.png</a>
                    </li>
                  </ul>
                </div>
                
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '05c2f6d6143b092d473b',
    clientSecret: '002d0d8f99a25af450995ef32a26c1eef0041d0d',
    repo: 'headhuanglan.github.io',
    owner: 'headhuanglan',
    admin: ['headhuanglan'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

              </section>
            </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <center>
      已运行:<span id="run_time"></span>
      <span class="post-meta-divider">|</span>
      已咕咕:<span id="gugu_time"></span>
    </center>

    总字数:<span id="word_count"></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      function runTime() {
        str = "";
        BirthDay = new Date("November 01,2021");
        today = new Date();
        timeold = today.getTime() - BirthDay.getTime();
        msPerDay = 24 * 60 * 60 * 1000;
        e_daysold = timeold / msPerDay;
        daysold = Math.floor(e_daysold);
        str += daysold + "天";
        return str;
      }
      setInterval(function () {
        $("#run_time").html(runTime());
      }, 1000);
    </script>

    <script>
      function guguTime() {
        str = "";
        guguDay = new Date(document.lastModified);
        today = new Date();
        timeold = today.getTime() - guguDay.getTime();
        msPerDay = 24 * 60 * 60 * 1000;
        e_daysold = timeold / msPerDay;
        daysold = Math.floor(e_daysold);
        str += daysold + "天";
        return str;
      }
      setInterval(function () {
        $("#gugu_time").html(guguTime());
      }, 1000);
    </script>

    <script>
      function site() {

        return 275.6 + "k";
      };

      setInterval(function () {
        $("#word_count").html(site());
      }, 1000);
    </script>

    <div class="copyright">
      Created by
      <a href="https://github.com/headhuanglan" target="_blank">headhuanglan</a>
      ©2021-Present
      <span class="post-meta-divider">|</span>
      Powered By
      <a href="https://github.com/headhuanglan/headhuanglan.github.io" target="_blank">Github</a>
      <span class="post-meta-divider">|</span>
      Theme By
      <a href="https://github.com/theme-next/hexo-theme-next" target="_blank">Next</a>
    </div>
    <div class="poweredby">
      Powered by L
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-30/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;271-encode-and-decode-strings-medium&#34;&gt;271. Encode and Decode Strings (Medium)&lt;/h1&gt;
&lt;p&gt;Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Codec:
    def encode(self, strs: [str]) -&amp;gt; str:
        &amp;quot;&amp;quot;&amp;quot;Encodes a list of strings to a single string.
        &amp;quot;&amp;quot;&amp;quot;
        candidate=&#39;a&#39;
        set_ = set()
        for str in strs:
            for s in str:
                set_.add(s)
        while candidate in set_:
            candidate = chr(ord(candidate)+1)
        return candidate + candidate.join(strs)
        

    def decode(self, s: str) -&amp;gt; [str]:
        &amp;quot;&amp;quot;&amp;quot;Decodes a single string to a list of strings.
        &amp;quot;&amp;quot;&amp;quot;
        candidate = s[0]
        s = s[1:]
        return s.split(candidate)
        


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue272-closest-binary-search-tree-value-ii-hard-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;272. Closest Binary Search Tree Value II (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -&amp;gt; List[int]:
        stack  = []
        s  =[]
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            root=stack.pop()
            diff = abs(root.val-target)
            if len(s)&amp;lt;k:
                s.append((diff,root.val))
            else:
                s.sort(key=lambda x:x[0])
                if s and s[-1][0]&amp;gt;diff:
                    s.pop()
                    s.append((diff,root.val))
                    s.sort(key=lambda x:x[0])
            
            root=root.right
        
        return [e[1] for e in s]

#ANSWER 1 Recursive Inorder + Sort, O(N log N) time
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        nums = inorder(root)
        nums.sort(key = lambda x: abs(x - target))
        return nums[:k]

#ANSWER 2 
from heapq import heappush, heappop
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            if not r:
                return
            
            inorder(r.left)
            heappush(heap, (- abs(r.val - target), r.val))
            if len(heap) &amp;gt; k:
                heappop(heap)
            inorder(r.right) 
    
        heap = []
        inorder(root)
        return [x for _, x in heap]

#ANSWER 3 QuickSelect, O(N) time.
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        def partition(pivot_idx, left, right):
            pivot_dist = dist(pivot_idx)
            
            # 1. move pivot to end
            nums[right], nums[pivot_idx] = nums[pivot_idx], nums[right]
            store_idx = left
            
            # 2. move more close elements to the left
            for i in range(left, right):
                if dist(i) &amp;lt; pivot_dist:
                    nums[i], nums[store_idx] = nums[store_idx], nums[i]
                    store_idx += 1
                    
            # 3. move pivot to its final place
            nums[right], nums[store_idx] = nums[store_idx], nums[right]
            
            return store_idx
            
        def quickselect(left, right):
            &amp;quot;&amp;quot;&amp;quot;
            Sort a list within left..right till kth less close element
            takes its place.
            &amp;quot;&amp;quot;&amp;quot;
            # base case: the list contains only one element
            if left == right:
                return 
            
            # select a random pivot_index
            pivot_idx = randint(left, right)
            
            # find the pivot position in a sorted list
            true_idx = partition(pivot_idx, left, right)
            
            # if the pivot is in its final sorted position
            if true_idx == k:
                return
            
            if true_idx &amp;lt; k:
                # go left
                quickselect(true_idx, right)
            else:
                # go right
                quickselect(left, true_idx)
        
        nums = inorder(root)
        dist = lambda idx : abs(nums[idx] - target)
        quickselect(0, len(nums) - 1)
        return nums[:k]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，但是感觉用minheap会更好。我的方法得一直sort，时间复杂度太高。  需要记住 from heapq import heappush，heappop 用法 heappush（heap，val） heappop（heap） 每次pop出来的是最小的元素。  O（n）方法用到了快排。&lt;/p&gt;
&lt;h1 id=&#34;273-integer-to-english-words-hard&#34;&gt;273. Integer to English Words （Hard）&lt;/h1&gt;
&lt;p&gt;Convert a non-negative integer num to its English words representation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberToWords(self, num: int) -&amp;gt; str:
      
        nums = []
      
        if num==0: nums.append(0)
        while num:
            nums.append(num%1000)
            num//=1000
        
    
        res = []
        l=len(nums)
        dic = {0:&#39;&#39;,1:&#39;Thousand&#39;,2:&#39;Million&#39;,3:&#39;Billion&#39;,4:&#39;Trillion&#39;}
        def helper(n):
            if type(n)==str: return &#39;&#39;
            s  = &#39;&#39;
            dic = {0:&#39;Zero&#39;,1:&#39;One&#39;,2:&#39;Two&#39;,3:&#39;Three&#39;,4:&#39;Four&#39;,5:&#39;Five&#39;,6:&#39;Six&#39;,7:&#39;Seven&#39;,8:&#39;Eight&#39;,9:&#39;Nine&#39;,10:&#39;Ten&#39;,11:&#39;Eleven&#39;,12:&#39;Twelve&#39;,13:&#39;Thirteen&#39;,14:&#39;Fourteen&#39;,15:&#39;Fifteen&#39;,16:&#39;Sixteen&#39;,17:&#39;Seventeen&#39;,18:&#39;Eighteen&#39;,19:&#39;Nineteen&#39;,20:&#39;Twenty&#39;,30:&#39;Thirty&#39;,40:&#39;Forty&#39;,50:&#39;Fifty&#39;,60:&#39;Sixty&#39;,70:&#39;Seventy&#39;,80:&#39;Eighty&#39;,90:&#39;Ninety&#39;}
            
            if n&amp;lt;10: return dic[n]
            if n&amp;gt;99:
                s+= dic[n//100]+&#39; Hundred&#39;
            n = n%100
            if n==0: return s
            if n in dic:
                s+= &#39; &#39;+dic[n]
                return s
            else:
                s+=&#39; &#39;+dic[10*(n//10)]
                n=n%10
                if n==0:
                    return s
                else:
                    s+= &#39; &#39;+ dic[n]
                    return s
       
        tmp=[]
        while nums:
            if nums[0]==0:
                nums.pop(0)
                tmp.append(&#39;#&#39;)
            else:
                tmp.append(nums.pop(0))

        nums=tmp
        if nums==[&#39;#&#39;]:
            nums=[0]
        for i,number in enumerate(nums):
            if number!=&#39;#&#39;:
                res.append(helper(number)+ &#39; &#39; + dic[i])
        return &#39; &#39;.join([ e.strip() for e in res[::-1] if e.strip()])
#ANSWER
class Solution:
    def numberToWords(self, num):
        &amp;quot;&amp;quot;&amp;quot;
        :type num: int
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        def one(num):
            switcher = {
                1: &#39;One&#39;,
                2: &#39;Two&#39;,
                3: &#39;Three&#39;,
                4: &#39;Four&#39;,
                5: &#39;Five&#39;,
                6: &#39;Six&#39;,
                7: &#39;Seven&#39;,
                8: &#39;Eight&#39;,
                9: &#39;Nine&#39;
            }
            return switcher.get(num)

        def two_less_20(num):
            switcher = {
                10: &#39;Ten&#39;,
                11: &#39;Eleven&#39;,
                12: &#39;Twelve&#39;,
                13: &#39;Thirteen&#39;,
                14: &#39;Fourteen&#39;,
                15: &#39;Fifteen&#39;,
                16: &#39;Sixteen&#39;,
                17: &#39;Seventeen&#39;,
                18: &#39;Eighteen&#39;,
                19: &#39;Nineteen&#39;
            }
            return switcher.get(num)
        
        def ten(num):
            switcher = {
                2: &#39;Twenty&#39;,
                3: &#39;Thirty&#39;,
                4: &#39;Forty&#39;,
                5: &#39;Fifty&#39;,
                6: &#39;Sixty&#39;,
                7: &#39;Seventy&#39;,
                8: &#39;Eighty&#39;,
                9: &#39;Ninety&#39;
            }
            return switcher.get(num)
        

        def two(num):
            if not num:
                return &#39;&#39;
            elif num &amp;lt; 10:
                return one(num)
            elif num &amp;lt; 20:
                return two_less_20(num)
            else:
                tenner = num // 10
                rest = num - tenner * 10
                return ten(tenner) + &#39; &#39; + one(rest) if rest else ten(tenner)
        
        def three(num):
            hundred = num // 100
            rest = num - hundred * 100
            if hundred and rest:
                return one(hundred) + &#39; Hundred &#39; + two(rest) 
            elif not hundred and rest: 
                return two(rest)
            elif hundred and not rest:
                return one(hundred) + &#39; Hundred&#39;
        
        billion = num // 1000000000
        million = (num - billion * 1000000000) // 1000000
        thousand = (num - billion * 1000000000 - million * 1000000) // 1000
        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000
        
        if not num:
            return &#39;Zero&#39;
        
        result = &#39;&#39;
        if billion:        
            result = three(billion) + &#39; Billion&#39;
        if million:
            result += &#39; &#39; if result else &#39;&#39;    
            result += three(million) + &#39; Million&#39;
        if thousand:
            result += &#39; &#39; if result else &#39;&#39;
            result += three(thousand) + &#39; Thousand&#39;
        if rest:
            result += &#39; &#39; if result else &#39;&#39;
            result += three(rest)
        return result

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;corner case 有点太多了。。。写出来是写出来了。&lt;/p&gt;
&lt;h1 id=&#34;274-h-index-medium&#34;&gt;274. H-Index （Medium）&lt;/h1&gt;
&lt;p&gt;Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher&#39;s h-index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
        # [1,3,1]
        # 
        #  0 1 2 3
        # []
        
        dp = [0]*(len(citations)+1)
        for c in citations:
            if c&amp;gt;len(citations):
                c=len(citations)
            dp[c]+=1
        
        for i in range(len(dp)-2,-1,-1):
            dp[i]=dp[i]+dp[i+1]
        
        hindex=[]
        print(dp)
        for ind, n in enumerate(dp):
            if n&amp;gt;=ind:
                hindex.append(ind)
        
        return max(hindex)

#ANSWER reverse SORT
class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
    
        citations.sort(reverse=True)
        print(citations)
        hindex=0
        for ind, cit in enumerate(citations):
            hindex_candidate = ind+1
            if cit&amp;gt;=hindex_candidate:
                hindex = hindex_candidate
                
        return hindex

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue275-h-index-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;275. H-Index II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;sorted citations O(lgn) time to solve&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
        # already sorterd so binary search
        
        #hindex=0
        #for idx in range(len(citations)-1,-1,-1):
        #    cit = citations[idx]
        #    hidx =  len(citations)-idx 
        #    if cit&amp;gt;=hidx:
        #        hindex=hidx
        # 
        #return hindex
        
        l=0
        r=len(citations)-1
        res = [0]
        while l&amp;lt;=r:
            m=(l+r)//2
            
            cit=citations[m]
            hidx=len(citations)-m
            if cit&amp;gt;=hidx:
                res.append(hidx)
                r=m-1
            else:
                l=m+1
        
        return max(res)

#ANSWER
class Solution:
    def hIndex(self, citations):
        &amp;quot;&amp;quot;&amp;quot;
        :type citations: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(citations)
        for idx, c in enumerate(citations):
            if c &amp;gt;= n - idx:
                return n - idx
        return 0
#binary serach
class Solution:
    def hIndex(self, citations):
        &amp;quot;&amp;quot;&amp;quot;
        :type citations: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(citations)
        left, right = 0, n - 1

        # We need to find the rightmost &#39;index&#39; such that: (citations[index] &amp;lt;= n - index)
        while left &amp;lt;= right:
            mid = left + (right - left) // 2

            # There&#39;s (n - mid) papers with an equal or higher citation count than citations[mid]
            # If (citations[mid] == n - mid) it&#39;s the optimal result and can be returned right away
            if citations[mid] == n - mid:
                return n - mid

            # If citations[mid] is less than (n - mid), narrow down on the right half to look for a paper
            # at a future index that meets the h-index criteria. Otherwise, narrow down on the left half
            if citations[mid] &amp;lt; n - mid:
                left = mid + 1
            else:
                right = mid - 1

        # We didn&#39;t find an exact match, so there&#39;s exactly (n - left) papers that have citations
        # greater than or equal to citations[left] and that is our answer
        return n - left
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，但是还是不熟。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred276-paint-fence-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;276. Paint Fence (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are painting a fence of n posts with k different colors. You must paint the posts following these rules:&lt;br&gt;
Every post must be painted exactly one color.&lt;br&gt;
There cannot be three or more consecutive posts with the same color.&lt;br&gt;
Given the two integers n and k, return the number of ways you can paint the fence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numWays(self, n: int, k: int) -&amp;gt; int:
        # dp    
        # n = 0    0  
        # n = 1    k
        # n = 2    k*k    
        # n = 3    diff color  (k-1)*dp[i-1]   same color 1*  (k-1)*dp[i-2]  
        # so, dp[i] = (k-1)dp[i-1]+(k-1)*dp[i-2]
        
        if n==1:
            return k
        if n==2:
            return k*k
        dp=[0]*(n+1)
        dp[1]=k
        dp[2]=k*k
        for i in range(3,n+1):
            dp[i] = (k-1)*(dp[i-1]+dp[i-2])
        
        return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是DP，递推关系是？ 已经想到了，但是没仔细去想。 当前颜色和前一个相同， 当前颜色和前一个不同。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-277-find-the-celebrity-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 277. Find the Celebrity （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def findCelebrity(self, n: int) -&amp;gt; int:
        self.n = n
        celebrity_candidate = 0
        for i in range(1, n):
            if knows(celebrity_candidate, i):
                celebrity_candidate = i
        if self.is_celebrity(celebrity_candidate):
            return celebrity_candidate
        return -1

    def is_celebrity(self, i):
        for j in range(self.n):
            if i == j: continue
            if knows(i, j) or not knows(j, i):
                return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案找possible candidate O（n）时间的方法第一次没想出来。。。&lt;/p&gt;
&lt;h1 id=&#34;278-first-bad-version-easy&#34;&gt;278. First Bad Version （Easy）&lt;/h1&gt;
&lt;p&gt;Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        
        l=1
        r=n
        while l&amp;lt;=r:
            m=(l+r)//2
            if isBadVersion(m):
                r=m-1
            else:
                l=m+1
        return l

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred279-perfect-squares-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;279. Perfect Squares (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the least number of perfect square numbers that sum to n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numSquares(self, n: int) -&amp;gt; int:
        #dp   1 2  3  4  5  6  7  8
        #     1 2  3  1  2  3  4  2
        if n&amp;lt;=3: return n
        def is_sqrt(num):
            for i in range(1,num//2+1):
                if i*i==num:
                    return True
            return False
        dp = [float(&#39;inf&#39;)]*(n+1)
        dp[0]=0
        dp[1]=1
        dp[2]=2
        dp[3]=3
        for i in range(4,n+1):
            if is_sqrt(i):
                dp[i]=1
            else:
                for ii in range(1,i//2+1):
                    dp[i]=min(dp[i],dp[ii]+dp[i-ii])
        
        print(dp)
        return dp[n]

#ANSWER O（n*sqrt（n））
class Solution(object):
    def numSquares(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float(&#39;inf&#39;)] * (n+1)
        # bottom case
        dp[0] = 0
        
        for i in range(1, n+1):
            for square in square_nums:
                if i &amp;lt; square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次整了个time limit exceeded。 思路类似,答案pre calculate square_nums  省了很多时间也不用判断是否为完全平方数。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred280-wiggle-sort-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;280. Wiggle Sort （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, reorder it such that nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]....&lt;br&gt;
You may assume the input array always has a valid answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wiggleSort(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        nums.sort()
        for i in range(1,len(nums)-1,2):
            nums[i],nums[i+1]=nums[i+1],nums[i]

#ANSWER
class Solution:
    def wiggleSort(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        less=True
        for i in range(len(nums)-1):
            if less:
                if nums[i]&amp;gt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            else:
                if nums[i]&amp;lt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            
            less=not less
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;too late today。  思路1  sort first， 从第二个元素开始swap。 思路2，如果顺序不正确就纠正。&lt;/p&gt;
">Leetcode 2021-11-30</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-29/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue261-graph-valid-tree-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;261. Graph Valid Tree （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.&lt;br&gt;
Return true if the edges of the given graph make up a valid tree, and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent = [None]*n
            self.rank = [0]*n
            for i in range(n):
                self.parent[i]=i
                
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&amp;gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&amp;lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
    
        
    def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
        #UNIONFIND
        uf =self.UnionFind(n)
        for (a,b) in edges:
            uf.union(a,b)
        
        if len(set( [uf.find(i) for i in range(n)]))!=1:
            return False
    
        return len(edges)==n-1

#answer DFS
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            stack.append(neighbour)
    
    return len(seen) == n
#answer 
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = set()

    def dfs(node):
        if node in seen: return
        seen.add(node)
        for neighbour in adj_list[node]:
            dfs(neighbour)

    dfs(0)
    return len(seen) == n

#answer
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    queue = collections.deque([0])
    
    while queue:
        node = queue.popleft()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            queue.append(neighbour)
    
    return len(seen) == n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;猜到了使用UnionFind做，但是还是copy了UnionFind Class 代码，还没熟练到自己写出来。 思路很简单，union后同一个parent，#edges+1=#node      答案思路：DFS或者BFS  判断是树1）n-1 edges， 2）graph fully connected。&lt;/p&gt;
&lt;h1 id=&#34;262-trips-and-users-hard&#34;&gt;262. Trips and Users （Hard）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
select   request_at as &#39;Day&#39;, round(sum(counter)/sum(total),2) as &#39;Cancellation Rate&#39; from (
select CASE WHEN Trips.status=&#39;completed&#39; THEN 0 else 1 END as counter, 1 as total, Trips.request_at  from
Trips left join Users c on Trips.client_id=c.users_id left join Users d on Trips.driver_id=d.users_id where c.banned!=&#39;Yes&#39; and d.banned!=&#39;Yes&#39;
) tmp  where Request_at&amp;gt;=&amp;quot;2013-10-01&amp;quot; AND Request_at&amp;lt;=&amp;quot;2013-10-03&amp;quot; group by request_at

#ANSWER 
SELECT Request_at as Day,
ROUND(SUM(CASE WHEN Status!=&amp;quot;completed&amp;quot; THEN 1 ELSE 0 END)/COUNT(*),2) as &amp;quot;Cancellation Rate&amp;quot; 
FROM Trips
WHERE Client_Id NOT IN
(
    SELECT Users_Id FROM Users
    WHERE Banned=&amp;quot;Yes&amp;quot;
)
AND Request_at&amp;gt;=&amp;quot;2013-10-01&amp;quot; AND Request_at&amp;lt;=&amp;quot;2013-10-03&amp;quot;
GROUP BY Request_at;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;263-ugly-number-easy&#34;&gt;263. Ugly Number (Easy)&lt;/h1&gt;
&lt;p&gt;An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.&lt;br&gt;
Given an integer n, return true if n is an ugly number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isUgly(self, n: int) -&amp;gt; bool:
        if n==0: return False
        if n==1: return True
        
        while n%2==0:
            n//=2
        if n==1: return True
        while n%3==0:
            n//=3
        if n==1: return True
        while n%5==0:
            n//=5
        if n==1: return True
        
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred264-ugly-number-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;264. Ugly Number II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.&lt;br&gt;
Given an integer n, return the nth ugly number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nthUglyNumber(self, n: int) -&amp;gt; int:
        dp = [0] * n
        t2 = t3 = t5 = 0
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
            if(dp[i] == dp[t2]*2): t2 += 1
            if(dp[i] == dp[t3]*3): t3 += 1
            if(dp[i] == dp[t5]*5): t5 += 1
        return dp[-1]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路 。。。或者知道思路但写不出代码。  要是添加2倍，3倍，4倍，5倍还是会有空隙当n很大时候。 答案，用了dynamic programming。 思路是多个pointer。 t2，t3，t5记录已经遍历的数字里2，3，5都有多少个。 关键点是找到下一个最小的ugly number当乘以2，3，5时候。 又因为已经存在的数字只能被2，3，5乘1次，所以可以用pointer保持下次2，3，5要乘以的位置。&lt;/p&gt;
&lt;h1 id=&#34;265-paint-house-ii-hard&#34;&gt;265. Paint House II （Hard）&lt;/h1&gt;
&lt;p&gt;There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;br&gt;
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCostII(self, costs: List[List[int]]) -&amp;gt; int:
        #  cost last =     [a1,a2,a3,a4]
        #  cost last-1 =   [a1&#39;+min(a2,a3,a4),a2&#39;+min(a1,a3,a4),...]
        #  ...
        #  cost  0     =    [a1&#39;&#39;&#39;,a2&#39;&#39;&#39;....]
        # ans= min(cost0)
        for i in range(len(costs)-2,-1,-1):
            for ii in range(len(costs[0])):
                costs[i][ii] = costs[i][ii]+min([costs[i+1][jj] for jj in range(len(costs[0])) if jj!=ii])
        
        return min(costs[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;266-palindrome-permutation-easy&#34;&gt;266. Palindrome Permutation (Easy)&lt;/h1&gt;
&lt;p&gt;Given a string s, return true if a permutation of the string could form a palindrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canPermutePalindrome(self, s: str) -&amp;gt; bool:
        #odd occurance can not &amp;gt;1
        dic = collections.Counter(s)
        c=0
        for k,v in dic.items():
            if v%2==1:
                c+=1
            if c&amp;gt;1:
                return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;267-palindrome-permutation-ii-medium&#34;&gt;267. Palindrome Permutation II (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generatePalindromes(self, s: str) -&amp;gt; List[str]:
        dic = collections.Counter(s)
        c = 0
        odd_char = &#39;&#39;
        odd_c = 0
        for k,v in dic.items():
            if v%2==1:
                c+=1
                odd_char = k
                odd_c = v
        if c&amp;gt;1: return []
        if len(dic)==1:
            return [list(dic.keys())[0]*dic[list(dic.keys())[0]]]
        if odd_char:
            tmp=odd_char
            dic[odd_char]-=1
            if dic[odd_char]&amp;lt;=0:
                del dic[odd_char]
                 
        res = []
        def bt(dic,tmp):
            if len(tmp)==len(s):
                res.append(tmp)
                return
            
            for k,v in dic.items():
                dic_copy = dic.copy()
                tmp = k+tmp+k
                dic_copy[k]-=2
                if dic_copy[k]==0:
                    del dic_copy[k]
                #print(tmp,dic_copy)
                bt(dic_copy,tmp)
                tmp=tmp[1:-1]

            
        bt(dic,odd_char)
        return  res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 分为odd 元素存在时候，中间位置只能是odd元素，然后从中间向两边扩展。&lt;/p&gt;
&lt;h1 id=&#34;268-missing-number-easy&#34;&gt;268. Missing Number （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        n=len(nums)
        return (0+n)*(n+1)//2 - sum(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred269-alien-dictionary-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;269. Alien Dictionary (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.&lt;br&gt;
You are given a list of strings words from the alien language&#39;s dictionary, where the strings in words are sorted lexicographically by the rules of this new language.&lt;br&gt;
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language&#39;s rules. If there is no solution, return &amp;quot;&amp;quot;. If there are multiple solutions, return any of them.&lt;br&gt;
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length &amp;lt; t.length.&lt;br&gt;
Input: words = [&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;]&lt;br&gt;
Output: &amp;quot;wertf&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
     
    
    from collections import defaultdict, Counter, deque

    def alienOrder(self, words: List[str]) -&amp;gt; str:

        # Step 0: create data structures + the in_degree of each unique letter to 0.
        adj_list = defaultdict(set)
        in_degree = Counter({c : 0 for word in words for c in word})

        # Step 1: We need to populate adj_list and in_degree.
        # For each pair of adjacent words...
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d:
                    if d not in adj_list[c]:
                        adj_list[c].add(d)
                        in_degree[d] += 1
                    break
            else: # Check that second word isn&#39;t a prefix of first word.
                if len(second_word) &amp;lt; len(first_word): return &amp;quot;&amp;quot;

        # Step 2: We need to repeatedly pick off nodes with an indegree of 0.
        output = []
        queue = deque([c for c in in_degree if in_degree[c] == 0])
        while queue:
            c = queue.popleft()
            output.append(c)
            for d in adj_list[c]:
                in_degree[d] -= 1
                if in_degree[d] == 0:
                    queue.append(d)

        # If not all letters are in output, that means there was a cycle and so
        # no valid ordering. Return &amp;quot;&amp;quot; as per the problem description.
        if len(output) &amp;lt; len(in_degree):
            return &amp;quot;&amp;quot;
        # Otherwise, convert the ordering we found into a string and return it.
        return &amp;quot;&amp;quot;.join(output)

#DFS topo sorter reverse adj list and using grey black for node color

class Solution:
    def alienOrder(self, words: List[str]) -&amp;gt; str:

        # Step 0: Put all unique letters into the adj list.
        reverse_adj_list = {c : [] for word in words for c in word}

        # Step 1: Find all edges and put them in reverse_adj_list.
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d: 
                    reverse_adj_list[d].append(c)
                    break
            else: # Check that second word isn&#39;t a prefix of first word.
                if len(second_word) &amp;lt; len(first_word): 
                    return &amp;quot;&amp;quot;

        # Step 2: Depth-first search.
        seen = {} # False = grey, True = black.
        output = []
        def visit(node):  # Return True iff there are no cycles.
            if node in seen:
                return seen[node] # If this node was grey (False), a cycle was detected.
            seen[node] = False # Mark node as grey.
            for next_node in reverse_adj_list[node]:
                result = visit(next_node)
                if not result: 
                    return False # Cycle was detected lower down.
            seen[node] = True # Mark node as black.
            output.append(node)
            return True

        if not all(visit(node) for node in reverse_adj_list):
            return &amp;quot;&amp;quot;

        return &amp;quot;&amp;quot;.join(output)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显图论相关的题，没复习到还，看答案。思路：1）找到dependence rules， 2）topological sort。用queue来存indegree=0的node，然后遍历neighbors。或者DFS，revse adj list 然后为了防止有环，需要标注node color white grey black。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for item in container:
    if search_something(item):
        # Found it!
        process(item)
        break
else:
    # Didn&#39;t find anything..
    not_found_in_container()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语法从来没见过，for后面可以带一个else表明for loop中没有break的条件，else 来执行后续操作。&lt;/p&gt;
&lt;h1 id=&#34;270-closest-binary-search-tree-value-easy&#34;&gt;270. Closest Binary Search Tree Value （Easy）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -&amp;gt; int:
        if not root.left and not root.right: return root.val
        if not root.right:
            if target&amp;lt;root.val:
                res=self.closestValue(root.left,target)
                return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val
            else:
                return root.val
        if not root.left:
            if target&amp;gt;root.val:
                res = self.closestValue(root.right,target)
                return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val
            else:
                return root.val
        
        if target==root.val:
            return root.val
        elif target&amp;lt;root.val:
            res = self.closestValue(root.left,target)
            return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val
        else:
            res= self.closestValue(root.right,target)
            return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val

#ANSWER
class Solution:
    def closestValue(self, root: TreeNode, target: float) -&amp;gt; int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            root = root.left if target &amp;lt; root.val else root.right
        return closest
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-29</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-28/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;251-flatten-2d-vector-medium&#34;&gt;251. Flatten 2D Vector (Medium)&lt;/h1&gt;
&lt;p&gt;Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.&lt;br&gt;
Implement the Vector2D class:&lt;br&gt;
Vector2D(int[][] vec) initializes the object with the 2D vector vec.&lt;br&gt;
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.&lt;br&gt;
hasNext() returns true if there are still some elements in the vector, and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Vector2D:

    def __init__(self, vec: List[List[int]]):
        self.stack=[]
        self.vec=vec

    def next(self) -&amp;gt; int:
        if self.hasNext():
            val=self.stack.pop(0)
        return val

    def hasNext(self) -&amp;gt; bool:
        if not self.stack:
            if not self.vec:
                return False
            row=self.vec.pop(0)
            if not row: 
                if self.hasNext():
                    return True
                else:
                    return False
            for e in row:
                self.stack.append(e)
        return True


# Your Vector2D object will be instantiated and called as such:
# obj = Vector2D(vec)
# param_1 = obj.next()
# param_2 = obj.hasNext()
#answer way of writing
class Vector2D:

    def __init__(self, v: List[List[int]]):
        # We need to iterate over the 2D vector, getting all the integers
        # out of it and putting them into the nums list.
         
        self.nums = []
        for inner_list in v:
            for num in inner_list:
                self.nums.append(num)
        # We&#39;ll keep position 1 behind the next number to return.
        self.position = -1

    def next(self) -&amp;gt; int:
        # Move up to the current element and return it.
        self.position += 1
        return self.nums[self.position]

    def hasNext(self) -&amp;gt; bool:
        # If the next position is a valid index of nums, return True.
        return self.position + 1 &amp;lt; len(self.nums)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己写的这个递归调用比较tricky。。。答案很简答。&lt;/p&gt;
&lt;h1 id=&#34;252-meeting-rooms-easy&#34;&gt;252. Meeting Rooms （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -&amp;gt; bool:
        intervals=sorted(intervals,key=lambda x:x[0])
        pre_end = None
        for interval in intervals:
            if pre_end is not None and interval[0]&amp;lt;pre_end:
                return False
            pre_end = interval[1]
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue253-meeting-rooms-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;253. Meeting Rooms II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&amp;gt; int:
        #find max overlapping interval num
        res=1
        c=0
        #at start +=1 at end -=1
        dic=dict()
        for interval in intervals:
            start,end=interval[0],interval[1]
            if start in dic:
                dic[start]+=1
            else:
                dic[start]=1
            
            if end in dic:
                dic[end]-=1
            else:
                dic[end]=-1
        
        for k in sorted(dic.keys()):
            c+=dic[k]
            res=max(res,c)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，感觉下次再做可能会忘记怎么做的， 思路： 把所有时节节点从小到大排序，如果是start， counter+=1 如果是end， counter-=1， 找出counter变化过程中最大值。 答案做的感觉没自己的思路简单。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-254-factor-combinations-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 254. Factor Combinations （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Numbers can be regarded as the product of their factors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, 8 = 2 x 2 x 2 = 2 x 4.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given an integer n, return all possible combinations of its factors. You may return the answer in any order.&lt;/p&gt;
&lt;p&gt;Note that the factors should be in the range [2, n - 1].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Iterative:

def getFactors(self, n):
    todo, combis = [(n, 2, [])], []
    while todo:
        n, i, combi = todo.pop()
        while i * i &amp;lt;= n:
            if n % i == 0:
                combis += combi + [i, n/i],
                todo += (n/i, i, combi+[i]),
            i += 1
    return combis

#Recursive:

class Solution:
    def getFactors(self, n: int) -&amp;gt; List[List[int]]:
        
        res=[]
        def factor(n, i, tmp):
            while i * i &amp;lt;= n:
                if n % i == 0:
                    res.append(tmp + [i, n//i])
                    factor(n//i, i, tmp+[i])
                i += 1
        factor(n, 2, [])
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路类似，但是还是没写粗来，这个不应该， res 先append  tmp+[i,n//i],然后再factor（n//i， i，tmp+【i】，res）&lt;/p&gt;
&lt;h1 id=&#34;font-colorred255-verify-preorder-sequence-in-binary-search-tree-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;255. Verify Preorder Sequence in Binary Search Tree （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def verifyPreorder(self, preorder):
    stack = []
    low = float(&#39;-inf&#39;)
    for p in preorder:
        if p &amp;lt; low:
            return False
        while stack and p &amp;gt; stack[-1]:
            low = stack.pop()
        stack.append(p)
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路，答案思路： 模拟traversal，stack是左子树的栈。 如果下一个数小于栈顶，说明还在左子树，所以append。  如果当前preorder值大于栈顶，所有小于当前值元素出栈。说明当前元素跳到了右子树。low=stack.pop() 很巧妙， lower bound是满足小于当前值的最后一个pop出去的元素。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred256-paint-house-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;256. Paint House （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Input: costs = [[17,2,17],[16,16,5],[14,3,19]]&lt;br&gt;
Output: 10&lt;br&gt;
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.&lt;br&gt;
Minimum cost: 2 + 5 + 3 = 10.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCost(self, costs: List[List[int]]) -&amp;gt; int:
        mem=dict()
        def paint(n,color):
            if (n,color) in mem:
                return mem[(n,color)]
            res = costs[n][color]
            
            if n!=len(costs)-1:
                if color==0:
                    res+=min(paint(n+1,1),paint(n+1,2))
                elif color==1:
                    res+=min(paint(n+1,0),paint(n+1,2))
                else:
                    res+=min(paint(n+1,0),paint(n+1,1))
            mem[(n,color)]=res
            return res
       
        return min([paint(0,0),paint(0,1),paint(0,2)])

#
class Solution:
    def minCost(self, costs: List[List[int]]) -&amp;gt; int:
        if not costs:return 0
        for n in range(len(costs)-2,-1,-1):
            costs[n][0]+=min(costs[n+1][1],costs[n+1][2])
            costs[n][1]+=min(costs[n+1][0],costs[n+1][2])
            costs[n][2]+=min(costs[n+1][0],costs[n+1][1])
        return min(costs[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个应该是递归mem的经典题和dp的经典题。用dynamic programming，但是写出来一版是错的。。。应该定义dp=【#costs】【#color】。从最后一个房子开始， 倒数第二个 cost红=最后一个min（绿，蓝），。。。&lt;/p&gt;
&lt;h1 id=&#34;257-binary-tree-paths-easy&#34;&gt;257. Binary Tree Paths （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -&amp;gt; List[str]:
        res=[]
        def bt(tmp,node):
            if not node: return
            if not node.left and not node.right:
                tmp.append(str(node.val))
                res.append(&#39;-&amp;gt;&#39;.join(tmp))
                return
            tmp.append(str(node.val))
            bt(tmp[:],node.left)
            bt(tmp[:],node.right)
        bt([],root)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;258-add-digits-easy&#34;&gt;258. Add Digits (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def addDigits(self, num: int) -&amp;gt; int:
        res = 0
        while num:
            #
            tmp=0
            while num:
                lastdig = num%10
                num=num//10
                tmp+=lastdig
            num=tmp
            if num&amp;gt;=0 and num&amp;lt;=9:
                return num
        
        return res 
# answer way of writing
class Solution:
    def addDigits(self, num: int) -&amp;gt; int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了一个数能被九整除，那么他们所有位数和能被9整除。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue259-3sum-smaller-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;259. 3Sum Smaller （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &amp;lt; target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&amp;gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            for left in range(start+1,len(nums)-1):
                right=left+1
                if nums[start]+nums[left]+nums[right]&amp;gt;target:continue
                
                while  right&amp;lt;len(nums) and nums[start]+nums[left]+nums[right]&amp;lt;target:
                    res+=1
                    right+=1
                
               
        return res

#answer
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&amp;gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            tar = target-nums[start]
            #become two sum question
            left=start+1
            right=len(nums)-1
            while left&amp;lt;right:
                #print(&#39;@&#39;,left,right,tar)
                if nums[left]+nums[right]&amp;lt;tar:
                    #print(left,right)
                    res+=right-left
                    left+=1
                else:
                    right-=1
            
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写出来个暴力解。。。 几乎是O(n^3)....  O（n^2）思路, 选出一个数字，把3sum转成2sum，然后定义left=start+1，right=len（nums）-1， 若left +right 值小于target 说明 left 到right所有都满足条件，这样left+1求解下一步， 若left +right 值大于target说明right太大得减1.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred260-single-number-iii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;260. Single Number III （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; List[int]:
        xor=0
        for n in nums:
            xor = xor^n
        
        # rightmost 1-bit diff between a and b
        diff = xor &amp;amp; -xor
        
        a=0
        for n in nums:
            if n&amp;amp;diff:
                # diff means a&#39;s last bit is diff then b&#39;s last bit
                # by using this filter we could get a 
                a= a^n
        return [a,xor^a]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路， one pass 只能找出xor=a^b  但不能确定出a，b具体值。&lt;br&gt;
答案思路：用了一个不知道的trick， x &amp;amp; (-x) 保留x中最右边bit，设置其他bit为0.   这样就能用a，b 的diff bit把所有数字过滤一次，只有a可以被过滤出来，因为a的diff bit是1 其余diff bit是1的都出现了2次抵消了。。&lt;/p&gt;
">Leetcode 2021-11-28</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/shu-dan/"" data-c="
          &lt;p&gt;半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史4&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史5&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画世界史1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf&#34;&gt;半小时漫画世界史2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学4&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画科学史1 2 3全 MOBI&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画预防常见病&lt;/a&gt;&lt;/p&gt;
">书单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-27/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-241-different-ways-to-add-parentheses-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 241. Different Ways to Add Parentheses （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def diffWaysToCompute(self, expression: str) -&amp;gt; List[int]:
        if not expression: return []
         
        exp = []
        start=0
        i=0
        while i&amp;lt;len(expression):
            if expression[i].isdigit():
                i+=1
            else:
                exp.append(expression[start:i])
                exp.append(expression[i])
                start=i+1
                i+=1
        exp.append(expression[start:])
        
        
        #basecase
        res = []
        if len(exp)==1 and (&#39;+&#39; not in exp) and (&#39;-&#39; not in exp) and (&#39;*&#39; not in exp):
            res=[int(exp[0])]
        
        
        for i, op in enumerate(exp):
            if not op.isdigit():
                left = self.diffWaysToCompute(&#39;&#39;.join(exp[:i]))
                right= self.diffWaysToCompute(&#39;&#39;.join(exp[i+1:]))
                if op==&#39;+&#39;:
                    for l in left:
                        for r in right:
                            res.append(l+r)
                elif op==&#39;-&#39;:
                     for l in left:
                        for r in right:
                            res.append(l-r)
                else:
                     for l in left:
                        for r in right:
                            res.append(l*r)
                      
 
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是backtracking但写code出现了问题。。。并不是 a+(b+...)   和 (a+b)+.... 这2种情况， 而是 （left）+ （right）产生不同的组合。  思路错误导致没写出来。。写了个bug。&lt;/p&gt;
&lt;h1 id=&#34;242-valid-anagram-easy&#34;&gt;242. Valid Anagram （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isAnagram(self, s: str, t: str) -&amp;gt; bool:
        return collections.Counter(s)==collections.Counter(t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了26个字符的数组存储出现次数，s出现+1，t出现-1. 这样相等时候所有位置都应该是0.&lt;/p&gt;
&lt;h1 id=&#34;243-shortest-word-distance-easy&#34;&gt;243. Shortest Word Distance (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&amp;gt; int:
        visited = dict()
        res=float(&#39;inf&#39;)
        for i,w in enumerate(wordsDict):
            if w==word1 and word2 in visited:
                res=min(res,i-visited[word2])
            if w==word2 and word1 in visited:
                res=min(res,i-visited[word1])
            visited[w]=i
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;244-shortest-word-distance-ii-medium&#34;&gt;244. Shortest Word Distance II (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class WordDistance:

    def __init__(self, wordsDict: List[str]):
        self.dic = collections.defaultdict(list)
        for i,w in enumerate(wordsDict):
            self.dic[w].append(i)
        

    def shortest(self, word1: str, word2: str) -&amp;gt; int:
        res=float(&#39;inf&#39;)
        for pos1 in self.dic[word1]:
            for pos2 in self.dic[word2]:
                res=min(res,abs(pos2-pos1))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;245-shortest-word-distance-iii-medium&#34;&gt;245. Shortest Word Distance III (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -&amp;gt; int:
        dic=dict()
        res = float(&#39;inf&#39;)
        for i, w in enumerate(wordsDict):
            if w==word1 and word2 in dic:
                res=min(res,i-dic[word2])
            if w==word2 and word1 in dic:
                res=min(res,i-dic[word1])
            
            dic[w]=i
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;246-strobogrammatic-number-easy&#34;&gt;246. Strobogrammatic Number (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isStrobogrammatic(self, num: str) -&amp;gt; bool:
        # 1 6 9 8 0
        if &#39;2&#39; in num or &#39;3&#39; in num or &#39;4&#39; in num or &#39;5&#39; in num or &#39;7&#39; in num:
            return False
        dic={&#39;6&#39;:&#39;9&#39;,&#39;9&#39;:&#39;6&#39;,&#39;1&#39;:&#39;1&#39;,&#39;8&#39;:&#39;8&#39;,&#39;0&#39;:&#39;0&#39;}
        num2= &#39;&#39;.join([dic[e] for e in num][::-1])
        return num==num2

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred247-strobogrammatic-number-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;247. Strobogrammatic Number II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findStrobogrammatic(self, n: int) -&amp;gt; List[str]:
        if n==1: return [&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;8&amp;quot;]
        nums=[&#39;0&#39;,&#39;1&#39;,&#39;6&#39;,&#39;8&#39;,&#39;9&#39;]
        
        def isStrobogrammatic(num: str) -&amp;gt; bool:
            if &#39;2&#39; in num or &#39;3&#39; in num or &#39;4&#39; in num or &#39;5&#39; in num or &#39;7&#39; in num:
                return False
            dic={&#39;6&#39;:&#39;9&#39;,&#39;9&#39;:&#39;6&#39;,&#39;1&#39;:&#39;1&#39;,&#39;8&#39;:&#39;8&#39;,&#39;0&#39;:&#39;0&#39;}
            num2= &#39;&#39;.join([dic[e] for e in num][::-1])
            return num==num2
        
        res = []
        def bt(tmp):
            if len(tmp)==n:
                sb = &#39;&#39;.join(tmp[:])
                if isStrobogrammatic(sb) and sb[0]!=&#39;0&#39;:
                    res.append(sb)
                return 
            for cur in nums:
                tmp.append(cur)
                bt(tmp)
                tmp.pop()
        
        bt([])
        return res
#answer way of writting
class Solution:
    def findStrobogrammatic(self, n: int) -&amp;gt; List[str]:
        evenMidCandidate = [&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;, &amp;quot;00&amp;quot;]
        oddMidCandidate = [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;8&amp;quot;]
        if n == 1:
            return oddMidCandidate
        if n == 2:
            return evenMidCandidate[:-1]
        if n % 2:
            pre, midCandidate = self.findStrobogrammatic(n-1), oddMidCandidate
        else: 
            pre, midCandidate = self.findStrobogrammatic(n-2), evenMidCandidate
        premid = (n-1)//2
        return [p[:premid] + c + p[premid:] for c in midCandidate for p in pre]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试， time limit exceeded。。。 backtracking属于暴力求解。 答案思路：&lt;br&gt;
n == 1: [0, 1, 8]&lt;br&gt;
n == 2: [11, 88, 69, 96]&lt;br&gt;
How about n == 3?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 2&lt;br&gt;
n == 4?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 2&lt;br&gt;
n == 5?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 4&lt;br&gt;
the same, for n == 6, it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 4&lt;/p&gt;
&lt;h1 id=&#34;font-colorred248-strobogrammatic-number-iii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;248. Strobogrammatic Number III （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -&amp;gt; int:
        
        
        dic = {&#39;0&#39;: &#39;0&#39;,&#39;1&#39;: &#39;1&#39;,&#39;6&#39;: &#39;9&#39;,&#39;8&#39;: &#39;8&#39;,&#39;9&#39;: &#39;6&#39;}    
        count=[0] # count as list can be modifed without return 
        
        
        
        def dfs(low,high,c,left,right,count):
            if left&amp;gt;right:
                s=&#39;&#39;.join(c)
                if (len(s)==len(low) and s&amp;lt;low) or (len(s)==len(high) and s&amp;gt;high):
                    return 
                count[0]+=1
                return
            for k,v in dic.items():
                c[left]=k
                c[right]=v
                if len(c)!=1 and c[0]==&#39;0&#39;:
                    continue
                if left==right and k!=v:
                    continue
                
                dfs(low,high,c,left+1,right-1,count)
        
        
        for length in range(len(low),len(high)+1):
   
            dfs(low, high, [&#39;&#39;]*length, 0, length-1, count);
        
        return count[0]
    

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;give up, 思路 ， 构建length长度的满足条件的string，从两边向中间构建。  做dfs search。&lt;br&gt;
用247的办法也可以感觉。 然后过滤出low，high之间有多少个。&lt;/p&gt;
&lt;h1 id=&#34;249-group-shifted-strings-medium&#34;&gt;249. Group Shifted Strings （Medium）&lt;/h1&gt;
&lt;p&gt;We can shift a string by shifting each of its letters to its successive letter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, &amp;quot;abc&amp;quot; can be shifted to be &amp;quot;bcd&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can keep shifting the string to form a sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, we can keep shifting &amp;quot;abc&amp;quot; to form the sequence: &amp;quot;abc&amp;quot; -&amp;gt; &amp;quot;bcd&amp;quot; -&amp;gt; ... -&amp;gt; &amp;quot;xyz&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given an array of strings strings, group all strings[i] that belong to the same shifting sequence. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def groupStrings(self, strings: List[str]) -&amp;gt; List[List[str]]:
        dic = collections.defaultdict(list)
        for s in strings:
            if len(s)==1:
                dic[&#39;NULL&#39;].append(s)
            else:
                key=[]
                for i in range(1,len(s)):
                    tmp = str((ord(s[i])-ord(s[i-1]))%26)
                    key.append(tmp)
                key=&#39;-&#39;.join(key)
                dic[key].append(s)
        return dic.values()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;250-count-univalue-subtrees-medium&#34;&gt;250. Count Univalue Subtrees (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the number of uni-value subtrees.&lt;br&gt;
A uni-value subtree means all nodes of the subtree have the same value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        count = [0]
        
        def isUnivalSubtrees(root):
            if not root:
                return False
            if not root.left and not root.right:
                count[0]+=1
                return True
            if not root.left:
                res = isUnivalSubtrees(root.right) and root.val==root.right.val
                if res:
                    count[0]+=1
                return res
            if not root.right:
                res= isUnivalSubtrees(root.left) and root.val==root.left.val
                if res:
                    count[0]+=1
                return res
            
            left = isUnivalSubtrees(root.left)
            right= isUnivalSubtrees(root.right)
            res=left and right and root.val==root.left.val and root.val==root.right.val
            if res:
                count[0]+=1
            return res
        
        isUnivalSubtrees(root)
        return count[0]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上个题目获得的trick这个题目马上用到， count作为list，边run边更新不影响helper function的bool返回值。&lt;/p&gt;
">Leetcode 2021-12-27</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-26/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;231-power-of-two-easy&#34;&gt;231. Power of Two (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        if n&amp;lt;0: return False
        c=0
        while n:
            lastbit= n%2
            if lastbit==1:
                c+=1
            n=n&amp;gt;&amp;gt;1
        return c==1

#answer is great
class Solution:
    def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        if n&amp;lt;=0: return False
        # 1 000 000 000
        #    111 111 111
        return n&amp;amp;(n-1)==0

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;232-implement-queue-using-stacks-easy&#34;&gt;232. Implement Queue using Stacks (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        

    def push(self, x: int) -&amp;gt; None:
        self.s1.append(x)

    def pop(self) -&amp;gt; int:
        # 1 2 3
        # 3 2 1
        while self.s1:
            self.s2.append(self.s1.pop())
        val=self.s2.pop()
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -&amp;gt; int:
        pre=None
        while self.s1:
            cur=self.s1.pop()
            self.s2.append(cur)
            pre=cur
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return pre
        

    def empty(self) -&amp;gt; bool:
        return len(self.s1)==0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        self.front=None

    def push(self, x: int) -&amp;gt; None:
        if self.s1==[]:
            self.front=x
        self.s1.append(x)

    def pop(self) -&amp;gt; int:
        if self.s2==[]:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&amp;gt; int:
        if self.s2:
            return self.s2[-1]
        
        return self.front
          
        
    def empty(self) -&amp;gt; bool:
        return self.s1==[] and self.s2==[]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;follow up的思路挺有意思，push: 数字保存在s1，但是当s1为空时候，保存front。  pop：如果s2有元素，pop s2， 否则 把s1 push到s2    peek: 若s2 有元素，peek s2 否则 就是 front。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred233-number-of-digit-one-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;233. Number of Digit One （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.&lt;br&gt;
Example：&lt;br&gt;
Input: n = 13&lt;br&gt;
Output: 6&lt;br&gt;
1，10， 11，12，13&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countDigitOne(self, n: int) -&amp;gt; int:
        c=0
        i=1
        while i&amp;lt;=n:
            divider = i*10
            c += (n//divider)*i + min(max(n%divider -i+1,0),i)
            i*=10
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完全不是考算法，对于个位来说，存在1的位置有，1，11，21，31，41，51，61，71 ... 基本10个一循环，比如 1到13的个位为1的有1，11，总共2个。 所以是 13//10 + (13%10)!=0。 对于十位来说存在1的有， 10，11，12，。。。19  |   110，111，112，113，。。。119| 210,...，每100个一循环，比如1到113的十位， (113/ 100) * 10 + min(max(113%100-10+1,0),10)   同理千位100,101,...199| 1100,1101....1199|....     千位中1的个数  (n/1000)*100 + min(max(n%1000-100+1,0),100)   具体的循环截断1的个数是在 0到 100之间， 具体多少是n%1000-100+1.&lt;/p&gt;
&lt;h1 id=&#34;234-palindrome-linked-list-easy&#34;&gt;234. Palindrome Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -&amp;gt; bool:
        
        fast=slow=head
        
        while slow and fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        
        if fast:
            mid=slow.next
        else:
            mid=slow
            
        
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        revmid  = rev(mid)
        
        while revmid:
            if revmid.val!=head.val:
                return False
            revmid=revmid.next
            head=head.next
        return True
        #1 2 3 4 5
        #    s m
        #        f
                
        #1 2 3 4
        #    s
        #    m   f  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred235-lowest-common-ancestor-of-a-binary-search-tree-easyfont&#34;&gt;&amp;lt;/font color=&#39;red&#39;&amp;gt;235. Lowest Common Ancestor of a Binary Search Tree （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        # 
        #    all left ,  all right,    p mid q
        #
        
        if root.val &amp;gt; p.val and root.val &amp;gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val &amp;lt; p.val and root.val &amp;lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;卡在了一道easy题上确实不应该。。。没仔细看题，忽略了这个是个BST，得用BST性质。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-236-lowest-common-ancestor-of-a-binary-tree-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 236. Lowest Common Ancestor of a Binary Tree （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    dic=dict()
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        
        def find(root,node):
            if not root: return False
            if (root.val,node.val) in self.dic:
                return self.dic[(root.val,node.val)]
          
            if root.val==node.val:
                self.dic[(root.val,node.val)]=True
                return True
            if find(root.left,node):
                self.dic[(root.left.val,node.val)]=True
                return True
            if find(root.right,node):
                if root.right:
                    self.dic[(root.right.val,node.val)]=True
                return True
            return False
        
        if find(root.left,p) and find(root.left,q):
            return self.lowestCommonAncestor(root.left,p,q)
        elif find(root.right,p) and find(root.right,q):
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
#answer way of writting
class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        
        if root in [p,q,None]: return root
        
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        
        
        if left and right: 
            return root
        if left: 
            return left
        if right:
            return right
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次尝试Time limit exceeded...，得找到p，q是在root的同侧还是异侧。 由于是递归调用，find funciton call了太多次，所以用memerization 方法， pass了。答案思路： 如果root 是{p,q,None} 就返回root， left=从root.left找p，q共同祖先， right=从root.right 找p，q共同祖先。&lt;/p&gt;
&lt;h1 id=&#34;237-delete-node-in-a-linked-list-easy&#34;&gt;237. Delete Node in a Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &amp;quot;&amp;quot;&amp;quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
      if node.next:
            node.val=node.next.val
            node.next=node.next.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把下一位数字覆盖到当前node， 然后跳过这个node。&lt;/p&gt;
&lt;h1 id=&#34;238-product-of-array-except-self-medium&#34;&gt;238. Product of Array Except Self （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in O(n) time and without using the division operation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]:
        
        prefix_left = [1]*len(nums)
        prefix_right= [1]*len(nums)
        
        for i in range(1,len(nums)):
            prefix_left[i] = prefix_left[i-1]*nums[i-1]
        for j in range(len(nums)-2,-1,-1):
            prefix_right[j] = prefix_right[j+1]*nums[j+1]
        res = []    
        for (l,r) in zip(prefix_left,prefix_right):
            res.append(l*r)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred239-sliding-window-maximum-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;239. Sliding Window Maximum (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;
&lt;p&gt;Return the max sliding window.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&amp;gt; List[int]:
        
        #if k==1: return nums
        
        stack_max = []
        queue = []
        res = []
        for n in nums:
            queue.append(n)
            
            
            while stack_max and n&amp;gt;stack_max[-1]:
                stack_max.pop()
            if not stack_max or  n&amp;gt;stack_max[-1]:
                stack_max.append(n)
            
            if len(queue)&amp;gt;k:
                expired = queue.pop(0)
                if expired == stack_max[-1]:
                    stack_max.pop()
            
            if len(queue)==k:
                #print(queue,stack_max)
                if stack_max:
                    res.append(stack_max[-1])
                else:
                    #the expired one is the max and poped out
                    newmax=max(queue)
                    res.append(newmax)
                    stack_max.append(newmax)
            
        return res
#answer way of writting
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        
        
        queue = collections.deque()
        res = []
        for i, n in enumerate(nums):
            while queue and n&amp;gt; nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            #expire
            if queue[0] == i - k:
                queue.popleft()
            #can add to result
            if i &amp;gt;= k - 1:
                res.append(nums[queue[0]])
        return res
    
#         if not nums:
#             return []
#         start=0
#         r=[]
#         while start+k&amp;lt;=len(nums):
#             r.append(max(nums[start:start+k]))
#             start+=1
            
#         return r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试， time limit exceeded。  思路是一致的， 如果过期，踢掉， queue中保存最大值位置。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue240-search-a-2d-matrix-ii-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;240. Search a 2D Matrix II （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        
        def search(rowl,rowr,coll,colr,target):
            if rowl==rowr and coll==colr:
                return matrix[rowl][coll]==target
            elif rowl==rowr:
                return target in matrix[rowl]
            elif coll==colr:
                return target in [row[coll] for row in matrix]
            
            if  rowr-rowl==1 and colr-coll==1:    
                if matrix[rowl][coll]==target or matrix[rowr][colr]==target or matrix[rowr][coll]==target or matrix[rowl][colr]==target:
                    return True
                return False
            
            
            rowmid = (rowl+rowr)//2
            colmid = (coll+colr)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif target&amp;lt;matrix[rowmid][colmid]:
                return search(rowl,rowmid,coll,colmid,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            else:
                return search(rowmid,rowr,colmid,colr,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            
        
        return search(0,len(matrix)-1,0,len(matrix[0])-1,target)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了分治法，虽然写出来了，但感觉写了陀X。 答案分治法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        # an empty matrix obviously does not contain `target`
        if not matrix:
            return False

        def search_rec(left, up, right, down):
            # this submatrix has no height or no width.
            if left &amp;gt; right or up &amp;gt; down:
                return False
            # `target` is already larger than the largest element or smaller
            # than the smallest element in this submatrix.
            elif target &amp;lt; matrix[up][left] or target &amp;gt; matrix[down][right]:
                return False

            mid = left + (right-left) // 2

            # Locate `row` such that matrix[row-1][mid] &amp;lt; target &amp;lt; matrix[row][mid]
            row = up
            while row &amp;lt;= down and matrix[row][mid] &amp;lt;= target:
                if matrix[row][mid] == target:
                    return True
                row += 1
            
            return search_rec(left, row, mid - 1, down) or \
                   search_rec(mid + 1, up, right, row - 1)

        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最佳答案 思路 ： 从左下角开始，如果target大于cur, 列+1， 如果targe 小于cur，行-1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        # an empty matrix obviously does not contain `target` (make this check
        # because we want to cache `width` for efficiency&#39;s sake)
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        # cache these, as they won&#39;t change.
        height = len(matrix)
        width = len(matrix[0])

        # start our &amp;quot;pointer&amp;quot; in the bottom-left
        row = height - 1
        col = 0

        while col &amp;lt; width and row &amp;gt;= 0:
            if matrix[row][col] &amp;gt; target:
                row -= 1
            elif matrix[row][col] &amp;lt; target:
                col += 1
            else: # found it
                return True
        
        return False
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-26</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-25/"" data-c="
          &lt;p&gt;感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-221-maximal-square-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 221. Maximal Square （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing only 1&#39;s and return its area.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&amp;gt; int:
        rows=len(matrix)
        cols=len(matrix[0])
        maxqlen=0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j]==&#39;1&#39;:
                    sqlen=1
                    flag=True
                    while sqlen+i&amp;lt;rows and sqlen+j&amp;lt; cols and flag:
                        for k in range(j,sqlen+j+1):
                            if matrix[i+sqlen][k]==&#39;0&#39;:
                                flag=False
                                break
                        for k in range(i,i+sqlen+1):
                            if matrix[k][j+sqlen]==&#39;0&#39;:
                                flag=False
                                break
                        if flag:
                            sqlen+=1
                    
                    if maxqlen&amp;lt;sqlen:
                        maxqlen=sqlen
                        
                        
        return maxqlen**2

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&amp;gt; int:
        # dp[i][j]  size of box which bottom right in pos[i][j]
        # if matrix[i][j]==1
        #    dp[i][j]=   min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0]*(n+1) for _ in range(m+1)]
        res=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]==&#39;1&#39;:
                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1
                    res=max(res,dp[i][j])
        return res**2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试着用cumsum去解但失败了， 方法1，暴力解。 每次发现是“1”就以它作为正方形左上角起始点， 检查 row: i，i+sqlen col: j, j+sqlen 是否有‘0’.&lt;br&gt;
方法2：dp： dp【i】【j】保存右下角位置在i，j的盒子大小。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-222-count-complete-tree-nodes-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 222. Count Complete Tree Nodes （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if not root.right:
            return 1+ self.countNodes(root.left)
        else:
            return  self.countNodes(root.left)+self.countNodes(root.right)+1


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        def depth(node):
            d=0
            while node.left:
                node=node.left
                d+=1
            return d
        
        def exists(idx,d,node):
            left=0
            right=2**d-1
            for _ in range(d):
                pivot = (left+right)//2
                if idx&amp;lt;=pivot:
                    node=node.left
                    right=pivot
                else:
                    node=node.right
                    left=pivot +1
            return node is not None
        
        if not root: return 0
        d = depth(root)
        if d==0: return 1
        
        l=1
        r=2**d-1
        while l&amp;lt;=r:
            mid = (l+r)//2
            if exists(mid,d,root):
                l=mid+1
            else:
                r=mid-1
        
        return (2**d-1) +l 
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给出了个O（n）解法，但题目要求小于O(n)...&lt;br&gt;
思路： 完全二叉树，第0层2&lt;sup&gt;0个node，第一层，2&lt;/sup&gt;1个node，第n层2^n个node，所以假设这个树深度为d=n， 不包含最后一层2&lt;sup&gt;0+2&lt;/sup&gt;1+..+2&lt;sup&gt;(n-1)=2&lt;/sup&gt;n  -  1 的所有node总和为2^d-1 ,问题转化成求最后一层有多少node。 范围在1~2^n.  因为d=n所以肯定有第一个node。  可以用binary search 求。&lt;/p&gt;
&lt;h1 id=&#34;223-rectangle-area-medium&#34;&gt;223. Rectangle Area （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&amp;gt; int:
        
        # intersect of 1d line
        
        def intersect(a1,a2,b1,b2):
            if a1&amp;gt;b1:
                a1,a2,b1,b2=b1,b2,a1,a2
            
            #print(a1,a2,b1,b2)
            #case 1  --
            #            --
            if a2&amp;lt;b1:
                return 0
            
            #case 2   a1---a2
            #            b1---b2
            if b1&amp;lt;=a2 and a2&amp;lt;=b2:
                return a2-b1
            # case 3  a1------a2
            #            b1-b2
            if b1&amp;lt;a2 and b2&amp;lt;a2:
                return b2-b1
            
            return &#39;ERROR&#39;
        
        width = intersect(ax1,ax2,bx1,bx2)
        height = intersect(by1,by2,ay1,ay2)
        print(width,height)
        return (ay2-ay1)*(ax2-ax1)+ (by2-by1)*(bx2-bx1)    -width*height

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred224-basic-calculator-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;224. Basic Calculator (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        #1+1
        #1 1 +  
        #2-1+3
        #2 1 - 3 + 
        #(1+(4+5+2)-3)+(6-8)
        
        s=&#39;(&#39;+s+&#39;)&#39;
        s_res=[]
        s_char=[]
        i=0
        while i&amp;lt;len(s):
            e=s[i]
            if e==&#39; &#39;:
                i+=1
                continue
            elif e==&#39;)&#39;:
                while s_char[-1]!=&#39;(&#39;:
                    op=s_char.pop()
                    s_res.append(op)
                if s_char and s_char[-1]==&#39;(&#39;:
                    s_char.pop()
            elif e in &#39;(&#39;:
                s_char.append(e)
                    
            elif e in &#39;+-&#39;:
                if e == &amp;quot;-&amp;quot; and (i == 0 or s[i-1] == &amp;quot;(&amp;quot; ):
                    s_res.append(0)
                    
                while s_char[-1] in &#39;+-&#39;:
                    s_res.append(s_char.pop())
                s_char.append(e)
            else:
                #e is num
                tmp=int(e)
                while i+1&amp;lt;len(s) and s[i+1] in &#39;0123456789&#39;:
                    tmp = tmp*10+ int(s[i+1])
                    i+=1
                s_res.append(tmp)
            
                
            i+=1
        
                
        
        print(s_res)
        if &#39;+&#39; not in s_res and &#39;-&#39; not in s_res:
            return int(&#39;&#39;.join(map(str,s_res)))
        
        res = []
        for e in s_res:
            if e==&#39;+&#39; or e==&#39;-&#39;:
                b = res.pop() if res else None
                a = res.pop() if res else None
                
                
                if a is None:
                    if e==&#39;+&#39;:
                        res.append(b)
                    else:
                        res.append(-b)
                
                else:    
                    if e==&#39;+&#39;:
                        res.append(a+b) 
                    else:
                        res.append(a-b)
            else:
                res.append(e)
        #print(res)
        return res[0]

#通解
class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        # 转换为 后缀表达式
        # 运算符优先级
        prec = {}
        prec[&amp;quot;*&amp;quot;] = 3
        prec[&amp;quot;/&amp;quot;] = 3
        prec[&amp;quot;+&amp;quot;] = 2
        prec[&amp;quot;-&amp;quot;] = 2
        prec[&amp;quot;(&amp;quot;] = 1

        res = []
        stack = []
        i = 0
        while i &amp;lt; len(s):
            # 数字 直接 接到后缀表达式上
            if s[i] == &amp;quot; &amp;quot;:
                i += 1
                
            elif s[i].isdigit():
                temp = &amp;quot;&amp;quot;
                while i &amp;lt; len(s) and s[i].isdigit():
                    temp += s[i]
                    i += 1
                res.append(temp)

            # 左括号直接入栈
            elif s[i] == &amp;quot;(&amp;quot;:
                stack.append(s[i])
                i += 1

            # 右括号，开始弹栈，直达遇到左括号 左括号出栈 但不输出
            elif s[i] == &amp;quot;)&amp;quot;:
                while stack and stack[-1] != &amp;quot;(&amp;quot;:
                    res.append(stack.pop())
                stack.pop() # 左括号出战， 但是不输出
                i += 1

            # 遇到运算符
            elif s[i] in [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                #  对 &amp;quot;-2 + 2&amp;quot; 或者 &amp;quot;1-(-2)&amp;quot; 进行特殊处理
                if s[i] == &amp;quot;-&amp;quot; and (i == 0 or s[i-1] == &amp;quot;(&amp;quot; ):
                    res.append(&#39;0&#39;)
                # 只要栈顶符号不低于当前符号，就一直输出。最后把当前符号入栈
                while stack and prec[s[i]]&amp;lt;=prec[stack[-1]]:
                    res.append(stack.pop())
                stack.append(s[i])
                i += 1
        
        # 最后把栈里面的元素均 放到后缀表达式后面
        while stack:
            res.append(stack.pop())


        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char.isdigit():
                stack.append(int(char))
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &amp;quot;+&amp;quot;:
                    stack.append(x + y)
                elif char == &amp;quot;-&amp;quot;:
                    stack.append(y-x)
                elif char == &amp;quot;*&amp;quot;:
                    stack.append(y*x)
                elif char == &amp;quot;/&amp;quot;:
                    stack.append(x/y)

        return stack.pop()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot; 2-1 + 2 &amp;quot; 直接用stack解出现-1时候符号和1是合体的，所以换思路把表达式变成前缀/后坠表达。 又遇到后缀表达如何去括号问题。&lt;br&gt;
1 + (( 2 + 3)* 4 ) – 5   方法：  当读到数时，立即输出， 若读到操作符，判断符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就依次把栈中运算符弹出并加到后缀表达式尾端，但又遇到 &amp;quot;1-(-2)&amp;quot; 无法pass。 同理 &amp;quot;- (3 - (- (4 + 5) ) )&amp;quot; 无法pass。 负号不作为减法，作为符号。 需要特殊处理： 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if e == &amp;quot;-&amp;quot; and (i == 0 or s[i-1] == &amp;quot;(&amp;quot; ):
    s_res.append(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案很简单，问题根源在-号不能互相换 比如(A-B)+C != A-(B+C) , 所以把-看作数字的符号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculate(self, s: str) -&amp;gt; int:

        stack = []
        operand = 0
        res = 0 # For the on-going result
        sign = 1 # 1 means positive, -1 means negative  

        for ch in s:
            if ch.isdigit():
                # Forming operand, since it could be more than one digit
                operand = (operand * 10) + int(ch)

            elif ch == &#39;+&#39;:
                # Evaluate the expression to the left,
                # with result, sign, operand
                res += sign * operand

                # Save the recently encountered &#39;+&#39; sign
                sign = 1
                # Reset operand
                operand = 0

            elif ch == &#39;-&#39;:

                res += sign * operand
                sign = -1
                operand = 0

            elif ch == &#39;(&#39;:

                # Push the result and sign on to the stack, for later
                # We push the result first, then sign
                stack.append(res)
                stack.append(sign)

                # Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1
                res = 0

            elif ch == &#39;)&#39;:

                # Evaluate the expression to the left
                # with result, sign and operand
                res += sign * operand

                # &#39;)&#39; marks end of expression within a set of parenthesis
                # Its result is multiplied with sign on top of stack
                # as stack.pop() is the sign before the parenthesis
                res *= stack.pop() # stack pop 1, sign

                # Then add to the next operand on the top.
                # as stack.pop() is the result calculated before this parenthesis
                # (operand on stack) + (sign on stack * (result from parenthesis))
                res += stack.pop() # stack pop 2, operand

                # Reset the operand
                operand = 0

        return res + sign * operand

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue225-implement-stack-using-queues-easy-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;225. Implement Stack using Queues (Easy) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyStack(object):
    def __init__(self):
        self._queue = collections.deque()

    def push(self, x):
        q = self._queue
        q.append(x)
        for _ in range(len(q) - 1):
            q.append(q.popleft())
 
    def pop(self):
        return self._queue.popleft()

    def top(self):
        return self._queue[0]
    
    def empty(self):
        return not len(self._queue)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三种方法&lt;/p&gt;
&lt;h1 id=&#34;226-invert-binary-tree-easy&#34;&gt;226. Invert Binary Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]:
        if not root: return root
        root.left,root.right = root.right,root.left
        root.left = self.invertTree(root.left)
        root.right=self.invertTree(root.right)
        return root

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue227-basic-calculator-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;227. Basic Calculator II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        #convert to 后缀表达
        priority = {&#39;+&#39;:1,&#39;-&#39;:1,&#39;*&#39;:2,&#39;/&#39;:2,&#39;(&#39;:0}
        res = [] #保存后缀表达式
        stack=[] #保存符号
        i=0
        while i&amp;lt;len(s):
            ch=s[i]
            if ch.isdigit():
                tmp=ch
                while i+1&amp;lt;len(s) and s[i+1].isdigit():
                    tmp+=s[i+1]
                    i+=1
                res.append(int(tmp))
            
            elif ch==&#39;(&#39;:
                stack.append(ch)
            elif ch==&#39;)&#39;:
                while stack and stack[-1] != &amp;quot;(&amp;quot;:
                    res.append(stack.pop())
                stack.pop() 
            elif ch in  [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                
                while stack and priority[ch] &amp;lt;= priority[stack[-1]]:
                    res.append(stack.pop())

                stack.append(ch)
            
            i+=1
                
        while stack:
            res.append(stack.pop())
        
        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char not in  [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                #char is number
                stack.append(char)
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &amp;quot;+&amp;quot;:
                    stack.append(x + y)
                elif char == &amp;quot;-&amp;quot;:
                    stack.append(y-x)
                elif char == &amp;quot;*&amp;quot;:
                    stack.append(y*x)
                elif char == &amp;quot;/&amp;quot;:
                    stack.append(y//x)

        return stack.pop()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接上通杀法。转成后缀表达然后求结果。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-228-summary-ranges-easy-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 228. Summary Ranges （Easy） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def summaryRanges(self, nums: List[int]) -&amp;gt; List[str]:
        # [0]
        # [0,1]
        # [0,2]
        # [0-2,4]
        # [0-2,4,5]
        
        res = []
        stack=[]
        for n in nums:
            if not stack:
                stack.append(n)
            elif len(stack)==1:
                if n==stack[-1]+1:
                    stack.append(n)
                else:
                    res.append(str(stack[-1]))
                    stack=[n]
            else:
                if n==stack[-1]+1:
                    stack[-1]=n
                else:
                    res.append(str(stack[0])+&#39;-&amp;gt;&#39;+str(stack[1]))
                    stack=[n]
 
        if len(stack)==1:
            res.append(str(stack[0]))
        elif len(stack)==2:
            res.append(str(stack[0])+&#39;-&amp;gt;&#39;+str(stack[1]))
        
        return res
#answer way of writting
class Solution:
    def summaryRanges(self, nums: List[int]) -&amp;gt; List[str]:
        res = []
        i=0
        for j in range(len(nums)):
            if j+1&amp;lt;len(nums) and nums[j+1]==nums[j]+1:
                continue
            if i==j:
                res.append(str(nums[i]))
            else:
                res.append(str(nums[i])+&#39;-&amp;gt;&#39;+str(nums[j]))
            i=j+1
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案更简单&lt;/p&gt;
&lt;h1 id=&#34;font-colorred229-majority-element-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;229. Majority Element II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def majorityElement(self, nums: List[int]) -&amp;gt; List[int]:
        
        maj1=nums[0]
        maj2=nums[0]
        c1=0
        c2=0

        for n in nums:
            if n==maj1:
                c1+=1
            elif n==maj2:
                c2+=1
            elif c1==0:
                c1=1
                maj1=n
            elif c2==0:
                c2=1
                maj2=n
            else:
                c1-=1
                c2-=1
        #recalce make sure        
        c1=c2=0
        for n in nums:
            if n==maj1:c1+=1
            if n==maj2:c2+=1
        res=[]
        if c1&amp;gt;len(nums)//3:
            res.append(maj1)
        if c2&amp;gt;len(nums)//3 and maj1!=maj2:
            res.append(maj2)
        return res


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经典算法，在做majorelement 1时候写过，需要记住。&lt;/p&gt;
&lt;h1 id=&#34;230-kth-smallest-element-in-a-bst-medium&#34;&gt;230. Kth Smallest Element in a BST （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -&amp;gt; int:
        ind=0
        stack=[]
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            ind+=1
            if ind==k:
                return node.val
            
            root=node.right
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-25</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-24/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;211-design-add-and-search-words-data-structure-medium&#34;&gt;211. Design Add and Search Words Data Structure （Medium）&lt;/h1&gt;
&lt;p&gt;Design Add and Search Words Data Structure&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class WordDictionary:

    def __init__(self):
        self.next = dict()
        self.isword= False
        

    def addWord(self, word: str) -&amp;gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char]=WordDictionary()
            self.next[char].addWord(rest)
        else:
            self.isword=True
        

    def search(self, word: str) -&amp;gt; bool:
        if not word:
            return self.isword
        char = word[0]
        rest = word[1:]
        if char!=&#39;.&#39;:
            if char not in self.next:
                return False
            else:
                return self.next[char].search(rest)
        else:
            return any([ node.search(rest) for key,node in self.next.items()])
        
        return True
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trie data structure&lt;/p&gt;
&lt;h1 id=&#34;font-colorred212-word-search-ii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;212. Word Search II （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n board of characters and a list of strings words, return all words on the board.&lt;br&gt;
Input: board = [[&amp;quot;o&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;],[&amp;quot;e&amp;quot;,&amp;quot;t&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;e&amp;quot;],[&amp;quot;i&amp;quot;,&amp;quot;h&amp;quot;,&amp;quot;k&amp;quot;,&amp;quot;r&amp;quot;],[&amp;quot;i&amp;quot;,&amp;quot;f&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;v&amp;quot;]], words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;]&lt;br&gt;
Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   
    
    def findWords(self, board: List[List[str]], words: List[str]) -&amp;gt; List[str]:
        #trie + DFS
        class Trie:
            def __init__(self):
                self.next=dict()
                self.isword=False
            def addwords(self,word):
                if word:
                    char=word[0]
                    rest=word[1:]
                    if char not in self.next:
                        self.next[char]=  Trie()
                    self.next[char].addwords(rest)
                else:
                    self.isword=True           
                
            
        trie =  Trie()
        for word in words:
            trie.addwords(word)
       
        m=len(board)
        n=len(board[0])
        res = []
        def dfs(trie,board,i,j,tmp=&#39;&#39;):
            if i&amp;gt;=0 and i&amp;lt;m and j&amp;gt;=0 and j&amp;lt;n:
                char= board[i][j]
                board[i][j]=&#39;#&#39;
                tmp+=char
                if char in trie.next:
                    if trie.next[char].isword:
                        res.append(tmp)
                        trie.next[char].isword=False
                   
                    trie = trie.next[char]
                    dfs(trie,board,i+1,j,tmp)
                    dfs(trie,board,i-1,j,tmp)
                    dfs(trie,board,i,j+1,tmp)
                    dfs(trie,board,i,j-1,tmp)
                
                tmp = tmp[:-1]
                board[i][j] = char
              
            
        for i in range(m):
            for j in range(n):
                if board[i][j] in [word[0] for word in words]:
                    dfs(trie,board,i,j,&#39;&#39;)
        
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试trie+DFS , time limit exceeded.   什么地方没优化到？？ 原来是 发现isword时候 把isword设为False，这样就不会找到重复的word。&lt;/p&gt;
&lt;h1 id=&#34;213-house-robber-ii-medium&#34;&gt;213. House Robber II （Medium）&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rob(self, nums: List[int]) -&amp;gt; int:
        # dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        # dp[0] = nums[0]
        # dp[1] = max(nums[:2])
        #
        # now circle constraint
        #
        # if select 0, -1 and 1 can not be selected
        #  dp[0] = nums[0]  dp[1] = dp[0] ... dp[-1]=dp[-2]
        # if not select 0, -1 and 1 can be selected
        #  dp[0] = 0 dp[1]=nums[1]  ... dp[-1]=dp[-2]+nums[-1]
        
        if len(nums)&amp;lt;3:
            return max(nums)
       
        #case1) select 0
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=nums[0]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-1]
        res=max(dp)
        #case2)
        dp=[0]*len(nums)
        dp[0]=0
        dp[1]=nums[1]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-2]+nums[-1]
        res=max(res,max(dp))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为循环数组，所以，分两种case， 抢劫第一户和不抢劫第一户。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred214-shortest-palindrome-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;214. Shortest Palindrome （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given a string s. You can convert s to a palindrome by adding characters in front of it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def shortestPalindrome(self, s: str) -&amp;gt; str:
        # brute force
        l=len(s)
        rev = &#39;&#39;.join(s[::-1])
        
        for i in range(l):
            if s[:l-i]==rev[i:]:
                return rev[:i]+s
        
        return &#39;&#39;
#KMP

class Solution:
    def shortestPalindrome(self, s: str) -&amp;gt; str:
        # KMP
        l=len(s)
        rev = &#39;&#39;.join(s[::-1])
        s_new = s +&#39;#&#39; + rev
        l_new = len(s_new)
        f = [0]*l_new
        for i in range(1,l_new):
            t = f[i-1]
            while t&amp;gt;0 and s_new[i]!=s_new[t]:
                #can&#39;f find prefix=sufix, t=f[t-1]
                t=f[t-1]
            if s_new[i]==s_new[t]:
                t+=1
            f[i]=t
        
        return rev[:l-f[l_new-1]] +s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： finding the largest palindrome substring from the beginning. O（n）方法用了KMP的loolup table。   rev[f[l_new-1]:]是形成回文的序列。和 s[:len(s)-f[l_new-1]] 是对应的，那么未形成回文的就是 rev[: f[l_new-1]] ，s+rev[: f[l_new-1]] 为答案。 s_new = s +&#39;#&#39; + rev 因为不加#会引起 2 strings could mix with each ther, producing wrong answer. For example, take the string &amp;quot;aaaa&amp;quot; . Had we not inserted &amp;quot;#&amp;quot; in the middle, the new string would be &amp;quot;aaaaaaaa&amp;quot;。&lt;/p&gt;
&lt;h1 id=&#34;215-kth-largest-element-in-an-array-medium&#34;&gt;215. Kth Largest Element in an Array （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
        from heapq import heapify, heappush, heappop
        stack=[]
        for i,n in enumerate(nums):
            if len(stack)&amp;lt;k:
                heappush(stack,n)
            else:
                tmp=heappop(stack)
                if n&amp;lt;tmp:
                    heappush(stack,tmp)
                else:
                    heappush(stack,n)
         
        return heappop(stack)
###
class Solution:
    def findKthLargest(self, nums, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        def partition(left, right, pivot_index):
            pivot = nums[pivot_index]
            # 1. move pivot to end
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  
            
            # 2. move all smaller elements to the left
            store_index = left
            for i in range(left, right):
                if nums[i] &amp;lt; pivot:
                    nums[store_index], nums[i] = nums[i], nums[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            nums[right], nums[store_index] = nums[store_index], nums[right]  
            
            return store_index
        
        def select(left, right, k_smallest):
            &amp;quot;&amp;quot;&amp;quot;
            Returns the k-th smallest element of list within left..right
            &amp;quot;&amp;quot;&amp;quot;
            if left == right:       # If the list contains only one element,
                return nums[left]   # return that element
            
            # select a random pivot_index between 
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return nums[k_smallest]
            # go left
            elif k_smallest &amp;lt; pivot_index:
                return select(left, pivot_index - 1, k_smallest)
            # go right
            else:
                return select(pivot_index + 1, right, k_smallest)

        # kth largest is (n - k)th smallest 
        return select(0, len(nums) - 1, len(nums) - k)
                
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;min heap&lt;br&gt;
第二种解法quicksort， O（n）&lt;br&gt;
Choose a random pivot.&lt;br&gt;
Use a partition algorithm to place the pivot into its perfect position pos in the sorted array, move smaller elements to the left of pivot, and larger or equal ones - to the right.&lt;br&gt;
Compare pos and N - k to choose the side of array to proceed recursively.&lt;/p&gt;
&lt;h1 id=&#34;216-combination-sum-iii-medium&#34;&gt;216. Combination Sum III （Medium）&lt;/h1&gt;
&lt;p&gt;Find all valid combinations of k numbers that sum up to n such that the following conditions are true:&lt;br&gt;
Only numbers 1 through 9 are used.&lt;br&gt;
Each number is used at most once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(start,tmp,target):
            if target&amp;lt;0: return
            if len(tmp)==k and target==0:
                res.append(tmp[:])
            
            for i in range(start,10):
                tmp.append(i)
                target -= i
                bt(i+1,tmp,target)
                target+=i
                tmp.pop()
        bt(1,[],n)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;217-contains-duplicate-easy&#34;&gt;217. Contains Duplicate (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def containsDuplicate(self, nums: List[int]) -&amp;gt; bool:
        s = set()
        for n in nums:
            if n in s:
                return True
            s.add(n)
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred218-the-skyline-problem-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;218. The Skyline Problem (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from heapq import * 
class Solution(object):
    def getSkyline(self, buildings):
        # add start-building events
        # also add end-building events(acts as buildings with 0 height)
        # and sort the events in left -&amp;gt; right order
        events = [(L, -H, R) for L, R, H in buildings]
        events.extend([(R, 0, 0) for _, R, _ in buildings])
        events.sort()

        # res: result, [x, height]
        # live: heap, [-height, ending position]
        res = [[0,0]] 
        live = [(0, float(&amp;quot;inf&amp;quot;))]
        for pos, negH, R in events:
            # 1, pop buildings that are already ended
            # 2, if it&#39;s the start-building event, make the building alive
            # 3, if previous keypoint height != current highest height, edit the result
            while pos&amp;gt;= live[0][1]:
                 heappop(live)
            if negH!=0:
                #start building event
                heappush(live, (negH, R))
            if res[-1][1] != -live[0][0]:
                res.append( [pos, -live[0][0]])
        return res[1:]

 #
class Solution:
    def getSkyline(self, buildings: &#39;List[List[int]]&#39;) -&amp;gt; &#39;List[List[int]]&#39;:
        &amp;quot;&amp;quot;&amp;quot;
        Divide-and-conquer algorithm to solve skyline problem,
        which is similar with the merge sort algorithm.
        &amp;quot;&amp;quot;&amp;quot;
        n = len(buildings)
        # The base cases
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            return [[x_start, y], [x_end, 0]]

        # If there is more than one building,
        # recursively divide the input into two subproblems.
        left_skyline = self.getSkyline(buildings[: n // 2])
        right_skyline = self.getSkyline(buildings[n // 2 :])

        # Merge the results of subproblem together.
        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left, right):
        &amp;quot;&amp;quot;&amp;quot;
        Merge two skylines together.
        &amp;quot;&amp;quot;&amp;quot;
        def update_output(x, y):
            &amp;quot;&amp;quot;&amp;quot;
            Update the final output with the new element.
            &amp;quot;&amp;quot;&amp;quot;
            # if skyline change is not vertical -
            # add the new point
            if not output or output[-1][0] != x:
                output.append([x, y])
            # if skyline change is vertical -
            # update the last point
            else:
                output[-1][1] = y

        def append_skyline(p, lst, n, y, curr_y):
            &amp;quot;&amp;quot;&amp;quot;
            Append the rest of the skyline elements with indice (p, n)
            to the final output.
            &amp;quot;&amp;quot;&amp;quot;
            while p &amp;lt; n:
                x, y = lst[p]
                p += 1
                if curr_y != y:
                    update_output(x, y)
                    curr_y = y

        n_l, n_r = len(left), len(right)
        p_l = p_r = 0
        curr_y  = left_y = right_y = 0
        output = []

        # while we&#39;re in the region where both skylines are present
        while p_l &amp;lt; n_l and p_r &amp;lt; n_r:
            point_l, point_r = left[p_l], right[p_r]
            # pick up the smallest x
            if point_l[0] &amp;lt; point_r[0]:
                x, left_y = point_l
                p_l += 1
            else:
                x, right_y = point_r
                p_r += 1
            # max height (i.e. y) between both skylines
            max_y = max(left_y, right_y)
            # if there is a skyline change
            if curr_y != max_y:
                update_output(x, max_y)
                curr_y = max_y

        # there is only left skyline
        append_skyline(p_l, left, n_l, left_y, curr_y)

        # there is only right skyline
        append_skyline(p_r, right, n_r, right_y, curr_y)

        return output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉用stack做， 还是直接看答案了， 思路：事件驱动， events 包括开始建筑和终止建筑，【（L，-H，R），（R，0，0）.。。。】 这样遍历events，live存放【（-height，end pos）】 1, pop buildings that are already ended in live 2，if it&#39;s the start-building event, make the building alive， 3，if previous keypoint height != current highest height, edit the result， 思路2，分治法 O(Nlog⁡N)&lt;/p&gt;
&lt;h1 id=&#34;font-colorred219-contains-duplicate-ii-easy-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;219. Contains Duplicate II （Easy） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&amp;gt; bool:
        s = set()
        k=k+1
        for i,n in enumerate(nums):
            if len(s)&amp;lt;k:
                if n in s: return True
                #print(&#39;s add &#39;,n)
                s.add(n)
            else:
                #remove outdated
                s.remove(nums[i-k])
                #print(&#39;s remove &#39;,nums[i-k])
                if n in s:return True
                #print(&#39;s add&#39;,n)
                s.add(n)
        return False

## correct way of doing
class Solution:
    def containsNearbyDuplicate(self, nums: &#39;List[int]&#39;, k: &#39;int&#39;) -&amp;gt; &#39;bool&#39;:
        dic=dict()
        
        for i,n in enumerate(nums):
            if n in dic:
                if abs(i-dic[n])&amp;lt;=k:
                    return True
            dic[n]=i
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer timestap&amp;lt;=k 过期，花的时间太长。。。， 正确方法还是用dict 存 mapping n=&amp;gt; i. 这样当遇到重复的n判断  i-dic【n】距离是否小于k，小于则为True。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-220-contains-duplicate-iii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39; &gt;220. Contains Duplicate III （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&amp;gt; bool:
        if t&amp;lt; 0: return False
        dic = dict()
        for i,n in enumerate(nums):
            #remove outdated 
            if i-k&amp;gt;=0 and nums[i-k] in dic and dic[nums[i-k]]&amp;lt;i-k:
                del dic[nums[i-k]] 
            
            #print(i,n,dic)
            
            #check 
            if any([abs(n-key)&amp;lt;=t and abs(i-val)&amp;lt;=k for key,val in dic.items()]):
                #print(i,n)
                #print(dic)
                return True
            
           
            #add current
            dic[n]=i
        return False

#
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&amp;gt; bool:
        #            0~9 10~19 .. 
        # buketid     0   1
        #   what is 9&#39;s buket id, 9//(9+1) 
        #   so bucket size = 10
        
        buket = dict()
        buket_size = t+1
        for i,n in enumerate(nums):
            buket_id  = n//buket_size
            if buket_id in buket or (buket_id-1 in buket and n-buket[buket_id-1]&amp;lt;=t) or(buket_id+1 in buket and buket[buket_id+1]-n&amp;lt;=t):
                return True
            
            buket[buket_id] = n
            if i&amp;gt;=k:
                del buket[nums[i-k]//buket_size]
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用过期del dict key方法会time limit exceeded。竟然是用bukets。检查当前buket 和上一个或者下一个buket。 这题应该是个hard。&lt;/p&gt;
">Leetcode 2021-11-24</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-23/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred201-bitwise-and-of-numbers-range-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;201. Bitwise AND of Numbers Range （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -&amp;gt; int:
        if left==right: return left
        res = 0
        for pos in range(32):
            res |= 1 &amp;lt;&amp;lt; pos
            for n in range(left,right+1):
                if (n &amp;amp; 1&amp;lt;&amp;lt;pos) &amp;gt;&amp;gt; pos ==0:
                    res ^= 1 &amp;lt;&amp;lt; pos
                    break
        return res

#answer way of writing
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&amp;gt; int:
        shift = 0   
        # find the common 1-bits
        while m &amp;lt; n:
            m = m &amp;gt;&amp;gt; 1
            n = n &amp;gt;&amp;gt; 1
            shift += 1
        return m &amp;lt;&amp;lt; shift
#
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&amp;gt; int:
        while m &amp;lt; n:
            # turn off rightmost 1-bit
            n = n &amp;amp; (n - 1)
        return m &amp;amp; n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试，time limit exceeded， 32位过一次，一旦发现在pos位上为0，就break。 还是速度慢，  after the AND operation on all the numbers, the remaining part of bit strings is the common prefix of all these bit strings.As a result, we then can reformulate the problem as &amp;quot;given two integer numbers, we are asked to find the common prefix of their binary strings.&amp;quot; 思路： shift 直到m n相等，然后再 shift back。 这样就找到了common prefix。另一解法，思路：关闭右侧最后是1的位，然后和左侧求&amp;amp;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When we do AND bit operation between number and number-1, the rightmost bit of one in the original number would be turned off (from one to zero).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;202-happy-number-easy&#34;&gt;202. Happy Number （Easy）&lt;/h1&gt;
&lt;p&gt;Write an algorithm to determine if a number n is happy.&lt;br&gt;
Input: n = 19&lt;br&gt;
Output: true&lt;br&gt;
Explanation:&lt;br&gt;
12 + 92 = 82&lt;br&gt;
82 + 22 = 68&lt;br&gt;
62 + 82 = 100&lt;br&gt;
12 + 02 + 02 = 1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isHappy(self, n: int) -&amp;gt; bool:
        visited =set()
        
        while n!=1:
            if n in visited: return False
            visited.add(n)
            new_n =0
            while n:
                lastdig = n%10
                new_n += lastdig*lastdig
                n //= 10
            n=new_n
        
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;203-remove-linked-list-elements-easy&#34;&gt;203. Remove Linked List Elements （Easy）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -&amp;gt; Optional[ListNode]:
        if not head: return head
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        cur=dummyhead
        while cur and cur.next:
            while cur.next and cur.next.val==val:
                cur.next=cur.next.next
            cur=cur.next
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred204-count-primes-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;204. Count Primes (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countPrimes(self, n: int) -&amp;gt; int:
 
        if n &amp;lt;=2:
            return 0
        primes = [True] * n
        primes[0] = primes[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if primes[i]:
                primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
        #如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。 
        return sum(primes)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接用判断是否位质数方法会time limit exceeded。 思路：如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;     def isP(num):
            for i in range(2,num//2+1):
                if num%i==0:
                    return False
            return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;205-isomorphic-strings-easy&#34;&gt;205. Isomorphic Strings （Easy）&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;br&gt;
Two strings s and t are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isIsomorphic(self, s: str, t: str) -&amp;gt; bool:
        if len(s)!=len(t): return False
        l=len(s)
        dic1 = dict()
        dic2 = dict()
        for i in range(l):
            a = s[i]
            b = t[i]
            if a in dic1:
                if dic1[a]!=b:
                    return False
            if b in dic2:
                if dic2[b]!=a:
                    return False
            dic1[a] = b
            dic2[b] = a
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;206-reverse-linked-list-easy&#34;&gt;206. Reverse Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        pre = None
        while head:
            headnext=head.next
            head.next = pre
            pre = head
            head=headnext
        return pre
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred207-course-schedule-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;207. Course Schedule (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #DFS 法    
        def dfs(node):
            # return True 无环 False 有环
            node.status=0
            for nei in node.nei:
                if nei.status==-1:
                    if not dfs(nei):
                        return False
                elif nei.status == 0:
                    return False
            
            node.status=1
            return True
        
        for node in nodes:
            if node.status==-1:
                if not dfs(node):
                    return False
        
        return True

# upper DFS lower BFS
class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #bfs 法
        queue=[]
        cnt=0
        for node in nodes:
            if node.ind==0:
                queue.append(node)
        while queue:
            v=queue.pop(0)
            cnt+=1
            for nei in v.nei:
                nei.ind-=1
                if nei.ind==0:
                    queue.append(nei)
        
        return cnt==numCourses
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是图的算法，判断是否为DAG。BFS找入度为0的。  DFS时候，如果正在搜索某V，但又回到了V。证明有环路。注意需要3个状态来表示node状态， 【visited，visiting，not visited】&lt;br&gt;
需要补充拓扑排序算法解决变种题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# TopoSort sudo
queue = []
for 图中每个顶点V:
    if indegree(V)==0:
        queue.append(V)
while queue:
    V=queue.pop(0)
    输出V，记录V的输出序号cnt++
    for V的每个邻居 W:
        indegree(W) -= 1
        if indegree(W)==0:
            queue.append(W)

if cnt!=|V|:
    ERROR(图中有回路)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;208-implement-trie-prefix-tree&#34;&gt;208. Implement Trie (Prefix Tree)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Trie:

    def __init__(self):
        self.next= dict()
        self.isword=False
 

    def insert(self, word: str) -&amp;gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char] = Trie()
            self.next[char].insert(rest)
        else:
            self.isword=True
             

    def search(self, word: str) -&amp;gt; bool:
       
        if not word:
            return self.isword
        
        char = word[0]
        rest = word[1:]
        if char in self.next:
            if not self.next[char].search(rest):
                return False
        else:
            return False
        return True
        

    def startsWith(self, prefix: str) -&amp;gt; bool:
        if not prefix:
            return True
        
        char=prefix[0]
        rest=prefix[1:]
        if char in self.next:
            if not self.next[char].startsWith(rest):
                return False
        else:
            return False
        
        return True
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue209-minimum-size-subarray-sum-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;209. Minimum Size Subarray Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&amp;gt; int:
        # two pointer
        
        l=0
        r=-1
        val=0
        res = float(&#39;inf&#39;)
        while val&amp;lt;target:
            r+=1
            if r&amp;gt;=len(nums):
                break
            val+=nums[r]  
        if val&amp;gt;=target:
            res=min(res,r-l+1)
        else:
            return 0
        while l&amp;lt;r:
            if val&amp;gt;=target:
                #drop left
                #print(&#39;dropleft&#39;,l)
                val-=nums[l]
                l+=1
                if val&amp;gt;=target: 
                    #print(l,r)
                    res=min(res,r-l+1)
                
            else:
                #print(&#39;expandright&#39;,r+1)
                r+=1
                if r&amp;gt;=len(nums):
                    break
                val+=nums[r] 
        
        return res
# answer way of writting
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&amp;gt; int:
        # two pointer
 
        l=len(nums)
        res=float(&#39;inf&#39;)
        left=0
        sum_=0
        for i,n in enumerate(nums):
            sum_+=n
            while sum_&amp;gt;=target:
                res=min(res,i-left+1)
                sum_-=nums[left]
                left+=1
        
        return res if res!= float(&#39;inf&#39;) else 0
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然是two pointer, 学习answer写法，很清晰。&lt;/p&gt;
&lt;h1 id=&#34;210-course-schedule-ii-medium&#34;&gt;210. Course Schedule II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    class Node:
        def __init__(self,val=None):
            self.val=val
            self.nei = []
            self.indegree = 0
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; List[int]:
        # dag
        
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for a,b in prerequisites:
            nodes[b].nei.append(nodes[a])
            nodes[a].indegree+=1
        
        queue = []
        for node in nodes:
            if node.indegree==0:
                queue.append(node)
                
        res = []
        while queue:
            cur=queue.pop(0)
            res.append(cur.val)
            for w in cur.nei:
                w.indegree-=1
                if w.indegree==0:
                    queue.append(w)
        
        return res if len(res)==numCourses else []
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BFS 拓扑排序，找出indegree==0的node output。&lt;/p&gt;
">Leetcode 2021-11-23</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-22/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;191-number-of-1-bits-easy&#34;&gt;191. Number of 1 Bits (Easy)&lt;/h1&gt;
&lt;p&gt;Write a function that takes an unsigned integer and returns the number of &#39;1&#39; bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hammingWeight(self, n: int) -&amp;gt; int:
        res = 0 
        for _ in range(32):
            lastbit = n &amp;amp; 1
            n = n &amp;gt;&amp;gt;1
            res += 1&amp;amp;lastbit
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;192-word-frequency-medium-bash&#34;&gt;192. Word Frequency (Medium) BASH&lt;/h1&gt;
&lt;p&gt;Write a bash script to calculate the frequency of each word in a text file words.txt.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;for word in $(cat words.txt);   do echo $word;  done | sort | uniq -c | sort -r | awk &#39;{ print $2 &amp;quot; &amp;quot;$1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;193-valid-phone-numbers-easy-bash&#34;&gt;193. Valid Phone Numbers (Easy) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;grep -e &#39;^[0-9]\{3\}-[0-9]\{3\}-[0-9]\{4\}$&#39; -e &#39;^([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}$&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;194-transpose-file-medium-bash&#34;&gt;194. Transpose File (Medium) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt, transpose its content.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;cat file.txt | awk &#39;{for(i=0;++i&amp;lt;=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++&amp;lt;NF;)print a[i]}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;195-tenth-line-easy-bash&#34;&gt;195. Tenth Line (Easy) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt, print just the 10th line of the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;sed -n &amp;quot;10p&amp;quot; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;196-delete-duplicate-emails-easy-sql&#34;&gt;196. Delete Duplicate Emails (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;DELETE p1 FROM Person p1,
    Person p2
WHERE
    p1.Email = p2.Email AND p1.Id &amp;gt; p2.Id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;197-rising-temperature-easy-sql&#34;&gt;197. Rising Temperature (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select w1.id as Id from Weather w1 left join Weather w2 on datediff(w1.RecordDate,w2.RecordDate)=1 where w2.Temperature&amp;lt;w1.Temperature

# answer way of writting
SELECT
    weather.id AS &#39;Id&#39;
FROM
    weather
        JOIN
    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1
        AND weather.Temperature &amp;gt; w.Temperature
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;198-house-robber-medium&#34;&gt;198. House Robber (Medium)&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rob(self, nums: List[int]) -&amp;gt; int:
        # dp[i] = tthe max amount can rob at house i
        # dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        # dp[0] = nums[0]
        # dp[1] = max(nums[0],nums[1])
        if not nums:return 0
        if len(nums)==1: return nums[0]
        if len(nums)==2: return max(nums)
        dp = [float(&#39;-inf&#39;)]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(nums[:2])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        return dp[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;199-binary-tree-right-side-view-medium&#34;&gt;199. Binary Tree Right Side View (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        if not root: return root
        queue = [root]
        res = []
        
        while queue:
            level =[]
            l=len(queue)
            for i in range(l):
                cur = queue.pop(0)
                level.append(cur.val)
                if cur.right:
                    queue.append(cur.right)
                if cur.left:
                    queue.append(cur.left)
            res.append(level[0])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;level order tresversal.&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue200-number-of-islands-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;200. Number of Islands (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
        
        
        def dfs(grid,i,j):
            m=len(grid)
            n=len(grid[0])
            if i&amp;lt;0 or j&amp;lt;0 or i&amp;gt;=m or j&amp;gt;=n: return 
            if grid[i][j]==&#39;1&#39;:
                grid[i][j]=&#39;#&#39;
                dfs(grid,i+1,j)
                dfs(grid,i-1,j)
                dfs(grid,i,j+1)
                dfs(grid,i,j-1)
        r=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==&#39;1&#39;:
                    dfs(grid,i,j)
                    r+=1
        
        return r

#UNION FIND
class Solution:
    class UnionFind:
        def __init__(self,grid):
            self.count=0
            self.m=len(grid)
            self.n=len(grid[0])
            self.parent = [None]*(self.m*self.n)
            self.rank = [0]*(self.m*self.n)
            for i in range(self.m):
                for j in range(self.n):
                    if grid[i][j]==&#39;1&#39;:
                        self.parent[i*self.n+j]=i*self.n+j
                        self.count+=1
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&amp;gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&amp;lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
                self.count-=1
        
        def getCount(self):
            return self.count
    
    def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
        nr=len(grid)
        nc=len(grid[0])
        uf = self.UnionFind(grid)
        for r in range(nr):
            for c in range(nc):
                if grid[r][c]==&#39;1&#39;:
                    grid[r][c]=&#39;0&#39;
                    if (r-1&amp;gt;=0 and grid[r-1][c]==&#39;1&#39;):
                        uf.union(r*nc+c,(r-1)*nc+c)
                    if (r + 1 &amp;lt; nr and grid[r+1][c] == &#39;1&#39;):
                        uf.union(r * nc + c, (r+1) * nc + c) 
                    if (c - 1 &amp;gt;= 0 and grid[r][c-1] == &#39;1&#39;):
                        uf.union(r * nc + c, r * nc + c - 1) 
                    if   (c + 1 &amp;lt; nc and grid[r][c+1] == &#39;1&#39;):
                        uf.union(r * nc + c, r * nc + c + 1) 
                    
    
        return uf.getCount() 
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案玩了个新东西，叫UnionFind， 挺有意思。 就是找爸爸的爸爸，然后谁rank高就作为最终父亲。 这样union时候只是pointer在移动， 刚开始所有1 都是自己的爸爸， 然后逐渐union周围的1， 每union一次counter -=1 这样最终counter就是所有独立的岛数目。DFS也很简单， BFS同理。&lt;/p&gt;
">Leetcode 2021-11-22</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-21/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;181-employees-earning-more-than-their-managers-easy-sql&#34;&gt;181. Employees Earning More Than Their Managers (Easy) SQL&lt;/h1&gt;
&lt;p&gt;Write an SQL query to find the employees who earn more than their managers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT
    a.Name AS &#39;Employee&#39;
FROM
    Employee AS a,
    Employee AS b
WHERE
    a.ManagerId = b.Id
        AND a.Salary &amp;gt; b.Salary
;

SELECT
     a.NAME AS Employee
FROM Employee AS a JOIN Employee AS b
     ON a.ManagerId = b.Id
     AND a.Salary &amp;gt; b.Salary
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;182-duplicate-emails-easy-sql&#34;&gt;182. Duplicate Emails (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;
# Write your MySQL query statement below

select Email from
(
  select Email, count(Email) as num
  from Person
  group by Email
) as statistic
where num &amp;gt; 1
;

select Email
from Person
group by Email
having count(Email) &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;183-customers-who-never-order-easy-sql&#34;&gt;183. Customers Who Never Order (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select name as &amp;quot;Customers&amp;quot; from Customers as c left join Orders o on c.id=o.customerId where o.id is NULL;


select customers.name as &#39;Customers&#39;
from customers
where customers.id not in
(
    select customerid from orders
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;184-department-highest-salary-medium-sql&#34;&gt;184. Department Highest Salary (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
select Department,Employee,Salary from (
    select d.name as &amp;quot;Department&amp;quot;, 
               e.name as &amp;quot;Employee&amp;quot;,  
               e.salary as &amp;quot;Salary&amp;quot;,
              rank()   OVER( partition by e.departmentId order by salary DESC) as &amp;quot;r&amp;quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
     as tmp where r=1


#answer way of writting

SELECT
    Department.name AS &#39;Department&#39;,
    Employee.name AS &#39;Employee&#39;,
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
    )
;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;185-department-top-three-salaries-hard-sql&#34;&gt;185. Department Top Three Salaries (Hard) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select Department,Employee,Salary from (
    select d.name as &amp;quot;Department&amp;quot;, 
               e.name as &amp;quot;Employee&amp;quot;,  
               e.salary as &amp;quot;Salary&amp;quot;,
              dense_rank()   OVER( partition by e.departmentId order by salary DESC) as &amp;quot;r&amp;quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
as tmp where   r&amp;lt;=3

#answer way of writting
SELECT
    d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 &amp;gt; (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary &amp;gt; e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;186-reverse-words-in-a-string-ii-medium&#34;&gt;186. Reverse Words in a String II (Medium)&lt;/h1&gt;
&lt;p&gt;Given a character array s, reverse the order of the words.&lt;br&gt;
A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.&lt;br&gt;
Your code must solve the problem in-place, i.e. without allocating extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseWords(self, s: List[str]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify s in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        def rev(s,i,j):
            while i&amp;gt;=0 and j&amp;lt;len(s) and i&amp;lt;j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
        
        l=0
        r=len(s)-1
        rev(s,l,r)
        start=0
        for i in range(r):
            if s[i]==&#39; &#39;:
                rev(s,start,i-1)
                start=i+1
        rev(s,start,r)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;187-repeated-dna-sequences-medium&#34;&gt;187. Repeated DNA Sequences (Medium)&lt;/h1&gt;
&lt;p&gt;The DNA sequence is composed of a series of nucleotides abbreviated as &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.&lt;br&gt;
For example, &amp;quot;ACGAATTCCG&amp;quot; is a DNA sequence.&lt;br&gt;
When studying DNA, it is useful to identify repeated sequences within the DNA.&lt;br&gt;
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findRepeatedDnaSequences(self, s: str) -&amp;gt; List[str]:
        #sliding window s[i,i+10]  drop i add i+10, if in set, append to res
        if len(s)&amp;lt;=10: 
            return []
        set_ = set()
        res = set()
        for i in range(len(s)-10+1):
            cur=s[i:i+10]
            if cur in set_:
                res.add(cur)
            set_.add(cur)
        return list(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred188-best-time-to-buy-and-sell-stock-iv-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;188. Best Time to Buy and Sell Stock IV （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.&lt;br&gt;
Find the maximum profit you can achieve. You may complete at most k transactions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&amp;gt; int:
        #  if k==1
        if not prices: return 0
        if k==0: return 0
        min_ = [float(&#39;inf&#39;)]*k
        p_ = [float(&#39;-inf&#39;)]*k
        
        for i,n in enumerate(prices):
            min_[0] = min(min_[0],n)
            p_[0] = max(p_[0],n-min_[0])
            for j in range(1,k):
                min_[j]=min(min_[j],n-p_[j-1])
                p_[j]=max(p_[j],n-min_[j])
                

        return p_[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;老老实实写出K=2的情况，然后改写为数组形式。但忘记了K=2怎么写。。。&lt;/p&gt;
&lt;h1 id=&#34;189-rotate-array-medium&#34;&gt;189. Rotate Array （Medium）&lt;/h1&gt;
&lt;p&gt;Given an array, rotate the array to the right by k steps, where k is non-negative.&lt;br&gt;
Input: nums = [1,2,3,4,5,6,7], k = 3&lt;br&gt;
Output: [5,6,7,1,2,3,4]&lt;br&gt;
7654321&lt;br&gt;
765|4321&lt;br&gt;
657|1234&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rotate(self, nums: List[int], k: int) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        l=len(nums)
        k = k%l
        def rev(nums,i,j):
            while i&amp;lt;j:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j-=1
        
        rev(nums,0,l-1)
        rev(nums,0,k-1)
        rev(nums,k,l-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;190-reverse-bits-easy&#34;&gt;190. Reverse Bits (Easy)&lt;/h1&gt;
&lt;p&gt;Reverse bits of a given 32 bits unsigned integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseBits(self, n: int) -&amp;gt; int:
        res = 0
        for _ in range(32):
            lastbit = n &amp;amp; 1
            n = n&amp;gt;&amp;gt;1
            res = res&amp;lt;&amp;lt;1 | lastbit
        return res  
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-21</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-20/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;171-excel-sheet-column-number-easy&#34;&gt;171. Excel Sheet Column Number (Easy)&lt;/h1&gt;
&lt;p&gt;convert excel sheet column chars to number&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def titleToNumber(self, columnTitle: str) -&amp;gt; int:
        
        s = [e for e in columnTitle]
        res=0
        for char in s:
            n=ord(char)-ord(&#39;A&#39;)+1
            res  = res*26 +n
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;172-factorial-trailing-zeroes-medium&#34;&gt;172. Factorial Trailing Zeroes (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trailingZeroes(self, n: int) -&amp;gt; int:
        # n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.
        #     2*5 =10 4*5=20 5*6=30 5*8=40 
        #    5&#39;s double time give one zero
        res5=0
        for i in range(n,0,-1):
            if i%5==0:  
                res5+=1
                i=i//5
                while i%5==0 and i!=0:
                    res5+=1
                    i=i//5
        
        return  res5
 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题有点意思，要形成末尾的0只能是5和2的结合，阶乘中公共因子2的数肯定大于公共因子为5的数，所以bound by 5的数目。 所以求所有含有5的因子的个数，特殊情况是25，125，625， 。。。 他们包含2个，3个，4个五，因此能产生更多的尾数0.  答案给出了lgn时间的解法。 就是循环求n能否除power of 5. 另一个思路是让n变小n=n//5.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#fives = 0
#power_of_5 = 5
#while n &amp;gt;= power_of_5:
#    fives += n / power_of_5
#    power_of_5 *= 5

tens = fives
def trailingZeroes(self, n: int) -&amp;gt; int:
    zero_count = 0
    current_multiple = 5
    while n &amp;gt;= current_multiple:
        zero_count += n // current_multiple
        current_multiple *= 5
    return zero_count

def trailingZeroes(self, n: int) -&amp;gt; int:
    zero_count = 0
    while n &amp;gt; 0:
        n //= 5
        zero_count += n
    return zero_count
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;173-binary-search-tree-iterator-medium&#34;&gt;173. Binary Search Tree Iterator (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        while root:
            self.stack.append(root)
            root=root.left
        #print([ e.val for e in self.stack])
        #print(&#39;##########################&#39;)
        

    def next(self) -&amp;gt; int:
        node = self.stack.pop()
        if node.right:
            root=node.right
            while root:
                self.stack.append(root)
                root=root.left
                
        #print(&#39;r&#39;,node.val)
        return node.val
    def hasNext(self) -&amp;gt; bool:
        return self.stack!=[]
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred174-dungeon-game-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;174. Dungeon Game (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -&amp;gt; int:
        
        # -2 -3  3
        # -5 -10 1
        # 10  30 -5
        #
        #  7  5   2
        #  16 11  5
        #  1  1   6  
        m = len(dungeon)
        n = len(dungeon[0])
        dp=[[0]*n for _ in range(m)]
        dp[-1][-1] = 1 if dungeon[-1][-1]&amp;gt;0 else -1*(dungeon[-1][-1]-1)
        
        
        for i in range(m-2,-1,-1):
            dp[i][n-1] = dp[i+1][n-1]-dungeon[i][n-1] if dp[i+1][n-1]-dungeon[i][n-1]&amp;gt;0 else 1
        for j in range(n-2,-1,-1):
            dp[m-1][j]= dp[m-1][j+1]-dungeon[m-1][j] if dp[m-1][j+1]-dungeon[m-1][j]&amp;gt;0 else 1
        
        for row in range(m-2,-1,-1):
            for col in range(n-2,-1,-1):
                godown = max(dp[row+1][col]-dungeon[row][col],1)    
                goright = max(dp[row][col+1]-dungeon[row][col],1)  
                dp[row][col]=min(godown,goright)
        
        return dp[0][0]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想复杂了，应该从右下角开始回溯。 回溯血量小于0说明格子给的补药多了，所以保持生命1就可以了。 dp存的是需要的生命值。&lt;/p&gt;
&lt;h1 id=&#34;175-combine-two-tables-easysql&#34;&gt;175. Combine Two Tables （Easy）SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
# first name, last name, city, and state of each person in the Person table.  

select Person.firstName, Person.lastName, Address.city, Address.state  from Person left join Address on Person.personId=Address.personId

select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;176-second-highest-salary-mediumsql&#34;&gt;176. Second Highest Salary （Medium）SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
# select  (
# select salary from Employee where salary&amp;lt; (select max(salary) from Employee ) order by salary desc limit 1
# ) as  SecondHighestSalary

select (select distinct salary from Employee order by salary desc limit 1 offset 1) as SecondHighestSalary
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;177-nth-highest-salary-medium-sql&#34;&gt;177. Nth Highest Salary (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
set N=N-1; 
  RETURN (
      # Write your MySQL query statement below.
      
    select distinct Salary from Employee order by Salary Desc limit 1 offset N
  );
END
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;178-rank-scores-medium-sql&#34;&gt;178. Rank Scores (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select  score,  dense_rank() over ( order by score desc) as &#39;rank&#39;    from Scores 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dense_rank和rank不同之处在于是否压缩值。 rank()用法举例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT * FROM (
	SELECT
		product_id,
		product_name,
		category_id,
		list_price,
		DENSE_RANK () OVER ( 
			PARTITION BY category_id
			ORDER BY list_price DESC
		) price_rank 
	FROM
		production.products
) t
WHERE price_rank &amp;lt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred179-largest-number-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;179. Largest Number (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a list of non-negative integers nums, arrange them such that they form the largest number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class LargerNumKey(str):
    def __lt__(x, y):
        return x+y &amp;gt; y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = &#39;&#39;.join(sorted(map(str, nums), key=LargerNumKey))
        return &#39;0&#39; if largest_num[0] == &#39;0&#39; else largest_num

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;太晚了，有个初步想法，但似乎在处理最高位相同情况时候还没完全想明白。直接看答案了。答案直接拒绝处理最高位相同情况直接按照string 去compare。。。&lt;/p&gt;
&lt;h1 id=&#34;180-consecutive-numbers-mediumsql&#34;&gt;180. Consecutive Numbers （Medium）SQL&lt;/h1&gt;
&lt;p&gt;Write an SQL query to find all numbers that appear at least three times consecutively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below


SELECT DISTINCT
    l1.Num AS ConsecutiveNums
FROM
    Logs l1,
    Logs l2,
    Logs l3
WHERE
    l1.Id = l2.Id - 1
    AND l2.Id = l3.Id - 1
    AND l1.Num = l2.Num
    AND l2.Num = l3.Num
;

&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-20</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-19/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;161-one-edit-distance-medium&#34;&gt;161. One Edit Distance (Medium)&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isOneEditDistance(self, s: str, t: str) -&amp;gt; bool:
        #
        #      &#39;&#39;  a  b
        #   &#39;&#39; 0   1  2
        #    a 1   0  1  
        #    c 2   1  1
        #    b 3   2  1
        #
        #    dp[i][j] is s[:i]  t[:j]&#39;s editdistance
        #    dp[i][j] =   min(dp[i][j-1] ,  dp[i-1][j] ,  dp[i-1][j-1]) +1 if s[i]!=t[j]        
        m = len(s)
        n = len(t)
        
        dp = [[0]*(n+1) for _ in range(m+1)]
      
        for i in range(n+1):
            dp[0][i]=i
        for i in range(m+1):
            dp[i][0]=i
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if s[i-1]!=t[j-1]:
                    dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1
                else:
                    dp[i][j] = dp[i-1][j-1]
                
                     
        
        return dp[-1][-1]==1

 #second way of writting
 class Solution:
    def isOneEditDistance(self, s: str, t: str) -&amp;gt; bool:
        
        # s-&amp;gt;t    insert
        
        if len(t)-len(s)==1 and len(set(t))-len(set(s))&amp;lt;=1:
            #s insert
            # ssss sss
            # tttttttt
           
            while s and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while s and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(t)==1:
                return True
            
        elif len(s)-len(t)==1 and len(set(s))-len(set(t))&amp;lt;=1:
            #s del
            # sssssss
            # ttt ttt
             
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(s)==1:
                return True
            
            
        elif len(s)==len(t)  and len(set(s))-len(set(t))&amp;lt;=1:
            # replace
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            
            if len(t)==1 and len(s)==1 and t!=s:
                return True
            
        
        
        return False
               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用dp方法，time limit exceeded。dp是n*n的。所以用定义做。 分3种情况， insert ，del， replace。 头尾之间去除相同的，剩下长度为1 就是可以的。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred162-find-peak-element-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;162. Find Peak Element （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A peak element is an element that is strictly greater than its neighbors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findPeakElement(self, nums: List[int]) -&amp;gt; int:
        
#         for i in range(len(nums)-1):
#             if nums[i] &amp;gt; nums[i+1]:
#                 return i
        
#         return len(nums)-1
        
        
        return self.search(nums,0,len(nums)-1)
    
    def search(self, nums,l,r):
        if l==r:
            return l
        
        m = (l+r)//2
        
        if nums[m] &amp;gt; nums[m+1]:
            return self.search(nums,l,m)
        else:
            return self.search(nums,m+1,r)
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定是考binary search的，但木有思路，答案很精彩。 就是比较 m 和 m+1就搞定了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred163-missing-ranges-easyfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;163. Missing Ranges （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&amp;gt; List[str]:
        res=[]
        
        def helper(x,y):
            if y-x==2:
                # y=3 x=1
                res.append(str(x+1))
            elif y-x&amp;gt;2:
                res.append(str(x + 1) + &#39;-&amp;gt;&#39; + str(y - 1))
            
        
        pre = lower-1
        for num in nums:
            helper(pre,num)
            pre=num
        
        helper(pre,upper+1)
            
        return res
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if else 判断太繁杂， 答案很简单，这个是个easy题目？？？ 为了统一 x 到 y之间判断， lower =lower-1，这样lower就包括进去了， upper=upper+1，这样upper就包括进去了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred164-maximum-gap-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;164. Maximum Gap （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximumGap(self, nums: List[int]) -&amp;gt; int:
        
        if not nums or len(nums)&amp;lt;2: return 0
        
        maxval = max(nums)
        exp=1 # 1,10,100,...
        radix=10 #base 10 system
        aux = [0]*len(nums)
        while maxval//exp&amp;gt;0:
            count = [0]*radix
            
            for i,n in enumerate(nums):
                count[(n//exp)%10] +=1
            
            for i,n in enumerate(count):
                if i==0: continue
                count[i] += count[i-1]
            
            for i in range(len(nums)-1,-1,-1):
                count[(nums[i]//exp)%10] -= 1
                aux[ count[(nums[i]//exp)%10] ] = nums[i]
                
            nums= aux[:]
            
            exp*=10
        
        print(nums)
        
        maxGap = 0 
        for   i  in range(len(nums)-1): 
            maxGap = max(nums[i + 1] - nums[i], maxGap)

        return maxGap

# answer way of writting
class Solution:
    def maximumGap(self, nums: List[int]) -&amp;gt; int:
        ## RC ##
        ## APPROACH : BUCKET SORT ##
        ## LOGIC ##
        ## 1. lets say we have number from 1 to 10 like, 1,1.1,1.2,2.4,3.5,3.7,4,....10 (not in the same order)
        ## 2. we create n - 1 buckets, why n-1 ? (b1 -&amp;gt; [1-2] b2-&amp;gt; [2-3] b3-&amp;gt;[3-4] ...so on 9 buckets)
        ## 3. we can say size of each bucket will be (10 - 1) // 9 i.e 1 ==&amp;gt; (maximum - mimimum) // (length - 1)
        ## 3. Instead of storing all the elements in the buckets, we store minvalue of that bucket and maximum value of that bucket
        ## 4. Maximum Gap can be Case 1: gap between min and max in the bucket itself (or) Case 2: Gap between bucket1 max and bucket2 and so on..
        
		## TIME COMPLEXITY : O(N) ##
		## SPACE COMPLEXITY : O(N) ##
        
        if len(nums) &amp;lt; 2 or min(nums) == max(nums):
            return 0
        minimum, maximum = min(nums), max(nums)
        size = ( maximum - minimum )//(len(nums)-1) or 1
        buckets = [[None, None] for _ in range(( maximum - minimum )//size+1)]
        for num in nums:
            # getting the bucket number in which it falls into
            bucket = buckets[ ( num - minimum )//size ]
            bucket[0] = num if bucket[0] is None else min(bucket[0], num)
            bucket[1] = num if bucket[1] is None else max(bucket[1], num)
        buckets = [bucket for bucket in buckets if bucket[0] is not None]
        return max(buckets[i][0]-buckets[i-1][1] for i in range(1, len(buckets)))        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要求O（n）for space and time没思路。答案思路1） Radix Sort 听过，但写不出来。。。2）Buckets 这个思路很好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识点 Radix Sort&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
     def count_sort(arr,exp):
           #辅助数组用于返回
           aux = [0]*len(nums)
           #0到9是个数字的计数器
           count=[0]*10
           #计数
           for i,n in enumerate(arr):
               ind= (n//exp)%10
               count[ind]+=1
           #计算位置  count【i】 就是 i 这个位，属于的数字所在的位置
           for i in range(1,10):
               count[i] += count[i-1]
            #从后向前遍历数组
           for i in range(len(arr)-1,-1,-1):
               #找到index
               ind = (arr[i]//exp)%10
               #找到位置 因为位置从0开始所以要-1
               count[ind] -= 1
               #赋值
               aux[count[ind]] = arr[i]
           return aux 


       def Radix_Sort(arr):
           maxval=max(arr)
           exp=1
           while maxval//exp&amp;gt;0:
               #print(&#39;#&#39;,exp)
               arr = count_sort(arr,exp)
               exp*=10
           return arr
       
       nums = Radix_Sort(nums)


&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;165-compare-version-numbers-medium&#34;&gt;165. Compare Version Numbers （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def compareVersion(self, version1: str, version2: str) -&amp;gt; int:
        while version1 or version2:
            v1=0
            v2=0
            while version1 and version1[0]!=&#39;.&#39;:
                v1 = v1*10+int(version1[0])
                version1=version1[1:]
            while version2 and version2[0]!=&#39;.&#39;:
                v2 = v2*10+int(version2[0])
                version2=version2[1:]
            
            if v1&amp;gt;v2: return 1
            if v1&amp;lt;v2: return -1
            
            version1 = version1[1:] if version1 else &#39;&#39;
            version2 = version2[1:] if version2 else &#39;&#39;
    
        return 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;166-fraction-to-recurring-decimal-medium&#34;&gt;166. Fraction to Recurring Decimal （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -&amp;gt; str:
        negsign = (numerator&amp;gt;0) ^ (denominator&amp;gt;0)
        numerator= abs(numerator)
        denominator=abs(denominator)
        if numerator==0: negsign=False
        
        integer = numerator//denominator
        if integer*denominator==numerator:
            return str(integer) if not negsign else  &#39;-&#39;+str(integer)
        res_int = str(integer)
        
        numerator -= integer*denominator
        
        def loop(res_dec,denominator_len):
            l=len(res_dec)
            if l&amp;gt;=2:
                for lookback in range(1,l//2+1):     
                    if lookback&amp;gt;=denominator_len and res_dec[l-lookback:l] == res_dec[l-2*lookback :l-lookback] :
                        return True, l-2*lookback, lookback
            return False, 0,0
        res_dec = []
        while True:
            numerator *= 10
            val =numerator//denominator
            res_dec.append(val)
            #print(res_dec)
            flag, start,length =  loop(res_dec,len(str(denominator)))
            if flag:
                l=len(res_dec)
                part1 = res_dec[:start]
                recur = res_dec[start:start+length]
                part1=&#39;&#39;.join([str(e) for e in part1])
                recur = &#39;(&#39;+&#39;&#39;.join([str(e) for e in recur]) +&#39;)&#39; if recur else &#39;&#39;
                decpart=part1+recur
                result= res_int+&#39;.&#39;+decpart if decpart else res_int
                return result if not negsign else &#39;-&#39;+result
            numerator=numerator-val*denominator
            if numerator==0:
                break
        
        decpart=&#39;&#39;.join([str(e) for e in res_dec])
        result=res_int+&#39;.&#39;+decpart if decpart else res_int
        return result if not negsign else &#39;-&#39;+result

#answer way of writting
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        &amp;quot;&amp;quot;&amp;quot;
        :type numerator: int
        :type denominator: int
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
       
        if not numerator: return &amp;quot;0&amp;quot;;
        res=&amp;quot;&amp;quot;
        if  (numerator &amp;lt; 0) ^ (denominator &amp;lt; 0):
            res += &#39;-&#39;
        
        numer = numerator * (-1) if numerator &amp;lt; 0 else numerator
            
        denom =  denominator * (-1) if denominator &amp;lt; 0 else denominator;
        integral = numer // denom;
        res += str(integral);
        rmd = numer % denom;
        if  rmd==0: return res
        res += &#39;.&#39;;
        rmd *= 10
        mp=dict() 
        while rmd:
            quotient = rmd / denom
            if rmd in mp:
                #res.insert(mp[rmd], 1, &#39;(&#39;);
                res=res[:mp[rmd]]+&#39;(&#39;+res[mp[rmd]:]
                res += &#39;)&#39;
                break
            
            mp[rmd] = len(res)
            res += str(quotient);
            rmd = (rmd % denom) * 10
        
        return res;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断recurring，lookback需要长度大于被除数。不难但细节太多，垃圾题。答案写的很优雅。用了dict去存reminder，如果重复出现reminder说明存在重复。 我的方法是之间判断数组是否循环。答案更优雅。&lt;/p&gt;
&lt;h1 id=&#34;167-two-sum-ii-input-array-is-sorted-easy&#34;&gt;167. Two Sum II - Input Array Is Sorted （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
        length = len(numbers)
        l=0
        r=length-1
        while l&amp;lt;r:
            if numbers[l]+numbers[r]==target:
                return [l+1,r+1]
            elif  numbers[l]+numbers[r]&amp;lt;target:
                l+=1
            else:
                r-=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sorterd 直接上two pointer了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred168-excel-sheet-column-title-easyfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;168. Excel Sheet Column Title （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def convertToTitle(self, columnNumber: int) -&amp;gt; str:
        # 26 进制数
        
      
        
        
        chars = &#39;ZABCDEFGHIJKLMNOPQRSTUVWXY&#39;
        dic = dict()
        for i in range(26):
            dic[i]=chars[i]
        
        res = []
        while columnNumber:
            
            reminder = columnNumber%26
            #print(columnNumber,reminder)
            res.append(dic[reminder])
            columnNumber = columnNumber //26
            if reminder==0:
                columnNumber-=1
             
        return &#39;&#39;.join(res[::-1])
             
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是个26进制数转换问题，这个也能卡。。。 卡在的点为 if reminder==0:   columnNumber-=1&lt;br&gt;
如果没有余数恰巧除干净了，说明需要上一位减去一。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred169-majority-element-easyfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;169. Majority Element （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def majorityElement(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        
        maj = nums[0]
        c = 0
        for n in nums:
            if n==maj:
                c+=1
            else:
                c-=1
            
            if c==0:
                maj=n
                c=1
       
        
        return  maj

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是个经典算法 摩尔投票算法，需要记住。 思路：遍历过程中不同元素之间两两抵消，由于一个数组中，出现次数超过n/2最多只有一个，那么遍历结束时，未被抵消掉的即是出现次数超过n/2的元素。在数组中maj元素出现一次，count就自加一次，如果出现了和maj不同的元素，说明maj可被抵消一次，count就自减一次，如果count减为0，也就说明maj元素已经被抵消完了， 更新maj。&lt;br&gt;
如果找超过1/3元素。 最多只有两个元素符合要求。需要设置maj1和count1、maj2和count2来分别记录这两个元素的抵消情况。如果出现了和maj1或maj2相同的元素，那么对应的count1和count2就自加1，如果元素与maj1和maj2都不相同，那么count1和count2就都应当自减1，如果maj1或maj2抵消掉后，就应当更新对应的maj1或maj2。NOTE 注意：  初始值 maj1和maj2、count1和count2相同，所以在判断二者与当前值是否相同时应当使用if else语句，而不是分开的两个if。此外，考虑到可能出现maj1和maj2都同时出现抵消掉的情况，所以也不能同时进行count自减和判断count1或count2是否为0，如果同时判断的话，那么maj1和maj2又会都同时成为当前元素了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;maj1=nums[0]
maj2=nums[0]
c1=0
c2=0

for n in nums:
   if n==maj1:
       c1+=1
   elif n==maj2:
       c2+=1
   elif c1==0:
       c1=1
       maj1=n
   elif c2==0:
       c2=1
       maj2=n
   else:
       c1-=1
       c2-=1
#recalce make sure        
c1=c2=0
for n in nums:
   if n==maj1:c1+=1
   if n==maj2:c2+=1
res=[]
if c1&amp;gt;len(nums)//3:
   res.append(maj1)
if c2&amp;gt;len(nums//3) and maj1!=maj2:
   res.append(maj2)
return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;170-two-sum-iii-data-structure-design-easy&#34;&gt;170. Two Sum III - Data structure design (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TwoSum:

    def __init__(self):
        self.stack = []
        

    def add(self, number: int) -&amp;gt; None:
        self.stack.append(number)
        

    def find(self, value: int) -&amp;gt; bool:
        dic= dict()
        for i,n in enumerate(self.stack):
            if value-n in dic:
                return True
            dic[n]=i
        return False
        


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-19</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-18/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;151-reverse-words-in-a-string-medium&#34;&gt;151. Reverse Words in a String （Medium）&lt;/h1&gt;
&lt;p&gt;Given an input string s, reverse the order of the words.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseWords(self, s: str) -&amp;gt; str:
        if not s: return s
        #trim space
        tmp=&#39;&#39;
        while s:
            if s[0]!=&#39; &#39;:
                tmp+=s[0]
            else:
                if tmp and tmp[-1]!=&#39; &#39; :
                    tmp+=&#39; &#39;
            s=s[1:]
        
        while tmp and tmp[-1]==&#39; &#39;:
            tmp=tmp[:-1]
        
                    
        
        s = [e for e in tmp]
        print(s)
        def rev(s,i,j):
            while i&amp;lt;=j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
            return s
        #rev all
        s = rev(s,0,len(s)-1)
        
        start=0
        for i in range(len(s)):
            if s[i]==&#39; &#39;:
                s = rev(s,start,i-1)
                start=i+1
        s=rev(s,start,len(s)-1)
        
        return &#39;&#39;.join(s)
#quick way using python function
class Solution:
    def reverseWords(self, s: str) -&amp;gt; str:
        def rev(e):
            w=[i for i in e]
            return &#39;&#39;.join(w[::-1])
        s=rev(s)
        res=[]
        for e in  s.strip().split():
            res.append(rev(e))
        return &#39; &#39;.join(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue152-maximum-product-subarray-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;152. Maximum Product Subarray (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProduct(self, nums: List[int]) -&amp;gt; int:
        # dp[i][j] is max subarry product till nums[i].. nums[j]
        # dp[i][i] = nums[i]
        #  -2 -3 -4 -5 -6
        #     -3 -4 -5 -6     
        #     max_dp[i][j] = max(min_dp[i][j-1]*nums[j], max_dp[i][j-1]*nums[j], nums[j])
        #     min_dp[i][j] = min(max_dp[i][j-1]*nums[j], min_dp[i][j-1]*nums[j], nums[j])
        #  j&amp;gt;=i
        #  
        l=len(nums)
        if l==1: return nums[0]
        res = float(&#39;-inf&#39;)
        max_dp = [[float(&#39;-inf&#39;)]*l for i in range(l)]
        min_dp = [[float(&#39;inf&#39;)]*l for i in range(l)]
        for i in range(l):
            max_dp[i][i] = nums[i]
            min_dp[i][i] = nums[i]
            res = max(res,max_dp[i][i])
    
        for i in range(l):
            for j in range(l):
                if i&amp;gt;=j:continue
                max_dp[i][j] = max(min_dp[i][j-1]*nums[j], max_dp[i][j-1]*nums[j], nums[j])
                min_dp[i][j] = min(max_dp[i][j-1]*nums[j], min_dp[i][j-1]*nums[j], nums[j])
                res=max(res,max_dp[i][j]) 
        #for row in max_dp:
        #    print(row)
        #for col in min_dp:
        #    print(col)
        
        return res
# 搞定 O（n）解法
class Solution:
    def maxProduct(self, nums: List[int]) -&amp;gt; int:
        
        # max_dp[i] = maxProduct up to nums[0] ... nums[i]
        # min_dp[i] = minProduct up to nums[0] ... nums[i]
        res = float(&#39;-inf&#39;)
        l=len(nums)
        max_dp = [float(&#39;-inf&#39;)]*l
        min_dp = [float(&#39;inf&#39;)]*l
        for i in range(l):
            max_dp[i] = max(nums[i],max_dp[i-1]*nums[i],min_dp[i-1]*nums[i]) if i!=0 else nums[i]
            res = max(res,max_dp[i])
            min_dp[i] = min(nums[i],min_dp[i-1]*nums[i],max_dp[i-1]*nums[i]) if i!=0 else nums[i]
        
        #print(max_dp)
        #print(min_dp)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想了个dp 但是O(n*n)的 time limit exceeded， 所以应该有O（n）的dp解法。&lt;br&gt;
思路： 由于nums的正负符号来回变化，所以需要追踪最大乘积和最小乘积。令max_dp[i] 表示用nums【0】到nums【i】所能得到的最大乘积。 min_dp[i]表示用nums【0】到nums【i】所能得到的最大乘积。 则  max_dp[i] = max(nums[i],max_dp[i-1]*nums[i],min_dp[i-1]*nums[i]) min_dp[i] = min(nums[i],min_dp[i-1]*nums[i],max_dp[i-1]*nums[i])  由于dp【i】只与dp【i-1】有关，所以甚至能简化为O（1）space的解。&lt;/p&gt;
&lt;h1 id=&#34;154-find-minimum-in-rotated-sorted-array-ii-hard&#34;&gt;154. Find Minimum in Rotated Sorted Array II （Hard）&lt;/h1&gt;
&lt;p&gt;Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:
        # nums[l]  &amp;lt; nums[m]
        
        nums_without_dup = []
        pre=None
        for n in nums:
            if (pre and n!=pre) or (pre is None):
                nums_without_dup.append(n)
            pre=n    
        nums = nums_without_dup
        
        l=0
        r=len(nums)-1
        res = float(&#39;inf&#39;)
        while l&amp;lt;r:
            m = (l+r)//2
            if nums[l] &amp;lt;= nums[m]:
                # left increse
                res=min(res,nums[l])
                l=m+1
            
            else:
                #right increase
                res=min(res,nums[m])
                r=m-1
        
        return min(res,nums[l])
 # 更正后算法
 class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:
 
        
        l=0
        r=len(nums)-1
        res = float(&#39;inf&#39;)
        while l&amp;lt;r:
            m = (l+r)//2
            while l&amp;lt;r and nums[l]==nums[r] :
                res=min(res,nums[l])
                l+=1
                r-=1
            
            if nums[l] &amp;lt;= nums[m]:
                # left increse
                res=min(res,nums[l])
                l=m+1
            
            else:
                #right increase
                res=min(res,nums[m])
                r=m-1
        
        return min(res,nums[l])
               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过比较nums【l】和nums【m】可以知道是左侧单增还是右侧单增， 左侧单增需要查找右侧，但左侧的起始也应该记录下，对右侧情况同理。 注意先去重。但问题是去重会花费O（n）时间。和直接找min一样了，思路不通。在之前思路上多加一行判断，while left==rgiht， left+=1 right-=1. 这样在大部分case下是lg（n）最坏情况是O（n）。&lt;/p&gt;
&lt;h1 id=&#34;155-min-stack-easy&#34;&gt;155. Min Stack （Easy）&lt;/h1&gt;
&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []
        

    def push(self, val: int) -&amp;gt; None:
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            self.min_stack.append(min(self.min_stack[-1],val))
        

    def pop(self) -&amp;gt; None:
        self.stack.pop()
        self.min_stack.pop()
        

    def top(self) -&amp;gt; int:
        return self.stack[-1] if self.stack else None
        

    def getMin(self) -&amp;gt; int:
        return self.min_stack[-1] if self.min_stack else None
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;156-binary-tree-upside-down-medium&#34;&gt;156. Binary Tree Upside Down (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def upsideDownBinaryTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]:
        # 层序遍历
        if not root: return root
        res = []
        queue = [root]
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur)
                if cur.left:
                    queue.append(cur.left)
                    cur.left=None
                if cur.right:
                    queue.append(cur.right)
                    cur.right=None
            res.append(level)
        
        result=res[-1][0]
        
        for j,row in enumerate(res):
            for i,node in enumerate(row):
                if j+1&amp;lt;len(res) and i*2&amp;lt;len(res[j+1]):
                    res[j+1][i*2].right=node  
                    res[j+1][i*2].left = res[j+1][i*2+1]  if   i*2+1 &amp;lt;len(res[j+1]) else None
                
        return result
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：层序遍历，然后strip left&amp;amp;right=None光剩下node。 然后重新组建链接关系。&lt;/p&gt;
&lt;h1 id=&#34;157-read-n-characters-given-read4-easy&#34;&gt;157. Read N Characters Given Read4 （Easy）&lt;/h1&gt;
&lt;p&gt;Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
The read4 API is already defined for you.

    @param buf4, a list of characters
    @return an integer
    def read4(buf4):

# Below is an example of how the read4 API can be called.
file = File(&amp;quot;abcdefghijk&amp;quot;) # File is &amp;quot;abcdefghijk&amp;quot;, initially file pointer (fp) points to &#39;a&#39;
buf4 = [&#39; &#39;] * 4 # Create buffer with enough space to store characters
read4(buf4) # read4 returns 4. Now buf = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], fp points to &#39;e&#39;
read4(buf4) # read4 returns 4. Now buf = [&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], fp points to &#39;i&#39;
read4(buf4) # read4 returns 3. Now buf = [&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,...], fp points to end of file
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def read(self, buf, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        &amp;quot;&amp;quot;&amp;quot;
        buf4 =[&#39; &#39; for _ in range(4)]
        c=0
        start=0
        while c&amp;lt;n:
            val=read4(buf4)
            c+=val
            if c&amp;lt;=n:
                buf[start:start+val]=buf4 
            else:
                
                buf[start:n]=buf4[:n-start] 
                return n
               
           
            start=start+val
           
            if val==0:
                break
                
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;158-read-n-characters-given-read4-ii-call-multiple-times-hard&#34;&gt;158. Read N Characters Given read4 II - Call Multiple Times (Hard)&lt;/h1&gt;
&lt;p&gt;Given a file and assume that you can only read the file using a given method read4, implement a method read to read n characters. Your method read may be called multiple times.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The read4 API is already defined for you.
# def read4(buf4: List[str]) -&amp;gt; int:

class Solution:
    
   
    buf4_rem = [&#39; &#39;]*4
    n_rem=0
   
    def read(self, buf: List[str], n: int) -&amp;gt; int:
         
        start=0
        buf4=[&#39; &#39;]*4
        c=0
        while c&amp;lt;n:
            if self.n_rem&amp;gt;0:
                #have remain
                if c+self.n_rem&amp;lt;n:
                    buf[start:start+self.n_rem] = self.buf4_rem[:self.n_rem]
                    start+=self.n_rem
                    c+=self.n_rem
                    self.n_rem=0
                  
                else:
                    #c+n_rem&amp;gt;=n
                    # char needed =  n-c
                    buf[start:n] = self.buf4_rem[:n-c]
                    self.n_rem = self.n_rem - (n-c)
                    if self.n_rem&amp;gt;0:
                        self.buf4_rem = self.buf4_rem[n-c:]+[&#39; &#39;]*(4-(n-c))
                    return n
            
            else:
                 
                #n_rem==0
                nread = read4(buf4)
                if nread==0:break
                if c+nread&amp;lt;n:
                    #overwrite nead chars
                    buf[start:start+nread] = buf4[:nread]
                    start+=nread
                    c+=nread
                else:
                    #char needed n-c
                    buf[start:n]=  buf4[:n-c]
                    self.buf4_rem = buf4[n-c:] + [&#39; &#39;]*(4-(n-c))
                    self.n_rem = nread-(n-c)
                    return n
            
        
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尼玛，这hard题目，完全是考细心不是考算法，垃圾题目。&lt;/p&gt;
&lt;h1 id=&#34;159-longest-substring-with-at-most-two-distinct-characters-medium&#34;&gt;159. Longest Substring with At Most Two Distinct Characters （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s, return the length of the longest substring that contains at most two distinct characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&amp;gt; int:
        # e c e b a
        # e c e b a
        
        map_2pos = dict()
        res=1
        start=0
        for i,char in enumerate(s):
            if (char not in map_2pos) and len(map_2pos)==2:
                #do calculation
                small_k=None
                small_v=float(&#39;inf&#39;)
                for k,v in map_2pos.items():
                    if v&amp;lt;small_v:
                        small_v=v
                        small_k=k
                del map_2pos[small_k]
                start=small_v+1
                res=max(res,i-start+1)
            elif char in map_2pos and len(map_2pos)==2:
                res=max(res,i-start+1)
            elif len(map_2pos)&amp;lt;2:
                res=max(res,i-start+1)
                
            map_2pos[char]=i
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： sliding window， 用dic保存char最近一次出现位置，dic保持2个元素内。 情况1： 当dic已经有2个元素，要加入不同元素，需要pop位置最小那个。然后计算。 情况2：还是在dic中相同char，只做长度更新。 情况3：dic中元素不到2，只做长度更新。&lt;/p&gt;
&lt;h1 id=&#34;160-intersection-of-two-linked-lists-easy&#34;&gt;160. Intersection of Two Linked Lists （Easy）&lt;/h1&gt;
&lt;p&gt;Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; ListNode:
        
        def length(node):
            c=0
            while node:
                c+=1
                node=node.next
            return c
        
        la=length(headA)
        lb=length(headB)
        
        if la&amp;lt;lb:
            la,lb=lb,la
            headA,headB=headB,headA
        
        # A always &amp;gt; B
        
        diff = la-lb 
        
        for i in range(diff):
            headA = headA.next
        
 
        while headA and headB:
            if headA==headB:
                return headA
            headA=headA.next
            headB=headB.next
        return None
        
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-18</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-17/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;141-linked-list-cycle-easy&#34;&gt;141. Linked List Cycle (Easy)&lt;/h1&gt;
&lt;p&gt;Given head, the head of a linked list, determine if the linked list has a cycle in it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool:
        if not head: return False
        
        slow=head
        fast=head
        
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            
            if slow==fast:
                return True
        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;142-linked-list-cycle-ii-medium&#34;&gt;142. Linked List Cycle II (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&amp;gt; ListNode:
        if not head: return head
        fast=slow=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if fast==slow:
                if fast==head: return head
                fast = head
                while fast:
                    fast=fast.next
                    slow=slow.next
                    if fast==slow:
                        return slow
        return None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意  if fast&lt;mark&gt;slow: 时候 if fast&lt;/mark&gt;head: return head 情况。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred143-reorder-list-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;143. Reorder List (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given the head of a singly linked-list. The list can be represented as:0 1 2 3 4 ..n, reorder as 0 n 1 n-1 2 n-2 ...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not head: return None
        if  head and head.next and not head.next.next   : return head
        if head and not head.next: return head
        
        
        cur=head
        
        tail_pre=None
        while cur.next:
            tail_pre=cur
            cur=cur.next
        tail=cur
      
        
        headnext = head.next
        tail_pre.next=None
        head.next=tail
        tail.next=self.reorderList(headnext)
        
        return head
# answer 思路 writing
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
 

        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
 
        slow=fast=head
        pre_slow=None
        while fast and fast.next:
            pre_slow=slow
            slow=slow.next
            fast=fast.next.next
        
        pre_mid = pre_slow
        mid=slow
         
        odd_head = rev(mid)
     
        #merge two
        first, second = head, odd_head
        while second.next:
            tmp=first.next
            first.next=second
            first=tmp
            
            tmp=second.next
            second.next=first
            second=tmp
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次尝试，time limit exceeded，base case： node为空，2个node，一个node情况。 然后暴力求解即可.T（n）= T（n-2）+1 所以时间复杂度 1+2+3.。。+n = O（n*n）&lt;br&gt;
第二次尝试放弃了， 思路： 找到mid， rev（mid）， merge 2个list。&lt;/p&gt;
&lt;h1 id=&#34;144-binary-tree-preorder-traversal-easy&#34;&gt;144. Binary Tree Preorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def pre(root):
            if not root: return
            res.append(root.val)
            pre(root.left)
            pre(root.right)
        pre(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        stack = []
        while stack or root:
            while root:
                res.append(root.val)
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            root=node.right
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;145-binary-tree-postorder-traversal-easy&#34;&gt;145. Binary Tree Postorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def post(root):
            if not root:return
            post(root.left)
            post(root.right)
            res.append(root.val)
        post(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        if not root:
            return []
        
        stack=[]
        result=[]
        
        stack.append(root)

        while stack:
            
            cur=stack.pop()
            result.append(cur.val)
            
            if cur.left:
                stack.append(cur.left)
                
            if cur.right:
                stack.append(cur.right)
                
        return result[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左右子树颠倒的前序遍历取反向就是正常树的后序遍历。&lt;/p&gt;
&lt;h1 id=&#34;146-lru-cache-medium&#34;&gt;146. LRU Cache （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Node:
    def __init__(self,key,val,next=None,pre=None):
        self.key=key
        self.val=val
        self.next=next
        self.pre=pre
        
class LRUCache:

    def __init__(self, capacity: int):
        self.cap = capacity
        self.n=0
        self.map_key_node=dict()
        self.head = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.tail = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.head.next = self.tail
        self.tail.pre = self.head
    
    def debug(self,disable=True):
        if not disable:
            cur=self.head
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.next
            print(&#39;,&#39;.join(tmp))
            cur=self.tail
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.pre
            print(&#39;,&#39;.join(tmp[::-1]))

    def get(self, key: int) -&amp;gt; int:
        print(&#39;get&#39;,key)
        if key in self.map_key_node:
            #pop from linked list
            node = self.map_key_node[key]
            node.pre.next=node.next
            node.next.pre = node.pre
            #add from head
            headnext=self.head.next
            node.pre= self.head
            self.head.next=node
            node.next=headnext
            headnext.pre=node
            
            self.debug()
            return self.map_key_node[key].val
        else:
            self.debug()
            return -1
        

    def put(self, key: int, value: int) -&amp;gt; None:
        print(&#39;put&#39;,key,value)
        if key in self.map_key_node:
            #if key in cache, update value &amp;amp; move to top of linked list
            self.map_key_node[key].val=value
            
            self.get(key) 
            
        else:
            #add key-val pair to cache
            self.map_key_node[key]= Node(key=key,val=value)
            self.n = self.n+1
            if self.n &amp;gt; self.cap:
                # evict least recently used key
                # pop from tail
                to_be_del = self.tail.pre
                to_be_del.pre.next= self.tail
                self.tail.pre= to_be_del.pre
                del self.map_key_node[to_be_del.key]
                #add from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                headnext.pre=self.map_key_node[key]
                self.map_key_node[key].next=headnext
                #update n
                self.n = self.n-1
            else:
                #put &amp;lt;=cap append from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                
                headnext.pre = self.map_key_node[key]
                self.map_key_node[key].next=headnext
                
        self.debug()
                
        
        
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

# double directed linkedlist
# dict   key-&amp;gt; Node   (put get update value)
#  put 
#  &amp;lt;= cap just append to linked from head.     head new old1 old2..
# &amp;gt; cap pop from tail   put from head
# get pop() then put to head


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： double linked list + map     get：首先pop from linked list 然后 add 到head下一位。   put： 如果小于等于cap，从head开始append，如果大于cap， pop tail 然后add from head。&lt;/p&gt;
&lt;h1 id=&#34;147-insertion-sort-list-medium&#34;&gt;147. Insertion Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&#39;s head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
       
        
        def insert(node):
            
            pre=None
            cur=head_sorted.next
            FLAG=False
            while cur:
                #    6 1
                if (pre and node.val&amp;lt;=cur.val and node.val&amp;gt;=pre.val) or (pre is None and cur.val&amp;gt;=node.val):
                    #do insert
                    if pre is None:
                        #insert after head_sorted
                        head_sorted_next=head_sorted.next
                        head_sorted.next=node
                        node.next= head_sorted_next
                    else:
                        #normal insertion
                        pre.next=node
                        node.next=cur
                    #after insertion break
                    FLAG=True
                    break
                
                pre=cur
                cur=cur.next
            
            if not FLAG:
                pre.next = node
            
        
        cur=head.next
        head.next=None
        head_sorted = ListNode(val=&#39;NULL&#39;,next=head)
        while cur:
            curnext = cur.next
            cur.next=None
            insert(cur)
            cur=curnext
        
        return head_sorted.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没啥难的，就是细心。&lt;/p&gt;
&lt;h1 id=&#34;148-sort-list-medium&#34;&gt;148. Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the list after sorting it in ascending order.&lt;br&gt;
Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        # nlogn compare method
        # O(1) space
        # merge sort
        
        def merge(l1,l2):
            #print(&#39;l1&#39;)
            #print(l1)
            #print(&#39;l2&#39;)
            #print(l2)
            dummy_head = ListNode(val=&#39;NULL&#39;)
            cur=dummy_head
            while l1 and l2:
                if l1.val&amp;lt;l2.val:
                    cur.next=l1
                    l1=l1.next if l1 else None
                else:
                    cur.next=l2
                    l2=l2.next if l2 else None
                
                cur=cur.next
                
            if l1:
                cur.next=l1
            if l2:
                cur.next=l2
            #print(&#39;res&#39;)
            #print(dummy_head.next)
            return dummy_head.next
        
        def sort(head):
            if (not head) or (not head.next): return head
            slow=fast=head
            pre=None
            while fast and fast.next:
                pre=slow
                slow=slow.next
                fast=fast.next.next
                
            
            pre.next=None
            mid =slow
         
            l1=sort(mid) 
            l2=sort(head)
          
            return merge(l1,l2)
        
        return sort(head)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;149-max-points-on-a-line-hard&#34;&gt;149. Max Points on a Line (Hard)&lt;/h1&gt;
&lt;p&gt;Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxPoints(self, points: List[List[int]]) -&amp;gt; int:
        # p1 [x, ax+b]
        # p2 [x&#39;,ax&#39;+b]     
        # y1=ax1+b
        # y2=ax2+b
        #   y1-y2=a(x1-x2)
        # a = y1-y2/x1-x2
        # b = y-ax
        dic = collections.defaultdict(set)
        n = len(points)
        if n==1: return 1
        for i in range(n-1):
            for j in range(i+1,n):
                p1=points[i]
                p2=points[j]
                a=(p1[1]-p2[1])/(p1[0]-p2[0]) if p1[0]!=p2[0] else None
                b = p1[1]-a*p1[0] if a is not None else None
                if a is not None:
                    key = str(a)+&#39;-&#39;+str(b)
                else:
                    key = &#39;x=constant&#39;+str(p1[0]) 
                dic[key].add(i)
                dic[key].add(j)
        #print(dic)
        return max(map(len,dic.values()))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;150-evaluate-reverse-polish-notation-medium&#34;&gt;150. Evaluate Reverse Polish Notation (Medium)&lt;/h1&gt;
&lt;p&gt;Input: tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;]&lt;br&gt;
Output: 9&lt;br&gt;
Explanation: ((2 + 1) * 3) = 9&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def evalRPN(self, tokens: List[str]) -&amp;gt; int:
        numstack = []
        for t in tokens:
            if t in &#39;+-*/&#39;:
                #op
            
                num2=numstack.pop()
                num1=numstack.pop()
                print(t,num1,num2,end=&#39;  # &#39;)
                if t==&#39;+&#39;:
                    numstack.append(num1+num2)
                elif t==&#39;-&#39;:
                    numstack.append(num1-num2)
                elif t==&#39;*&#39;:
                    numstack.append(num1*num2)
                elif t==&#39;/&#39;:
                    numstack.append(int(num1/num2) )
                else:
                    print(error)
                #print(numstack[-1])
            else:
                numstack.append(int(t))
         
        #print(numstack)
        return numstack[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 int(num1/num2)，  int(1.8)=1 int(-1.8)=-1  但是  -2/1.1=-1.8181818181818181     -2//1.1=-2  取整后会更偏小，但是对负数希望的是偏大。对正数希望的是抹去小数偏小。 所以只能取int。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;141-linked-list-cycle-easy-2&#34;&gt;141. Linked List Cycle (Easy)&lt;/h1&gt;
&lt;p&gt;Given head, the head of a linked list, determine if the linked list has a cycle in it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool:
        if not head: return False
        
        slow=head
        fast=head
        
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            
            if slow==fast:
                return True
        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;142-linked-list-cycle-ii-medium-2&#34;&gt;142. Linked List Cycle II (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&amp;gt; ListNode:
        if not head: return head
        fast=slow=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if fast==slow:
                if fast==head: return head
                fast = head
                while fast:
                    fast=fast.next
                    slow=slow.next
                    if fast==slow:
                        return slow
        return None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意  if fast&lt;mark&gt;slow: 时候 if fast&lt;/mark&gt;head: return head 情况。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred143-reorder-list-medium-font-2&#34;&gt;&lt;font color=&#39;red&#39;&gt;143. Reorder List (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given the head of a singly linked-list. The list can be represented as:0 1 2 3 4 ..n, reorder as 0 n 1 n-1 2 n-2 ...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not head: return None
        if  head and head.next and not head.next.next   : return head
        if head and not head.next: return head
        
        
        cur=head
        
        tail_pre=None
        while cur.next:
            tail_pre=cur
            cur=cur.next
        tail=cur
      
        
        headnext = head.next
        tail_pre.next=None
        head.next=tail
        tail.next=self.reorderList(headnext)
        
        return head
# answer 思路 writing
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
 

        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
 
        slow=fast=head
        pre_slow=None
        while fast and fast.next:
            pre_slow=slow
            slow=slow.next
            fast=fast.next.next
        
        pre_mid = pre_slow
        mid=slow
         
        odd_head = rev(mid)
     
        #merge two
        first, second = head, odd_head
        while second.next:
            tmp=first.next
            first.next=second
            first=tmp
            
            tmp=second.next
            second.next=first
            second=tmp
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次尝试，time limit exceeded，base case： node为空，2个node，一个node情况。 然后暴力求解即可.T（n）= T（n-2）+1 所以时间复杂度 1+2+3.。。+n = O（n*n）&lt;br&gt;
第二次尝试放弃了， 思路： 找到mid， rev（mid）， merge 2个list。&lt;/p&gt;
&lt;h1 id=&#34;144-binary-tree-preorder-traversal-easy-2&#34;&gt;144. Binary Tree Preorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def pre(root):
            if not root: return
            res.append(root.val)
            pre(root.left)
            pre(root.right)
        pre(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        stack = []
        while stack or root:
            while root:
                res.append(root.val)
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            root=node.right
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;145-binary-tree-postorder-traversal-easy-2&#34;&gt;145. Binary Tree Postorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def post(root):
            if not root:return
            post(root.left)
            post(root.right)
            res.append(root.val)
        post(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        if not root:
            return []
        
        stack=[]
        result=[]
        
        stack.append(root)

        while stack:
            
            cur=stack.pop()
            result.append(cur.val)
            
            if cur.left:
                stack.append(cur.left)
                
            if cur.right:
                stack.append(cur.right)
                
        return result[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左右子树颠倒的前序遍历取反向就是正常树的后序遍历。&lt;/p&gt;
&lt;h1 id=&#34;146-lru-cache-medium-2&#34;&gt;146. LRU Cache （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Node:
    def __init__(self,key,val,next=None,pre=None):
        self.key=key
        self.val=val
        self.next=next
        self.pre=pre
        
class LRUCache:

    def __init__(self, capacity: int):
        self.cap = capacity
        self.n=0
        self.map_key_node=dict()
        self.head = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.tail = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.head.next = self.tail
        self.tail.pre = self.head
    
    def debug(self,disable=True):
        if not disable:
            cur=self.head
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.next
            print(&#39;,&#39;.join(tmp))
            cur=self.tail
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.pre
            print(&#39;,&#39;.join(tmp[::-1]))

    def get(self, key: int) -&amp;gt; int:
        print(&#39;get&#39;,key)
        if key in self.map_key_node:
            #pop from linked list
            node = self.map_key_node[key]
            node.pre.next=node.next
            node.next.pre = node.pre
            #add from head
            headnext=self.head.next
            node.pre= self.head
            self.head.next=node
            node.next=headnext
            headnext.pre=node
            
            self.debug()
            return self.map_key_node[key].val
        else:
            self.debug()
            return -1
        

    def put(self, key: int, value: int) -&amp;gt; None:
        print(&#39;put&#39;,key,value)
        if key in self.map_key_node:
            #if key in cache, update value &amp;amp; move to top of linked list
            self.map_key_node[key].val=value
            
            self.get(key) 
            
        else:
            #add key-val pair to cache
            self.map_key_node[key]= Node(key=key,val=value)
            self.n = self.n+1
            if self.n &amp;gt; self.cap:
                # evict least recently used key
                # pop from tail
                to_be_del = self.tail.pre
                to_be_del.pre.next= self.tail
                self.tail.pre= to_be_del.pre
                del self.map_key_node[to_be_del.key]
                #add from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                headnext.pre=self.map_key_node[key]
                self.map_key_node[key].next=headnext
                #update n
                self.n = self.n-1
            else:
                #put &amp;lt;=cap append from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                
                headnext.pre = self.map_key_node[key]
                self.map_key_node[key].next=headnext
                
        self.debug()
                
        
        
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

# double directed linkedlist
# dict   key-&amp;gt; Node   (put get update value)
#  put 
#  &amp;lt;= cap just append to linked from head.     head new old1 old2..
# &amp;gt; cap pop from tail   put from head
# get pop() then put to head


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： double linked list + map     get：首先pop from linked list 然后 add 到head下一位。   put： 如果小于等于cap，从head开始append，如果大于cap， pop tail 然后add from head。&lt;/p&gt;
&lt;h1 id=&#34;147-insertion-sort-list-medium-2&#34;&gt;147. Insertion Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&#39;s head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
       
        
        def insert(node):
            
            pre=None
            cur=head_sorted.next
            FLAG=False
            while cur:
                #    6 1
                if (pre and node.val&amp;lt;=cur.val and node.val&amp;gt;=pre.val) or (pre is None and cur.val&amp;gt;=node.val):
                    #do insert
                    if pre is None:
                        #insert after head_sorted
                        head_sorted_next=head_sorted.next
                        head_sorted.next=node
                        node.next= head_sorted_next
                    else:
                        #normal insertion
                        pre.next=node
                        node.next=cur
                    #after insertion break
                    FLAG=True
                    break
                
                pre=cur
                cur=cur.next
            
            if not FLAG:
                pre.next = node
            
        
        cur=head.next
        head.next=None
        head_sorted = ListNode(val=&#39;NULL&#39;,next=head)
        while cur:
            curnext = cur.next
            cur.next=None
            insert(cur)
            cur=curnext
        
        return head_sorted.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没啥难的，就是细心。&lt;/p&gt;
&lt;h1 id=&#34;148-sort-list-medium-2&#34;&gt;148. Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the list after sorting it in ascending order.&lt;br&gt;
Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        # nlogn compare method
        # O(1) space
        # merge sort
        
        def merge(l1,l2):
            #print(&#39;l1&#39;)
            #print(l1)
            #print(&#39;l2&#39;)
            #print(l2)
            dummy_head = ListNode(val=&#39;NULL&#39;)
            cur=dummy_head
            while l1 and l2:
                if l1.val&amp;lt;l2.val:
                    cur.next=l1
                    l1=l1.next if l1 else None
                else:
                    cur.next=l2
                    l2=l2.next if l2 else None
                
                cur=cur.next
                
            if l1:
                cur.next=l1
            if l2:
                cur.next=l2
            #print(&#39;res&#39;)
            #print(dummy_head.next)
            return dummy_head.next
        
        def sort(head):
            if (not head) or (not head.next): return head
            slow=fast=head
            pre=None
            while fast and fast.next:
                pre=slow
                slow=slow.next
                fast=fast.next.next
                
            
            pre.next=None
            mid =slow
         
            l1=sort(mid) 
            l2=sort(head)
          
            return merge(l1,l2)
        
        return sort(head)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;149-max-points-on-a-line-hard-2&#34;&gt;149. Max Points on a Line (Hard)&lt;/h1&gt;
&lt;p&gt;Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxPoints(self, points: List[List[int]]) -&amp;gt; int:
        # p1 [x, ax+b]
        # p2 [x&#39;,ax&#39;+b]     
        # y1=ax1+b
        # y2=ax2+b
        #   y1-y2=a(x1-x2)
        # a = y1-y2/x1-x2
        # b = y-ax
        dic = collections.defaultdict(set)
        n = len(points)
        if n==1: return 1
        for i in range(n-1):
            for j in range(i+1,n):
                p1=points[i]
                p2=points[j]
                a=(p1[1]-p2[1])/(p1[0]-p2[0]) if p1[0]!=p2[0] else None
                b = p1[1]-a*p1[0] if a is not None else None
                if a is not None:
                    key = str(a)+&#39;-&#39;+str(b)
                else:
                    key = &#39;x=constant&#39;+str(p1[0]) 
                dic[key].add(i)
                dic[key].add(j)
        #print(dic)
        return max(map(len,dic.values()))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;150-evaluate-reverse-polish-notation-medium-2&#34;&gt;150. Evaluate Reverse Polish Notation (Medium)&lt;/h1&gt;
&lt;p&gt;Input: tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;]&lt;br&gt;
Output: 9&lt;br&gt;
Explanation: ((2 + 1) * 3) = 9&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def evalRPN(self, tokens: List[str]) -&amp;gt; int:
        numstack = []
        for t in tokens:
            if t in &#39;+-*/&#39;:
                #op
            
                num2=numstack.pop()
                num1=numstack.pop()
                print(t,num1,num2,end=&#39;  # &#39;)
                if t==&#39;+&#39;:
                    numstack.append(num1+num2)
                elif t==&#39;-&#39;:
                    numstack.append(num1-num2)
                elif t==&#39;*&#39;:
                    numstack.append(num1*num2)
                elif t==&#39;/&#39;:
                    numstack.append(int(num1/num2) )
                else:
                    print(error)
                #print(numstack[-1])
            else:
                numstack.append(int(t))
         
        #print(numstack)
        return numstack[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 int(num1/num2)，  int(1.8)=1 int(-1.8)=-1  但是  -2/1.1=-1.8181818181818181     -2//1.1=-2  取整后会更偏小，但是对负数希望的是偏大。对正数希望的是抹去小数偏小。 所以只能取int。&lt;/p&gt;
">Leetcode 2021-11-17</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-16/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;131-palindrome-partitioning-medium&#34;&gt;131. Palindrome Partitioning (Medium)&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.&lt;br&gt;
A palindrome string is a string that reads the same backward as forward.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def partition(self, s: str) -&amp;gt; List[List[str]]:
        if len(s)==1:
            return [[s]]
        res = []
        for i in range(1,len(s)):
            head = s[:i]
            tail = s[i:]
          
            if [e for e in head]==[e for e in head][::-1]:
                for rest in self.partition(tail):
                    res.append([head]+rest)
        #check total
        if [e for e in s ]==[e for e in s][::-1]:
            res.append([s])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred132-palindrome-partitioning-ii-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;132. Palindrome Partitioning II （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;br&gt;
Return the minimum cuts needed for a palindrome partitioning of s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCut(self, s: str) -&amp;gt; int:
        # find all possible palindrome then return 
        mem = dict()
        def palindrom(s):
            if s in mem: return mem[s]
            if len(s)==1:
                return [[s]]
            res = []
            for i in range(1,len(s)):
                head=s[:i]
                tail=s[i:]
                if [e for e in head]==[e for e in head][::-1]:
                    for rest in palindrom(tail):
                        res.append([head]+rest)
            #final test on whole string
            if [e for e in s]==[e for e in s][::-1]:
                res.append([s])
            mem[s]=res
            return res
        
        res = palindrom(s)
        mincut=float(&#39;inf&#39;)
        for row in res:
            mincut=min(mincut,len(row)-1)
        return mincut

 # second way of time limit exceeded
class Solution:
    mem =dict()
    def minCut(self, s: str) -&amp;gt; int:  
        if s in self.mem: 
            return self.mem[s]
        if not s  or len(s)==1: 
            self.mem[s]=0
            return 0
        
        min_c = float(&#39;inf&#39;)
        
        for i in range(1,len(s)):
            head = s[:i]
            tail = s[i:]
            if [s for s in head]==[s for s in head][::-1]:
                min_c= min(min_c,1+self.minCut(tail))
            else:
                min_c = min(min_c, 1+self.minCut(head)+self.minCut(tail))
        
        if [e for e in s]==[e for e in s][::-1]:
            return 0
        self.mem[s]=min_c
        return min_c
                
#answer way of DP
class Solution:
    def minCut(self, s: str) -&amp;gt; int:
        
        if not s or len(s)==1: return 0
        
        dp=[i for i in range(len(s))]
        
        # 0...ith char cut 
        for mid in range(1,len(s)):
            #case 1 odd len center is at index mid
            start=mid
            end=mid
            while start&amp;gt;=0 and end&amp;lt;len(s) and s[start]==s[end]:
                newcutatend=0 if start==0 else dp[start-1]+1
                dp[end]=min(dp[end],newcutatend)
                start-=1
                end+=1
             
            #case 2  even len center is between mid-1,mid
            start=mid-1
            end=mid
            while start&amp;gt;=0 and end&amp;lt;len(s) and s[start]==s[end]:
                newcutatend=0 if start==0 else dp[start-1]+1
                dp[end]=min(dp[end],newcutatend)
                start-=1
                end+=1
               
            
        return dp[len(s)-1]
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接产生出full list 来计算time limit exceeded。即使加了mem都不行。所以得调整思路。BT无法解决，感觉像DP问题。但没思路。&lt;br&gt;
思路：string expansion+DP&lt;br&gt;
string可以从mid的位置做expansion，但odd/even长度expansion初始情况不同， odd时候 start=mid end=mid， enven时候 start=mid-1 end=mid, 定义dp【i】为在0~i包含i位置的string minCut。 则 dp【end】=min（dp【end】，dp【start-1】+1），注意边界情况，如果start==0， dp【end】=dp【end】。&lt;/p&gt;
&lt;h1 id=&#34;133-clone-graph-medium&#34;&gt;133. Clone Graph （Medium）&lt;/h1&gt;
&lt;p&gt;Given a reference of a node in a connected undirected graph.&lt;br&gt;
Return a deep copy (clone) of the graph.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def cloneGraph(self, node: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        if not node: return node
        
        visited=set()
        map_old2new = dict()
        
        #clone node only
        def walk(node):
            visited.add(node)
            #clone node without neighbors
            new_node = Node(node.val)
            map_old2new[node]=new_node
            for nei in node.neighbors:
                if nei not in visited:
                    walk(nei)
        
        walk(node)
        
        #clone neighbors
        visited=set()
        def walk_nei(node):
            visited.add(node)
            #clone new_node neighbors
            map_old2new[node].neighbors = [map_old2new[nei] for nei in node.neighbors]
            for nei in node.neighbors:
                if nei not in visited:
                    walk_nei(nei)
        
        walk_nei(node)
        
        return map_old2new[node]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue134-gas-station-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;134. Gas Station (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].&lt;br&gt;
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.&lt;br&gt;
Given two integer arrays gas and cost, return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique&lt;br&gt;
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]&lt;br&gt;
Output: 3&lt;br&gt;
Explanation:&lt;br&gt;
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4&lt;br&gt;
Travel to station 4. Your tank = 4 - 1 + 5 = 8&lt;br&gt;
Travel to station 0. Your tank = 8 - 2 + 1 = 7&lt;br&gt;
Travel to station 1. Your tank = 7 - 3 + 2 = 6&lt;br&gt;
Travel to station 2. Your tank = 6 - 4 + 3 = 5&lt;br&gt;
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.&lt;br&gt;
Therefore, return 3 as the starting index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int:
        
        #gas = [1,2,3,4,5], cost = [3,4,5,1,2]
        #Start at station 2 (index 2) and fill up with 3 unit of gas. Your tank = 0 + 3 = 3
        #Travel to station 3. Your tank = 3 - 5 + 4 = 2
        #Travel to station 4. Your tank = 2 - 1 + 5 = 6
        #Travel to station 0. Your tank = 6 - 2 + 1 = 5
        #Travel to station 1. Your tank = 5 - 3 + 2 = 4
        #Travel to station 2. Your tank = 4 - 4 + 3 = 3
        
 
     
        length=len(gas)
       
        for start_pos in range(length):
            my_tank=gas[start_pos]
            cur_pos = start_pos
            i=0
            #print(&#39;start_pos{} mytank {}&#39;.format(start_pos,my_tank))
            while i&amp;lt;=length:
                i+=1
                travel_to = (cur_pos+1)%length
                my_tank=my_tank-cost[cur_pos]
                if my_tank&amp;lt;=0:
                    if my_tank==0 and i&amp;gt;0 and travel_to==start_pos: return start_pos
                    break
                my_tank+=gas[travel_to]
                #print(&#39;travel to {} mytank {}&#39;.format(travel_to,my_tank))
              
                cur_pos=travel_to
                if cur_pos==start_pos:
                    return start_pos
                         
  
        return -1

#answer way of writting
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int:
        
        n=len(gas)
        total_tank=cur_tank=0
        starting_station=0
        for i in range(n):
            total_tank += gas[i]-cost[i]
            cur_tank+=gas[i]-cost[i]
            if cur_tank&amp;lt;0:
                starting_station=i+1
                cur_tank=0
        
        if total_tank&amp;gt;=0:
            return starting_station
        return -1
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心，做判断时候， my_tank - cost[cur_pos] 如果小于0要break的， 只有确认可以到 travel_to时候才能my_tank += gas[traval_to] 但是显然是O（n*n）时间复杂度。 答案是O（N）。思路： 记录total_tank 和 cur_tank, 如果total_tank 小于0 或者cur_tank 小于0都不能成环路。 如果cur_tank 小于0，说明起始点有问题， start_station=i+1 cur_tank=0.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-135-candy-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 135. Candy (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.&lt;/p&gt;
&lt;p&gt;You are giving candies to these children subjected to the following requirements:&lt;br&gt;
Each child must have at least one candy.&lt;br&gt;
Children with a higher rating get more candies than their neighbors.&lt;br&gt;
Return the minimum number of candies you need to have to distribute the candies to the children.&lt;br&gt;
Input: ratings = [1,0,2]&lt;br&gt;
Output: 5&lt;br&gt;
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        #[1,0,2]
        # 1 1 1
        # 2 1 2
        
        #[1,2,2]
        # 1 1 1
        # 1 2 1
        
        res = [1]*len(ratings)
        
        hasChanged = True
        while hasChanged:
            hasChanged = False
            for i in range(len(ratings)):
                neigh_left_rating = ratings[i-1] if i-1&amp;gt;=0 else None
                neigh_right_rating = ratings[i+1] if i+1&amp;lt;len(ratings) else None
                if neigh_left_rating is not None and ratings[i]&amp;gt;neigh_left_rating and res[i]&amp;lt;=res[i-1]:
                    hasChanged=True
                    res[i] = res[i-1]+1

                if  neigh_right_rating is not None and ratings[i]&amp;gt;neigh_right_rating and res[i+1] &amp;gt;= res[i]:
                    hasChanged=True
                    res[i] = res[i+1]+1
       
        print(res)
        return sum(res)

#answer way of writting 1）Using two arrays 
class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        
        left2right = [1]*len(ratings)
        right2left = [1]*len(ratings)
        for i in range(1,len(ratings)):
            if ratings[i] &amp;gt; ratings[i - 1]:
                left2right[i] = left2right[i - 1] + 1
            
        for i in range(len(ratings)-2,-1,-1):
            if ratings[i] &amp;gt; ratings[i + 1]:
                right2left[i] = right2left[i + 1] + 1;
        
        res = 0
        for i in range(len(ratings)):
            res+=max( left2right[i], right2left[i]) 
        
        return res

# answer way of writting： Using one array
class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        
        candies = [1]*len(ratings)
        for i in range(1,len(ratings)):
            if ratings[i] &amp;gt; ratings[i - 1]:  
                candies[i] = candies[i - 1] + 1
          
        sum = candies[-1]
        
        for i in range(len(ratings)-2,-1,-1):
            if  ratings[i] &amp;gt; ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
            
            sum += candies[i];
        
        return sum 
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hard题目果然有坑，直接做会遇到更新candy数目之后发现之前的res违反了rules 还需要回溯更新。而且即使是brutal force也只写对了一半，没想到用hasChanged Flag，以为过一次就已经得到解了。  O（n）方法  感觉是用stack。但感觉不正确。应该用拆分方法。    答案思路：   1）Using two arrays ：把一个复杂问题分割成2个小问题，单从左向右扫， 做更新使其满足左侧限制，让后从右向左扫。 使其满足右侧条件。最后结果必须满足左右条件，所以取max即可。2）Using one array：  思路和法1相同。&lt;/p&gt;
&lt;h1 id=&#34;136-single-number-easy&#34;&gt;136. Single Number （Easy）&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.&lt;br&gt;
You must implement a solution with a linear runtime complexity and use only constant extra space.&lt;br&gt;
Input: nums = [2,2,1]&lt;br&gt;
Output: 1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        res = 0
        for n in nums:
            res = res^n
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred137-single-number-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;137. Single Number II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.&lt;br&gt;
You must implement a solution with a linear runtime complexity and use only constant extra space.&lt;br&gt;
Input: nums = [2,2,3,2]&lt;br&gt;
Output: 3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        seen_once = seen_twice = 0
        
        for num in nums:
            # first appearance: 
            # add num to seen_once 
            # don&#39;t add to seen_twice because of presence in seen_once
            
            # second appearance: 
            # remove num from seen_once 
            # add num to seen_twice
            
            # third appearance: 
            # don&#39;t add to seen_once because of presence in seen_twice
            # remove num from seen_twice
            seen_once = ~seen_twice &amp;amp; (seen_once ^ num)
            seen_twice = ~seen_once &amp;amp; (seen_twice ^ num)

        return seen_once
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O1 mem On time 木有思路,要是用set 会violate use only constant extra space. 答案是bit manipulation。&lt;/p&gt;
&lt;h1 id=&#34;138-copy-list-with-random-pointer-medium&#34;&gt;138. Copy List with Random Pointer （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        if not head: return head
        map_old2new = dict()
        # just copy node without random 
        cur=head
        while cur:
            map_old2new[cur] = Node(x=cur.val)
            cur=cur.next
        
        # copy random and next pointers
        cur=head
        while cur:
            map_old2new[cur].next = map_old2new.get(cur.next,None)
            map_old2new[cur].random = map_old2new.get(cur.random,None)
            cur=cur.next
        
        return map_old2new[head]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;139-word-break-medium&#34;&gt;139. Word Break (Medium)&lt;/h1&gt;
&lt;p&gt;Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:

    def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool:
       
        mem=dict()
        def helper(s,wordDict):
            if not s: return True
            if s in mem: return mem[s]
            res = False
            for word in wordDict:
                l=len(word)
                if s[:l] == word:
                    res = res or helper(s[l:],wordDict)

            mem[s]=res
            return res
        
        return helper(s,wordDict)
#answer way of writting
class Solution(object):
    def wordBreak(self, s, wordDict):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        
        
        dp[i]= dp[j] and s[j:i] in dic    j&amp;lt;i
        
        &amp;quot;&amp;quot;&amp;quot;
        dp=[False]*(len(s)+1)
        se=set(wordDict)
        
        for i in range(1,len(s)+1):
            dp[i]=(s[:i] in se)
            for j in range(i):
                if dp[j]:
                    dp[i]=dp[i] or (s[j:i] in se)
        #print(dp)
        return dp[-1]


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了recursion+mem ，答案dp，异曲同工。&lt;/p&gt;
&lt;h1 id=&#34;140-word-break-ii-hard&#34;&gt;140. Word Break II （Hard）&lt;/h1&gt;
&lt;p&gt;Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.&lt;br&gt;
Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;,&amp;quot;cats&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;dog&amp;quot;]&lt;br&gt;
Output: [&amp;quot;cats and dog&amp;quot;,&amp;quot;cat sand dog&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]:
        
        
        def helper(s,wordDict):
            res = []
            for word in set(wordDict):
                l=len(word)
                if s[:l] in set(wordDict):
                    head = s[:l]
                    tail = s[l:]
                    if not tail:
                        res.append([head])
                    else:
                        for rest in helper(tail,wordDict):
                            res.append([head]+rest)
            return res
        
        res = set()
        for row in  helper(s,wordDict):
            res.add(&#39; &#39;.join(row))
        return list(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;just backtracking.&lt;/p&gt;
">Leetcode 2021-11-16</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-15/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;121-best-time-to-buy-and-sell-stock-easy&#34;&gt;121. Best Time to Buy and Sell Stock (Easy)&lt;/h1&gt;
&lt;p&gt;You are given an array prices where prices[i] is the price of a given stock on the ith day.&lt;br&gt;
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.&lt;br&gt;
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        #two pointer
        profit = 0
        min_price = float(&#39;inf&#39;)
        for i,n in enumerate(prices):
            min_price= min(min_price,n)
            profit=max(profit,n-min_price)
        return profit
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;122-best-time-to-buy-and-sell-stock-ii-medium&#34;&gt;122. Best Time to Buy and Sell Stock II (Medium)&lt;/h1&gt;
&lt;p&gt;On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.&lt;br&gt;
Find and return the maximum profit you can achieve.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        # this means I can accumulate every increase trend in fluctuation of price
        if len(prices)&amp;lt;=1: return 0
        profit=0
        for i in range(1,len(prices)):
            profit_i = prices[i]-prices[i-1]
            if profit_i&amp;gt;0:
                profit+=profit_i
        return profit
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred123-best-time-to-buy-and-sell-stock-iii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;123. Best Time to Buy and Sell Stock III (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Find the maximum profit you can achieve. You may complete at most two transactions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        
        min_=[float(&#39;inf&#39;)]*3
        r=[0]*3
        
        for i in range(len(prices)):
            for k in range(1,3):
                min_[k]=min(min_[k],prices[i]-r[k-1])
                r[k]=max(r[k],prices[i]-min_[k])
        
        return r[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一感觉是用Dynamic Programming。但是没想出来递推关系。。。Two pointer 的扩展， 求第二次min的时候是price[i]-第一次profit， 因为算第二次profit时候会用price[j] - (price[i]-第一次profit) 所以正好加上了第一次profit。比较巧妙。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred124-binary-tree-maximum-path-sum-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;124. Binary Tree Maximum Path Sum （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.&lt;br&gt;
The path sum of a path is the sum of the node&#39;s values in the path.&lt;br&gt;
Given the root of a binary tree, return the maximum path sum of any non-empty path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        def max_gain(node):
            nonlocal max_sum
            if not node:
                return 0

            # max sum on the left and right sub-trees of node
            left_gain = max(max_gain(node.left), 0)
            right_gain = max(max_gain(node.right), 0)
            
            # the price to start a new path where `node` is a highest node
            price_newpath = node.val + left_gain + right_gain
            
            # update max_sum if it&#39;s better to start a new path
            max_sum = max(max_sum, price_newpath)
        
            # for recursion :
            # return the max gain if continue the same path
            return node.val + max(left_gain, right_gain)
   
        max_sum = float(&#39;-inf&#39;)
        max_gain(root)
        return max_sum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fail to writing a working recursive solution!....问题出在recursion的return部分。&lt;br&gt;
思路：  local_max_sum = root.val + leftpath+rightpath  但在return时候，由于之前调用自己计算root.left 的leftpath和root.right的rightpath，所以是root.val+max(leftpath,rightpath) 这样return的路径是从root.left/root.right 单点延申出去的。不存在重复计算问题， 要是return  root.val+ leftpath+rightpath， 那么调用自己在root.left计算的是root.left的左右扩展了， 而不是 root.left 的单一延申。  这样返回值会错误。&lt;/p&gt;
&lt;h1 id=&#34;125-valid-palindrome-easy&#34;&gt;125. Valid Palindrome （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPalindrome(self, s: str) -&amp;gt; bool:
        l=0
        r=len(s)-1
        s=s.lower()
        while l&amp;lt;=r:
            while l&amp;lt;=r and s[l] not in &#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;:
                l+=1
            while l&amp;lt;=r and s[r] not in &#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;:
                r-=1
            
            if l&amp;lt;=r and s[l]!=s[r]:
                return False
            
            l+=1
            r-=1
        
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意while l&amp;lt;=r的判断。。。即使在内循环中。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred126-word-ladder-ii-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;126. Word Ladder II （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; List[List[str]]:
        # sortest path, graph bfs 
        # node is word
        # node neighbors are word differ by 1 letter in wordList.
        # find sortest path from beginWordd to endWord
        
        
        visited =set()
        
        def neigh(word, wordList):
            nei = []
            for w in wordList:
                if w not in visited:
                    valid = 0
                    for a,b in zip(w,word):
                        if ord(a)^ord(b)==0:
                            continue
                        else:
                            valid+=1
                    if valid==1:
                        nei.append(w)
            return nei
        
        queue = [beginWord]
        res = []
        Found=False
        while queue:
            level = []
            for i in range(len(queue)):
                cur = queue.pop(0)
                if cur==endWord:
                    Found=True
                if Found:
                    break
                level.append(cur)
                visited.add(cur)
                
                for w in neigh(cur,wordList):
                    queue.append(w)
            if Found:
                break
            
            res.append(level)
        
        if Found:
            visited = set()
            res[-1] = neigh(endWord,res[-1])
           
            #buld result
            level= [[]]
            while res:
                new_level = []
                for w in res.pop(0):
                    for oldlevelpath in level:
                        tmp=oldlevelpath[:]
                        if tmp:
                            flag=0
                            for a,b in zip(tmp[-1],w):
                                if ord(a)^ord(b)==0:
                                    continue
                                else:
                                    flag+=1
                            if flag==1:

                                tmp.append(w)
                                new_level.append(tmp)
                            else:
                                continue
                        else:
                            tmp.append(w)
                            new_level.append(tmp)
                            
                level=new_level
            for row in level:
                row.append(endWord)
            #remove dup
            resdic = dict()
            for row in level:
                key  =&#39;-&#39;.join(row)
                val = row
                resdic[key]=val
            return resdic.values()
        else:
            return []

#answer way of writting
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; List[List[str]]:
        # sortest path, graph bfs 
        # node is word
        # node neighbors are word differ by 1 letter in wordList.
        # find sortest path from beginWordd to endWord
        tree=collections.defaultdict(set)
        words = set(wordList)
        if endWord not in words:
            return []
        starts = {beginWord}
        ends = {endWord}
        rev=False
        FOUND=False
        
        while starts and not FOUND:
            
            words -= starts
            next_words = set()
            for word in starts:
                for i in range(len(word)):
                    left = word[:i]
                    right = word[i+1:]
                    for char in string.ascii_lowercase:
                        next_word = left + char + right
                        if next_word in words:
                            if next_word in ends:
                                FOUND= True
                            else:
                                next_words.add(next_word)
                            
                            tree[word].add(next_word) if not rev else tree[next_word].add(word)
            starts = next_words
            if len(starts) &amp;gt; len(ends):
                starts, ends = ends, starts
                rev=not rev
        
        def bt(x):
            if x==endWord:
                return [[x]]
            else:
                res = []
                for y in tree[x]:
                    for rest in bt(y):
                        res.append([x]+rest)
                return res
      
        return bt(beginWord)
        


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整出来一个写的巨丑但还算正确的time limit exceeded解决方法,思路应该是graph bfs 找最短路径。&lt;br&gt;
答案思路很巧妙， 用了bfs但是是从2端查找，缩小了时间。 然后通过collections.defaultdict(set)记录下一个节点。最后通过backtracking 得到结果。果然是hard 题目。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-127-word-ladder-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 127. Word Ladder （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that:&lt;br&gt;
Every adjacent pair of words differs by a single letter.&lt;br&gt;
Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList.&lt;br&gt;
sk == endWord&lt;br&gt;
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; int:
        
      
        visited =set()
        
        def neigh(word, wordList):
            nei = []
            for w in wordList:
                if w not in visited:
                    valid = 0
                    for a,b in zip(w,word):
                        if ord(a)^ord(b)==0:
                            continue
                        else:
                            valid+=1
                    if valid==1:
                        nei.append(w)
            return nei
        
        queue = [beginWord]
        res = []
        Found=False
        level=0
        while queue:
            level += 1
            for i in range(len(queue)):
                cur = queue.pop(0)
                if cur==endWord:
                    Found=True
                    return level
                if Found:
                    break
                
                visited.add(cur)
                
                for w in neigh(cur,wordList):
                    queue.append(w)
            if Found:
                break
        return 0

#answer way of writring
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; int:
        
        words = set(wordList)
        if endWord not in words:
            return 0
        starts = {beginWord}
        ends = {endWord}
        level = 1
        # charSet = {w for word in wordList for w in word}
        while starts:
            level += 1
            words -= starts
            next_words = set()
            for word in starts:
                for i in range(len(word)):
                    left = word[:i]
                    right = word[i+1:]
                    for char in string.ascii_lowercase:
                        next_word = left + char + right
                        if next_word in words:
                            if next_word in ends:
                                return level
                            next_words.add(next_word)
            starts = next_words
            if len(starts) &amp;gt; len(ends):
                starts, ends = ends, starts
        return 0 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单复用之前代码还是会得到time limit exceeded，因为bfs不是2头扫的。但2头扫bfs 怎么写？？&lt;/p&gt;
&lt;h1 id=&#34;font-colorred128-longest-consecutive-sequence-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;128. Longest Consecutive Sequence （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&lt;br&gt;
You must write an algorithm that runs in O(n) time.&lt;br&gt;
Input: nums = [100,4,200,1,3,2]&lt;br&gt;
Output: 4&lt;br&gt;
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestConsecutive(self, nums: List[int]) -&amp;gt; int:
        
        res=0
        nums=set(nums)
        
        for num in nums:
            if num-1 not in nums:
                cur=num
                cres=1
                
                while cur+1 in nums:
                    cur+=1
                    cres+=1
                    
                res=max(res,cres)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O（n）没思路。。。 看到答案后。。。大悟。  用了set，这样 num-1 not in nums时候知道当前值为开头。 如果当前值+1还在nums里。 更新当前值和局部最大值。  扫一次，虽然右内部while loop但还是O（n）&lt;/p&gt;
&lt;h1 id=&#34;font129-sum-root-to-leaf-numbers-medium-font&#34;&gt;&lt;font&gt;129. Sum Root to Leaf Numbers (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Input: root = [1,2,3]&lt;br&gt;
Output: 25&lt;br&gt;
Explanation:&lt;br&gt;
The root-to-leaf path 1-&amp;gt;2 represents the number 12.&lt;br&gt;
The root-to-leaf path 1-&amp;gt;3 represents the number 13.&lt;br&gt;
Therefore, sum = 12 + 13 = 25.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        res = 0
        def calc(root,tmp):
            nonlocal res
            if not root: return
            if not root.left and not root.right:
                #I am leaf do calculatoin and the sum
                res +=  tmp*10+root.val
            
            tmp = tmp*10+root.val
            calc(root.left,tmp)
            calc(root.right,tmp)
            
            
        calc(root,0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：到达leave 才把结果加和给res。 如果不是leave只更新tmp值。 然后前序遍历。&lt;/p&gt;
&lt;h1 id=&#34;130-surrounded-regions-medium&#34;&gt;130. Surrounded Regions （Medium）&lt;/h1&gt;
&lt;p&gt;Given an m x n matrix board containing &#39;X&#39; and &#39;O&#39;, capture all regions that are 4-directionally surrounded by &#39;X&#39;.&lt;br&gt;
A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def solve(self, board: List[List[str]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        m = len(board)
        n = len(board[0])
        
        def dfs(board,i,j):
            
            if m&amp;gt;i&amp;gt;=0 and n&amp;gt;j&amp;gt;=0:
                if board[i][j]==&#39;O&#39;:
                    board[i][j]=&#39;#&#39;
                    
            
                    for newi,newj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                        dfs(board,newi,newj)
      
        
        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1 and board[i][j]==&#39;O&#39;:
                    dfs(board,i,j)
        
        for i in range(m):
            for j in range(n):
                if board[i][j]!=&#39;#&#39;:
                    board[i][j]=&#39;X&#39;
        for i in range(m):
            for j in range(n):
                if board[i][j]==&#39;#&#39;:
                    board[i][j]=&#39;O&#39;

#BFS way of writting
class Solution(object):
    def solve(self, board):
        &amp;quot;&amp;quot;&amp;quot;
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not board: return 
        m=len(board)
        n=len(board[0])
        #boarder bfs O-&amp;gt;#          else to  X  restore # to O
        
      
        def nei(i,j):
            r= [ (i+1,j),(i-1,j),(i,j+1),(i,j-1)]
            return [ (xy[0],xy[1]) for xy in r if  (0&amp;lt;=xy[0]&amp;lt;m and 0&amp;lt;=xy[1]&amp;lt;n)]
        
      
        def bfs(i,j):
            visited=set()
            q=[(i,j)]
            visited.add((i,j))
            board[i][j]=&#39;#&#39;
            while q:
                x,y=q.pop(0)
                neis=nei(x,y)
                for xy in neis:
                    if xy not in visited:
                        if board[xy[0]][xy[1]]==&#39;O&#39;:
                            q.append(xy)
                            board[xy[0]][xy[1]]=&#39;#&#39;
                            visited.add(xy)
                            
                         
                        
                    
                    
                
        
        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1:
                    if board[i][j]==&#39;O&#39;:
                        bfs(i,j)
            
        
        for row in board:
            print(row)
        for i in range(m):
            for j in range(n):
                if board[i][j]!=&#39;#&#39;:
                    board[i][j]=&#39;X&#39;
                if board[i][j]==&#39;#&#39;:
                    board[i][j]=&#39;O&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路，在board边界地方为O的点做dfs，更新为#。之后把所有不为#的变为X。之后把#变为O。 得写个bfs dfs模板总结。&lt;/p&gt;
">Leetcode 2021-11-15</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-14/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;bfs-template&#34;&gt;BFS - Template&lt;/h1&gt;
&lt;h2 id=&#34;template-i&#34;&gt;template I&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue&amp;lt;Node&amp;gt; queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template-ii&#34;&gt;template II&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue&amp;lt;Node&amp;gt; queue;  // store all nodes which are waiting to be processed
    Set&amp;lt;Node&amp;gt; visited;  // store all the nodes that we&#39;ve visited
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to visited;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to visited;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dfs-template&#34;&gt;DFS - Template&lt;/h1&gt;
&lt;h2 id=&#34;template-i-2&#34;&gt;template I&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set&amp;lt;Node&amp;gt; visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template-ii-2&#34;&gt;template II&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set&amp;lt;Node&amp;gt; visited;
    Stack&amp;lt;Node&amp;gt; stack;
    add root to stack;
    while (stack is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
">BFS DFS 模板总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-13/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;111-minimum-depth-of-binary-tree-easy&#34;&gt;111. Minimum Depth of Binary Tree (Easy)&lt;/h1&gt;
&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    #      2
    #        3
    #          4
    #            5 
    #             6
    
    def minDepth(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        min_ = float(&#39;inf&#39;)
        if root.left:
            min_ = min(min_,self.minDepth(root.left))
        if root.right:
            min_ = min(min_,self.minDepth(root.right))
        
        if not root.left and not root.right:
            min_=0
        return 1+min_

#answer way of writting
class Solution:
    def minDepth(self, root: TreeNode) -&amp;gt; int:
         
        if not root:
            return 0
        if root.left is None:
            return self.minDepth(root.right)+1
        if root.right is None:
            return self.minDepth(root.left)+1
        return min(self.minDepth(root.left),self.minDepth(root.right))+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意special case 全是右斜。    直接写成 if not root: return 0 ， return 1+min(self.minDepth(root.left),self.minDepth(root.right))是不对的。全右斜情况root.left直接是空，所以会返回0+1. 应该多一个判断，左右子树是否存在，存在再更新值。&lt;/p&gt;
&lt;h1 id=&#34;112-path-sum-easy&#34;&gt;112. Path Sum （Easy）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.&lt;br&gt;
A leaf is a node with no children.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; bool:
        if not root: return False 
        
        if (not root.left) and not (root.right) and (targetSum==root.val):
            return True
        
        if  (not root.left) and not (root.right) and (targetSum!=root.val):
            return False
        
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;113-path-sum-ii-medium&#34;&gt;113. Path Sum II (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; List[List[int]]:
        
        res = []
        if not root: return res
        def ps(root,target,tmp):
            if not root.left and not root.right and root.val==target:
                tmp.append(root.val)
                res.append(tmp[:])
                
            if root:
                tmp.append(root.val)
                
                if root.left:
                    ps(root.left,target-root.val,tmp[:])
                
                if root.right:
                    ps(root.right,target-root.val,tmp[:])
        
        ps(root,targetSum,[])
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义帮助函数保存path。&lt;/p&gt;
&lt;h1 id=&#34;114-flatten-binary-tree-to-linked-list-medium&#34;&gt;114. Flatten Binary Tree to Linked List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, flatten the tree into a &amp;quot;linked list&amp;quot;&lt;br&gt;
The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.&lt;br&gt;
The &amp;quot;linked list&amp;quot; should be in the same order as a pre-order traversal of the binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: Optional[TreeNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify root in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
   
        res = []
        stack = []
        head=None
        cur=None
        while root or stack:
            while root:
                res.append(root)  
                stack.append(root)
                root=root.left
            
            node = stack.pop()
            root=node.right
        
        pre=None
        for node in res:
            if pre:
                pre.left = None
                pre.right = node
            
            pre = node
        
        if pre:
            pre.left=None
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred115-distinct-subsequences-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;115. Distinct Subsequences (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, return the number of distinct subsequences of s which equals t&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numDistinct(self, s: str, t: str) -&amp;gt; int:
        
        if len(t)&amp;gt;len(s): return 0
        
        m=len(t)
        n=len(s)
        
        dp=[[0]*(n+1) for _ in range(m+1)]
        
        # fill row 0:
        for i in range(n+1):
            dp[0][i]=1
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if t[i-1]==s[j-1]:
                    dp[i][j]=dp[i-1][j-1]+dp[i][j-1]
                else:
                    dp[i][j]=dp[i][j-1]
        
        return dp[m][n]
        
#               S
#           #  b a b g b a g
#    T  #   1  1 1 1 1 1 1 1
#       b   0  1 1 2 2 3 3 3 
#       a   0  0 1 1 1 1 4 4
#       g   0  0 0 0 1 1 1 5
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉应该用dp做。找递推关系。。。。&lt;br&gt;
如果s和t末尾字符一样， dp[i][j] = dp[i-1][j-1] + dp[i][j-1]  是t，s都drop末尾+只有s drop末尾，因为是t去匹配s。 如果s和末尾字符不一样 dp[i][j] = dp[i][j-1]。 注意初始条件，空字符串匹配s可能的方式为1.&lt;/p&gt;
&lt;h1 id=&#34;116-populating-next-right-pointers-in-each-node-medium&#34;&gt;116. Populating Next Right Pointers in Each Node （Medium）&lt;/h1&gt;
&lt;p&gt;You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:struct Node {&lt;br&gt;
int val;&lt;br&gt;
Node *left;&lt;br&gt;
Node *right;&lt;br&gt;
Node *next;&lt;br&gt;
}&lt;br&gt;
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;br&gt;
Initially, all next pointers are set to NULL&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def connect(self, root: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        
        if not root: return root
        queue = [root]
        
        while queue:
            level=[]
            l=len(queue)
            for _ in range(l):
                cur = queue.pop(0)
                level.append(cur)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            
            pre=None
            for node in level:
                if pre:
                    pre.next=node
                pre = node
        
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs level order transversal ...&lt;/p&gt;
&lt;h1 id=&#34;117-populating-next-right-pointers-in-each-node-ii-medium&#34;&gt;117. Populating Next Right Pointers in Each Node II (Medium)&lt;/h1&gt;
&lt;p&gt;解决方法同上&lt;/p&gt;
&lt;h1 id=&#34;118-pascals-triangle-easy&#34;&gt;118. Pascal&#39;s Triangle （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer numRows, return the first numRows of Pascal&#39;s triangle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generate(self, numRows: int) -&amp;gt; List[List[int]]:
        
        
        if numRows==1:
            return [[1]]
        if numRows==2:
            return [[1],[1,1]]
        res = [[1],[1,1]]
        
        for _ in range(numRows-2):
            level = [1,]
            prev_level = res[-1]
            for i in range(len(prev_level)-1):
                val = prev_level[i]+prev_level[i+1]
                level.append(val)
            
            level.append(1)
            res.append(level)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;杨辉三角&lt;/p&gt;
&lt;h1 id=&#34;119-pascals-triangle-ii-easy&#34;&gt;119. Pascal&#39;s Triangle II （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal&#39;s triangle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getRow(self, rowIndex: int) -&amp;gt; List[int]:
       
        res = [1]*(rowIndex+1)
        
        if rowIndex&amp;lt;=1:
            return res
        
        for i in range(rowIndex):
            length = 2+i
            res_copy = res[:]
            for j in range(1,length-1):
                res[j]=res_copy[j]+res_copy[j-1]
                
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是杨辉三角，要细心。&lt;/p&gt;
&lt;h1 id=&#34;120-triangle-medium&#34;&gt;120. Triangle （Medium）&lt;/h1&gt;
&lt;p&gt;Given a triangle array, return the minimum path sum from top to bottom.&lt;br&gt;
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        def mintotal(triangle, i):
            if not triangle:
                return 0
            root = triangle[0][i]
            triangle.pop(0)
            return root+min(mintotal(triangle[:],i),mintotal(triangle[:],i+1))
        return mintotal(triangle,0)

 # second pass solution
 class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        
        mem=dict()
        def mintotal(triangle, i,level):
            if (level,i) in mem: return mem[(level,i)]
            if not triangle:
                return 0
            root = triangle[0][i]
            triangle.pop(0)
            res= root+min(mintotal(triangle[:],i,level+1),mintotal(triangle[:],i+1,level+1))
            mem[(level,i)]=res
            return res
        return mintotal(triangle,0,0)

#answer way of writting
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        rows=len(triangle)
        minlen=triangle[-1][:]
        for layer in range(rows-2,-1,-1):
            for i in range(layer+1):
                minlen[i]=min(minlen[i],minlen[i+1])+triangle[layer][i]
        return minlen[0]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;first try, time limit exceeded.  add mem, nailed it. 答案用DP方法也很巧妙，因为最后一行就是所有可能性，慢慢回溯去求结果。root是 minlen[0].&lt;/p&gt;
">Leetcode 2021-11-13</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-12/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;101-symmetric-tree-easy&#34;&gt;101. Symmetric Tree (Easy)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        def helper(left,right):
            if not left:
                return not right
            if not right:
                return not left
            return left.val==right.val and helper(left.right,right.left) and helper(left.left,right.right)
        
        return helper(root,root)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;102-binary-tree-level-order-traversal-medium&#34;&gt;102. Binary Tree Level Order Traversal (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        res = []
        if not root: return res
        queue = [root]
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            res.append(level)
        return res    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs用queue，range（length）来确定要pop的元素个数。&lt;/p&gt;
&lt;h1 id=&#34;103-binary-tree-zigzag-level-order-traversal-medium&#34;&gt;103. Binary Tree Zigzag Level Order Traversal （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        if not root: return []
        queue = [root]
        level = 0
        res = []
        while queue:
            li_level = []
            level +=1
            l=len(queue)
            for i in range(l):
                cur=queue.pop(0)
                li_level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            if level%2==0:
                res.append(li_level[::-1])
            else:
                res.append(li_level)
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs+level counter 如果偶数，翻转。&lt;/p&gt;
&lt;h1 id=&#34;104-maximum-depth-of-binary-tree-easy&#34;&gt;104. Maximum Depth of Binary Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred105-construct-binary-tree-from-preorder-and-inorder-traversal-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;105. Construct Binary Tree from Preorder and Inorder Traversal (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; Optional[TreeNode]:
    
        if not preorder or not inorder: return None
        
        rootval = preorder[0]
        preorder = preorder[1:]
        root = TreeNode(rootval)
        lileft=[]
        liright=[]
        left=True
        for n in inorder:
            if n!=rootval:
                if left:
                    lileft.append(n)
                else:
                    liright.append(n)
            else:
                left=False
                
        leftnode = self.buildTree([e for e in preorder if e in lileft],lileft)
        rightnode = self.buildTree([e for e in preorder if e in liright],liright)
        root.left=leftnode
        root.right=rightnode
        return root

#answer way of writting
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; TreeNode:
        
        if not preorder or not inorder: return None
        
        rootval=preorder.pop(0)

        root=TreeNode(rootval)
        
        index=inorder.index(rootval)
        
        root.left=self.buildTree(preorder,inorder[:index])
        root.right=self.buildTree(preorder,inorder[index+1:]) #if index+1&amp;lt;len(inorder) else None
        
        return root
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道使用preorder找root 然后split inorder找到左右子数，但time limit exceed。 是因为过滤preordder必须和inorder的元素一样。其实按照子树生长方式不用这层过滤。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue106-construct-binary-tree-from-inorder-and-postorder-traversal-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;106. Construct Binary Tree from Inorder and Postorder Traversal （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; Optional[TreeNode]:
        if not inorder or not postorder: return None
         
        val = postorder.pop()
        ind = inorder.index(val)
        root=TreeNode(val)
       
        right = self.buildTree(inorder[ind+1:],postorder)
        left = self.buildTree(inorder[:ind],postorder)
        
        root.left = left
        root.right = right
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： 后序遍历最后一个数为root val。 这样可在inorder中分出左右子树数据。但建立数的时候要从右子树开始然后到左子树。&lt;/p&gt;
&lt;h1 id=&#34;107-binary-tree-level-order-traversal-ii-medium&#34;&gt;107. Binary Tree Level Order Traversal II （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (i.e., from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        if not root: return []
        queue = [root]
        res = []
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            res.append(level)
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;still bfs&lt;/p&gt;
&lt;h1 id=&#34;108-convert-sorted-array-to-binary-search-tree-easy&#34;&gt;108. Convert Sorted Array to Binary Search Tree (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&amp;gt; Optional[TreeNode]:
        if not nums: return None
        l=0
        r=len(nums)
        m = (l+r)//2
        root=TreeNode(nums[m])
        root.left=self.sortedArrayToBST(nums[:m])
        root.right=self.sortedArrayToBST(nums[m+1:])
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;109-convert-sorted-list-to-binary-search-tree-medium&#34;&gt;109. Convert Sorted List to Binary Search Tree (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -&amp;gt; Optional[TreeNode]:
        
        if not head:return None
        if not head.next: return TreeNode(head.val)
        #if not head.next.next: 
        #    return TreeNode(head.next.val,left=TreeNode(head.val))
        p0=head #slow
        p1=head #fast
        pre=None
        while p1 and p1.next:
            p1=p1.next.next
            pre = p0
            p0=p0.next
            
        #print(pre.val,p0.val)    
        pre.next=None
        p0next=p0.next
        p0.next=None
        
        root = TreeNode(p0.val)
        root.left = self.sortedListToBST(head)
        root.right= self.sortedListToBST(p0next)
        
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心。。。&lt;/p&gt;
&lt;h1 id=&#34;110-balanced-binary-tree-easy&#34;&gt;110. Balanced Binary Tree (Easy)&lt;/h1&gt;
&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;br&gt;
For this problem, a height-balanced binary tree is defined as:&lt;br&gt;
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        def depth(root):
            if not root: 
                return 0
            return 1+max(depth(root.left),depth(root.right))
        
        if not root: return True
        
        left=depth(root.left)
        right=depth(root.right)
        isbalanced = abs(left-right)&amp;lt;=1
        return isbalanced and self.isBalanced(root.left) and self.isBalanced(root.right)
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-12</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-11/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-91-decode-ways-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 91. Decode Ways (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A message containing letters from A-Z can be encoded into numbers using the following mapping:&lt;/p&gt;
&lt;p&gt;&#39;A&#39; -&amp;gt; &amp;quot;1&amp;quot;&lt;br&gt;
&#39;B&#39; -&amp;gt; &amp;quot;2&amp;quot;&lt;br&gt;
...&lt;br&gt;
&#39;Z&#39; -&amp;gt; &amp;quot;26&amp;quot;&lt;/p&gt;
&lt;p&gt;To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;quot;11106&amp;quot; can be mapped into:&lt;br&gt;
&amp;quot;AAJF&amp;quot; with the grouping (1 1 10 6)&lt;br&gt;
&amp;quot;KJF&amp;quot; with the grouping (11 10 6)&lt;br&gt;
Note that the grouping (1 11 06) is invalid because &amp;quot;06&amp;quot; cannot be mapped into &#39;F&#39; since &amp;quot;6&amp;quot; is different from &amp;quot;06&amp;quot;.&lt;br&gt;
Given a string s containing only digits, return the number of ways to decode it.&lt;br&gt;
The answer is guaranteed to fit in a 32-bit integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numDecodings(self, s: str) -&amp;gt; int:
        
        if not s: return 0
        n=len(s)
        dp=[0]*(n+1)
        dp[0]=1 # empty s have 1 way 
        dp[1]=1 if s[0]!=&#39;0&#39; else 0 # 1 single char, if char!=0 dp[1]=1 else 0
        
        for i in range(2,n+1):
            #     cur
            # pre cur 
            cur=int(s[i-1])
            precur=int(s[i-2:i])
            # cur 1 to 9 is valid
            if cur&amp;gt;=1 and cur&amp;lt;=9:
                dp[i]+=dp[i-1]
            
            #precur 10 to 26 is valid
            if precur&amp;gt;=10 and precur&amp;lt;=26:
                dp[i]+=dp[i-2]
                
        return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试图用递归+mem方法写，越写越繁琐。。。没有解决。 看答案用了DP。&lt;br&gt;
解决方法很巧妙。 空字符dp val=1， dp【1】为首字符结果， 如果首字符为0，则dp【1】=0 else dp【1】=1 从字符第二位到末位。 检查cur 和 （per，cur）形成的数字。 如果valid。就做dp【i】的更新。&lt;/p&gt;
&lt;h1 id=&#34;92-reverse-linked-list-ii-medium&#34;&gt;92. Reverse Linked List II （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]:
        
        def rev(node):
            pre=None
            while node :
                nodenext=node.next
                node.next = pre
                pre=node
                node = nodenext    
            return pre
        
        # get left~right chan, do rev, concat
        
        dummyhead=ListNode(val=&#39;NULL&#39;,next=head)
        
        cur = dummyhead
        pre=None
        for _ in range(left):
            pre=cur
            cur = cur.next
        
        revhead_pre=pre
        revhead=cur
        
        for _ in range(right-left):
            cur=cur.next

        revend = cur
        revend_next = revend.next
        revend.next = None
        
        revhead_pre.next=rev(revhead)
        revhead.next = revend_next
        
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了dummyhead 细心就可以了。。。&lt;/p&gt;
&lt;h1 id=&#34;93-restore-ip-addresses-medium&#34;&gt;93. Restore IP Addresses （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def restoreIpAddresses(self, s: str) -&amp;gt; List[str]:
        # 4 parts, 0 ~ 255 
        ss = s
        
        res = []
        
        def bt(s,tmp):
             
            if len(&#39;.&#39;.join(tmp))==len(ss)+3 and len(tmp)==4:
                res.append(&#39;.&#39;.join(tmp))
                
            for length in [1,2,3]:
                if len(s)&amp;gt;=length and 255&amp;gt;=int(s[:length])&amp;gt;=0:
                    if (length==2 or length==3) and s[0]==&#39;0&#39; : continue
                    tmp.append(s[:length])
                    bt(s[length:],tmp)
                    tmp.pop()
        
        bt(s,[])
        
        return res
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 终止条件是被分割成4份而且总长度是string长度加3个点长度。 可能的length只有1，2，3。 length 2，3时候0不能作为开头元素。&lt;/p&gt;
&lt;h1 id=&#34;94-binary-tree-inorder-traversal-easy&#34;&gt;94. Binary Tree Inorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        
        res = []
        def ino(node):
            if not node: 
                return
            ino(node.left)
            res.append(node.val)
            ino(node.right)
        
        ino(root)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归很容易写，how about iterative one？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        
        res = []
        s = []
        while s or root:
            while root:
                s.append(root)
                root = root.left
            
            node = s.pop()
            res.append(node.val)
            
            if node.right:
                root =node.right
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经典写法了应该是，当stack有东西或者root不为空，root先入栈，一直探索左子树。当root为空时。从stack中取出node，提取值。如果有右子树。则开始以右子树的node作为root探索。&lt;/p&gt;
&lt;h1 id=&#34;95-unique-binary-search-trees-ii-medium&#34;&gt;95. Unique Binary Search Trees II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -&amp;gt; List[Optional[TreeNode]]:
        
        
        nums = list(range(1,n+1))
        
        def gen(nums):
            if not nums:
                return [None]
            res = []
            for i in range(len(nums)):
                mid = nums[i]
                leftnums=nums[:i] if i!=0 else []
                rightnums = nums[i+1:] if i!=len(nums)-1 else []
                
                for left in gen(leftnums):
                    for right in gen(rightnums):
                        root = TreeNode(mid)
                        root.left = left
                        root.right= right
                        res.append(root)
            
            return res
        
        return gen(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归分治法。&lt;/p&gt;
&lt;h1 id=&#34;96-unique-binary-search-trees-medium&#34;&gt;96. Unique Binary Search Trees （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the number of structurally unique BST&#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    mem = {0:1,1:1,2:2}
    def numTrees(self, n: int) -&amp;gt; int:
        if n in self.mem: return self.mem[n]
        if n==0:
            return 1
        if n==1:
            return 1
        if n==2:
            return 2
        
        res= 0
        for i in range(n):
            left = i
            right= n-left-1
            res += self.numTrees(left)*self.numTrees(right)
        self.mem[n]=res
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归+记忆  比较容易理解。 答案是什么catalanta number，不感兴趣。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-97-interleaving-string-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 97. Interleaving String （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.&lt;br&gt;
An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:&lt;br&gt;
s = s1 + s2 + ... + sn&lt;br&gt;
t = t1 + t2 + ... + tm&lt;br&gt;
|n - m| &amp;lt;= 1&lt;br&gt;
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&amp;gt; bool:
        
        #dp[i][j]   i is length of string1   
        #           j is length of string2
        #           so interleaving length= i+j
        
        
        
        m=len(s1)
        n=len(s2)
        
        if m+n!=len(s3) or sorted(s1+s2)!=sorted(s3):
            return False
        
        dp=[ [False]*(n+1) for _ in range(m+1)]
        dp[0][0]=True
        
        #fill row 0
        for col in range(1,n+1):
            dp[0][col]=dp[0][col-1] and s2[col-1]==s3[0+col-1]
        #fill col 0
        for row in range(1,m+1):
            dp[row][0]=dp[row-1][0] and s1[row-1]==s3[0+row-1]
            
        #dp
        
        for row in range(1,m+1):
            for col in range(1,n+1):
                dp[row][col]=(dp[row-1][col] and s1[row-1]==s3[row+col-1] ) or (dp[row][col-1] and s2[col-1]==s3[row+col-1])
        
        return dp[m][n]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。&lt;br&gt;
思路： dynamic programming  dp[i][j] 是指长度为i的s1和长度为j的s2是否可interleave。所以dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])&lt;br&gt;
没想到是dynamic programming， 最小子结构是差一位时候，是否interleaving有递推关系。&lt;/p&gt;
&lt;h1 id=&#34;98-validate-binary-search-tree-medium&#34;&gt;98. Validate Binary Search Tree （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        s = []
        pre=None
        while s or root:
            while root:
                s.append(root)
                root=root.left
                
            node = s.pop()
            if pre is not None:
                if pre&amp;gt;=node.val:
                    return False
                
            pre = node.val
            
            if node.right:
                root=node.right
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以inorder 然后看是否递增，或者iterative的inorder 直接判断。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred99-recover-binary-search-tree-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;99. Recover Binary Search Tree （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify root in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
 
        s=[]
        y=x=pre=None

        while s or root:
            while root:
                s.append(root)
                root=root.left
           
            node=s.pop()
            
            if pre and pre.val&amp;gt; node.val:
                y=node
                if x is None:
                    x=pre
                else:
                    break
           
            pre=node
            if node.right:
                root=node.right
            
        x.val,y.val=y.val,x.val
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很巧妙的解法， 如果x是None， 第一次记录下pre&amp;gt;cur中的pre node, 第二次记录下 pre&amp;gt;cur中的cur node。 【1，2，3，4，5，6】交换2，5 【1，5，3，4，2，6】 第一次出现pre&amp;gt;cur 时候，pre就是5，第二次出现pre&amp;gt;cur时候 cur 是2. 这样就找到了需要交换的nodes。&lt;/p&gt;
&lt;h1 id=&#34;100-same-tree-easy&#34;&gt;100. Same Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&amp;gt; bool:
        
        if not p:
            return not q
        
        if not q:
            return not p
        
        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) 
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-10/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue-81-search-in-rotated-sorted-array-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 81. Search in Rotated Sorted Array II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).&lt;/p&gt;
&lt;p&gt;Before being passed to your function, nums is rotated at an unknown pivot index k (0 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].&lt;/p&gt;
&lt;p&gt;Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.&lt;/p&gt;
&lt;p&gt;You must decrease the overall operation steps as much as possible.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; bool:
        #still binary search
        l=0
        r=len(nums)-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==nums[m]:return True
            
            while nums[l]==nums[r] and l&amp;lt;r:
                if nums[l]==target:
                    return True
                l+=1
                r-=1
               
            
            if nums[m] &amp;gt;= nums[l]:
                #left increase
                if nums[m]&amp;gt;=target&amp;gt;=nums[l]:
                    r=m-1
                else:
                    l=m+1
            else:
                #right increase
                if   nums[r]&amp;gt;=target&amp;gt;=nums[m]:
                    l=m+1
                else:
                    r=m-1
        
        return False

#other method
class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; bool:
        #         |
        #      |  |
        #   |  |  |
        #   |  |  |      |
        #   |  |  |  |   |
        #    
        
        newnums=[]
        
        for n in nums:
            
            if not newnums or newnums[-1]!=n:
            
                newnums.append(n)
        
        nums=newnums
        
        l=0
        r=len(nums)-1
        
        while l&amp;lt;=r:
            
            m=(l+r)//2
            
            if nums[m]==target:
                return True
            elif nums[m]&amp;gt;=nums[l]:
                #left order
                if target&amp;gt;=nums[l] and target&amp;lt;nums[m]:
                    r=m-1
                else:
                    l=m+1
                        
                
            else:
                #right order
                if target&amp;gt;nums[m] and target&amp;lt;=nums[r]:
                    l=m+1
                else:
                    r=m-1

        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做粗来了，但是再一次次提交中修改代码才pass的，需要注意特别处理 nums[l]==nums[r] 情况 而且要确保 l小于r  也就是aba情形。 这样才能l+1 ， r-1。&lt;br&gt;
另一种思路先去重。再计算。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-82-remove-duplicates-from-sorted-list-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 82. Remove Duplicates from Sorted List II （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        
        pre = dummyhead
        cur = head

        while cur and cur.next:
            
            if cur.val==cur.next.val:
                #find dup, do while loop til end, update pre and cur
                while cur and cur.next and cur.val==cur.next.val:
                    cur = cur.next

                pre.next = cur.next if cur.next else None
                cur = cur.next if cur.next else None
            else:
                #normal update
                pre=cur
                cur=cur.next
        
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写了半天都是去掉一个重复，也是很奇怪了，【1，1，1，2，3】=》【1，2，3】错的，应该是【2，3】直接看答案。这道题不应该翻车。&lt;/p&gt;
&lt;h1 id=&#34;83-remove-duplicates-from-sorted-list-easy&#34;&gt;83. Remove Duplicates from Sorted List （Easy）&lt;/h1&gt;
&lt;p&gt;Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        pre=dummyhead
        cur=head
        while cur:
            if pre.val==cur.val:
                #find dup
                while cur and pre.val==cur.val:
                    cur=cur.next
                pre.next=cur
                
            else:
                #normal update
                pre=cur
                cur=cur.next
                
        return dummyhead.next

#answer way of writting
class Solution:
    def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode:
        cur=head
        while cur and cur.next:
            if cur.val==cur.next.val:
                cur.next=cur.next.next
            else:
                cur=cur.next
        
        return head
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案写法更优雅。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-84-largest-rectangle-in-histogram-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 84. Largest Rectangle in Histogram （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of integers heights representing the histogram&#39;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def largestRectangleArea(self, heights: List[int]) -&amp;gt; int:
        stack=[-1]
        res=0
        for i in range(len(heights)):
            while stack[-1]!=-1 and heights[stack[-1]]&amp;gt;=heights[i]:
                res=max(res, heights[stack.pop()]*(i-stack[-1]-1)
            stack.append(i)
        
        while stack[-1]!=-1 and stack:
            res=max(res,heights[stack.pop()]*(len(heights)-stack[-1]-1))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路， 似乎是用stack 。。。但如何知道哪块板是需要的？&lt;br&gt;
思路: 如果当前高度小于等于栈顶，说明找到了栈顶的右边界，开始计算。pop栈顶元素的高度为高度，宽度为目前位置到已经pop过的栈顶位置减一。 过完一遍后，如果栈里还有元素， 开始计算， pop栈顶元素的高度为高度， 宽度为目前位置（已经是len（heights）了）到已经pop过的栈顶位置减一。注意初始栈为-1， 方便计算面积公式再edge case 下成立。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-85-maximal-rectangle-hardfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 85. Maximal Rectangle （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a rows x cols binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -&amp;gt; int:
        
        # 似乎能转化成上一题，板子面积最大问题。
        
        def maxarea(nums):
            res = 0
            stack = [-1]
            for i, n in enumerate(nums):
                while stack[-1]!=-1 and nums[stack[-1]] &amp;gt;= n:
                    #calculate
                    res = max(res, nums[stack.pop()]*(i-stack[-1]-1))
                
                stack.append(i)
                
            while stack and stack[-1]!=-1:
                res = max(res, nums[stack.pop()]*(len(nums)-stack[-1]-1))
            return res  
        
        res = 0
        for rowid in range(len(matrix)):
            if rowid==0:
                row = [int(e) for e in matrix[0]]
                #print(row)
                res = max(res,maxarea(row[:]))
            else:
                currow = [int(e) for e in matrix[rowid]]
                row = [ cr+cr*r for (cr,r) in zip(currow,row)]
                #print(row)
                res = max(res,maxarea(row[:]))
        
         
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接用了上一题求解。。。。&lt;/p&gt;
&lt;h1 id=&#34;86-partition-list-medium&#34;&gt;86. Partition List (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -&amp;gt; Optional[ListNode]:
        
        smallhead = ListNode(val=&#39;NULL&#39;)
        largehead = ListNode(val=&#39;NULL&#39;)
        small = smallhead
        large = largehead
        while head:
            if head.val&amp;lt;x:
                small.next = head
                small = small.next
            else:
                large.next = head
                large = large.next
                
            head = head.next
        
        #makde ends clean
        if small:
            small.next = None
        if large:
            large.next = None
        
        small.next = largehead.next
        
        return smallhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-87-scramble-string-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 87. Scramble String (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;We can scramble a string s to get a string t using the following algorithm:&lt;br&gt;
If the length of the string is 1, stop.&lt;br&gt;
If the length of the string is &amp;gt; 1, do the following:&lt;br&gt;
Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.&lt;br&gt;
Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.&lt;br&gt;
Apply step 1 recursively on each of the two substrings x and y.&lt;br&gt;
Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isScramble(self, s1: str, s2: str) -&amp;gt; bool:
        
        #backtracking calculate all
        
        def helper(s):
             
            if len(s)==1:
                return [s] 
            else:
                res = set()
                for i in range(1,len(s)):
                    x = s[:i]
                    y=s[i:]
                    res.add(y+x)
                    res.add(x+y)
                    for xx in helper(x):
                        for yy in helper(y):
                            res.add(xx+yy)
                            res.add(yy+xx)
                return list(res)
                    
        
        res = helper(s1)
        #print(res)
        return s2 in res

# answer way of writting
class Solution:
    mem

    def isScramble(self, s1: str, s2: str) -&amp;gt; bool:
        
        m=len(s1)
        n=len(s2)
        
        if m!=n or sorted(s1)!=sorted(s2):
            return False
        #from now, m==n and sorted s1==sorted s2
        if m&amp;lt;=3 or s1==s2:
            return True
        f = self.isScramble
        for i in range(1, len(s1)):
            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or  f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):
                return True
        return False

#modified answer way of writting
class Solution:
    mem = dict()
    def isScramble(self, s1: str, s2: str) -&amp;gt; bool:
        
        if (s1,s2) in self.mem: return self.mem[(s1,s2)]
        m=len(s1)
        n=len(s2)
        
        if m!=n or sorted(s1)!=sorted(s2):
            self.mem[(s1,s2)]=False
            self.mem[(s2,s1)]=False
            return False
        #from now, m==n and sorted s1==sorted s2
        if m&amp;lt;=3 or s1==s2:
            self.mem[(s1,s2)]=True
            self.mem[(s2,s1)]=True
            return True
        f = self.isScramble
        for i in range(1, len(s1)):
            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or  f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):
                self.mem[(s1,s2)]=True
                self.mem[(s2,s1)]=True
                return True
        self.mem[(s1,s2)]=False
        self.mem[(s2,s1)]=False
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtraking 导致超时，重新想办法。。。感觉得用stack。 感觉错误，&lt;br&gt;
答案很优雅，用了递归。。但还是超时。于是用mem。&lt;/p&gt;
&lt;h1 id=&#34;88-merge-sorted-array-easy&#34;&gt;88. Merge Sorted Array （Easy）&lt;/h1&gt;
&lt;p&gt;You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.&lt;br&gt;
Merge nums1 and nums2 into a single array sorted in non-decreasing order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums1 in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        # fill nums1 from end pos to head pos
        cur=len(nums1)-1
        while m&amp;gt;0 and n&amp;gt;0:
            if nums1[m-1]&amp;gt;nums2[n-1]:
                nums1[cur]=nums1[m-1]
                m-=1
            else:
                nums1[cur]=nums2[n-1]
                n-=1
            cur-=1
        
        while m&amp;gt;0:
            nums1[cur]=nums1[m-1]
            m-=1
            cur-=1
        while n&amp;gt;0:
            nums1[cur]=nums2[n-1]
            n-=1
            cur-=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从后向前覆盖，避免overwrite。&lt;/p&gt;
&lt;h1 id=&#34;89-gray-code-medium&#34;&gt;89. Gray Code （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def grayCode(self, n: int) -&amp;gt; List[int]:
        
        #  0      0
        #  1     [0  1]
        #  2     [00 01 11 10]
        
        level = [0,1]
        if n==1: return level
        for i in range(n-1):
            level_res  = []
            mask1 = 1&amp;lt;&amp;lt;(i+1)
            mask0 = 0
            for n in level:
                level_res.append(n|mask0)
            for n in level[::-1]:
                level_res.append(n|mask1)
            
            level=level_res
        
        return level
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每个level下，用0/1 mask遍历前一个level的结果就行了，注意mask1时候reverse遍历顺序。&lt;/p&gt;
&lt;h1 id=&#34;90-subsets-ii-medium&#34;&gt;90. Subsets II （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums that may contain duplicates, return all possible subsets (the power set).&lt;br&gt;
The solution set must not contain duplicate subsets. Return the solution in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(temp,start):
            res.append(temp[:])
            
            for i in range(start,len(nums)):
                if i&amp;gt;start and nums[i]==nums[i-1]: continue
                temp.append(nums[i])
                bt(temp,i+1)
                temp.pop()
        
        nums.sort()
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经在backtrakcing总结篇写过，注意2点，去重，下一次bt起始位置为i+1，不look back。&lt;/p&gt;
">Leetcode 2021-11-10</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-09/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;71-simplify-path-medium&#34;&gt;71. Simplify Path （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string path, which is an absolute path (starting with a slash &#39;/&#39;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def simplifyPath(self, path: str) -&amp;gt; str:
        path = [e.replace(&#39;/&#39;,&#39;&#39;) for e in path.split(&#39;/&#39;) ]
        print(path)
        path = [e for e in path if e!=&#39;.&#39; and len(e)&amp;gt;0]
        print(path)
        res = []
        for p in path:
            if p==&#39;..&#39;:
                if res:
                    res.pop()
            else:
                res.append(p)
        return &#39;/&#39;+&#39;/&#39;.join(res) 
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred72-edit-distance-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;72. Edit Distance (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minDistance(self, word1: str, word2: str) -&amp;gt; int:
        
        # insert 2 del 3 replace
        
        #dp            0  r  o   s  
        #           0  0  1  2   3 
        #           h  1  1  2   3
        #           o  2  2  1   2
        #           r  3  3  2   2
        #           s  4  4  3   2
        #           e  5  5  4   3
        
        rows=len(word1)+1
        cols=len(word2)+1
        
        dp=[[0]*cols for _ in range(rows)]
        
        #fill row0 :
        for j in range(len(word2)+1):
            dp[0][j]=j
            
        #fill col0
        for i in range(len(word1)+1):
            dp[i][0]=i
        
        for i in range(1,rows):
            for j in range(1,cols):
                min_=min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j])
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min_+1
        
        return dp[rows-1][cols-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;似乎是用dynamic programmming， 但没想出来递归怎么写。&lt;br&gt;
看了答案发现很简单。。。dp[i][j] = min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j]) + 1 如果末尾不同，如果末尾相同 dp[i][j] = dp[i-1]dp[j-1]&lt;/p&gt;
&lt;h1 id=&#34;73-set-matrix-zeroes-medium&#34;&gt;73. Set Matrix Zeroes (Medium)&lt;/h1&gt;
&lt;p&gt;Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&#39;s, and return the matrix.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify matrix in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        # project 0 to row[0] &amp;amp; col[0] but matrix[0][0] will overlapping should be taken care
        
        row00 = 1
        
        for row in range(len(matrix)):
            for col in range(len(matrix[0])):
                if matrix[row][col]==0:
                    if col==0:
                        row00=0
                    else:
                        matrix[0][col]=0
                    matrix[row][0]=0
        # for row in matrix:
        #     print(row)
        for row in range(len(matrix)-1,-1,-1):
            for col in range(len(matrix[0])-1,-1,-1):
                if col==0:
                    if row00==0:
                        matrix[row][col]=0
                        
                else:
                    if (matrix[0][col]==0 or matrix[row][0]==0):
                        matrix[row][col]=0
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挺有意思一题目，正的扫0位置，把0位置存在top和left边上，但是【0，0】的位置会存2此产生数据覆盖，所以如果第一列有元素是0，则需要把row00这个赋为0.  第二部，反的扫元素位置，防止填0的时候覆盖数据。然后注意第一列是不是为0依靠判断row00元素是否为0即可。&lt;/p&gt;
&lt;h1 id=&#34;74-search-a-2d-matrix-medium&#34;&gt;74. Search a 2D Matrix （Medium）&lt;/h1&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;br&gt;
Integers in each row are sorted from left to right.&lt;br&gt;
The first integer of each row is greater than the last integer of the previous row.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        #     1   2  3
        #     4   5  6   seach 2  mid=5   target&amp;lt;mid  left top or left right
        #     7   8  9         9  mid=5   target&amp;gt;mid  right bot or left bot
        
        
        m = len(matrix)
        n = len(matrix[0])
        
        def helper(matrix, target, rowleft,rowright,colleft,colright):
            print(rowleft,rowright,colleft,colright)
            if rowleft==rowright:
                return target in [matrix[rowleft][col] for col in range(colleft,colright+1)]
            if colleft==colright:
                return target in [matrix[row][colleft] for row in range(rowleft,rowright+1)]
            if rowright-rowleft==1 and colright-colleft==1:
                if matrix[rowleft][colleft]==target:
                    return True
                if matrix[rowleft][colright]==target:
                    return True
                if matrix[rowright][colleft]==target:
                    return True
                if matrix[rowright][colright]==target:
                    return True
                return False
                
            rowmid = (rowleft+rowright)//2
            colmid = (colleft+colright)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif matrix[rowmid][colmid]&amp;lt;target:
                #seach right bot or left bot
                return helper(matrix,target,rowmid,rowright,colmid,colright) or helper(matrix,target,rowmid,rowright, colleft,colmid)
            else:
                #seaerch left top or left right
                return helper(matrix,target,rowleft,rowmid,colleft,colmid) or helper(matrix,target,rowleft,rowmid, colmid,colright)
            
    
        return helper(matrix,target,0,m-1,0,n-1)


# answer way of writting
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        if not matrix or not matrix[0]: return False
        
        
        #binary find row first
        rows=len(matrix)
        cols=len(matrix[0])
        
        if rows==cols and rows==1:
            return matrix[0][0]==target
        
        l=0
        r=rows-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==matrix[m][cols-1]:
                return True
            elif target&amp;gt;matrix[m][cols-1]:
                l=m+1
            else:
                r=m-1
        
        findrow=l
        if findrow&amp;lt;0: findrow=0
        if findrow&amp;gt;=rows: findrow=rows-1
        
       
        #binary search find col
        
        l=0
        r=cols-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==matrix[findrow][m]:
                return True
            elif target&amp;gt;matrix[findrow][m]:
                l=m+1
            else:
                r=m-1
                
        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;binary search for matrix... 虽然写出来了，但感觉写的不完美而且用时过长，思路：如果最后是4个正方形矩阵，依次寻找target，如果最后是一行，依次寻找。 把目标分解到4个象限中的2个来寻找。&lt;br&gt;
感觉递归base case这步可以优化。另一种写法是先找行再找列。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-75-sort-colors-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 75. Sort Colors （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.&lt;br&gt;
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.&lt;br&gt;
Input: nums = [2,0,2,1,1,0]&lt;br&gt;
Output: [0,0,1,1,2,2]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sortColors(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        # left maintail all 0s rigth maintain all 2s
        l=0
        r=len(nums)-1
        
        for i,n in enumerate(nums):
            if n==0:
                nums[l],nums[i] = nums[i],nums[l]
                l+=1
        l=0
        r=len(nums)-1
        #print(nums)
        for i in range(len(nums)-1,-1,-1):
            if nums[i]==2:
                nums[r],nums[i] = nums[i],nums[r]
                r-=1

#answer way of writting
class Solution:
    def sortColors(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        p0=cur=0
        p2=len(nums)-1
        
        while cur&amp;lt;=p2:
            if nums[cur]==0:
                nums[p0],nums[cur]=nums[cur],nums[p0]
                p0+=1
                cur+=1
            elif nums[cur]==2:
                nums[p2],nums[cur],=nums[cur],nums[p2]
                p2-=1
            else:
                cur+=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的答案是遍历2次， 第一次找0位置做交换， 第二次从末向前遍历找2位置做交换。&lt;br&gt;
答案更简单只遍历一次。。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue76-minimum-window-substring-hardfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;76. Minimum Window Substring (Hard)&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;quot;&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minWindow(self, s: str, t: str) -&amp;gt; str:
        # sliding window
        # how?
        #
        # l  r
        # move r util contains all t&#39;s chars
        # shrink l,until count[char]==0 del count char, then move r
        #
        def equal(dic_s,dic_t):
            for k,v in dic_t.items():
                if k not in dic_s:
                    return False
                if dic_s[k]&amp;lt;v:
                    return False
            return True
        
        dic_t = dict()
        for char in t:
            dic_t[char]=dic_t.get(char,0)+1
            
        
        l=0
        r=0
        
        dic_s = dict()
        
        while not equal(dic_s,dic_t) and r&amp;lt;len(s):
        
            if s[r] in dic_t:
                dic_s[s[r]]=dic_s.get(s[r],0)+1
            r+=1
        
        r=r-1 if r-1&amp;gt;=0 else 0
        #print(l,r)
        #now l to r contains all chars in t
        res = &#39;&#39;
        minw = float(&#39;inf&#39;)
        #shrink l , move r
        while l&amp;lt;=r and r&amp;lt;len(s):
            #calculate
            if r-l+1 &amp;lt; minw and equal(dic_s,dic_t):
                minw=r-l+1
                res=s[l:r+1]
            #remove char
            char = s[l]
            if char in dic_t:
                dic_s[char] = dic_s.get(char,0)-1
                if dic_s[char]&amp;lt;=0:
                    del dic_s[char]
            
            while not equal(dic_s,dic_t):
                r+=1
                if r&amp;gt;=len(s):
                    break
                if s[r] in dic_t:
                    dic_s[s[r]]=dic_s.get(s[r],0)+1
           
                    
            #
            l=l+1
        
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过sliding window做出来了， equal 这个helper function很关键。  要equal dic_s里面得有所有 dic_target 的key 而且val必须大于等于target val。  思路：  move r util contains all t&#39;s chars。shrink l,until count[char]==0 del count char, then move r。&lt;/p&gt;
&lt;h1 id=&#34;77-combinations-medium&#34;&gt;77. Combinations （Medium）&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].&lt;br&gt;
You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combine(self, n: int, k: int) -&amp;gt; List[List[int]]:
        
        res = []
        nums = [i for i in range(1,n+1)]
        def bt(tmp,start):
            if len(tmp)==k:
                res.append(tmp[:])
            else:
                for i in range(start,n):
                    tmp.append(nums[i])
                    bt(tmp,i+1)
                    tmp.pop()
        
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型backtracking， 新start=i+1 假如是start+1 则可能这个start+1 是小于等于i的，相当于重复选择 。&lt;/p&gt;
&lt;h1 id=&#34;78-subsets-medium&#34;&gt;78. Subsets （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of unique elements, return all possible subsets (the power set).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res = []
        def bt(tmp,start):
            res.append(tmp[:])
            for i in range(start,len(nums)):
                n=nums[i]
                if n not in tmp:
                    tmp.append(n)
                    bt(tmp,i+1)
                    tmp.pop()
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue79-word-search-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;79. Word Search (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n grid of characters board and a string word, return true if word exists in the grid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def exist(self, board: List[List[str]], word: str) -&amp;gt; bool:
        # bfs???  几乎忘记了 dfs bfs 怎么写?
        # 不能重复用元素，所以访问后设为-1，
        
        def bfs(board,word,i,j):
            if not word:
                return True
            
            if word[0]!= board[i][j]:
                return False
            
            boardij=board[i][j]
            board[i][j]=-1
            
            
            word=word[1:]
            
            res = False
            neig = [(i,j+1),(i,j-1),(i-1,j),(i+1,j)]
            valid_neig = []
            for nei in neig:
                row,col=nei
                if row&amp;gt;=0 and row&amp;lt;len(board) and col&amp;gt;=0 and col&amp;lt;len(board[0]):
                        valid_neig.append((row,col))
            if not valid_neig and not word:
                return True
            
            for nei in valid_neig:
                row,col=nei
                res = res or bfs(board,word,row,col)
            
            board[i][j]=boardij
            return res 
        
     
        
        res = False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j]==word[0]:
                    res = res or bfs(board,word,i,j)
        return res
# answer way of writting
class Solution:
    def exist(self, board: List[List[str]], word: str) -&amp;gt; bool:
        
        if not word: return True
        if not board: return False
        
 
        def dfs(board,i,j,w):
            if not w: 
                return True
            
            if i&amp;lt;0 or j&amp;lt;0 or i&amp;gt;=len(board) or j&amp;gt;=len(board[0]) or board[i][j]!=w[0]:
                return False
            
            #found first fit
            temp=board[i][j]
            board[i][j]=&amp;quot;#&amp;quot; #avoid visit again
            res=dfs(board,i+1,j,w[1:]) or dfs(board,i,j+1,w[1:]) or dfs(board,i-1,j,w[1:]) or dfs(board,i,j-1,w[1:]) 
            board[i][j]=temp
            return res
            
           
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(board, i, j, word):
                    return True
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码巨大丑无比， 但是pass了 。 答案的dfs写的很优雅。。。Time Complexity: O(N⋅3**L) where N  is the number of cells in the board and L is the length of the word to be matched.&lt;/p&gt;
&lt;h1 id=&#34;80-remove-duplicates-from-sorted-array-ii-medium&#34;&gt;80. Remove Duplicates from Sorted Array II (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeDuplicates(self, nums: List[int]) -&amp;gt; int:
        # 
        pos = 0
        pre=nums[0]
        c =0
        
        for i,n in enumerate(nums):
            
            
            if pre==n:
                c+=1
            else:
                c=1
                
            if c&amp;lt;=2:
                nums[pos] = nums[i]
                pos+=1
            
            pre=n
        
        return pos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 。 pos是下一个正确位置。当pre！=cur时候 重新更新计数器为1，pre=cur&lt;br&gt;
如果 计数器c 小于等于2. 把nums[i]放入nums[pos]。&lt;/p&gt;
">Leetcode 2021-11-09</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-07/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;61-rotate-list-medium&#34;&gt;61. Rotate List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, rotate the list to the right by k places.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]:
        
        if not head: return head
        def length(head):
            c=0
            tail=None
            while head:
                c+=1
                tail=head
                head=head.next
            return c,tail
        
        leng,tail = length(head)
        k = k%leng 
        if k==leng or k==0: return head
        
        
        
        p1=head
        p2=head
        
        for _ in range(k):
            p2=p2.next
        
        
        while p2.next:
            p1=p1.next
            p2=p2.next
        
        new_head=p1.next
        p1.next=None
        tail.next=head
        
        return new_head

#concise writing with dummy head
class Solution:
    def rotateRight(self, head: ListNode, k: int) -&amp;gt; ListNode:
        
        
        if k==0 or (not head): return head
        
        l=0
        cur=head
        while cur:
            l+=1
            cur=cur.next
        
        if k%l==0: return head
        
        k=k%l
        
        dummy=ListNode(-1)
        dummy.next=head
        
        p1=p2=dummy
        
        for _ in range(k):
            p2=p2.next
        
        while p2.next:
            p1=p1.next
            p2=p2.next
            
        
        newhead=p1.next
        p1.next=None
        p2.next=dummy.next
        
        return newhead
                   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心。。。&lt;/p&gt;
&lt;h1 id=&#34;62-unique-paths-medium&#34;&gt;62. Unique Paths (Medium)&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).&lt;br&gt;
How many possible unique paths are there?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def uniquePaths(self, m: int, n: int) -&amp;gt; int:
        ###  0  1  1  1  1  1  1
        ###  1  2  3  4  5  6  7
        ###  1
        ###  1
        ###  1
        # m rows   n cols
        # dp[i][j] = dp[i][j-1]+dp[i-1][j]
        #
        
        dp = [[0]*n for _  in range(m)]
        for i in range(n):
            if i==0: continue
            dp[0][i]=1
        for i in range(m):
            if m==0: continue
            dp[i][0]=1
        
        for row in range(1,m):
            for col in range(1,n):
                dp[row][col]=dp[row][col-1]+dp[row-1][col]
        return dp[m-1][n-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;63-unique-paths-ii-medium&#34;&gt;63. Unique Paths II (Medium)&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).&lt;br&gt;
Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;br&gt;
An obstacle and space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int:
        
        ###  0  1  1  1  1  1  1
        ###  1  2  3  4  5  6  7
        ###  1  O
        ###  1  
        ###  1
        # m rows   n cols
        # dp[i][j] = dp[i][j-1]+dp[i-1][j]
        #
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        if obstacleGrid[m-1][n-1]==1 or obstacleGrid[0][0]==1 : return 0
        dp = [[0]*n for _  in range(m)]
        for i in range(n):
            if i==0: continue
            if obstacleGrid[0][i]!=1:
                dp[0][i]=1
            else:
                break
        for i in range(m):
            if m==0: continue
            if obstacleGrid[i][0]!=1:
                dp[i][0]=1
            else:
                break
        
        for row in range(1,m):
            for col in range(1,n):
                rowcol1 = dp[row][col-1] if obstacleGrid[row][col-1]!=1 else 0
                row1col = dp[row-1][col] if obstacleGrid[row-1][col]!=1 else 0
                dp[row][col]=rowcol1+row1col
        return dp[m-1][n-1]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dp去解， 注意edge case， 在起始和终止位置blok。&lt;/p&gt;
&lt;h1 id=&#34;64-minimum-path-sum-medium&#34;&gt;64. Minimum Path Sum (Medium)&lt;/h1&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minPathSum(self, grid: List[List[int]]) -&amp;gt; int:
        
        # dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]
        m=len(grid)
        n=len(grid[0])
        dp = [[0]*n for _ in range(m)]
        
        for i in range(n):
            if i==0: 
                dp[0][0]=grid[0][0]
            else:
                dp[0][i] = dp[0][i-1]+grid[0][i]
        
        for i in range(m):
            if i==0:
                dp[0][0]=grid[0][0]
            else:
                dp[i][0]=dp[i-1][0]+grid[i][0]
        
        for row in range(1,m):
            for col in range(1,n):
                dp[row][col]=min(dp[row-1][col],dp[row][col-1])+grid[row][col]
        
        return dp[m-1][n-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred65-valid-number-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;65. Valid Number (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Finite state machine, but hard to write ..... 试了半天。。。。没试出来。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isNumber(self, s: str) -&amp;gt; bool:
        s = s.lower()
        #define DFA(determinstic finite automation) state transition tables
        states = [{},
                 # State (1) - initial state (scan ahead thru blanks)
                 {&#39;blank&#39;: 1, &#39;sign&#39;: 2, &#39;digit&#39;:3, &#39;.&#39;:4},
                 # State (2) - found sign (expect digit/dot)
                 {&#39;digit&#39;:3, &#39;.&#39;:4},
                 # State (3) - digit consumer (loop until non-digit)
                 {&#39;digit&#39;:3, &#39;.&#39;:5, &#39;e&#39;:6, &#39;blank&#39;:9},
                 # State (4) - found dot (only a digit is valid)
                 {&#39;digit&#39;:5},
                 # State (5) - after dot (expect digits, e, or end of valid input)
                 {&#39;digit&#39;:5, &#39;e&#39;:6, &#39;blank&#39;:9},
                 # State (6) - found &#39;e&#39; (only a sign or digit valid)
                 {&#39;sign&#39;:7, &#39;digit&#39;:8},
                 # State (7) - sign after &#39;e&#39; (only digit)
                 {&#39;digit&#39;:8},
                 # State (8) - digit after &#39;e&#39; (expect digits or end of valid input) 
                 {&#39;digit&#39;:8, &#39;blank&#39;:9},
                 # State (9) - Terminal state (fail if non-blank found)
                 {&#39;blank&#39;:9}]
        currentState = 1
        for c in s:
            # If char c is of a known class set it to the class name
            if c in &#39;0123456789&#39;:
                c = &#39;digit&#39;
            elif c in &#39; &#39;:
                c = &#39;blank&#39;
            elif c in &#39;+-&#39;:
                c = &#39;sign&#39;
            # If char/class is not in our state transition table it is invalid input
            if c not in states[currentState]:
                return False
            # State transition
            currentState = states[currentState][c]
        # The only valid terminal states are end on digit, after dot, digit after e, or white space after valid input    
        if currentState not in [3,5,8,9]:
            return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;66-plus-one-easy&#34;&gt;66. Plus One (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def plusOne(self, digits: List[int]) -&amp;gt; List[int]:
        
        res = []
        carry=0
        First=True
        for i in digits[::-1]:
            if First:
                val = carry+i+1
                First=False
            else:
                val = carry+i
            carry = val//10 
            val = val%10
            res.append(val)
         
        if carry!=0:
            res.append(carry)
        
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;67-add-binary-easy&#34;&gt;67. Add Binary （Easy）&lt;/h1&gt;
&lt;p&gt;Given two binary strings a and b, return their sum as a binary string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def addBinary(self, a: str, b: str) -&amp;gt; str:
        res = []
        carry=0
        a = [int(e) for e in a][::-1]
        b = [int(e) for e in b][::-1]
        while a or b:
            inta = a[0] if a else 0
            intb = b[0] if b else 0
            val = carry+inta+intb
            carry=val//2
            res.append(val%2)
            a=a[1:] if a else None
            b=b[1:] if b else None
        if carry:
            res.append(1)
        return &#39;&#39;.join([str(e) for e in res[::-1]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;68-text-justification-hard&#34;&gt;68. Text Justification (Hard)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -&amp;gt; List[str]:
        
        # W1+1  W2+1  W3
        level = []
        res = []
        c_level = 0
        while words:
            word = words.pop(0)
            lw = len(word)
            c_level+=(lw+1)
            if c_level-1&amp;gt;maxWidth:
                words = [word]+words
                res.append(level[:])
                level=[]
                c_level=0
            else:
                level.append(word)
        if level:
            res.append(level)
        
        result = []
        for rowid,row in enumerate(res):
            l = len(row)
            ngap =l-1
            if rowid!=len(res)-1:
                if ngap!=0:
                    i=0
                    while sum([len(w) for w in row])&amp;lt;maxWidth:
                        ind = i%ngap
                        row[ind] = row[ind]+&#39; &#39;
                        i+=1
                    row = &#39;&#39;.join(row)
                else:
                    row = row[0]+&#39; &#39;*(maxWidth-len(row[0]))
            else:
                row=&#39; &#39;.join(row)
                row = row+&#39; &#39;*(maxWidth-len(row))
                
            result.append(row)
        
        return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;round robin 分配除了最后一行外的空格。。。&lt;/p&gt;
&lt;h1 id=&#34;69-sqrtx-easy&#34;&gt;69. Sqrt(x) （Easy）&lt;/h1&gt;
&lt;p&gt;Given a non-negative integer x, compute and return the square root of x.&lt;br&gt;
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def mySqrt(self, x: int) -&amp;gt; int:
        
        l=0
        r=x
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if   m**2&amp;lt;=x and (m+1)**2&amp;gt;x:
                return m
            
            elif m**2&amp;gt;x:
                r=m-1
            else:
                l=m+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接二分法了。。&lt;/p&gt;
&lt;h1 id=&#34;70-climbing-stairs-easy&#34;&gt;70. Climbing Stairs （Easy）&lt;/h1&gt;
&lt;p&gt;You are climbing a staircase. It takes n steps to reach the top.&lt;br&gt;
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def climbStairs(self, n: int) -&amp;gt; int:
        # 
        #   0 step to climit to 0    0 
        #   1 step to clime to 1     1
        #   1+1 to clime to 2 
        if n==1: return 1
        if n==2: return 2
        
        dp = [0]*(n+1)
        dp[1]=1
        dp[2]=2
        # dp[n] = dp[n-1]+dp[n-2]
        
        for i in range(3,n+1):
            dp[i]=dp[i-1]+dp[i-2]
    
        return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单dynamic programming应用。&lt;/p&gt;
">Leetcode 2021-11-08</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/backtracking-zong-jie/"" data-c="
          &lt;p&gt;backtracking 不同题目不完全汇总&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
### Subsets
        def backtrack(list, templist,nums,start):
            list.append(templist[:])
            for i in range(start,len(nums)):
                templist.append(nums[i])
                backtrack(list,templist,nums,i+1)
                templist.pop()      

        list=[]
        nums.sort()
        backtrack(list,[],nums,0)
        return list
### Subsets II
    def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]:
        def backtrack(list, templist,nums,start):
            list.append(templist[:])
            for i in range(start,len(nums)):
                if i &amp;gt; start and nums[i] == nums[i-1]: continue
                templist.append(nums[i])
                backtrack(list,templist,nums,i+1)
                templist.pop()      

        list=[]
        nums.sort()
        backtrack(list,[],nums,0)
        return list
### Permutations
    def permute(self, nums: List[int]) -&amp;gt; List[List[int]]:
        def backtrack(list, templist,nums):
            
            if len(templist)==len(nums): list.append(templist[:])
            else:
                for i in range(0,len(nums)):
                    if nums[i] in templist: continue
                    templist.append(nums[i])
                    backtrack(list,templist,nums)
                    templist.pop()      

        list=[]
        #nums.sort()
        backtrack(list,[],nums)
        return list
### Permutations II
    def permuteUnique(self, nums: List[int]) -&amp;gt; List[List[int]]:
             
        def backtrack(list, templist,nums,used):
            
            if len(templist)==len(nums): list.append(templist[:])
            else:
                for i in range(0,len(nums)):
                    if used[i] or (i &amp;gt; 0 and nums[i] == nums[i-1] and (not used[i - 1])): continue
                    used[i]=True
                    templist.append(nums[i])
                    backtrack(list,templist,nums,used)
                    used[i] = False 
                    templist.pop()      

        list=[]
        used=[False]*len(nums)
        nums.sort()
        backtrack(list,[],nums,used)
        return list
### combination sum
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        
        def backtrack(list, templist,nums,remain,start):
            
            if remain &amp;lt; 0: return
            elif remain == 0: list.append(templist[:])
            else:
                for i in range(start,len(nums)):
                    
                    templist.append(nums[i])
                    backtrack(list,templist,nums,remain - nums[i], i)
                    templist.pop()      
        nums=candidates
        list=[]
        nums.sort()
        backtrack(list,[],nums,target,0)
        return list
### combination sum II
    def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
             
        def backtrack(list, templist,nums,remain,start):
            
            if remain &amp;lt; 0: return
            elif remain == 0: list.append(templist[:])
            else:
                for i in range(start,len(nums)):
                    if (i &amp;gt; start) and (nums[i] == nums[i-1]): continue
                    templist.append(nums[i])
                    backtrack(list,templist,nums,remain - nums[i], i+1)
                    templist.pop()      
        nums=candidates
        list=[]
        nums.sort()
        backtrack(list,[],nums,target,0)
        return list
### Palindrome Partitional 
    def partition(self, s: str) -&amp;gt; List[List[str]]:
        
        def backtrack(list, templist,s,start):
            
            if start==len(s): list.append(templist[:])  
            else:
                for i in range(start,len(s)):
                    if s[start:i+1]==s[start:i+1][::-1]:
                        templist.append(s[start:i+1])
                        backtrack(list,templist,s, i+1)
                        templist.pop()      

        list=[]
        backtrack(list,[],s,0)
        return list
&lt;/code&gt;&lt;/pre&gt;
">backtracking 总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-06/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-51-n-queens-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 51. N-Queens (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   def solveNQueens(self, n: int) -&amp;gt; List[List[str]]:
       # notation [-1,-1,-1,-1]
       #          [1,3,0,2]
       # 
       res = []
       def canplace(board,rowid,colid):
           for r,c in enumerate(board):
               if c!=-1:
                   if r+c == rowid+colid:
                       return False
                   if r-c == rowid-colid:
                       return False
                   if rowid==r or colid==c:
                       return False    
               if board[rowid]!=-1:
                   return False
           return True
       
       
       def bt(board,start=0):
           
           if start==n:
               res.append(board)
               
           else:
               for i in range(start, n):
                   #ith queens at row i
                   for j in range(n):
                       # j is the col of ith queens
                       if canplace(board,i,j):
                           board[i]=j
                           bt(board[:],start+1)
                           board[i]=-1
       bt([-1]*n,0)
       result = []
       for r in res:
           tmpresult = []
           for row, col in enumerate(r):
               string=&#39;.&#39;*n
               if col+1&amp;lt;n:
                   tmp=string[:col]+&#39;Q&#39;+string[col+1:]
               else:
                   tmp=string[:col]+&#39;Q&#39;
               tmpresult.append(tmp)
           result.append(tmpresult)
       return result

#answer way of writing
class Solution(object):
   def solveNQueens(self, n):
       &amp;quot;&amp;quot;&amp;quot;
       :type n: int
       :rtype: List[List[str]]
       &amp;quot;&amp;quot;&amp;quot;
       
       board = [-1]*n
       
       
       def conflict(board, row, col):
           
           for row_i in range(n):
               #if has Queue in row_i  col != -1 
               if  board[row_i] != -1 and ( col==board[row_i] or row==row_i or row+col==row_i+ board[row_i] or  row-col==row_i- board[row_i]):
                   #same row
                   return True
               
           return False
       
       res = []
       def bt(board,row):
           if row==n:
               res.append(board[:])
           else:
               for col in range(n):
                   if not conflict(board,row,col):
                       board[row]=col
                       bt(board,row+1)
                       board[row]=-1
       bt(board,0)

       result = []
       for solution in res:
           s = []
           for i in solution:
               row = [&#39;.&#39;]*n
               row[i]=&#39;Q&#39;
               s.append(&#39;&#39;.join(row))
           result.append(s)
       return  result
               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 做出来time limit exceed， 代码正确但用时过长。错误地方在于多写了一层循环 for i in range(start, n):   #ith queens at row i， start已经可以表示ith quene了。。。算半个做出来。。。&lt;/p&gt;
&lt;h1 id=&#34;52-n-queens-ii-hard&#34;&gt;52. N-Queens II （Hard）&lt;/h1&gt;
&lt;p&gt;和之间一样求出所有组合然后求length。。。&lt;/p&gt;
&lt;h1 id=&#34;53-maximum-subarray-easy&#34;&gt;53. Maximum Subarray （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum&lt;br&gt;
A subarray is a contiguous part of an array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
   
        #  dp[i][j] 表示i to j sum
        #  dp[0][0] = nums[0]
        #  dp[1][1] = nums[1]
        #  dp[i][i] = nums[i]
        #  dp[i][i+1]=dp[i][i]+nums[i+1]
        #  dp[i][i+2]=dp[i][i+1]+nums[i+3]
        
        
        dp = [[-float(&#39;inf&#39;)]*len(nums) for _ in range(len(nums))]
        res = -float(&#39;inf&#39;)
        #init dp
        for i in range(len(nums)):
            dp[i][i] = nums[i]
            res=max(res,dp[i][i])
        #run dp
        for col_row in range(1,len(nums)):
            for row in range(len(nums)-1):
                col = row+col_row
                if len(nums)&amp;gt;row&amp;gt;=0 and len(nums)&amp;gt;col&amp;gt;=0:
                    dp[row][col] = dp[row][col-1]+nums[col]
                    res=max(res,dp[row][col])
        #for row in dp:
        #    print(row)
        return res

class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
        #O（n）方法， 
        #  dp[i] 表示 在i包含i元素的最大和
        #  dp[i] = max(nums[i],dp[i-1]+nums[i])
        if len(nums)==1: return nums[0]
        res = nums[0]
        dpi1 = nums[0]
        for i in range(1,len(nums)):
            dpi=max(nums[i],dpi1+nums[i])
            if dpi&amp;gt;res:
                res=dpi
            dpi1=dpi
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己写了个dp方法但是O（n**2）， time limit exceed。。。然后可以化简成 O（n）的方法， 因为dpi1=dpi 写反了。。。写成了dpi=dpi1 报错， 一位思路错了，其实没错。。。。~~&lt;/p&gt;
&lt;h1 id=&#34;54-spiral-matrix-medium&#34;&gt;54. Spiral Matrix （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]:
        res = []
        while matrix:
            res.extend(matrix.pop(0))
            matrix = list(zip(*matrix))[::-1]
        return res

#answer way of writting
class Solution(object):
    def spiralOrder(self, matrix):
        &amp;quot;&amp;quot;&amp;quot;
        :type matrix: List[List[int]]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if not matrix: return []
        
        visited = [[False for i in range(len(matrix[0]))] for j in range(len(matrix))]
        
        moveX = [1,0,-1,0]
        moveY = [0,1,0,-1]
        res = []
        moveOption = 0
        row = len(matrix)
        col = len(matrix[0])
        r = 0
        c = 0
        for _ in range(row*col):
            res.append(matrix[r][c])
            visited[r][c]=True
            rr = r + moveY[moveOption]
            cc = c + moveX[moveOption]
            if (rr&amp;gt;=0 and rr&amp;lt;row and cc&amp;gt;=0 and cc&amp;lt;col) and not visited[rr][cc]
                r=rr
                c=cc
            else:
                moveOption = (moveOption+1)%4
                r = r+moveY[moveOption]
                c = c+moveX[moveOption]
        return res        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;55-jump-game-medium&#34;&gt;55. Jump Game (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canJump(self, nums: List[int]) -&amp;gt; bool:
        
        right=nums[0]
        cur = 0
        for i,n in enumerate(nums):
            #form 1th index
            if i==0: continue
            if right&amp;gt;=i:
                #if I can reach Ith pos, update right
                right = max(right,i+n)
        
        return right&amp;gt;=len(nums)-1
    ```
# 56. Merge Intervals (Medium)
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]:
        #[sort by start
        # scan if &amp;lt; append, else  continue til end
        # case1)
        #    al    ar   
        #    |      |
        #       bl|    |br
        #
        # case2)
        #    al    ar   
        #    |      |
        #              bl|    |br
        # case3)
        #    al               ar   
        #    |                |
        #       bl|    |br
        
        if len(intervals)==1: return intervals
        intervals = sorted(intervals, key=lambda x: x[0])
        res = []
        pre_left = intervals[0][0]
        pre_right = intervals[0][1]
        for i,interval in enumerate(intervals):
            if i==0: continue
            local_left = interval[0]
            local_right = interval[1]
            if local_left &amp;gt; pre_right:
                #case 2)
                res.append([pre_left,pre_right])
                pre_left=local_left
                pre_right=local_right
            else:
                #case 1,3)
                pre_right=max(pre_right,local_right)
                
            if i==len(intervals)-1:
                res.append([pre_left,max(pre_right,local_right)])
                
        return res

#answer way of writting
class Solution:
    def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]:
        
        intervals.sort(key=lambda x:x[0])
        
        if not intervals: return []
        
        cur=intervals.pop(0) 
        res=[cur]
        
        while intervals:
            cur=intervals.pop(0)
            res_1=res[-1]
            # a   b
            #  cd       case 1  drop cur
            #   c  d    csse 2  extend res[-1] to d
            #        cd case 3  add cur to res
            
            if cur[1]&amp;lt;=res_1[1]: 
                continue
            elif    cur[0]&amp;lt;=res_1[1] and cur[1]&amp;gt;res_1[1]:
                res[-1][1]=cur[1]
            else:
                res.append(cur)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sort by 起始元素， 总共有3种情况很容易想到， 答案写的代码比较简单。。。&lt;/p&gt;
&lt;h1 id=&#34;57-insert-interval-medium&#34;&gt;57. Insert Interval （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&amp;gt; List[List[int]]:
        
        intervals.append(newInterval)
        intervals.sort(key=lambda x: x[0])
        if not intervals or len(intervals)==1: return intervals
        
        res = []
        cur = intervals.pop(0)
        res.append(cur)
        
        while intervals:
            cur=intervals.pop(0)
            cur_left = cur[0]
            cur_right= cur[1]
            pre_left = res[-1][0]
            pre_right = res[-1][1]
            
            if cur_right&amp;lt;=pre_right:
                # a  b b  a
                continue
            elif cur_left&amp;lt;=pre_right and cur_right&amp;gt;=pre_right:
                # a  b  a  b
                res[-1][1]=cur_right
            else:
                # a  a  b b
                res.append(cur)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把区间插入， 排序， 然后重复上题代码。&lt;/p&gt;
&lt;h1 id=&#34;58-length-of-last-word-easy&#34;&gt;58. Length of Last Word （Easy）&lt;/h1&gt;
&lt;p&gt;Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLastWord(self, s: str) -&amp;gt; int:
        c=0
        while s[-1]==&#39; &#39;:
            s= s[:-1]
        while s:
            char = s[-1]
            if char!=&#39; &#39;:
                c+=1
            else:
                break
            s=s[:-1]
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先去尾部空格，然后从尾部开始计数，如果碰到空格就break return。&lt;/p&gt;
&lt;h1 id=&#34;59-spiral-matrix-ii-medium&#34;&gt;59. Spiral Matrix II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generateMatrix(self, n: int) -&amp;gt; List[List[int]]:
        
        matrix = [[&#39;NULL&#39;]*n for _ in range(n)]
        visited= [[False]*n for _ in range(n)]
        move_X = [1,0,-1,0]
        move_Y = [0,1,0, -1]
        
        r=0
        c=0
        moveOption = 0
        for i in range(1,n*n+1):
            matrix[r][c]=i
            visited[r][c]=True
            #calculate next pos
            rr=r+move_Y[moveOption]
            cc=c+move_X[moveOption]
            #print(rr,cc)
            if not (n&amp;gt;rr&amp;gt;=0 and n&amp;gt;cc&amp;gt;=0 and not visited[rr][cc]):
                moveOption = (moveOption+1)%4
                rr=r+move_Y[moveOption]
                cc=c+move_X[moveOption]
            r=rr
            c=cc
        return matrix
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-60-permutation-sequence-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 60. Permutation Sequence （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The set [1, 2, 3, ..., n] contains a total of n! unique permutations.&lt;br&gt;
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&lt;br&gt;
&amp;quot;123&amp;quot;&lt;br&gt;
&amp;quot;132&amp;quot;&lt;br&gt;
&amp;quot;213&amp;quot;&lt;br&gt;
&amp;quot;231&amp;quot;&lt;br&gt;
&amp;quot;312&amp;quot;&lt;br&gt;
&amp;quot;321&amp;quot;&lt;br&gt;
Given n and k, return the kth permutation sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getPermutation(self, n: int, k: int) -&amp;gt; str:
        
        # &amp;quot;123&amp;quot;             0
        # &amp;quot;132&amp;quot;             1
        # &amp;quot;213&amp;quot;             2
        # &amp;quot;231&amp;quot;             3
        # &amp;quot;312&amp;quot;             4
        # &amp;quot;321&amp;quot;             5
        #      3!  2!  1! 0!
        #      a*6  + b2   c1  d1
        #   4= 0      2     0   0
        #             3     1   2
        if n==1: return &amp;quot;1&amp;quot;
        bignumber=[0]*n
        bignumber[0]=1
        bignumber[1]=1
        for i in range(2,n):
            bignumber[i]=i*bignumber[i-1]
        select=[str(i) for i in range(1,n+1)]
        res=[]
        k=k-1
        for i in range(n-1,-1,-1):
            index=k//bignumber[i]
            k=k-index*bignumber[i]
            res.append(select[index])
            select.remove(select[index])
        
        return &amp;quot;&amp;quot;.join(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不会做， 没思路，要是按照求下一个permutation方法肯定time limit exceeded。backtracking too 。&lt;br&gt;
答案思路是： k看作为以阶乘进制计数。eg. 3个数的阶乘进制base为  3!  2!  1! 0!&lt;br&gt;
某个k只是这个阶乘进制计数的值，所以先算bignumber阶乘计数base。&lt;br&gt;
k的最大位阶乘计数对应的值为 index=k//bignumber[i]   i~n-1:0。知道index就能定位出当前位应该放哪个值，由于是无放回抽样。需要删除值。 然后算下一个index。&lt;/p&gt;
">Leetcode 2021-11-06</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-05/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;41-first-missing-positive-hard&#34;&gt;41. First Missing Positive （Hard）&lt;/h1&gt;
&lt;p&gt;Given an unsorted integer array nums, return the smallest missing positive integer.&lt;br&gt;
You must implement an algorithm that runs in O(n) time and uses constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def firstMissingPositive(self, nums: List[int]) -&amp;gt; int:
        
        # full [1,2,3...len]
        # missing due to -1 , gap ..
        # e.g [3,4,-1,1]
        #     [-3,4,-5,-1]
        #      
        
        length = len(nums)
        
        for i,n in enumerate(nums):
            if n&amp;lt;=0:
                nums[i]=length+1
                #length+1  means mums[i] invalid
                
        for i,n in enumerate(nums):
            real_n = abs(n)
            pos_n = real_n-1
            if pos_n&amp;lt;=length-1:
                nums[pos_n] = -abs(nums[pos_n])
        
        for i,n in enumerate(nums):
            if n&amp;gt;0:
                return i+1
        
        return length+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 -abs（val）符号来判断是否已经扫过，注意0和负数的处理。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-42-trapping-rain-water-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 42. Trapping Rain Water （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&lt;br&gt;
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;
Output: 6&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trap(self, height: List[int]) -&amp;gt; int:
        
        # 当入栈时候左边界确定
        # 当入的元素比栈顶大出栈，出栈右边界确定，计算，入栈当前值
        # 边界情况， 第一个元素入栈左边界为空
        # 
        stack = []
        res = 0
        for i,h in enumerate(height):
            while stack and h&amp;gt;height[stack[-1]]:
                #calculate
                cur = stack.pop()
                if stack:
                    left= stack[-1]  
                    right = i
                  
                    width = right-left-1  
                     
                    height_ = min(height[left],height[right])-height[cur]  
                    val = width*height_
                    res+=val
            
            stack.append(i)
        
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了， 但花了很长时间。。。。。&lt;/p&gt;
&lt;h1 id=&#34;43-multiply-strings-medium&#34;&gt;43. Multiply Strings (Medium)&lt;/h1&gt;
&lt;p&gt;Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.&lt;br&gt;
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def multiply(self, num1: str, num2: str) -&amp;gt; str:
        
        
        # 1 2 3 j
        # 4 5 6 i
        #-------
        # 7 3 8
     #  6 1 5
    # 4 9 2
    #  5 6 0 8 8
    
        #
        
        res = [0] *(len(num1)+len(num2)) 
        l=len(res)
        
        for i in range(len(num2)):
            carry=0
            n_num2 = int(num2[len(num2)-1-i])
            for j in range(len(num1)):
                n_num1=int(num1[len(num1)-1-j])
                val = carry+n_num2*n_num1 + res[l-1-(i+j)]
                res[l-1-(i+j)] = val%10
                #print(i,j,val)
                carry = val//10
                
            if carry:
                res[l-1-i-len(num1)]=carry
        
        #print(res)
        while res and res[0]==0:
            res = res[1:]
        return &#39;&#39;.join([str(e) for e in res]) if &#39;&#39;.join([str(e) for e in res]) else &amp;quot;0&amp;quot;

## answer
class Solution(object):
    def multiply(self, num1, num2):
        &amp;quot;&amp;quot;&amp;quot;
        :type num1: str
        :type num2: str
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        res = [0]*(len(num1)+len(num2))
        for i in range(len(num1)-1,-1,-1):
            carry = 0
            for j in range(len(num2)-1,-1,-1):
                temp = int(num1[i])*int(num2[j]) + carry
                carry = (res[i+j+1] + temp) //10
                res[i+j+1] = (res[i+j+1] + temp) % 10
            res[i] += carry
        return &#39;&#39;.join(list(map(str,res))).lstrip(&#39;0&#39;) if &#39;&#39;.join(list(map(str,res))).lstrip(&#39;0&#39;) else &amp;quot;0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功做出来，但是得很细心。&lt;br&gt;
答案写的很精简，思路一样&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-44-wildcard-matching-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 44. Wildcard Matching （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 遇到 time limit exceeded 问题
class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        
        # ? any single
        # * any sequence
        
        if not p:
            return not s
        if not s:
            if len(set(p))==1 and p[0]==&#39;*&#39;:
                return True
            return False
#       first block  way of writing           
        if p[0] in {s[0],&#39;?&#39;}:
            #match single
            return self.isMatch(s[1:],p[1:])
        elif p[0]==&#39;*&#39;:
            #match sequence     match 0 s,      match 1 s,p not change
            return self.isMatch(s,p[1:]) or self.isMatch(s[1:],p)
        elif p[0]!=s[0]:
            return False
        
#         second block way of writting   using var firstmatch     
#         firstmatch=  p[0] in {&#39;?&#39;,s[0]}              
#         if p[0]==&#39;*&#39;:
#             if len(p)==1:
#                 return True
#             else:
#                 #                 0 s                     1 s
#                 return self.isMatch(s,p[1:]) or  self.isMatch(s[1:],p)
#         else:
#             return firstmatch and self.isMatch(s[1:],p[1:])
    
            
&#39;&#39;&#39; time limit exceeded   1) remove dup*  2) using memorization of (s,p) results   &#39;&#39;&#39;  
class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        def removedup(p):
            res=[]
            pre=None
            for e in p:
                if pre==&#39;*&#39; and e==&#39;*&#39;:
                    continue
                res.append(e)
                pre=e
            return &amp;quot;&amp;quot;.join(res)
                
        dic=dict()
        
        def M(s,p):
            if (s,p) in dic: return dic[(s,p)]
            if not p: return not s
            if not s: 
                if p==&#39;*&#39;:
                    dic[(s,p)]=True
                    return True
                else:
                    dic[(s,p)]=False
                    return False
            firstmatch= p[0] in {s[0],&#39;?&#39;}
            
            if p[0]==&#39;*&#39;:
                res=M(s,p[1:]) or M(s[1:],p)
                dic[(s,p)]=res
                return res
            else:
                res=firstmatch and M(s[1:],p[1:])
                dic[(s,p)]=res
                return res
        
        return M(s,removedup(p))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有dynamic programming 解法， 比较不熟悉， 暂时放弃。&lt;/p&gt;
&lt;h1 id=&#34;45-jump-game-ii-medium&#34;&gt;45. Jump Game II （Medium）&lt;/h1&gt;
&lt;p&gt;Given an array of non-negative integers nums, you are initially positioned at the first index of the array.&lt;br&gt;
Each element in the array represents your maximum jump length at that position.&lt;br&gt;
Your goal is to reach the last index in the minimum number of jumps.&lt;br&gt;
You can assume that you can always reach the last index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def jump(self, nums: List[int]) -&amp;gt; int:
        # i,
        # i+nums[i] is max can just at this step
        # search prev to i+nums[i], which can just further
        if len(nums)==1: return 0
        
        pos = 0 
        step = 0
        while pos&amp;lt;len(nums)-1:
            step+=1
            move_to = None
            max_can_reach = -float(&#39;inf&#39;)
            for i in range(pos,pos+nums[pos]+1):
                if i&amp;gt;=len(nums)-1: return step
                reach = i+nums[i]
                if reach&amp;gt; max_can_reach:
                    max_can_reach = reach
                    move_to = i
            pos = move_to
               
        return step

#anser way of writing
class Solution(object):
    def jump(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(nums)
        if n &amp;lt; 2:
            return 0 
        
        # max position one could reach 
        # starting from index &amp;lt;= i 
        right = nums[0]
        # max number of steps one could do
        # inside this jump
        cur = nums[0]
        
        jumps = 1
        for i in range(1, n):
            # if to reach this point 
            # one needs one more jump
            if cur &amp;lt; i:
                jumps += 1
                cur = right
            right = max(right, nums[i] + i)
                
        return jumps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;费了点力气写出来了，思路， 如果pos不到最后一位，需要移动，step+=1， 确定移动到哪里，移动到可以使下次移动更远的index位置。 从【pos，pos+nums【pos】】中选出能达到最远的index，那个index就当前步会移动的地方。 注意再扫能移动到最远的地方时候， 如果【pos，pos+nums【pos】】已经大于等于了最后的位置，再当前步就可提前结束了，return step就行。&lt;br&gt;
答案直接扫从1到LEN（nums）的位置，right能到位置为 right = max(right, nums[i] + i)， 如果在right更新前， cur小于i， 则需要jump，jump后 cur=right。&lt;/p&gt;
&lt;h1 id=&#34;46-permutations-medium&#34;&gt;46. Permutations （Medium）&lt;/h1&gt;
&lt;p&gt;Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def permute(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res =[]
        def bt(tmp):
            if len(tmp)==len(nums):
                res.append(tmp[:])
            for n in nums:
                if n not in tmp:   
                    tmp.append(n)
                    bt(tmp)
                    tmp.pop()
        
        bt([])
        return res

# aswer way of writing 用了swap 比较省检查是否在tmp那步。
class Solution:
    def permute(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &amp;quot;&amp;quot;&amp;quot;
        def backtrack(first = 0):
            # if all integers are used up
            if first == n:  
                output.append(nums[:])
            for i in range(first, n):
                # place i-th integer first 
                # in the current permutation
                nums[first], nums[i] = nums[i], nums[first]
                # use next integers to complete the permutations
                backtrack(first + 1)
                # backtrack
                nums[first], nums[i] = nums[i], nums[first]
        
        n = len(nums)
        output = []
        backtrack()
        return output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 应用，有空得写bt总结。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-47-permutations-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 47. Permutations II （Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def permuteUnique(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &amp;quot;&amp;quot;&amp;quot;
        
        visited = [False]*len(nums)
        
        res = []
        def bt(temp,visited):
            if len(temp)==len(nums):
                res.append(temp[:])
            
            else:
                for i in range(len(nums)):
                    
                    if visited[i] or (i&amp;gt;0 and nums[i]==nums[i-1] and not visited[i-1]) : continue 
         
                    visited[i]=True
                    temp.append(nums[i])
                    bt(temp,visited[:])
                    temp.pop()
                    visited[i]=False
                     
        
        nums.sort()
        bt([],visited)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试着用 Permutations  swap方法+if条件去重，失败， 没想到得开一个visited来记录是否访问过。 如果访问过或者提前访问（i-1 没访问但开始访问i）则continue。&lt;/p&gt;
&lt;h1 id=&#34;48-rotate-image-medium&#34;&gt;48. Rotate Image （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rotate(self, matrix: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify matrix in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        n = len(matrix)
        
        for level in range(n//2):
            len_level = n-level*2
            
            for i in range(len_level-1):
                lefttop = matrix[level][level+i]
                righttop =matrix[level+i][level+len_level-1]
                rightbot = matrix[n-level-1][level+len_level-i-1]
                leftbot = matrix[level+len_level-i-1][level]
                
                print(lefttop,righttop,rightbot,leftbot)
                
                matrix[level+i][level+len_level-1] = lefttop
                matrix[n-level-1][level+len_level-i-1] = righttop
                matrix[level+len_level-i-1][level] = rightbot
                matrix[level][level+i] = leftbot
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;49-group-anagrams-medium&#34;&gt;49. Group Anagrams (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]:
        
        if len(strs)==1: return [strs]
        res = []
        dic = dict()
        for str in strs:
            key = &#39;&#39;.join(sorted([e for e in str]))
            if key not in dic:
                          dic[key] = []
            dic[key].append(str)
        for k,v in dic.items():
                          res.append(v)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;50-powx-n-medium&#34;&gt;50. Pow(x, n) Medium&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def myPow(self, x: float, n: int) -&amp;gt; float:
        if n==0: return 1.0
        if n&amp;lt;0:
            x=1.0/x
            n=-n
        
        if n%2==1:
            return x*self.myPow(x,n//2)**2
        else:
            return self.myPow(x,n//2)**2
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-05</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-04/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;31-next-permutation-medium&#34;&gt;31. Next Permutation （Medium）&lt;/h1&gt;
&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;br&gt;
If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).&lt;br&gt;
The replacement must be in place and use only constant extra memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextPermutation(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        #                     peak  &amp;lt;--      
        # 9  6  8   7  1  |2|  5  4  3 1
        #                     find first greater than 2 swap &amp;lt;-
        #                 |3|  5  4  2 1
        #                     rest just rev
        #                  3   1  4  2 5
        
        def rev(nums):
            l=0
            r=len(nums)-1
            while l&amp;lt;r:
                nums[l],nums[r]=nums[r],nums[l]
                l+=1
                r-=1
        
        l = len(nums)
        pos_a = None
        pos_b = None
        for i in range(l-1,-1,-1):
            if i-1&amp;gt;=0 and nums[i-1] &amp;lt; nums[i]:
                a = nums[i-1]
                pos_a = i-1
                break
         
        if  pos_a is None: 
            rev(nums)  
        else:
            for i in range(l-1,pos_a,-1):
                if nums[i]&amp;gt;nums[pos_a]:
                    pos_b = i
                    break
            print(pos_a,pos_b)
            nums[pos_a],nums[pos_b] = nums[pos_b],nums[pos_a]
            nums[pos_a+1:] =  nums[pos_a+1:][::-1 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路， 从最后一位开始，找到第一次drop位置标记为pos_a, 再从后向前找到第一个比num【pos_a】大的位置计为pos_b, swap value of pos_a, pos_b, 对于pos_a之后的，rev。&lt;br&gt;
what if 是 下一个更小的位置？？ drop=&amp;gt;increase,   大=&amp;gt;小&lt;/p&gt;
&lt;h1 id=&#34;font-colorred32-longest-valid-parentheses-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;32. Longest Valid Parentheses （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestValidParentheses(self, s: str) -&amp;gt; int:
        
        #&amp;quot;))))())()()(()&amp;quot;
        stack=[-1]
        res=0
        for i,n in enumerate(s):
            if n==&#39;(&#39;:
                stack.append(i)
            else:
                #n==&#39;)&#39;
                if stack:
                    stack.pop()
                
                if stack:
                    res=max(res,i-stack[-1])
                else:
                    stack.append(i)
        
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;题目有坑，如果直接用判断是否是valid parentheses方法计算长度，就掉坑里了。。。&lt;br&gt;
方法依旧是用stack， 但stack里面存的是（括号的位置，如果是（入栈， 否则出栈，出栈时候因为是），所以开始计算长度，“当前位置-stack【-1】” stack【-1】是已经pop后的位置了，所以是起始点，如果栈pop后为空，继续入栈，此为新起始点。（其实为起始点的前一位，算长度避免 j-i+1，直接j-i）&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-33-search-in-rotated-sorted-array-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 33. Search in Rotated Sorted Array (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;        l = 0
        r = len(nums)-1
        
        while l&amp;lt;=r:
            m = (l+r)//2
            if nums[m] == target: return m
            
            #@stuck here
            if nums[l] &amp;gt; nums[m]:
                #increasing at right
                if nums[m] &amp;lt;= target and target&amp;lt;=nums[r]:
                    l = m+1
                else:
                    r = m-1
            
            else:
                #increasing at left
                if nums[l] &amp;lt;= target and target&amp;lt;=nums[m]:
                    r = m-1
                else:
                    l = m+1
        return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个必须会的题目，binary search 判断单增区间用mid 和 left 比 （mid he right比是错误的）。根据单调区间缩小搜索范围。&lt;/p&gt;
&lt;h1 id=&#34;34-find-first-and-last-position-of-element-in-sorted-array-medium&#34;&gt;34. Find First and Last Position of Element in Sorted Array （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]:
        
        def bsl(nums,target):
            l=0
            r=len(nums)-1
            while l&amp;lt;=r:
                m = (l+r)//2
                
                if nums[m] &amp;gt;= target:
                    r = m-1
                else:
                    l = m+1
            return l
        
        def bsr(nums,target):
            l=0
            r=len(nums)-1
            while l&amp;lt;=r:
                m = (l+r)//2
                
                if nums[m] &amp;lt;= target:
                    l = m+1
                else:
                    r = m-1
            return r
        
        return [bsl(nums,target),bsr(nums,target)] if bsl(nums,target) &amp;lt;= bsr(nums,target) else [-1,-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;35-search-insert-position-easy&#34;&gt;35. Search Insert Position (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchInsert(self, nums: List[int], target: int) -&amp;gt; int:
        
        l=0
        r=len(nums)-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if nums[m]==target:
                return m
            elif nums[m]&amp;lt;target:
                l=m+1
            else:
                r=m-1
        return l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;target 大于 mid值 说明是插入位置，l位置刚好更新为插入位置， 返回left。&lt;/p&gt;
&lt;h1 id=&#34;36-valid-sudoku-medium&#34;&gt;36. Valid Sudoku （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool:
        for row in board:
            row = [e for e in row if e!=&#39;.&#39;]
            if len(set(row))!=len(row):
                return False
        
        for col in zip(*board):
            print(col)
            col = [e for e in col if e!=&#39;.&#39;]
            if len(set(col))!=len(col):
                return False
        dic={k:[] for k in range(9)}    
        for i in range(9):
            for j in range(9):
                ind = (i//3)*3 + j//3
                dic[ind].append(board[i][j])
        
        for k,v in dic.items():
            row = [e for e in v if e!=&#39;.&#39;]
            if len(set(row))!=len(row):
                return False        
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;box index boxid = (i//3)*3+j//3 or key=(i//3,j//3)&lt;/p&gt;
&lt;h1 id=&#34;37-font-colorred-sudoku-solver-hard-font&#34;&gt;37. &lt;font color=&#39;red&#39;&gt; Sudoku Solver (hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def solveSudoku(self, board: List[List[str]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        row  = {i:set() for i in range(9)}
        col = {j:set() for j in range(9)}
        box = {boxid:set() for boxid in range(9)}
        
        def canplace(num,i,j):
            boxid = (i//3)*3+j//3
            if (num in row[i]) or (num in col[j]) or (num in box[boxid]):
                return False
            return True
        
        def place(num,i,j):
            boxid = (i//3)*3+j//3
            board[i][j] = num
            row[i].add(num)
            col[j].add(num)
            box[boxid].add(num)
        
        def remove(num,i,j):
            board[i][j] = &#39;.&#39;
            boxid = (i//3)*3+j//3
            row[i].remove(num)
            col[j].remove(num)
            box[boxid].remove(num)
        
        solved = False
        def placenext(i,j):
            if i==8 and j==8:
                nonlocal solved
                solved=True
            
            elif j==8:
                bt(i+1,0)
            else:
                bt(i,j+1)
        
        #@stuck place step ignored
        for i in range(9):
            for j in range(9):
                if board[i][j]!=&#39;.&#39;:
                    place(board[i][j],i,j)
                    
        
        def bt(i,j):
            
            if board[i][j]==&#39;.&#39;:
                for d in range(1,10):
                    d = str(d)
                    if canplace(d,i,j):
                        place(d,i,j)
                        placenext(i,j)

                        if not solved:
                            remove(d,i,j)
            else:
                placenext(i,j)
                            
        
        bt(0,0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要function， canplace、 remove、 placenext。 backtracking逻辑，如果要填， scan1到9，如果能填入，填入，填入下一个， 如果没有solve，去除填入值。 如果当前空不填，填入下一个。&lt;br&gt;
思路简单，但构建出思路难。&lt;/p&gt;
&lt;h1 id=&#34;38-count-and-say-medium&#34;&gt;38. Count and Say （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countAndSay(self, n: int) -&amp;gt; str:
        
        if n==1: return &#39;1&#39;
        prev = &#39;1&#39;
        
        for i in range(n-1):
            cur = &#39;&#39;    
            pre_char = None
            c=0
            #print(&#39;in&#39;,prev)
            while prev:
                cur_char = prev[0]
                if pre_char and cur_char!=pre_char:
                    #output
                    cur+= str(c)+pre_char
                    c=1
                else:
                    c+=1
                
                pre_char = cur_char
                prev=prev[1:]
            if c:
                cur+= str(c)+pre_char
            #print(&#39;out&#39;,cur)
            prev=cur
        
        return prev
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;not hard,but need to pay attention to details.&lt;/p&gt;
&lt;h1 id=&#34;39-combination-sum-medium&#34;&gt;39. Combination Sum (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(tmp,val,start):
            if val&amp;lt;0: return
            if val==0:
                res.append(tmp[:])
                
            for i in range(start,len(candidates)):
                tmp.append(candidates[i])
                bt(tmp,val-candidates[i],i)
                tmp.pop()
                
        bt([],target,0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型的backtracking，可以重复利用元素，所以内循环中 start=i&lt;/p&gt;
&lt;h1 id=&#34;40-combination-sum-ii-medium&#34;&gt;40. Combination Sum II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        res = []
        candidates.sort()
        def bt(tmp,val,start):
            if val&amp;lt;0:
                return
            if val==0:
                res.append(tmp[:])
            
            for i in range(start,len(candidates)):
                if i&amp;gt;start and candidates[i]==candidates[i-1]:continue
                tmp.append(candidates[i])
                bt(tmp,val-candidates[i],i+1)
                tmp.pop()
        bt([],target,0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意去重复，也许得写个backtracking模板总结。&lt;/p&gt;
">Leetcode 2021-11-04</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-03/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;21-merge-two-sorted-lists-easy&#34;&gt;21. Merge Two Sorted Lists （Easy）&lt;/h1&gt;
&lt;p&gt;Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        dummy_head = ListNode(val=&#39;NULL&#39;)
        cur = dummy_head
        while l1 and l2:
            if l1.val&amp;lt;l2.val:
                cur.next = l1
                l1=l1.next
            else:
                cur.next = l2
                l2=l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy_head.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-generate-parentheses-medium&#34;&gt;22. Generate Parentheses (Medium)&lt;/h1&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generateParenthesis(self, n: int) -&amp;gt; List[str]:
        # 1(2)3
        # 1(2)3(4)5   1(2(3)4)5
        if n==1: return [&#39;()&#39;]
        level_result =  [&#39;()&#39;]
        for level in range(n-1):
            level_result_tmp = set()
            for result in level_result:
                for ind in range(len(result)+1):
                    if ind==0:
                        new = &#39;()&#39;+result[ind:]
                    elif ind==len(result):
                        new = result+&#39;()&#39;
                    else:
                        new = result[:ind] +&#39;()&#39;+result[ind:]
                    level_result_tmp.add(new)
            level_result = list(level_result_tmp)
        return level_result
#answer way of writing
class Solution:
    def generateParenthesis(self, n: int) -&amp;gt; List[str]:
        if n==0: return [&amp;quot;&amp;quot;]
        res =[]
        for i in range(n):
            left = self.generateParenthesis(i)
            right  = self.generateParenthesis(n-i-1)
            for l in left:
                for r in right:
                    res.append(&amp;quot;({}){}&amp;quot;.format(l,r))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了递归，逻辑简单，把所有复杂表示简化为（{}）{} 。 自己方法是通过观察逐层增加构建答案。&lt;/p&gt;
&lt;h1 id=&#34;23-merge-k-sorted-lists-hard&#34;&gt;23. Merge k Sorted Lists (hard)&lt;/h1&gt;
&lt;p&gt;You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.&lt;br&gt;
Merge all the linked-lists into one sorted linked-list and return it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self,l1,l2):
        dummy_head = ListNode(val=&#39;NULL&#39;)
        cur = dummy_head
        while l1 and l2:
            if l1.val&amp;lt;l2.val:
                cur.next = l1
                l1=l1.next
            else:
                cur.next = l2
                l2=l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy_head.next
    
    def mergeKLists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]:
        
        # 0 1 2 4 5
        if not lists:
            return None
        
        elif len(lists)==1:
            return lists[0]
        
        elif len(lists)==2:
            return  self.mergeTwoLists(lists[0],lists[1])
        
        else:
            l = len(lists)
            left = self.mergeKLists(lists[:l//2])
            right = self.mergeKLists(lists[l//2:])
            return self.mergeTwoLists(left,right)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经知道merge two了， 如何merge K？递归容易写， iterative如何写(假设已经有merge2 function m2)？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 0  1  2  3  4
 while bitmask &amp;lt; len(list)=5
bitmask = 0001
partner= rank ^ bitmask;   I am sending =  rank &amp;amp; bitmask；
0=&amp;gt;0^1=1                    False
1=&amp;gt;1^1=0                    True
2=&amp;gt;2^1=3                    False
3=&amp;gt;3^1=2                    True
4 =&amp;gt;4^1=5  (no 5)        False
  （01   1   23   3    4）
bitmask = 0010
0=&amp;gt;0^2=2                    False
1=&amp;gt;1^2=3                    False
2=&amp;gt;2^2=0                    True
3=&amp;gt;3^2=1                    True
4=&amp;gt;4^2=6 （no 6）     False
  （0123   13   23   3    4）
bitmask = 0100
0=&amp;gt;0^4 = 4                 False
1=&amp;gt;1^4= 5                  False
2=&amp;gt;2^4=6                   False
3=&amp;gt;3^4=7                   False
4=&amp;gt;4^4=0                   True 
 （01234   13   23   3    4）
或者不用bit方法，开始segmentation 是1，i 收集 i， i+seg信息， 之后segment变为2 ...
k=len(lists)
        seg=1
        while seg&amp;lt;k:
            for i in range(0,k,seg*2):
                if i+seg&amp;lt;k:
                    lists[i]=m2(lists[i],lists[i+seg]) 
            seg*=2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-swap-nodes-in-pairs-medium&#34;&gt;24. Swap Nodes in Pairs (Medium)&lt;/h1&gt;
&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        if not head or (head and not head.next): return head
        
        newhead = head.next
        tmp = newhead.next 
        newhead.next = head
        head.next = self.swapPairs(tmp)
        return newhead
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意边界条件， 至少需要2个才能玩的起来， 如果没有或者只有一个元素，直接return。&lt;/p&gt;
&lt;h1 id=&#34;25-reverse-nodes-in-k-group-hard&#34;&gt;25. Reverse Nodes in k-Group （Hard）&lt;/h1&gt;
&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;
&lt;p&gt;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.&lt;br&gt;
Input: head = [1,2,3,4,5], k = 2&lt;br&gt;
Output: [2,1,4,3,5]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]:
        
        
        cur = head
        counter = 0
        can_reverse = False
        while cur:
            counter+=1
            cur=cur.next
            if counter&amp;gt;=k:
                can_reverse = True
                break
                
        forthnode = cur 
        
        if not can_reverse:
            return head
        
        #can_reverse, let&#39;s reverse k 
        
        cur = head
        pre = None
        c=0
        while cur:
            
            curnext = cur.next
            cur.next = pre
            pre = cur
            cur = curnext
            c+=1
            if c==k:
                break
        
        head.next = self.reverseKGroup(forthnode,k)
        
        return pre 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没想到做出来了， 。。。&lt;/p&gt;
&lt;h1 id=&#34;26-remove-duplicates-from-sorted-array-easy&#34;&gt;26. Remove Duplicates from Sorted Array （Easy）&lt;/h1&gt;
&lt;p&gt;Input: nums = [1,1,2]&lt;br&gt;
Output: 2, nums = [1,2,&lt;em&gt;]&lt;br&gt;
Input: nums = [0,0,1,1,1,2,2,3,3,4]&lt;br&gt;
Output: 5, nums = [0,1,2,3,4,&lt;/em&gt;,&lt;em&gt;,&lt;/em&gt;,&lt;em&gt;,&lt;/em&gt;]&lt;br&gt;
典型的two pointer， array已经sorted，p1 保存将要储存元素位置， p2 扫nums，pre保留之前扫过的数值，如果和pre不同就保存在p1 位置， p1++&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeDuplicates(self, nums: List[int]) -&amp;gt; int:
        pre=None
        i=0
        for j,n in enumerate(nums):
            if n!=pre:
                nums[i]=nums[j]
                i+=1
            pre = n
        return i
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27-remove-element-easy&#34;&gt;27. Remove Element (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeElement(self, nums: List[int], val: int) -&amp;gt; int:
        i=0
        for j,n in enumerate(nums):
            if n!=val:
                nums[i]=n
                i+=1
        return i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in-place 依旧是考察two pointer&lt;/p&gt;
&lt;h1 id=&#34;28-implement-strstr-easy&#34;&gt;28. Implement strStr() （Easy）&lt;/h1&gt;
&lt;p&gt;Implement strStr().&lt;br&gt;
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def strStr(self, haystack: str, needle: str) -&amp;gt; int:
        if len(needle)&amp;gt;len(haystack): return -1
        res = -1
        #0 1 2 3 4
        #        4
        # 5 -1  range(5)
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred29-divide-two-integers-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;29. Divide Two Integers (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
        INT_MIN=-2**31
        INT_MAX=2**31-1
        
        if  not divisor or (dividend == INT_MIN and divisor == -1):
            return INT_MAX
        
        sign= (dividend&amp;gt;0) ^ ( divisor&amp;gt;0)
        dividend, divisor=abs(dividend), abs(divisor)
        
        c=0
        while dividend &amp;gt;= divisor:
            temp = divisor
            level = 1
            while dividend &amp;gt;= (temp&amp;lt;&amp;lt;1):
                level = level&amp;lt;&amp;lt;1
                temp = temp&amp;lt;&amp;lt;1
            
            dividend-=temp
            c+=level
            
        return -c if sign else c

###my solution

class Solution:
    def divide(self, dividend: int, divisor: int) -&amp;gt; int:
        sign = (dividend&amp;gt;0 and divisor&amp;gt;0) or (dividend&amp;lt;0 and divisor&amp;lt;0)
        divident = abs(dividend)
        divisor = abs(divisor)
        res = 0
        while divident&amp;gt;=divisor:
            mask = 1
            tmp = divisor
            while divident &amp;gt;= (tmp&amp;lt;&amp;lt;1):
                mask = mask &amp;lt;&amp;lt; 1
                tmp = tmp &amp;lt;&amp;lt; 1
            res+= mask
            divident-=tmp
        res = res if sign else -res
        if res&amp;gt;= 2**31-1: return 2**31-1
        if res&amp;lt;=-2**31:return -2**31
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-30-substring-with-concatenation-of-all-words-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 30. Substring with Concatenation of All Words (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findSubstring(self, s: str, words: List[str]) -&amp;gt; List[int]:
        if not s or not words: return []
        wc=Counter(words)
        nwords = len(words)
        lword = len(words[0])
        head = list(zip(*words))[0]
        res=[]
        for i in range(len(s)-lword*nwords+1):
            if s[i] in head:
                substring = s[i:i+lword*nwords]
                temp =dict()
                for j in range(nwords):
                    key = substring[j*lword:(j+1)*lword]
                    temp[key]=temp.get(key,0)+1
                if temp==wc:
                    res.append(i)
        return res  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Too late today, 知道应该用Counter_dict做比较但没写出来，思路：扫所有字符， 发现在头字符列表中，测试i:i+lword*nwords的字符范围是不是和Counter_dict一样， 一样就append i。&lt;br&gt;
two pointer + counter dict 应用。&lt;/p&gt;
">Leetcode 2021-11-03</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-02/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;11-container-with-most-water-medium&#34;&gt;11. Container With Most Water (Medium)&lt;/h1&gt;
&lt;p&gt;Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxArea(self, height: List[int]) -&amp;gt; int:
        
        res = 0
        l = 0
        r = len(height)-1
        while l&amp;lt;r:
            res = max(res, (r-l)*min([height[r],height[l]]))
            if height[l]&amp;lt;height[r]:
                l+=1
            else:
                r-=1
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 方法， 计算 left到right之间的water，如果left小于right，得寻找更大的left所以left右移动，反之right左移动。  假如 l --- r 移动中错过了最优解，比如在 l 前，比l 还高， 那这个解已经扫过了，因为r只可能在现在的位置或者更右的位置，所有two pointer可以扫出最优解。&lt;/p&gt;
&lt;h1 id=&#34;12-integer-to-roman-medium&#34;&gt;12. Integer to Roman （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def intToRoman(self, num: int) -&amp;gt; str:
        #finding highest possible symbol, extract the val then loop until 0
        
        dic = {1000:&#39;M&#39;,900:&#39;CM&#39;,500:&#39;D&#39;,400:&#39;CD&#39;,
               100:&#39;C&#39;,90:&#39;XC&#39; ,50:&#39;L&#39;,40:&#39;XL&#39;,10:&#39;X&#39;,
              9:&#39;IX&#39;,5:&#39;V&#39;,4:&#39;IV&#39;,1:&#39;I&#39;}
        
        res = &#39;&#39;
        while num:
            for k,v in dic.items():
                if num-k &amp;gt;=0:
                    num = num-k
                    res+=v
                    break
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13-roman-to-integer-easy&#34;&gt;13. Roman to Integer (easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def romanToInt(self, s: str) -&amp;gt; int:
        # I before V is 4
        #          X is 9
        # X before L is 40
        #          C is 90
        # C before D is 400
        #          M is 900
        
        dic1 = {
&#39;I&#39;:             1,
&#39;V&#39;:             5,
&#39;X&#39;:             10,
&#39;L&#39;:             50,
&#39;C&#39;:             100,
&#39;D&#39;:             500,
&#39;M&#39;:             1000,}
        
        dic2={
            &#39;IV&#39;:4,
            &#39;IX&#39;:9,
            &#39;XL&#39;:40,
            &#39;XC&#39;:90,
            &#39;CD&#39;:400,
            &#39;CM&#39;:900
        }
        res = 0
        while s:
            if len(s)&amp;gt;1 and s[:2] in dic2:
                res += dic2[s[:2]]
                s=s[2:]
            elif s[0] in dic1:
                res += dic1[s[0]]
                s=s[1:]
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-longest-common-prefix-easy&#34;&gt;14. Longest Common Prefix (Easy)&lt;/h1&gt;
&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string &amp;quot;&amp;quot;.&lt;br&gt;
Example 1:&lt;/p&gt;
&lt;p&gt;Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;br&gt;
Output: &amp;quot;fl&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str:
        
        max_len = min([len(s) for s in strs])
        
        i=0
        res = &#39;&#39;
        common_char = None
        while i&amp;lt;max_len:
            for s in strs:
                char = s[i]
                if common_char is None:
                    common_char = char
                else:
                    if common_char!=char:
                        return res
            res+= common_char
            i+=1
            common_char = None
        
        return res
            
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-15-3sum-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 15. 3Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.&lt;br&gt;
Notice that the solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#backtracking
class Solution:
    def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]:
        #-4 -1 -1 0 1 2
        res = []
        def bt(nums,tmp,start):
            
            
            if len(tmp)==3 and sum(tmp)==0:
                res.append(tmp[:])
            for i in range(start,len(nums)):
                if i &amp;gt; start and nums[i] == nums[i-1]: continue
                n = nums[i]
                tmp.append(n)
                bt(nums,tmp,i+1)
                tmp.pop()
        nums.sort()
        bt(nums,[],0)
        return res

#two pointer
class Solution:
    def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]:
        nums.sort()
        res=[]
        for i in range(len(nums)-2):
            cur = nums[i]
            if i-1&amp;gt;=0 and nums[i]==nums[i-1]: continue
            l = i+1
            r = len(nums)-1
            while l&amp;lt;r:
                if nums[l]+nums[r]+cur&amp;lt;0:
                    l+=1
                elif nums[l]+nums[r]+cur&amp;gt;0:
                    r-=1
                else:
                    res.append([cur,nums[l],nums[r]])
                    while l+1&amp;lt;len(nums) and nums[l]==nums[l+1]:
                        l+=1
                    while r-1&amp;gt;=0 and nums[r]==nums[r-1]:
                        r-=1
                    l+=1
                    r-=1
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking在去重复时候卡住了（但正确结果也会TIME LIMIT EXCEED），two pointer？忘记了算法。。。 选定一个target 然后 移动left 和right 注意去重。&lt;/p&gt;
&lt;h1 id=&#34;16-3sum-closest-medium&#34;&gt;16. 3Sum Closest (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.&lt;br&gt;
Return the sum of the three integers.&lt;br&gt;
You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&amp;gt; int:
        
        nums.sort()
        abs_diff = float(&#39;inf&#39;)
        res = float(&#39;inf&#39;)
        for i in range(len(nums)-2):
            cur = nums[i]
            left= i+1
            right = len(nums)-1
            
            while left&amp;lt; right:
                val = cur+nums[left]+nums[right] 
                
                if abs(val-target)&amp;lt; abs_diff:
                        abs_diff = abs(val-target)
                        res = val
                        
                if val&amp;gt;target:
                    right -= 1
                elif val&amp;lt;target:
                    left+=1
                else:
                    left+=1
                    right -=1

        return res
            
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-letter-combinations-of-a-phone-number-medium&#34;&gt;17. Letter Combinations of a Phone Number (Medium)&lt;/h1&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&lt;br&gt;
Example :&lt;br&gt;
Input: digits = &amp;quot;23&amp;quot;&lt;br&gt;
Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def letterCombinations(self, digits: str) -&amp;gt; List[str]:
        
        if not digits:
            return []
        
        dic= {
            2:&#39;abc&#39;,
            3:&#39;def&#39;,
            4:&#39;ghi&#39;,
            5:&#39;jkl&#39;,
            6:&#39;mno&#39;,
            7:&#39;pqrs&#39;,
            8:&#39;tuv&#39;,
            9:&#39;wxyz&#39;
        }
        
        res = []
        l = len(digits)
        
        def bt(digits,tmp,start):
            
            if len(tmp)==l:
                res.append(tmp[:])
            
            for i in range(start,len(digits)):
                key = int(digits[i])
                row = dic[key]
                for char in row:
                    tmp.append(char)
                    bt(digits,tmp,i+1)
                    tmp.pop()
                    
        bt(digits,[],0)
        
        return [&#39;&#39;.join(r) for r in res] if len(res)&amp;gt;0 else []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准的backtracking应用&lt;/p&gt;
&lt;h1 id=&#34;font-colorred18-4sum-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;18. 4Sum （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fourSum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]:
        
        
        nums.sort()
        res = []
        
        for i in range(len(nums)-3):
            if i-1&amp;gt;=0 and nums[i-1] == nums[i]: continue
            for j in range(i+1,len(nums)-2):
                if j-1&amp;gt;i and nums[j-1]==nums[j]:continue
                    
                l=j+1
                r=len(nums)-1
                
                while l&amp;lt;r:
                    
                    if nums[i]+nums[j]+nums[l]+nums[r]&amp;lt;target:
                        l+=1
                    elif  nums[i]+nums[j]+nums[l]+nums[r]&amp;gt;target:
                        r-=1
                    else:
                        res.append([nums[i],nums[j],nums[l],nums[r]])
                        
                        while l+1&amp;lt;len(nums)  and nums[l+1]==nums[l]:
                            l+=1
                        while r-1&amp;gt;=0 and nums[r-1]==nums[r]:
                            r-=1
                        
                        l+=1
                        r-=1
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意去重判断  if i-1&amp;gt;=0 and nums[i-1] == nums[i]: continue，   if j-1&amp;gt;i and nums[j]==nums[j-1]: continue，   while l+1小于len(nums)  and nums[l+1]==nums[l]:   l+=1， while r-1&amp;gt;=0 and nums[r-1]==nums[r]:   r-=1&lt;/p&gt;
&lt;h1 id=&#34;19-remove-nth-node-from-end-of-list-medium&#34;&gt;19. Remove Nth Node From End of List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, remove the nth node from the end of the list and return its head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;)
        dummyhead.next = head
        
        heada = dummyhead
        headb = dummyhead
        
        for i in range(n):
            headb = headb.next
        
        while headb and headb.next:
            
            heada = heada.next
            headb = headb.next
            
        
        heada.next = heada.next.next
        
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-valid-parentheses-easy&#34;&gt;20. Valid Parentheses (Easy)&lt;/h1&gt;
&lt;p&gt;Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&lt;br&gt;
An input string is valid if:&lt;br&gt;
Open brackets must be closed by the same type of brackets.&lt;br&gt;
Open brackets must be closed in the correct order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValid(self, s: str) -&amp;gt; bool:
        # meet （ push in stack 
        # meet  ）pop outof stack
        
        
        
        dic={&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;}
        stack = []
        
        for char in s:
            if char in {&#39;(&#39;,&#39;[&#39;,&#39;{&#39;}:
                stack.append(char)
            else:
                #pop
                if not stack:
                    return False
                
                top_stack = stack.pop()
                if top_stack!= dic[char]: 
                    return False
        
        return not stack


#simply way of writing code
class Solution:
    def isValid(self, s: str) -&amp;gt; bool:
        
        dic = {&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;}
        stack = []
        for e in s:
            if e in dic:
                #pop
                if not stack or stack[-1]!=dic[e]:
                    return False
                stack.pop()
            else:
                stack.append(e)
        return not stack
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-02</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-01/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;1-two-sum-easy&#34;&gt;1. Two Sum （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]:
       dic = dict()
       for i, n in enumerate(nums):
           if target - n in dic:
               return [i, dic[target-n]]
           dic[n] = i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;笨方法，double loop， 找到加和是target。O（N**2）&lt;br&gt;
实际解法，用map存位置，如果target-n 剩余的在之前存过的map里，说明 target-n 和 n 就是要求的结果。&lt;/p&gt;
&lt;h1 id=&#34;2-add-two-numbers-medium&#34;&gt;2. Add Two Numbers （Medium）&lt;/h1&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        result = ListNode(&#39;NULL&#39;)
        head = result
        carry = 0 
        while l1 or l2:
        
            l1val = 0 
            l2val = 0
            if l1:
                l1val = l1.val
                l1 = l1.next
            if l2:
                l2val = l2.val
                l2 = l2.next
            
            val = (l1val+l2val+carry)%10
            carry = (l1val+l2val+carry)//10
            head.next = ListNode(val=val)
            head = head.next
        
        if carry:
            head.next = ListNode(val=carry)
        
        
        return result.next

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经是reverse ordered linked list，所以可以直接对l1,l2的val加和， 但是需要注意carry 以及 l1 or l2 可能在loop到下一位时提前空了， 所以预先定义l1val=0 和l2val=0 有value就overwrite，最后检查是否还有carry， 有就新建个ListNode存carry。返回结果。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred3-longest-substring-without-repeating-characters-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;3. Longest Substring Without Repeating Characters （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, find the length of the longest substring without repeating characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
       #when meet the overlapping char, start = overlapping char pos end =current char pos -1
       #when not meet overlapping char, start stil old start end = current char pos
       
       if s == &#39; &#39;: return 1
       if not s: return 0
       result = 0
       dic = dict()
       start = 0
       for i,char in enumerate(s):
           if (char in dic) and (dic[char]&amp;gt;=start):
               #find a overlapping char
               start = dic[char]
               tmp_result = i-start
               result = max(result,tmp_result)
               start = start + 1
           else:
               # no overlapping
               # 0 1 2
               tmp_result = i-start+1
               result = max(result,tmp_result)
               
               
    
           dic[char] = i
       
       return result

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;花了些时间还是写出答案了，但是时间较长，解题思路：&lt;br&gt;
如果存在已经见过的char，更新结果result = max（result， i-dic[char]），老的已经见过char的下一位是新的起始点， 如果没见过char，则同样更新结果 result = max（result， i-start+1）,&lt;br&gt;
但注意 start 这个位置一直应该是单增的， 所以 有这行判断 if (char in dic) and (dic[char]&amp;gt;=start)   例子： abba，如果没这行判断， start 在遇到第二个a时候会重置回0，明显错误。 根据leetcode 这种解法属于sliding window。&lt;br&gt;
精简写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
        
        dic = dict()
        res = 0
        start = 0
        for i,char in enumerate(s):
            if char in dic:
                start = max(start,dic[char]+1) # a b ..... a  # start=b pos
            res = max(res, i-start+1)
            dic[char] = i
            
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-4-median-of-two-sorted-arrays-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 4. Median of Two Sorted Arrays (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.&lt;br&gt;
The overall run time complexity should be O(log (m+n)).&lt;br&gt;
粗暴解法直接重新排序求中位数，但不满足 O(log (m+n))， 说明用了二分法。&lt;br&gt;
中位数定义是一半的数， 则假设有个分界线 | 同时分开nums1，nums2.&lt;br&gt;
nums1[0] nums1[1] ... nums1[i-1] | nums1[i] ... nums1[m-1]&lt;br&gt;
nums2[0] nums2[1] ... nums2[j-1] | nums2[j] ... nums2[n-1]&lt;br&gt;
median    nums1[i-1] 小于 nums2[j]&lt;br&gt;
nums2[j-1] 小于 nums1[i]&lt;br&gt;
i+j =  (m+n +1)//2&lt;br&gt;
i: 0~m  j = (m+n+1)//2 - i     m小于n&lt;/p&gt;
&lt;p&gt;在 0~m中 二分查找&lt;br&gt;
确定 i&lt;br&gt;
确定 j&lt;br&gt;
知道 | 边界情况来决定是左移还是右移动搜索边界&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:
        # nums1[0] nums1[1] ... nums1[i-1] | nums1[i] ... nums1[m-1]
        # nums2[0] nums2[1] ... nums2[j-1] | nums2[j] ... nums2[n-1]
        
        # median    nums1[i-1]&amp;lt;nums2[j]
        #           nums2[j-1]&amp;lt;nums1[i]
        #           i+j =  (m+n +1)//2
        #           i: 0~m  j = (m+n+1)//2 - i     m&amp;lt;n
        
        #edge cases
        if nums1 and not nums2:
            if len(nums1)%2==1:
                return nums1[len(nums1)//2]
            else:
                return  (nums1[len(nums1)//2] +  nums1[len(nums1)//2-1])/2.0
        
        if nums2 and not nums1:
            if len(nums2)%2==1:
                return nums2[len(nums2)//2]
            else:
                return  (nums2[len(nums2)//2] +  nums2[len(nums2)//2-1])/2.0
        
        m = len(nums1)
        n = len(nums2)
        
        if m&amp;gt;n:
            m,n= n,m
            nums1,nums2=nums2,nums1
        
        left = 0
        right = m
        while left &amp;lt;= right:
            
            i = (left+right)//2
            j = (m+n+1)//2 - i
            
            if i-1&amp;gt;=0 and nums1[i-1] &amp;gt; nums2[j]:
                # i is too large
                right = i-1
            elif i&amp;lt;m and nums2[j-1] &amp;gt; nums1[i]:
                #i is too small
                left = i+1
            else:
                
                if i==0:
                    larget_left=nums2[j-1]
                elif j==0:
                    larget_left = nums1[i-1]
                else:
                    larget_left = max(nums2[j-1],nums1[i-1])
                
                if (m+n)%2==1: return larget_left
                
                
                if i==m:
                    smaller_right = nums2[j]
                elif j==n:
                    smaller_right = nums1[i]
                else:
                    smaller_right = min(nums1[i],nums2[j])
                    
                
                return (larget_left+smaller_right)/2.0
                    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接copy了答案。。。&lt;/p&gt;
&lt;h1 id=&#34;5-longest-palindromic-substring-medium&#34;&gt;5. Longest Palindromic Substring （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s, return the longest palindromic substring in s.&lt;br&gt;
Input: s = &amp;quot;babad&amp;quot;&lt;br&gt;
Output: &amp;quot;bab&amp;quot;&lt;br&gt;
Note: &amp;quot;aba&amp;quot; is also a valid answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; str:
        
        # ith pos, s[i-length]~ s[i] is palindrome 
        #     ith
        #  0 1 2
        #  b a b
        #         or s[i-length-1]~s[i] is palindrome
        
        if not s: return s
        if len(s)==1: return s
        length = 1
        string = s[0]
        
        for i in range(len(s)):
            if (i-length&amp;gt;=0) and (s[i-length:i+1] == s[i-length:i+1][::-1]):
                l = len(s[i-length:i+1])
                if l &amp;gt; length:
                    string = s[i-length:i+1]
                    length = l
                    
            
            if (i-length-1&amp;gt;=0) and s[i-length-1:i+1] == s[i-length-1:i+1][::-1]:
                l = len( s[i-length-1:i+1])
                if  l &amp;gt; length:
                    string = s[i-length-1:i+1]
                    length = l

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-zigzag-conversion-medium&#34;&gt;6. Zigzag Conversion （Medium）&lt;/h1&gt;
&lt;p&gt;The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;p&gt;P   A   H   N&lt;br&gt;
A P L S I I G&lt;br&gt;
Y   I   R&lt;/p&gt;
&lt;p&gt;And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/p&gt;
&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;
&lt;p&gt;string convert(string s, int numRows);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        
        if numRows == 1: return s
        
        #init rows
        res = [[] for _ in range(numRows)]
        #
        direction_down = True
        #y_pos is the next y_pos char sitting at
        y_pos = 0
        #
        for char in s:
            res[y_pos].append(char)
            
            if direction_down:
                y_pos += 1
                if y_pos == numRows:
                    #revert pos
                    direction_down = not direction_down
                    y_pos = numRows-1-1
            else:
                y_pos -= 1
                if y_pos == -1:
                    #revert pos
                    direction_down = not direction_down
                    y_pos = 1
                    
        return &#39;&#39;.join([&#39;&#39;.join(row) for row in res])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意numRows==1 edge case&lt;/p&gt;
&lt;h1 id=&#34;7-reverse-integer-medium&#34;&gt;7. Reverse Integer （Medium）&lt;/h1&gt;
&lt;p&gt;Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2&lt;strong&gt;31, 2&lt;/strong&gt;31 - 1], then return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverse(self, x: int) -&amp;gt; int:
        
        sign = 1 if x&amp;gt;=0 else -1
        x = abs(x)
        res = 0
        while x:
            last_dig = x%10
            res = res*10 + last_dig
            x = x//10
            
        return res*sign if (res*sign&amp;gt;=-2**31 and res*sign&amp;lt;=2**31-1) else 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-string-to-integer-atoi-medium&#34;&gt;8. String to Integer (atoi) （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def myAtoi(self, s: str) -&amp;gt; int:
        sign = 1
        #1)remove leading white space
        while s and s[0] == &#39; &#39;:
            s = s[1:]
        #2) check +/-
        if len(s)&amp;gt;1 and s[0] in {&#39;-&#39;,&#39;+&#39;}:
            s0 = s[0]
            s = s[1:]
            if s0 == &#39;-&#39;:
                sign = -1
        #3) read next until next none-dig/end
        i = 0
        while (i&amp;lt;len(s)) and (s[i] in &#39;0123456789&#39;)   :
            i+=1
        string = s[:i]
        #4) conver to int
        res = int(string) if string else 0
        #5) clamp res
        res = res*sign
        if res&amp;lt;-2**31:
            res = -2**31
        if res&amp;gt; 2**31-1:
            res = 2**31-1
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照题目要求写每个判断，很easy。&lt;/p&gt;
&lt;h1 id=&#34;9-palindrome-number-easy&#34;&gt;9. Palindrome Number （easy）&lt;/h1&gt;
&lt;p&gt;Given an integer x, return true if x is palindrome integer.&lt;/p&gt;
&lt;p&gt;An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPalindrome(self, x: int) -&amp;gt; bool:
        x_backup = x
        if x&amp;lt;0: return False
        res = 0
        while x:
            last_dig = x%10
            res = res*10 + last_dig
            x = x//10
        return res == x_backup
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred10-regular-expression-matching-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;10. Regular Expression Matching (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an input string s and a pattern p, implement regular expression matching with support for &#39;.&#39; and &#39;*&#39; where:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;.&#39; Matches any single character.​​​​
&#39;*&#39; Matches zero or more of the preceding element.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The matching should cover the entire input string (not partial).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        #               .match one
        # p[0] is .   isMatch[s[1:],p[1:]]
        #               *match 0/more p[0]
        # p[1] is *   if * match 0 p[0]
        #               isMatch(s, p[2:])
        #              if * match more p[0]
        #                s[0]==p[0] and isMatch(s[1:],p)
        
        if not p:
            return not s
        
        
        firstmatch = p[0] in {s[0],&#39;.&#39;} if s else False
    
        
        if len(p)&amp;gt;1 and p[1]==&#39;*&#39;:
            #start matching
            return (firstmatch and self.isMatch(s[1:],p)) or self.isMatch(s,p[2:])
        else:
            #normal matching
            return firstmatch and self.isMatch(s[1:],p[1:])
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意判断 p[0] in {s[0],&#39;.&#39;} if s else False  这里的if s不为空。差一点写出来。。。&lt;/p&gt;
">Leetcode 2021-11-01</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/er-fen-fa-mo-ban/"" data-c="
          &lt;p&gt;Binary Search 模板总结&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1&#34;&gt;1&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left &amp;lt;= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid + 1
        else:
            right = mid - 1

    # End Condition: left &amp;gt; right
    return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2&#34;&gt;2&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)
    while left &amp;lt; right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:
        return left
    return -1

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3&#34;&gt;3&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left + 1 &amp;lt; right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid
        else:
            right = mid

    # Post-processing:
    # End Condition: left + 1 == right
    if nums[left] == target: return left
    if nums[right] == target: return right
    return -1
&lt;/code&gt;&lt;/pre&gt;
">二分法模板</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/da-jia-lai-zhao-chi-wen-zi-ban/"" data-c="
          &lt;p&gt;&lt;a href=&#34;/zhaocha&#34;&gt;点击PLAY大家来找茬&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://headhuanglan.github.io/post-images/1635790537514.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;准备写个大家来找茬的文字版，需要找出所有中文的形状相似字符对，已知GBK下33088-65278为中文编码。找个字库文件比如FZLanTingHei-R-GBK.TTF，把字符黑白矩阵转成一个向量，然后算所有文字对的COS相似度就可以了，算法很简单。 开搞！&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import string
from PIL import Image
from PIL import ImageFont
from PIL import ImageDraw
import numpy as np

fobidden_chars = {&#39;■&#39;,&#39;●&#39;,&#39;︱&#39;, &#39;｜&#39;,&#39;▉&#39; ,&#39;▼&#39;,&#39;▊&#39;,&#39;█&#39;, &#39;▇&#39;,&#39;▇&#39;}.union(set(&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;))

def char_to_pixels(text, path=&#39;font.ttf&#39;, fontsize=80):
    font = ImageFont.truetype(path, fontsize) 
    #getsize lead to w, h change for diffrent chars 
    #w, h = font.getsize(text)  
    w, h = fontsize+5, fontsize+5 
    #print(w,h)
    h *= 2
    image = Image.new(&#39;L&#39;, (w, h), 1)  
    draw = ImageDraw.Draw(image)
    draw.text((0, 0), text, font=font) 
    arr = np.asarray(image)
    arr = np.where(arr, 0, 1)
    #arr = arr[(arr != 0).any(axis=1)]
    return arr
    
def display(arr):
    result = np.where(arr, &#39;1&#39;, &#39;0&#39;)
    print(&#39;\n&#39;.join([&#39;&#39;.join(row) for row in result]))

def get_distance(vecs,me):
    #calculate the cos distance of me with other vecs
    dst = (np.dot(vecs, me) / np.linalg.norm(vecs, axis=1) / np.linalg.norm(me))
    return dst
    
def get_closest_chars (li_arrs, vec,li_gbk_chars, number=6):
    dst = get_distance(li_arrs, vec)
    gbk_char_ids = np.argsort(-dst)
    return [li_gbk_chars[ind] for ind in gbk_char_ids[:number] ]
    
if __name__ == &#39;__main__&#39;:
	li_gbk_chars = []
	li_arrs = []
	#GBK 33088-65278
	for ind in range(33088,65278+1):
		try:
		  gbk_char =  bytes.fromhex(str(hex(ind))[2:]).decode(&amp;quot;GBK&amp;quot;)
		  if gbk_char in fobidden_chars: continue
		  arr = char_to_pixels(gbk_char,&#39;./FZLanTingHei-R-GBK.TTF&#39;)
		  #print(gbk_char)
		  #display(arr)
		  li_gbk_chars.append(gbk_char) 
		  #print(gbk_char, arr)
		  li_arrs.append(arr.reshape(-1)) 	
		  #print(arr.reshape(-1).shape)	  	
		except:
			pass
&lt;/code&gt;&lt;/pre&gt;
">大家来找茬(文字版)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/about/"" data-c="
          &lt;p&gt;记录下刷题过程以及一些随机想法~~&lt;/p&gt;
&lt;!-- more --&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>
    
      <input hidden id="copy" />
      <script>
        !function () {
          let times = document.querySelectorAll('.publish-time');
          for (let i = 0; i < times.length; i++) {
            let date = times[i].dataset.t;
            let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
            if (time < 60) {
              str = time + '秒之前';
            } else if (time < 3600) {
              str = Math.floor(time / 60) + '分钟之前';
            } else if (time >= 3600 && time < 86400) {
              str = Math.floor(time / 3600) + '小时之前';
            } else if (time >= 86400 && time < 259200) {
              str = Math.floor(time / 86400) + '天之前';
            } else {
              str = times[i].textContent;
            }
            times[i].textContent = str;
          }
        }();
      </script>

      <script>
        let language = '';
        if (language !== '') {
          let map = new Map();
          if (language === 'en') {
            map.set('search', 'Search');
            map.set('category', 'Categories');
            map.set('article', 'Articles');
            map.set('tag', 'Tags');
            map.set('top', 'Top');
            map.set('publish', 'published');
            map.set('minute', ' minutes');
            map.set('read-more', 'Read More');
            map.set('view', 'View');
            map.set('words', ' words');
            map.set('category-in', 'category in');
            map.set('preview', 'Meta');
            map.set('index', 'Toc');
            map.set('no-archives', "You haven't created yet");
            map.set('archives', " articles in total");
            map.set('cloud-tags', " tags in total");
            map.set('copyright', "Copyright: ");
            map.set('author', "Author: ");
            map.set('link', "Link: ");
            map.set('leave-message', "Leave a message");
            map.set('format', "Links Format");
            map.set('site-name', "Name: ");
            map.set('site-link', "Link: ");
            map.set('site-desc', "Desc: ");
            map.set('stat', " related results, taking ");
            map.set('stat-time', " ms");
            map.set('site-img', "Image: ");
          }

          if (map.size > 0) {
            let lanElems = document.querySelectorAll('.language');
            lanElems.forEach(elem => {
              let lan = elem.dataset.lan, text = map.get(lan);
              if (elem.__proto__ === HTMLInputElement.prototype) {
                elem.placeholder = text
              } else {
                if (elem.dataset.count) {
                  text = elem.dataset.count + text;
                }
                elem.textContent = text;
              }
            })
          }
        }

        window.Clipboard = (function (window, document, navigator) {
          var textArea,
            copy;

          // 判断是不是ios端
          function isOS() {
            return navigator.userAgent.match(/ipad|iphone/i);
          }
          //创建文本元素
          function createTextArea(text) {
            textArea = document.createElement('textArea');
            textArea.value = text;
            textArea.style.width = 0;
            textArea.style.height = 0;
            textArea.clientHeight = 0;
            textArea.clientWidth = 0;
            document.body.appendChild(textArea);
          }
          //选择内容
          function selectText() {
            var range,
              selection;

            if (isOS()) {
              range = document.createRange();
              range.selectNodeContents(textArea);
              selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
              textArea.setSelectionRange(0, 999999);
            } else {
              textArea.select();
            }
          }

          //复制到剪贴板
          function copyToClipboard() {
            try {
              document.execCommand("Copy")
            } catch (err) {
              alert("复制错误！请手动复制！")
            }
            document.body.removeChild(textArea);
          }

          copy = function (text) {
            createTextArea(text);
            selectText();
            copyToClipboard();
          };

          return {
            copy: copy
          };
        })(window, document, navigator);

        function copyCode(e) {
          if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
            let code = e.currentTarget.querySelector('code');
            var text = code.innerText;
            if (e.srcElement.textContent === '复制成功') {
              return;
            }
            e.srcElement.textContent = '复制成功';
            (function (elem) {
              setTimeout(() => {
                if (elem.textContent === '复制成功') {
                  elem.textContent = '复制代码'
                }
              }, 1000);
            })(e.srcElement)
            Clipboard.copy(text);
          }
        }

        let pres = document.querySelectorAll('pre');
        pres.forEach(pre => {
          let code = pre.querySelector('code');
          let copyElem = document.createElement('span');
          copyElem.classList.add('copy-code');
          copyElem.textContent = '复制代码';
          pre.appendChild(copyElem);
          pre.onclick = copyCode
        })

      </script>
      <script src="/media/js/motion.js"></script>

      
        <script
          src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
        <script>
          var scroll = new SmoothScroll('a[href*="#"]', {
            speed: 200
          });
        </script>
        
          
            

                

</html>