<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="L&#39;s Tech Blog">
<meta name="description" content="回忆未来">
<meta name="theme-color" content="#dee2e6">
<title>Leetcode 2021-12-10 | Lan&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1688971234485">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/obsidian.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Leetcode 2021-12-10" />
  <meta name="keywords" content="leetcode" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Lan&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Welcome to Lan&#39;s Blog</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Lan</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>My Coding Journey </p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">60</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">5</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#font-colorred-371-sum-of-two-integers-medium-font"><font color='red'> 371. Sum of Two Integers （Medium） </font></a></li>
<li><a href="#font-colorred-372-super-pow-medium-font"><font color='red'> 372. Super Pow (Medium) </font></a></li>
<li><a href="#font-colorred-373-find-k-pairs-with-smallest-sums-medium-font"><font color='red'> 373. Find K Pairs with Smallest Sums （Medium） </font></a></li>
<li><a href="#374-guess-number-higher-or-lower-easy">374. Guess Number Higher or Lower （Easy）</a></li>
<li><a href="#font-colorred375-guess-number-higher-or-lower-ii-mediumfont"><font color='red'>375. Guess Number Higher or Lower II （Medium）</font></a></li>
<li><a href="#font-colorblue376-wiggle-subsequence-mediumfont"><font color='blue'>376. Wiggle Subsequence （Medium）</font></a></li>
<li><a href="#font-colorred-377-combination-sum-iv-mediumfont"><font color='red'> 377. Combination Sum IV （Medium）</font></a></li>
<li><a href="#font-colorred378-kth-smallest-element-in-a-sorted-matrix-mediumfont"><font color='red'>378. Kth Smallest Element in a Sorted Matrix （Medium）</font></a></li>
<li><a href="#379-design-phone-directory-medium">379. Design Phone Directory （Medium）</a></li>
<li><a href="#font-colorred-380-insert-delete-getrandom-o1-mediumfont"><font color='red'> 380. Insert Delete GetRandom O(1) （Medium）</font></a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://headhuanglan.github.io/post/leetcode-2021-12-10/"> Leetcode 2021-12-10 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-12-08 23:33:22">2021-12-08</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://headhuanglan.github.io/tag/8v2np0s07/">
        <span>leetcode</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >22<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >3770<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <!-- more -->
<h1 id="font-colorred-371-sum-of-two-integers-medium-font"><font color='red'> 371. Sum of Two Integers （Medium） </font></h1>
<p>Given two integers a and b, return the sum of the two integers without using the operators + and -.</p>
<pre><code class="language-python">class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        x, y = abs(a), abs(b)
        # ensure that abs(a) &gt;= abs(b)
        if x &lt; y:
            return self.getSum(b, a)
        
        # abs(a) &gt;= abs(b) --&gt; 
        # a determines the sign
        sign = 1 if a &gt; 0 else -1
        
        if a * b &gt;= 0:
            # sum of two positive integers x + y
            # where x &gt; y
            while y:
                answer = x ^ y
                carry = (x &amp; y) &lt;&lt; 1
                x, y = answer, carry
        else:
            # difference of two integers x - y
            # where x &gt; y
            while y:
                answer = x ^ y
                borrow = ((~x) &amp; y) &lt;&lt; 1
                x, y = answer, borrow
        
        return x * sign
#ANSWER
class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        mask = 0xFFFFFFFF
        
        while b != 0:
            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask
        
        max_int = 0x7FFFFFFF
        return a if a &lt; max_int else ~(a ^ mask)
</code></pre>
<p>bit manipulation 初见感觉是。 但不知道怎么处理。思路，borrow 是 x&amp;y《《1， 没borrow的sum是x^y.</p>
<h1 id="font-colorred-372-super-pow-medium-font"><font color='red'> 372. Super Pow (Medium) </font></h1>
<p>Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<pre><code class="language-python">class Solution:
    def superPow(self, a: int, b: List[int]) -&gt; int:
        base=1337
        def f(a,b):
            res=1
            for i in range(b):
                res*=(a%base)
                res%=base
            return res
        if not b: return 1
        last_digit=b.pop()
        return f(self.superPow(a, b), 10) * f(a, last_digit) % base;
</code></pre>
<p>mod 有结合律交换律吗？。。不太清楚。。。 答案用了1） ab % k = (a%k)(b%k)%k<br>
2）a<sup>b%k=(a%k)</sup>b%k<br>
推到递推关系：<br>
a^1234567 % k = (a^1234560 a^7)%k= ((a^1234560)%k )  ((a^7)%k ) %k<br>
= ((a<sup>123456)</sup>10)%k )  ((a^7)%k ) %k<br>
= ((((a<sup>123456)%k)</sup>10 )% k)  ((a^7)%k ) %k<br>
设 a^b%k=f(a,b)<br>
f(a,1234567)=  f(f(a,123456),10) f(a,7)%k</p>
<h1 id="font-colorred-373-find-k-pairs-with-smallest-sums-medium-font"><font color='red'> 373. Find K Pairs with Smallest Sums （Medium） </font></h1>
<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.<br>
Define a pair (u, v) which consists of one element from the first array and one element from the second array.<br>
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.</p>
<pre><code class="language-python">class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:
        res = []
        if not nums1 or not nums2 or not k:
            return res
        
        heap = []
        visited = set()
        
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        
        visited.add((0, 0))
        
        while len(res) &lt; k and heap:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            
            if i+1 &lt; len(nums1) and (i+1, j) not in visited:
                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))
                visited.add((i+1, j))
            
            if j+1 &lt; len(nums2) and (i, j+1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
                visited.add((i, j+1))
        return res
        
           

</code></pre>
<p>暴力解肯定TLE。。。也想到了是k-way merge sort 但怎么写出来？直接抄答案了，用到了heapq.heappush, heapq.heappop, visited.  先从（0，0）开始push，然后是（1，0）（0，1）， i.e.   (i,j) then (i+1,j),(i,j+1)... 通过visited 去重。<br>
TWO POINTER 思路是错的，因为 0 1 2 |  1 2 3 一旦pointer1 移动到+1位置，所有pointer1之后位置能匹配p2的都会lost。 所以用heapq去做。</p>
<h1 id="374-guess-number-higher-or-lower-easy">374. Guess Number Higher or Lower （Easy）</h1>
<p>We are playing the Guess Game. The game is as follows:<br>
I pick a number from 1 to n. You have to guess which number I picked.<br>
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.<br>
You call a pre-defined API int guess(int num), which returns three possible results:<br>
-1: Your guess is higher than the number I picked (i.e. num &gt; pick).<br>
1: Your guess is lower than the number I picked (i.e. num &lt; pick).<br>
0: your guess is equal to the number I picked (i.e. num == pick).</p>
<pre><code class="language-python"># The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if guess(m)==0:
                return m
            elif guess(m)==1:
                l=m+1
            else:
                r=m-1
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m1=l+(r-l)//3
            m2=r-(r-l)//3
            res1=guess(m1)
            res2=guess(m2)
            if res1==0:
                return m1
            if res2==0:
                return m2
            elif res1&lt;0:
                r=m1-1
            elif res2&gt;0:
                l=m2+1
            else:
                l=m1+1
                r=m2-1
</code></pre>
<p>二分法，三分法。。。</p>
<h1 id="font-colorred375-guess-number-higher-or-lower-ii-mediumfont"><font color='red'>375. Guess Number Higher or Lower II （Medium）</font></h1>
<p>We are playing the Guessing Game. The game will work as follows:<br>
I pick a number between 1 and n.<br>
You guess a number.<br>
If you guess the right number, you win the game.<br>
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.<br>
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.</p>
<pre><code class="language-python">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        #dp[i][j] will save the min cost guessing from i to j
        dp=[[0]*(n+1) for _ in range(n+1)]
         
        def helper(start,end):
            if start&gt;=end: return 0
            if dp[start][end]!=0: return dp[start][end]
            res=float('inf')
            for x in range(start,end+1):
                #try select x,the cost will be
                tmp=x+max(helper(start,x-1),helper(x+1,end))
                res=min(res,tmp)
            dp[start][end]=res
            return res
            
        return helper( 1, n)
    
</code></pre>
<p>没思路。。。看答案，用了DP 关键是DP【i】【j】定义为从i猜到j，花费的最小cost。 那么如果X在i，j之间，选定了X，则cost为 X+max（dp【start】【x-1】，dp【x+1】【end】）因为dp这时候还没值，所以用helper（start，x-1），helper（x+1，end）代替，用max是因为不确定是左面还是右面，只能按照最坏情况准备钱。扫描所有X，然后最小的作为dp【i】【j】cost结果。</p>
<h1 id="font-colorblue376-wiggle-subsequence-mediumfont"><font color='blue'>376. Wiggle Subsequence （Medium）</font></h1>
<p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.<br>
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.<br>
Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<pre><code class="language-python">class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        #dp[i]   the max length of wiggle including nums[i]
        # 1 17 5 10 13 15 10 5 16 8
        # 0 +  - +  +   +  - - +  -
        # 1 2  3 4  4   4  5 5 6  7   
        
        # 1 7 4 9 2 5
        # 0 + - + - +
        #sign[i] the sign of max length of nums[i-1] to nums[i] if increasing 1 decresasing -1
        if len(nums)&lt;2: return len(nums)
        if len(nums)==2 and nums[0]!=nums[1]:return 2
        if len(nums)==2 and nums[0]==nums[1]:return 1
        
        
        count_plus=0
        count_minus=0
        presign=None
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]: continue
            sign= nums[i]-nums[i-1]&gt;0
            if sign:
                #positive
                if presign is None:
                    count_minus=1
                
                if presign!=sign:
                    
                    count_plus=count_minus+1
            else:
                #negtive
                if presign is None:
                    count_plus=1
                if presign!=sign:
                    count_minus=count_plus+1 
            
            presign=sign
        
        return max([1,count_plus,count_minus])

#ANSWER DP O（n*n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[1]*len(nums)
        down=[1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]&gt;nums[j]:
                    up[i]=max(up[i],down[j]+1)
                elif nums[i]&lt;nums[j]:
                    down[i]=max(down[i],up[j]+1)
        return max(up[-1],down[-1])

#ANSWER DP O（n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[0]*len(nums)
        down=[0]*len(nums)
        up[0]=1
        down[0]=1
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up[i]=down[i-1]+1
                down[i]=down[i-1]
            elif nums[i]&lt;nums[i-1]:
                down[i]=up[i-1]+1
                up[i]=up[i-1]
            else:
                down[i]=down[i-1]
                up[i]=up[i-1]
        return max(up[-1],down[-1])

#ANSWER DP O（n） space O（1）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=1
        down=1
       
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up =down +1
           
            elif nums[i]&lt;nums[i-1]:
                down =up +1
              
        return max(up ,down )

#Greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        maxLen=1
        sign=0
        for i in range(1,len(nums)):
            if nums[i]&lt;nums[i-1] and sign!=-1:
                # find a peak nums[i-1] is peak, now it is a decreasing sequence sign=-1
                sign=-1
                maxLen+=1
           
            elif nums[i]&gt;nums[i-1] and sign!=1:
                #valley
                sign=1
                maxLen+=1
              
        return maxLen
         
</code></pre>
<p>本来想用DP做，但发现只用保持 count+ 和 count- 两个计数器就够了。  如果发现增加2元序列，count-加1. 如果发现减小2元序列，count+加1，最后返回count+,count-中最大的就可以了，注意corner case。答案用了多种方法，贴上来开阔思路。第三个方法和我的一样但是写的更简单</p>
<h1 id="font-colorred-377-combination-sum-iv-mediumfont"><font color='red'> 377. Combination Sum IV （Medium）</font></h1>
<p>Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.<br>
The test cases are generated so that the answer can fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        @lru_cache(None)
        def dp(remain):
            if remain==0:
                return 1
            res=0
            for n in nums:
                if remain-n&gt;=0:
                    res+=dp(remain-n)
            return res
        return dp(target)
    
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):

            for num in nums:
                if comb_sum - num &gt;= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
</code></pre>
<p>知道是DP，而且知道DP【i】是能sum到i的组合个数，那么dp【i】=dp【i-n】+dp【n】为啥不对？？ n是添加的最后一个数。而且扫的是所有n in nums。 如果再拆分n，那么会有重复。<br>
思路卡了， 应该是dp【i】+=dp【i-n】   要往组合里加n能到i，那么多出来的组合数就是dp【i-n】。应该求的是和。。。</p>
<h1 id="font-colorred378-kth-smallest-element-in-a-sorted-matrix-mediumfont"><font color='red'>378. Kth Smallest Element in a Sorted Matrix （Medium）</font></h1>
<p>Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.<br>
Note that it is the kth smallest element in the sorted order, not the kth distinct element.<br>
You must find a solution with a memory complexity better than O(n2).</p>
<pre><code class="language-python">
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int:

        n = len(matrix)
        minheap = []
        for r in range(min(k,n)):
            minheap.append((matrix[r][0], r, 0 ))
        heapq.heapify(minheap)
    
        e = None
        while k:
            e, r,c  = heapq.heappop(minheap)
            if c&lt;n-1:
                heapq.heappush(minheap, (matrix[r][c+1], r, c+1))
            k-=1
        return e

#ANSWER II
class Solution:
    
    def countLessEqual(self, matrix, mid, smaller, larger):
        
        count, n = 0, len(matrix)
        row, col = n - 1, 0
        
        while row &gt;= 0 and col &lt; n:
            if matrix[row][col] &gt; mid:
               
                # As matrix[row][col] is bigger than the mid, let's keep track of the
                # smallest number greater than the mid
                larger = min(larger, matrix[row][col])
                row -= 1
                
            else:
                
                # As matrix[row][col] is less than or equal to the mid, let's keep track of the
                # biggest number less than or equal to the mid
                
                smaller = max(smaller, matrix[row][col])
                count += row + 1
                col += 1

        return count, smaller, larger
    
    def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int:
        
        n = len(matrix)
        start, end = matrix[0][0], matrix[n - 1][n - 1]
        while start &lt; end:
            mid =  (end + start) // 2
            smaller, larger = matrix[0][0], matrix[n - 1][n - 1]

            count, smaller, larger = self.countLessEqual(matrix, mid, smaller, larger)

            if count == k:
                return smaller
            if count &lt; k:
                start = larger  # search higher
            else:
                end = smaller  # search lower

        return start

</code></pre>
<p>方法一，用minheap去merge n行rows。<br>
方法二，左上和右下是min max，找到middle，  从左下角开始， 这时候计数多少数字小于middle，如果当前值小于middle，说明当前row以上的col元素都小于middle值，计数，并把当前元素指针向右移动， 并同时计算小于middle值的最大元素，同理， 如果当前元素大于mid， 当前元素指针向上移动，<br>
起码minheap方法应该想出来。</p>
<h1 id="379-design-phone-directory-medium">379. Design Phone Directory （Medium）</h1>
<p>Design a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.<br>
Implement the PhoneDirectory class:<br>
PhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.<br>
int get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.<br>
bool check(int number) Returns true if the slot number is available and false otherwise.<br>
void release(int number) Recycles or releases the slot number.</p>
<pre><code class="language-python">class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n=maxNumbers
        self.avaliable=set([i for i in range(self.n)])
        self.used=set()
        self.current=-1
        

    def get(self) -&gt; int:
        if not self.avaliable: return -1
        while not self.check(self.current):
            self.current= (self.current+1)%self.n
        
        #current in self.avaliable
        # remove from self.avaliable
        self.avaliable.remove(self.current)
        self.used.add(self.current)
        
        res = self.current
        self.current= (self.current+1)%self.n
        return res

    def check(self, number: int) -&gt; bool:
        return  number in self.avaliable 

    def release(self, number: int) -&gt; None:
        self.avaliable.add(number)
        if number in self.used:
            self.used.remove(number)
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)

   def __init__(self, maxNumbers):
        self.available = set(range(maxNumbers))

    def get(self):
        return self.available.pop() if self.available else -1

    def check(self, number):
        return number in self.available

    def release(self, number):
        self.available.add(number)

#MY ANSWER
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n = maxNumbers
        self.circular = list(range(maxNumbers))
        self.head = 0
        

    def get(self) -&gt; int:
        if self.circular[self.head%self.n]!=-1:
            val =  self.circular[self.head%self.n]
            self.circular[self.head%self.n] = -1
            self.head+=1
            return val
        else:
            c=0
            while self.circular[self.head %self.n]==-1:
                c+=1
                self.head+=1
                if c&gt;=self.n:
                    return -1
            val = self.circular[self.head%self.n]
            self.circular[self.head%self.n]=-1
            return val
              
        

    def check(self, number: int) -&gt; bool:
        return self.circular[number]!=-1
        

    def release(self, number: int) -&gt; None:
        self.circular[number] = number
        

#ANSWER PERFECT
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.pos=0
        self.next=[0]*maxNumbers
        for i in range(maxNumbers):
            self.next[i]=(i+1)%maxNumbers
        

    def get(self) -&gt; int:
        if self.next[self.pos]==-1: return -1
        res=self.pos
        self.pos=self.next[self.pos]
        self.next[res]=-1
        return res
        

    def check(self, number: int) -&gt; bool:
        return self.next[number]!=-1

    def release(self, number: int) -&gt; None:
        if self.next[number]!=-1: return
        self.next[number]=self.pos
        self.pos=number
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number) int[] next;
   
  


</code></pre>
<p>答案很完美的写法：Use a linked list to track available numbers, and a pointer to head. If head is still available, get() would return it and move to the next available number. Release would re-add a node to the beginning of the linked list and update head</p>
<h1 id="font-colorred-380-insert-delete-getrandom-o1-mediumfont"><font color='red'> 380. Insert Delete GetRandom O(1) （Medium）</font></h1>
<p>Implement the RandomizedSet class:</p>
<pre><code>RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
</code></pre>
<p>You must implement the functions of the class such that each function works in average O(1) time complexity.</p>
<pre><code class="language-python">from random import choice
class RandomizedSet():
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -&gt; int:
        &quot;&quot;&quot;
        Get a random element from the set.
        &quot;&quot;&quot;
        return choice(self.list)


#MY SOLUTION
class RandomizedSet:

    def __init__(self):
        self.dic = dict()
        self.rev_dic = dict()
        self.i = 0
        self.i_store = set()

    def insert(self, val: int) -&gt; bool:
        if val in self.dic:
            return False
        
        if not self.i_store:
            self.dic[val] = self.i
            self.rev_dic[self.i] = val
            self.i+=1
        else:
            self.dic[val] = self.i_store.pop()
            self.rev_dic[ self.dic[val] ] = val
        return True

    def remove(self, val: int) -&gt; bool:
        if val not in self.dic:
            return False
        
        i = self.dic[val]
        self.i_store.add(i)
        del self.dic[val]
        del self.rev_dic[i]

        return True

    def getRandom(self) -&gt; int:
        
        
        idx = random.randint(0,self.i)
        while idx not in self.rev_dic:
            idx = random.randint(0,self.i)
        
        return self.rev_dic[idx]


</code></pre>
<p>答案思路好，用dic保存插入元素位置方便找出index， 删除时候找出index，然后和list中最后一个元素交换位置，然后pop list del dict【val】</p>
<p>我的思路， 用dic和rev_dic作为存储val - pos的mapping， 当remove时候， 位置会多余出来，存在i_store中， 当插入时候优先用i_store的pos， 这样random找的时候大概率从0到i是连续存储的，这样random一个int就能找到val。</p>
<p>还是答案思路好。</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Lan
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://headhuanglan.github.io/post/leetcode-2021-12-10/" title="Leetcode 2021-12-10">https://headhuanglan.github.io/post/leetcode-2021-12-10/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://headhuanglan.github.io/tag/8v2np0s07/"># leetcode</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Leetcode 2021-12-11" href="https://headhuanglan.github.io/post/leetcode-2021-12-11/">Leetcode 2021-12-11</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Leetcode 2021-12-11" href="https://headhuanglan.github.io/post/leetcode-2021-12-11/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Leetcode 2021-12-09" href="https://headhuanglan.github.io/post/leetcode-2021-12-09/">Leetcode 2021-12-09</a>
        <a class="nav-mobile-next" title="Leetcode 2021-12-09" href="https://headhuanglan.github.io/post/leetcode-2021-12-09/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '05c2f6d6143b092d473b',
    clientSecret: '002d0d8f99a25af450995ef32a26c1eef0041d0d',
    repo: 'headhuanglan.github.io',
    owner: 'headhuanglan',
    admin: ['headhuanglan'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center>
      已运行:<span id="run_time"></span>
      <span class="post-meta-divider">|</span>
      已咕咕:<span id="gugu_time"></span>
    </center>

    总字数:<span id="word_count"></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      function runTime() {
        str = "";
        BirthDay = new Date("November 01,2021");
        today = new Date();
        timeold = today.getTime() - BirthDay.getTime();
        msPerDay = 24 * 60 * 60 * 1000;
        e_daysold = timeold / msPerDay;
        daysold = Math.floor(e_daysold);
        str += daysold + "天";
        return str;
      }
      setInterval(function () {
        $("#run_time").html(runTime());
      }, 1000);
    </script>

    <script>
      function guguTime() {
        str = "";
        guguDay = new Date(document.lastModified);
        today = new Date();
        timeold = today.getTime() - guguDay.getTime();
        msPerDay = 24 * 60 * 60 * 1000;
        e_daysold = timeold / msPerDay;
        daysold = Math.floor(e_daysold);
        str += daysold + "天";
        return str;
      }
      setInterval(function () {
        $("#gugu_time").html(guguTime());
      }, 1000);
    </script>

    <script>
      function site() {

        return 275.6 + "k";
      };

      setInterval(function () {
        $("#word_count").html(site());
      }, 1000);
    </script>

    <div class="copyright">
      Created by
      <a href="https://github.com/headhuanglan" target="_blank">headhuanglan</a>
      ©2021-Present
      <span class="post-meta-divider">|</span>
      Powered By
      <a href="https://github.com/headhuanglan/headhuanglan.github.io" target="_blank">Github</a>
      <span class="post-meta-divider">|</span>
      Theme By
      <a href="https://github.com/theme-next/hexo-theme-next" target="_blank">Next</a>
    </div>
    <div class="poweredby">
      Powered by L
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/gu-piao-mai-mai-wen-ti-zong-jie/"" data-c="
          &lt;p&gt;总结股票买卖问题，所有case都化简为DP处理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;通解&#34;&gt;通解&lt;/h1&gt;
&lt;p&gt;i 代表 ith day&lt;br&gt;
k 代表最大交易次数&lt;br&gt;
0/1 代表手中是否持有股票&lt;/p&gt;
&lt;p&gt;T【i】【k】【0】 代表 在ith day 最多k次交易，ith day结束后不持有股票的 profit&lt;br&gt;
T【i】【k】【1】 代表 在ith day 最多k次交易，ith day结束后持有股票的 profit&lt;/p&gt;
&lt;p&gt;那么base case&lt;br&gt;
T【-1】【k】【0】 = 0   （1）&lt;br&gt;
T【-1】【k】【1】 = -INF （2）&lt;br&gt;
T【i】【0】【0】 = 0 （3）&lt;br&gt;
T【i】【0】【1】= -INF （4）&lt;br&gt;
递推关系&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;/p&gt;
&lt;p&gt;（只有买入操作消耗交易次数）&lt;/p&gt;
&lt;h1 id=&#34;应用&#34;&gt;应用&lt;/h1&gt;
&lt;h2 id=&#34;k1&#34;&gt;K=1&lt;/h2&gt;
&lt;p&gt;T【i】【1】【0】=max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）&lt;br&gt;
T【i】【1】【1】=max（T【i-1】【1】【1】，T【i-1】【0】【0】-prices【i】）&lt;br&gt;
因为（3）&lt;br&gt;
所以&lt;br&gt;
T【i】【1】【0】=max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）&lt;br&gt;
T【i】【1】【1】=max（T【i-1】【1】【1】，-prices【i】）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i10;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kinf&#34;&gt;K=INF&lt;/h2&gt;
&lt;p&gt;K无穷大时候，K和K-1 没区别&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;br&gt;
变成&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int[] prices) {
    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
    
    return T_ik0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;k2&#34;&gt;K=2&lt;/h2&gt;
&lt;p&gt;T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;br&gt;
变成&lt;br&gt;
T【i】【2】【0】 = max（T【i-1】【2】【0】，T【i-1】【2】【1】+prices【i】）&lt;br&gt;
T【i】【2】【1】 = max（T【i-1】【2】【1】，T【i-1】【1】【0】- prices【i】）&lt;br&gt;
T【i】【1】【0】 = max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）&lt;br&gt;
T【i】【1】【1】 = max（T【i-1】【1】【1】，- prices【i】）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i20 = Math.max(T_i20, T_i21 + price);
        T_i21 = Math.max(T_i21, T_i10 - price);
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i20;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;k-是任何数&#34;&gt;K 是任何数&lt;/h2&gt;
&lt;p&gt;T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int k, int[] prices) {
    //如果K 大于等于Prices长度的一半，那么相当于K=INF的情况
    if (k &amp;gt;= prices.length &amp;gt;&amp;gt;&amp;gt; 1) {
        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
        for (int price : prices) {
            int T_ik0_old = T_ik0;
            T_ik0 = Math.max(T_ik0, T_ik1 + price);
            T_ik1 = Math.max(T_ik1, T_ik0_old - price);
        }
    
        return T_ik0;
    }
        
    int[] T_ik0 = new int[k + 1];
    int[] T_ik1 = new int[k + 1];
    Arrays.fill(T_ik1, Integer.MIN_VALUE);
        
    for (int price : prices) {
        for (int j = k; j &amp;gt; 0; j--) {
            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);
            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);
        }
    }
        
    return T_ik0[k];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kinf-with-cooldown&#34;&gt;K=INF with Cooldown&lt;/h2&gt;
&lt;p&gt;T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;br&gt;
当K=INF变为&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入&lt;br&gt;
但是有cooldown时候，变为&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-2】【k】【0】- prices【i】）#买入&lt;br&gt;
因为不能在i天买入如果股票是在i-1天卖出的，所以只能用T【i-2】【k】【0】&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int[] prices) {
    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);
        T_ik0_pre = T_ik0_old;
    }
    
    return T_ik0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kinf-with-transaction-fee&#34;&gt;K=INF with Transaction Fee&lt;/h2&gt;
&lt;p&gt;T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入&lt;br&gt;
当K=INF变为&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入&lt;br&gt;
但是有Fee时候，变为因为fee只在卖出时候付清&lt;br&gt;
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】-fee） #卖出&lt;br&gt;
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int maxProfit(int[] prices, int fee) {
    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        long T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
        
    return (int)T_ik0;
}

&lt;/code&gt;&lt;/pre&gt;
">股票买卖问题总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2023-01-06/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;491-non-decreasing-subsequences-medium&#34;&gt;491. Non-decreasing Subsequences （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findSubsequences(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res = set()
        def bt(start, tmp):
            if len(tmp)&amp;gt;1:
                res.add(tuple(tmp))
            for i in range(start,len(nums)):
                if i-1&amp;gt;= start and nums[i]==nums[i-1]: continue
                if not tmp or nums[i]&amp;gt;=tmp[-1]:
                    tmp.append(nums[i])
                    bt(i+1,tmp)
                    tmp.pop()
    
        bt(0,[])
        return list(res)

#ANSWER 
class Solution:
    def findSubsequences(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res = set()
        def bt(start, tmp):
            
            if start==len(nums):
                if len(tmp)&amp;gt;1:
                    res.add(tuple(tmp))
                return

            
            #add num[i]
            if not tmp or nums[start]&amp;gt;=tmp[-1]:
                tmp.append(nums[start])
                bt(start+1,tmp)
                tmp.pop()
            #not add num[i]
            bt(start+1,tmp)
    
        
        bt(0,[])
        return list(res)
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是个backtracking问题， debug了一会解决了。。答案更好&lt;/p&gt;
&lt;h1 id=&#34;492-construct-the-rectangle-easy&#34;&gt;492. Construct the Rectangle （Easy）&lt;/h1&gt;
&lt;p&gt;A web developer needs to know how to design a web page&#39;s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:&lt;br&gt;
The area of the rectangular web page you designed must equal to the given target area.&lt;br&gt;
The width W should not be larger than the length L, which means L &amp;gt;= W.&lt;br&gt;
The difference between length L and width W should be as small as possible.&lt;br&gt;
Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def constructRectangle(self, area: int) -&amp;gt; List[int]:
        # L*W=area
        # L&amp;gt;=W
        # min(abs(L-W))

        L=res_L=area
        W=res_W=1
        while L&amp;gt;=W:
            W+=1
            L=area//W
            if L&amp;gt;=W and L*W==area:
                res_L=L
                res_W=W
        return res_L,res_W
#ANSWER

class Solution:
    def constructRectangle(self, area: int) -&amp;gt; List[int]:
        # L*W=area
        # L&amp;gt;=W
        # min(abs(L-W))

         
        W=int(math.sqrt(area))
        while area%W!=0:
            W-=1
        return area//W, W

#ANSWER
class Solution:
    def constructRectangle(self, area: int) -&amp;gt; List[int]:
        middle=int(sqrt(area))
        for i in range(middle,0,-1):
            if area%i==0:
                return[int(area/i),i]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-493-reverse-pairs-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 493. Reverse Pairs (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the number of reverse pairs in the array.&lt;br&gt;
A reverse pair is a pair (i, j) where:&lt;br&gt;
0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length and&lt;br&gt;
nums[i] &amp;gt; 2 * nums[j].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reversePairs(self, nums: List[int]) -&amp;gt; int:
        # I   J
        # nI&amp;gt;2nJ
        # scan through nums with B-I-Tree find 2*cur_val+1 ~ end   count sum
        res = 0
        size = len(nums)+1
        bit = [0]*size

        def insert(ind):
            #bit ind from 1
            while ind:
                bit[ind]+=1
                ind -= ind &amp;amp; -ind

        def query(ind):
            res=0
            while ind&amp;lt;size:
                res+=bit[ind]
                ind+=ind&amp;amp;-ind
            return res
        
        def index(arr,val):
            l = bisect.bisect_left(arr,val)
            return l+1 #plus one due to BIT index from 1

        
        copy = nums[:]
        copy.sort()
        res=0
        for n in nums:
            res+=query(index(copy,2*n+1))
            insert(index(copy,n))
        return res        

#ANSWER 2 Merge SORT
class Solution:
    def reversePairs(self, nums: List[int]) -&amp;gt; int:

        def ms(l, r):
            if l &amp;gt;= r: return 0
            mid = (l + r) // 2
            count = ms(l, mid) + ms(mid + 1, r)

            j = mid + 1
            for i in range(l, mid+1):
                while j &amp;lt;= r and nums[i] &amp;gt; 2 * nums[j]:
                    j += 1
                count += j - mid - 1

            nums[l:r+1] = sorted(nums[l:r+1])
            return count

        return ms(0, len(nums) - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初看像用stack做 但是做不出来。。。答案用了BIT。。。。但是不是通常意义的BIT。反了insert 和update function。&lt;br&gt;
For our case, the running total is simply the number of elements encountered during the traversal process. If we stick to the convention above, the running total will be the number of elements smaller than the one at the given index, since the copy array is sorted in ascending order. However, we&#39;d actually like to find the number of elements greater than some value (i.e., twice of the element being scanned), therefore we need to flip the convention. This is what you see inside the search and insert functions: the former traversing towards the end of the bit while the latter towards the root.&lt;br&gt;
MergeSort方法二 。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-494-target-sum-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 494. Target Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array nums and an integer target.&lt;/p&gt;
&lt;p&gt;You want to build an expression out of nums by adding one of the symbols &#39;+&#39; and &#39;-&#39; before each integer in nums and then concatenate all the integers.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, if nums = [2, 1], you can add a &#39;+&#39; before 2 and a &#39;-&#39; before 1 and concatenate them to build the expression &amp;quot;+2-1&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return the number of different expressions that you can build, which evaluates to target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int:
        self.res = 0
        def bt(start,target):
            if start==len(nums):
                if target==0:
                    self.res+=1
                return
            
            # +
            bt(start+1,target-nums[start])
            # - 
            bt(start+1,target+nums[start])
        
        bt(0,target)
        return self.res

#ANSWER
 def findTargetSumWays(self, nums, S):
        if not nums:
            return 0
        dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2}
        for i in range(1, len(nums)):
            tdic = {}
            for d in dic:
                tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)
                tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)
            dic = tdic
        return dic.get(S, 0)  

#ANSWER
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int:
        # dp[i][t]   using upto ith number of target t
        total=sum(nums)
        if abs(target)&amp;gt;total:return 0
        dp=[  [0]*(2*total+1)  for _ in range(len(nums))]
        dp[0][nums[0]+total] = 1
        dp[0][-nums[0]+total] +=1

        for i in range(1,len(nums)):
            for sum_ in range(-total,total+1):
                if dp[i-1][sum_+total]&amp;gt;0:
                    dp[i][sum_+nums[i]+total]+=dp[i-1][sum_+total]
                    dp[i][sum_-nums[i]+total]+=dp[i-1][sum_+total]
        
        return dp[len(nums)-1][target+total]  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接用BT会TLE。。。所以换思路， 试试DP。 因为数字和在-sum到sum之间，offset到0开始需要+sum。&lt;/p&gt;
&lt;h1 id=&#34;495-teemo-attacking-easy&#34;&gt;495. Teemo Attacking （Easy）&lt;/h1&gt;
&lt;p&gt;Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.&lt;/p&gt;
&lt;p&gt;You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.&lt;/p&gt;
&lt;p&gt;Return the total number of seconds that Ashe is poisoned.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&amp;gt; int:
        # input:[1,2] 2
        #     1        2
        #    start     end
        #           start2           new_end3

          
        start = timeSeries[0]
        end = start+duration-1
        res = end-start+1
        for t in timeSeries[1:]:
            new_end = t+duration-1
            if new_end&amp;gt;end:
                start = end+1 if t&amp;lt;=end else t
                end = new_end
                res+=end-start+1
        return res


#ANSER ORZ indeed EZ
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&amp;gt; int:
        n = len(timeSeries)
        if n == 0:
            return 0
        
        total = 0
        for i in range(n - 1):
            total += min(timeSeries[i + 1] - timeSeries[i], duration)
        return total + duration
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;496-next-greater-element-i-easy&#34;&gt;496. Next Greater Element I (Easy)&lt;/h1&gt;
&lt;p&gt;The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.&lt;/p&gt;
&lt;p&gt;You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.&lt;/p&gt;
&lt;p&gt;For each 0 &amp;lt;= i &amp;lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.&lt;/p&gt;
&lt;p&gt;Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        minheap=[ ]
        dic= dict()
        for n in nums2:
            while minheap and minheap[0]&amp;lt;n:
                dic[heappop(minheap)] = n
            heappush(minheap,n)
        
        return [dic.get(n,-1) for n in nums1]

class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        
        dic = dict()
        
        stack = []
        
        while nums2:
            cur = nums2.pop(0)
            if not stack:
                stack.append(cur)
            else:
                while stack and cur&amp;gt;stack[-1]:
                    dic[stack[-1]] = cur
                    stack.pop()
                stack.append(cur)
        
        return [dic.get(e,-1) for e in nums1]
             

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用不着用minheap 直接用stack就好，因为插入时候顺序已经是从左到右满足条件了。&lt;/p&gt;
&lt;h1 id=&#34;497-random-point-in-non-overlapping-rectangles-medium&#34;&gt;497. Random Point in Non-overlapping Rectangles （Medium）&lt;/h1&gt;
&lt;p&gt;You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.&lt;br&gt;
Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.&lt;br&gt;
Note that an integer point is a point that has integer coordinates.&lt;br&gt;
Implement the Solution class:&lt;br&gt;
Solution(int[][] rects) Initializes the object with the given rectangles rects.&lt;br&gt;
int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.area = [ (p[2]-p[0]+1)*(p[3]-p[1]+1) for p in self.rects]
        

    def pick(self) -&amp;gt; List[int]:
        #pick rect based on area
        pick_rect = random.random()*sum(self.area)
        now = 0
        ind = -1
        while now&amp;lt;pick_rect:
            ind+=1
            now+=self.area[ind]
        rect = self.rects[ind]
        return [random.randint(rect[0], rect[2]),random.randint(rect[1], rect[3])]
       
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题有个tricky地方，area为0的rect也是有点包含在里面的，要想包含边上的点需要 （width+1）*（height+1）&lt;/p&gt;
&lt;h1 id=&#34;498-diagonal-traverse-medium&#34;&gt;498. Diagonal Traverse （Medium）&lt;/h1&gt;
&lt;p&gt;iven an m x n matrix mat, return an array of all the elements of the array in a diagonal order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -&amp;gt; List[int]:        
        m=len(mat)
        n=len(mat[0])
        res = []
        ij_sum=0
        for level in range(m+n-1):
            tmp=[]
            for i in range(level+1):
                j = ij_sum-i
                if i&amp;gt;=0 and i&amp;lt;m and j&amp;gt;=0 and j&amp;lt;n:
                    tmp.append(mat[i][j])
            if level%2==0:
                tmp=tmp[::-1]
            res.extend(tmp)
            ij_sum+=1
        return res

class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -&amp;gt; List[int]:        
        dic = defaultdict(list)
        res = []
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                key=i+j
                dic[key].append(mat[i][j])
        

        for key in range(len(mat)-1+len(mat[0])):
            if key%2==0:
                res.extend(dic[key][::-1])
            else:
                res.extend(dic[key])
        return res

#ANSWER
class Solution:
    
    def findDiagonalOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]:
        
        # Check for empty matrices
        if not matrix or not matrix[0]:
            return []
        
        # Variables to track the size of the matrix
        N, M = len(matrix), len(matrix[0])
        
        # The two arrays as explained in the algorithm
        result, intermediate = [], []
        
        # We have to go over all the elements in the first
        # row and the last column to cover all possible diagonals
        for d in range(N + M - 1):
            
            # Clear the intermediate array everytime we start
            # to process another diagonal
            intermediate.clear()
            
            # We need to figure out the &amp;quot;head&amp;quot; of this diagonal
            # The elements in the first row and the last column
            # are the respective heads.
            r, c = 0 if d &amp;lt; M else d - M + 1, d if d &amp;lt; M else M - 1
            
            # Iterate until one of the indices goes out of scope
            # Take note of the index math to go down the diagonal
            while r &amp;lt; N and c &amp;gt; -1:
                intermediate.append(matrix[r][c])
                r += 1
                c -= 1
            
            # Reverse even numbered diagonals. The
            # article says we have to reverse odd 
            # numbered articles but here, the numbering
            # is starting from 0 :P
            if d % 2 == 0:
                result.extend(intermediate[::-1])
            else:
                result.extend(intermediate)
        return result        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试TLE，用dic后满足条件。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-499-the-maze-iii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 499. The Maze III （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won&#39;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.&lt;/p&gt;
&lt;p&gt;Given the m x n maze, the ball&#39;s position ball and the hole&#39;s position hole, where ball = [ballrow, ballcol] and hole = [holerow, holecol], return a string instructions of all the instructions that the ball should follow to drop in the hole with the shortest distance possible. If there are multiple valid instructions, return the lexicographically minimum one. If the ball can&#39;t drop in the hole, return &amp;quot;impossible&amp;quot;.&lt;/p&gt;
&lt;p&gt;If there is a way for the ball to drop in the hole, the answer instructions should contain the characters &#39;u&#39; (i.e., up), &#39;d&#39; (i.e., down), &#39;l&#39; (i.e., left), and &#39;r&#39; (i.e., right).&lt;/p&gt;
&lt;p&gt;The distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).&lt;/p&gt;
&lt;p&gt;You may assume that the borders of the maze are all walls&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#ANSWER
class Solution:
    def findShortestWay(self, maze, ball, hole):
        m, n, q, stopped = len(maze), len(maze[0]), [(0, &amp;quot;&amp;quot;, ball[0], ball[1])], {(ball[0], ball[1]): [0, &amp;quot;&amp;quot;]}
        while q:
            dist, pattern, x, y = heapq.heappop(q)
            if [x, y] == hole:
                return pattern
            for i, j, p in ((-1, 0, &amp;quot;u&amp;quot;), (1, 0, &amp;quot;d&amp;quot;), (0, -1, &amp;quot;l&amp;quot;), (0, 1, &amp;quot;r&amp;quot;)):
                newX, newY, d = x, y, 0
                while 0 &amp;lt;= newX + i &amp;lt; m and 0 &amp;lt;= newY + j &amp;lt; n and maze[newX + i][newY + j] != 1:
                    newX += i
                    newY += j
                    d += 1
                    if [newX, newY] == hole:
                        break
                if (newX, newY) not in stopped or [dist + d, pattern + p] &amp;lt; stopped[(newX, newY)]:
                    stopped[(newX, newY)] = [dist + d, pattern + p]
                    heapq.heappush(q, (dist + d, pattern + p, newX, newY))
        return &amp;quot;impossible&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BFS 写了答案能过60/64 个test case。。。不知道哪里还有BUG。看答案。难点在，循环queue时候，这个queue不是普通的queue，是minheap。 这样就能取出距离最小的而且lexcially最小的next node做计算。&lt;/p&gt;
&lt;h1 id=&#34;500-keyboard-row-easy&#34;&gt;500. Keyboard Row （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.&lt;br&gt;
In the American keyboard:&lt;br&gt;
the first row consists of the characters &amp;quot;qwertyuiop&amp;quot;,&lt;br&gt;
the second row consists of the characters &amp;quot;asdfghjkl&amp;quot;, and&lt;br&gt;
the third row consists of the characters &amp;quot;zxcvbnm&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findWords(self, words: List[str]) -&amp;gt; List[str]:
        s1 = set(&amp;quot;qwertyuiopQWERTYUIOP&amp;quot;)
        s2=set(&amp;quot;asdfghjklASDFGHJKL&amp;quot;)
        s3=set(&amp;quot;zxcvbnmZXCVBNM&amp;quot;)
        
        return [w for w in words if any(set(w)&amp;amp;s==set(w) for s in [s1,s2,s3]  )  ]

&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2023-01-06</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/sum-xiang-guan-shu-ju-jie-gou-zong-jie/"" data-c="
          &lt;p&gt;BIT ， SEGMENT TREE， UnionFind&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;binary-indexed-tree&#34;&gt;Binary Indexed Tree&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BIT:
    def __init__(self,n):
        self.size = n
        self.bit = [0]*(self.size+1)
    
    def update(self,index,val):
         #index in BIT is 1 more than original index
        while index&amp;lt;=self.size:
            self.bit[index]+=val
            index += index&amp;amp;-index
    def query(self,index):
         #index in BIT is 1 more than original index
        res = 0 
        while index&amp;gt;0:
            res+=self.bit[index]
            index-= index&amp;amp;-index
        return res

#2D
class BIT:
    def __init__(self,m,n):
        self.m= m
        self.n = n
        self.bit = [[0]*(self.n+1) for _ in range(self.m+1)]
    
    def update(self,r,c,val):
        i = r
        while i&amp;lt;=self.m:
            j = c
            while j&amp;lt;=self.n:
                self.bit[i][j]+=val
                j+= j&amp;amp;-j
            i+= i&amp;amp;-i

    def query(self,r,c):
        res = 0
        i=r
        while i&amp;gt;0:
            j = c
            while j&amp;gt;0:
                res+=self.bit[i][j]
                j-= j&amp;amp;-j
            i-= i&amp;amp;-i
        return res
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update / \ query 注意index from 1&lt;/p&gt;
&lt;h1 id=&#34;segment-tree&#34;&gt;Segment Tree&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ST:
    def __init__(self,n):
        self.size = n
        self.tree = [0]*(2*self.size)
    
    def update(self,ind,val):
        #       1
        #     2   3
        #    4 5 6 7
        #  self.tree is:
        #  @ 1 2 3 4 5 6 7
        
        #offset index by size, the leave save value node save summation
        ind+=self.size
        self.tree[ind] += val
        while ind&amp;gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&amp;gt;0:
                self.tree[ind//2]=self.tree[left]+self.tree[right]
            ind //=2


    def query(self,left,right):
        left+=self.size
        right+=self.size
        res=0
        while left&amp;lt;=right:
            if right%2==0:
                res+=self.tree[right]
                right-=1
            if left%2==1:
                res+=self.tree[left]
                left+=1
            left//=2
            right//=2
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原始值保存在叶子节点中，所以ind是要加slef.size的&lt;/p&gt;
&lt;h1 id=&#34;unionfind&#34;&gt;UnionFind&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;     class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&amp;lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&amp;gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1

&lt;/code&gt;&lt;/pre&gt;
">SUM相关数据结构总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2023-01-05/"" data-c="
          &lt;p&gt;没想到都拖到2023年了 还没上500&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-481-magical-string-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 481. Magical String （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A magical string s consists of only &#39;1&#39; and &#39;2&#39; and obeys the following rules:&lt;br&gt;
The string s is magical because concatenating the number of contiguous occurrences of characters &#39;1&#39; and &#39;2&#39; generates the string s itself.&lt;br&gt;
The first few elements of s is s = &amp;quot;1221121221221121122……&amp;quot;. If we group the consecutive 1&#39;s and 2&#39;s in s, it will be &amp;quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&amp;quot; and the occurrences of 1&#39;s or 2&#39;s in each group are &amp;quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&amp;quot;. You can see that the occurrence sequence is s itself.&lt;br&gt;
Given an integer n, return the number of 1&#39;s in the first n number in the magical string s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def magicalString(self, n: int) -&amp;gt; int:
        #          #
        #     1 2  2
        #            #
     
        if n &amp;lt;= 0: return 0
        if n &amp;lt;= 3: return 1

        nums = [0]*n
        nums[0] = 1
        nums[1] = 2
        nums[2] = 2
        countIdx = 2 #the count of next number
        num = 1 # next number to fill
        pos = 3 # empty position we will fill
        res = 1 # the number of 1&#39;s

        while pos &amp;lt; n:
            count = nums[countIdx]
            countIdx+=1
            
            while count &amp;gt; 0 and pos &amp;lt; n:
                res += int(num == 1) 
                nums[pos] = num
                pos+=1
                count-=1
            
            num = 3 - num
        

        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;理解题目意思后，思路还是很清楚的。&lt;/p&gt;
&lt;h1 id=&#34;482-license-key-formatting-easy&#34;&gt;482. License Key Formatting （Easy）&lt;/h1&gt;
&lt;p&gt;You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.&lt;br&gt;
We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -&amp;gt; str:
        if set(s)=={&#39;-&#39;}: return &#39;&#39;
        li=[]
        for char in s:
            if char!=&#39;-&#39; and (char.isalpha or char.isnumeric):
                li.append(char.upper())
        res=[]
        c=0
        while li:
            res.append(li.pop())
            c+=1
            if c==k:
                c=0
                res.append(&#39;-&#39;)
        
        
        return (&#39;&#39;.join(res[::-1])) if &#39;&#39;.join(res[::-1])[0]!=&#39;-&#39; else (&#39;&#39;.join(res[::-1]))[1:]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到chars后从后往前填充。res.append(li.pop())&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-483-smallest-good-base-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 483. Smallest Good Base （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n represented as a string, return the smallest good base of n.&lt;br&gt;
We call k &amp;gt;= 2 a good base of n, if all digits of n base k are 1&#39;s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
class Solution(object):
    def smallestGoodBase(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: str
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        n = int(n)
        max_m = int(math.log(n,2)) # Refer [7]
        for m in range(max_m,1,-1):
            k = int(n**m**-1)  # Refer [6]
            if (k**(m+1)-1)//(k-1) == n:
                # Refer [3]
                return str(k)
        
        return str(n-1)  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始想法是写个function(base,order)但得binary search 2个参数。。感觉不可行。&lt;br&gt;
答案很精彩 完全是数学问题&lt;br&gt;
For a given m &amp;gt; 1:&lt;br&gt;
From n = k^m + ... + k^0 &amp;gt; k^m you get k &amp;lt; m-th root of n&lt;br&gt;
From n = k^m + ... + k^0 &amp;lt; (k+1)^m (see binomial theorem) you also get k+1 &amp;gt; m-th root of n.&lt;/p&gt;
&lt;p&gt;So k &amp;lt; m-th root of n &amp;lt; k+1. Thus ⌊m-th root of n⌋ is the only candidate that needs to be tested. As&lt;/p&gt;
&lt;p&gt;From given information, we can say one thing- Numbers will be of form-&lt;/p&gt;
&lt;p&gt;n = k^m + k^(m-1) + ... + k + 1&lt;br&gt;
=&amp;gt; n-1 = k^m + k^(m-1) + ... + k&lt;br&gt;
=&amp;gt; n-1 = k (k^(m-1) + k^(m-2) + ... + k + 1) ...... [1]&lt;/p&gt;
&lt;p&gt;Also, from n = k^m + k^(m-1) + ... + k + 1, we can say,&lt;br&gt;
n-k^m = k^(m-1) + k^(m-2) + ... + k + 1 ...... [2]&lt;/p&gt;
&lt;p&gt;from [1] and [2],&lt;/p&gt;
&lt;p&gt;n-1 = k (n - k^m)&lt;br&gt;
=&amp;gt;k^(m+1) = nk - n + 1&lt;/p&gt;
&lt;p&gt;if you shuffle sides you will end up getting following form,&lt;/p&gt;
&lt;p&gt;(k^(m+1) - 1)/(k - 1) = n .... [3]&lt;/p&gt;
&lt;p&gt;Also from [1] note that, (n - 1) must be divisible by k.&lt;/p&gt;
&lt;p&gt;We know that, n = k^m + k^(m-1) + ... + k + 1&lt;/p&gt;
&lt;p&gt;=&amp;gt; n &amp;gt; k^m&lt;br&gt;
=&amp;gt; m-th root of n &amp;gt; k .... [4]&lt;/p&gt;
&lt;p&gt;With inputs from @StefanPochmann we can also say, from binomial thorem, n = k^m + ... + 1 &amp;lt; (k+1)^m .... [5]&lt;br&gt;
Therefore, k+1 &amp;gt; m-th root of n &amp;gt; k. .... from [4] and [5]&lt;br&gt;
Thus ⌊m-th root of n⌋ is the only candidate that needs to be tested. [6]&lt;br&gt;
So our number should satisfy this equation where k will be our base and m will be (number of 1s - 1)&lt;br&gt;
This brings us to the search problem where we need to find k and m.&lt;br&gt;
Linear search from 1 to n does not work. it gives us TLE. So it leaves us with performing some optimization on search space.&lt;br&gt;
From [6] we know that the only candidate that needs to be tested is, ⌊m-th root of n⌋&lt;br&gt;
We also know that the smallest base is 2 so we can find our m must be between 2 and log2n else m is (n-1) [7]&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-484-find-permutation-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 484. Find Permutation （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A permutation perm of n integers of all the integers in the range [1, n] can be represented as a string s of length n - 1 where:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s[i] == &#39;I&#39; if perm[i] &amp;lt; perm[i + 1], and
s[i] == &#39;D&#39; if perm[i] &amp;gt; perm[i + 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given a string s, reconstruct the lexicographically smallest permutation perm and return it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findPermutation(self, s: str) -&amp;gt; List[int]:
        stack = []
        res = []
        n=len(s)+1
       
        for i,ch in enumerate(s):
            idx = i+1
            if ch== &#39;I&#39;:
                stack.append(idx)
                while stack:
                    res.append(stack.pop())
            else:
                stack.append(idx)
        
        stack.append(n)
        while stack:
            res.append(stack.pop())
        return res 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 思路和答案是一样的  但就是写不出来。。。&lt;/p&gt;
&lt;h1 id=&#34;485-max-consecutive-ones-easy&#34;&gt;485. Max Consecutive Ones （Easy）&lt;/h1&gt;
&lt;p&gt;Given a binary array nums, return the maximum number of consecutive 1&#39;s in the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -&amp;gt; int:
        c=0
        res = 0
        for n in nums:
            if n==1:
                c+=1
            else:
                c=0            
            res = max(res,c)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-486-predict-the-winner-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 486. Predict the Winner （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.&lt;/p&gt;
&lt;p&gt;Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.&lt;/p&gt;
&lt;p&gt;Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def PredictTheWinner(self, nums: List[int]) -&amp;gt; bool:
        #[a b c d]   
        # 0 0 0 0
        # 0 0 0 0                      
        # 0 0 0 0                         
        # 0 0 0 0

        # dp[i,j] is i to j score.
        # dp[i,j] = max(nums[i]-dp[i+1,j]  , nums[j]-dp[i,j-1]   )

        n=len(nums)
       
        @lru_cache(None)
        def score(i,j):
            if i==j: return nums[i]
            left = nums[i]-score(i+1,j)  
            right = nums[j]-score(i,j-1)  
            return max(left,right)
        
        return score(0,n-1) &amp;gt;=0
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dp can be tricky to write&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean PredictTheWinner(int[] nums) {
    int n = nums.length;
    int[][] dp = new int[n][n];
    for (int i = 0; i &amp;lt; n; i++) { 
             dp[i][i] = nums[i]; 
             }
    for (int len = 1; len &amp;lt; n; len++) {
        for (int i = 0; i &amp;lt; n - len; i++) {
            int j = i + len;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] &amp;gt;= 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-487-max-consecutive-ones-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 487. Max Consecutive Ones II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a binary array nums, return the maximum number of consecutive 1&#39;s in the array if you can flip at most one 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        # previous and current length of consecutive 1 
        pre, curr, maxlen = -1, 0, 0
        for n in nums:
            if n == 0:
                pre, curr = curr, 0
            else:
                curr += 1
            maxlen = max(maxlen, pre + 1 + curr )
        
        return maxlen

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道是sliding window但写不出来。。。store the length of previous and current consecutive 1&#39;s (separated by the last 0) as pre and curr , respectively.&lt;br&gt;
Whenever we get a new number, update these two variables accordingly. The consecutive length would be pre + 1 + curr, where the 1 is a zero that got flipped to 1. (note that pre is initialized to -1, meaning that we haven&#39;t seen any 0 yet)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0, zero = 0, k = 1; // flip at most k zero
        for (int l = 0, h = 0; h &amp;lt; nums.length; h++) {
            if (nums[h] == 0)                                           
                zero++;
            while (zero &amp;gt; k)
                if (nums[l++] == 0)
                    zero--;                                     
            max = Math.max(max, h - l + 1);
        }                                                               
        return max;             
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;flip k 的通解&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-488-zuma-game-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 488. Zuma Game （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are playing a variation of the game Zuma.&lt;br&gt;
In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red &#39;R&#39;, yellow &#39;Y&#39;, blue &#39;B&#39;, green &#39;G&#39;, or white &#39;W&#39;. You also have several colored balls in your hand.&lt;br&gt;
Your goal is to clear all of the balls from the board. On each turn:&lt;br&gt;
Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.&lt;br&gt;
If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.&lt;br&gt;
If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.&lt;br&gt;
If there are no more balls on the board, then you win the game.&lt;br&gt;
Repeat this process until you either win or do not have any more balls in your hand.&lt;br&gt;
Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMinStep(self, board: str, hand: str) -&amp;gt; int:

        @lru_cache(None)
        def clean(board):
            stack = []
            for b in board:
                if stack and stack[-1][0] != b and stack[-1][1] &amp;gt;= 3:
                    stack.pop()
                if not stack or stack[-1][0] != b:
                    stack += [b, 1],
                else:
                    stack[-1][1] += 1
            if stack and stack[-1][1] &amp;gt;= 3:
                stack.pop()
            return &#39;&#39;.join([a*b for a,b in stack])

        @lru_cache(None)
        def dfs(board, hand):
            if not board:
                return 0
            if not hand:
                return float(&#39;inf&#39;)
            m = len(board)
            ans = float(&#39;inf&#39;)
            for j, b in enumerate(hand):
                new_hand = hand[:j] + hand[j+1:]
                for i in range(m + 1):
                    new_board = clean(board[:i] + b + board[i:])
                    ans = min(ans, 1 + dfs(new_board, new_hand))
            return ans
        
        ans = dfs(board, hand)
        return ans if ans &amp;lt; float(&#39;inf&#39;) else -1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TLE backtracking dfs, bfs with optimize pass&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMinStep(self, board: str, hand: str) -&amp;gt; int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i &amp;lt; 0:
                return s
            
            left = right = i
            while left &amp;gt; 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 &amp;lt; len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length &amp;gt;= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = &amp;quot;&amp;quot;.join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j &amp;gt; 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i &amp;gt; 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i &amp;lt; len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0&amp;lt;i&amp;lt;len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs 优化有意思，1）board 过到i位置相同情况下，ball之间见过的直接skip， 2）在board 【i-1】==ball时候skip，相当于不在末尾放ball。 3）board【i】=hand【j】放置ball容易理解 4）发现之前boad 已经连续2个了board【i-1】==board【i】，可以随便放置ball碰运气。但是不要放置和i一样的ball这样违背了rule2不在末尾放球的规定.&lt;/p&gt;
&lt;h1 id=&#34;489-robot-room-cleaner-hard&#34;&gt;489. Robot Room Cleaner (hard)&lt;/h1&gt;
&lt;p&gt;You are controlling a robot that is located somewhere in a room. The room is modeled as an m x n binary grid where 0 represents a wall and 1 represents an empty slot.&lt;/p&gt;
&lt;p&gt;The robot starts at an unknown location in the room that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API Robot.&lt;/p&gt;
&lt;p&gt;You are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. Each turn is 90 degrees.&lt;/p&gt;
&lt;p&gt;When the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.&lt;/p&gt;
&lt;p&gt;Design an algorithm to clean the entire room using the following APIs:&lt;/p&gt;
&lt;p&gt;interface Robot {&lt;br&gt;
// returns true if next cell is open and robot moves into the cell.&lt;br&gt;
// returns false if next cell is obstacle and robot stays on the current cell.&lt;br&gt;
boolean move();&lt;/p&gt;
&lt;p&gt;// Robot will stay on the same cell after calling turnLeft/turnRight.&lt;br&gt;
// Each turn will be 90 degrees.&lt;br&gt;
void turnLeft();&lt;br&gt;
void turnRight();&lt;/p&gt;
&lt;p&gt;// Clean the current cell.&lt;br&gt;
void clean();&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;Note that the initial direction of the robot will be facing up. You can assume all four edges of the grid are all surrounded by a wall.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the robot&#39;s control interface.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class Robot:
#    def move(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        Returns true if the cell in front is open and robot moves into the cell.
#        Returns false if the cell in front is blocked and robot stays in the current cell.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def turnLeft(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def turnRight(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def clean(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        Clean the current cell.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;

class Solution:
    def cleanRoom(self, robot):
        &amp;quot;&amp;quot;&amp;quot;
        :type robot: Robot
        :rtype: None
        &amp;quot;&amp;quot;&amp;quot;
        
        visited=set()
        degree = 90
        #degree direction dic
        dic = {&#39;u&#39;:90,&#39;r&#39;:0,&#39;l&#39;:180,&#39;d&#39;:270}
        dix = {&#39;u&#39;:0,&#39;r&#39;:1,&#39;l&#39;:-1,&#39;d&#39;:0}
        diy = {&#39;u&#39;:1,&#39;r&#39;:0,&#39;l&#39;:0,&#39;d&#39;:-1}
        drev = {&#39;u&#39;:&#39;d&#39;,&#39;d&#39;:&#39;u&#39;,&#39;l&#39;:&#39;r&#39;,&#39;r&#39;:&#39;l&#39;}
        #assume init is up
        def move(dir):
            nonlocal degree
            delta = degree - dic[dir]
            if delta&amp;gt;0:
                for _ in range(delta//90):
                    robot.turnRight()
            if delta&amp;lt;0:
                for _ in range(-delta//90):
                    robot.turnLeft()
            degree = dic[dir]
            return robot.move()
        
        def dfs(x,y):
            if (x,y) in visited: return
            visited.add((x,y))
            robot.clean()
            for dir in [&#39;u&#39;,&#39;d&#39;,&#39;l&#39;,&#39;r&#39;]:
                new_x = x+dix[dir]
                new_y = y+diy[dir]
                if (new_x,new_y) not in visited:
                    if move(dir):
                        dfs(new_x,new_y)
                        move(drev[dir])
                        
        
        dfs(0,0)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking... nothing hard&lt;/p&gt;
&lt;h1 id=&#34;490-the-maze-medium&#34;&gt;490. The Maze (Medium)&lt;/h1&gt;
&lt;p&gt;There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won&#39;t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.&lt;br&gt;
Given the m x n maze, the ball&#39;s start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return true if the ball can stop at the destination, otherwise return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -&amp;gt; bool:
        #    d  r l  u
        dx = [0,1,-1,0]
        dy = [1,0,0,-1]
        m=len(maze)
        n=len(maze[0])
        if start==destination: return True
        visited = set()
        self.res = False
        def dfs(x,y):
            visited.add((x,y))
            if [x,y]==destination:
                self.res = True
            
            for i in range(4):
                new_x = x+dx[i]
                new_y = y+dy[i]
                while new_x&amp;gt;=0 and new_x&amp;lt;m and new_y&amp;gt;=0 and new_y&amp;lt;n and maze[new_x][new_y]==0:
                    new_x+=dx[i]
                    new_y+=dy[i]
                
                new_x -= dx[i]
                new_y -= dy[i]
                if (new_x,new_y) not in visited:
                    dfs(new_x,new_y) 
            
        dfs(*start)
        return self.res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有点卡，卡在了dfs 不能直接return true or false， 设置了个self.res捕捉结果。还能用BFS。。&lt;/p&gt;
">Leetcode 2023-01-05</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/zi-zhuang-kidd-1022-bu-tong-pin-pai-zi-dan-group-fen-xi/"" data-c="
          &lt;p&gt;找到适合首把22LR定制枪的最佳子弹&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;器材&#34;&gt;器材&lt;/h1&gt;
&lt;h2 id=&#34;枪&#34;&gt;枪&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KIDD Bolt&lt;/li&gt;
&lt;li&gt;KIDD Two Stage Trigger （Pull Weight: 8oz/8oz=1lb ）&lt;/li&gt;
&lt;li&gt;KIDD Bolt Handle Charging Assembly With Guide Rod &amp;amp; Springs&lt;/li&gt;
&lt;li&gt;KIDD Aftermarket .22LR Receiver Classic Slip Fit Model&lt;/li&gt;
&lt;li&gt;KIDD 22LR Match Stainless Steel Rifle Bull Barrel 20&#39;&#39; Bead Blasted&lt;/li&gt;
&lt;li&gt;Boyds At-One Applejack Stock&lt;/li&gt;
&lt;li&gt;Vortex Optics Diamondback Tactical 6-24x50 First Focal Plane Riflescopes - EBR-2C&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;脚架及支撑&#34;&gt;脚架及支撑&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Harris Engineering S-BRM Hinged Base 6 - 9-Inch BiPod&lt;/li&gt;
&lt;li&gt;Caldwell Deadshot Filled, Rear Shooting Bag&lt;/li&gt;
&lt;li&gt;MIM Mfg S Lock for S Series Harris Bipod&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;弹药&#34;&gt;弹药&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Speed of Sound (30 Celsius) = 1145 fps&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CCI Standard Velocity  （1070fps）&lt;/li&gt;
&lt;li&gt;Eley Semi-Auto Benchrest Precision （1060 fps）&lt;/li&gt;
&lt;li&gt;Norma TAC-22  （1083 fps）&lt;/li&gt;
&lt;li&gt;Eley Match（1085 fps）&lt;/li&gt;
&lt;li&gt;SK Pistol Match Special（955 fps）&lt;/li&gt;
&lt;li&gt;SK Rifle Match（955 fps）&lt;/li&gt;
&lt;li&gt;Blazer Ammunition 22 Long Rifle 40 Grain Lead Round Nose （1235 fps）&lt;/li&gt;
&lt;li&gt;Lapua Pistol King （950 fps）&lt;/li&gt;
&lt;li&gt;Aguila Super Maximum （1750 fps）&lt;/li&gt;
&lt;li&gt;CCI MiniMag (1235 fps)&lt;/li&gt;
&lt;li&gt;Federal AutoMatch 325 (1200 fps)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;气温&#34;&gt;气温&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;30度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;风力风向&#34;&gt;风力风向&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;微风&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;射击距离&#34;&gt;射击距离&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;55码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实验方式&#34;&gt;实验方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最左边的标定靶纸调整瞄准镜的高度和风向，20发。&lt;/li&gt;
&lt;li&gt;每5发一个group射击5次&lt;/li&gt;
&lt;li&gt;每完成一种子弹射击用枪绳清理枪管2次，清理bolt和breechface 。等待枪管冷却。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的射击实验的 Takedown Screw 10 inch lbs 遵照KIDD给出的推荐值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分析软件&#34;&gt;分析软件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;（Android） Range Buddy&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;结果&#34;&gt;结果&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;day1 shooting&lt;br&gt;
&lt;img src=&#34;https://headhuanglan.github.io/post-images/KIDD.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;day2 shooting&lt;br&gt;
&lt;img src=&#34;https://headhuanglan.github.io/post-images/KIDD2.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分析-moa&#34;&gt;分析 （MOA）&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;弹药&lt;/th&gt;
&lt;th&gt;50发价格&lt;/th&gt;
&lt;th&gt;Group1&lt;/th&gt;
&lt;th&gt;Group2&lt;/th&gt;
&lt;th&gt;Group3&lt;/th&gt;
&lt;th&gt;Group4&lt;/th&gt;
&lt;th&gt;Group5&lt;/th&gt;
&lt;th&gt;Min&lt;/th&gt;
&lt;th&gt;Max&lt;/th&gt;
&lt;th&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SK Pistol Match Special&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$11.99&lt;/td&gt;
&lt;td&gt;0.62&lt;/td&gt;
&lt;td&gt;0.62&lt;/td&gt;
&lt;td&gt;0.79&lt;/td&gt;
&lt;td&gt;0.91&lt;/td&gt;
&lt;td&gt;0.74&lt;/td&gt;
&lt;td&gt;0.62&lt;/td&gt;
&lt;td&gt;0.79&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0.736&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Eley Match&lt;/td&gt;
&lt;td&gt;$21.99&lt;/td&gt;
&lt;td&gt;0.34&lt;/td&gt;
&lt;td&gt;0.68&lt;/td&gt;
&lt;td&gt;0.57&lt;/td&gt;
&lt;td&gt;0.74&lt;/td&gt;
&lt;td&gt;1.59&lt;/td&gt;
&lt;td&gt;0.34&lt;/td&gt;
&lt;td&gt;1.59&lt;/td&gt;
&lt;td&gt;0.784&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lapua Pistol King&lt;/td&gt;
&lt;td&gt;$14.72&lt;/td&gt;
&lt;td&gt;1.09&lt;/td&gt;
&lt;td&gt;0.54&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.76&lt;/td&gt;
&lt;td&gt;0.98&lt;/td&gt;
&lt;td&gt;0.54&lt;/td&gt;
&lt;td&gt;1.09&lt;/td&gt;
&lt;td&gt;0.794&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Eley Semi-Auto Benchrest Precision&lt;/td&gt;
&lt;td&gt;$15.99&lt;/td&gt;
&lt;td&gt;0.53&lt;/td&gt;
&lt;td&gt;0.79&lt;/td&gt;
&lt;td&gt;0.74&lt;/td&gt;
&lt;td&gt;0.95&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;0.53&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;0.802&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SK Rifle Match&lt;/td&gt;
&lt;td&gt;$12.99&lt;/td&gt;
&lt;td&gt;0.68&lt;/td&gt;
&lt;td&gt;0.68&lt;/td&gt;
&lt;td&gt;1.19&lt;/td&gt;
&lt;td&gt;0.91&lt;/td&gt;
&lt;td&gt;0.96&lt;/td&gt;
&lt;td&gt;0.68&lt;/td&gt;
&lt;td&gt;1.19&lt;/td&gt;
&lt;td&gt;0.884&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CCI Standard Velocity&lt;/td&gt;
&lt;td&gt;$4.99&lt;/td&gt;
&lt;td&gt;0.89&lt;/td&gt;
&lt;td&gt;1.05&lt;/td&gt;
&lt;td&gt;1.05&lt;/td&gt;
&lt;td&gt;1.32&lt;/td&gt;
&lt;td&gt;0.95&lt;/td&gt;
&lt;td&gt;0.89&lt;/td&gt;
&lt;td&gt;1.32&lt;/td&gt;
&lt;td&gt;1.052&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Blazer&lt;/td&gt;
&lt;td&gt;$3.99&lt;/td&gt;
&lt;td&gt;1.24&lt;/td&gt;
&lt;td&gt;1.01&lt;/td&gt;
&lt;td&gt;2.07&lt;/td&gt;
&lt;td&gt;1.01&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;0.83&lt;/td&gt;
&lt;td&gt;2.07&lt;/td&gt;
&lt;td&gt;1.232&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Norma TAC-22&lt;/td&gt;
&lt;td&gt;$4.29&lt;/td&gt;
&lt;td&gt;0.74&lt;/td&gt;
&lt;td&gt;1.79&lt;/td&gt;
&lt;td&gt;1.63&lt;/td&gt;
&lt;td&gt;1.21&lt;/td&gt;
&lt;td&gt;1.26&lt;/td&gt;
&lt;td&gt;0.74&lt;/td&gt;
&lt;td&gt;1.79&lt;/td&gt;
&lt;td&gt;1.326&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CCI MiniMag&lt;/td&gt;
&lt;td&gt;$6.0&lt;/td&gt;
&lt;td&gt;1.07&lt;/td&gt;
&lt;td&gt;1.28&lt;/td&gt;
&lt;td&gt;2.39&lt;/td&gt;
&lt;td&gt;1.24&lt;/td&gt;
&lt;td&gt;1.67&lt;/td&gt;
&lt;td&gt;1.07&lt;/td&gt;
&lt;td&gt;2.39&lt;/td&gt;
&lt;td&gt;1.53&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Federal AutoMatch 325&lt;/td&gt;
&lt;td&gt;$3.23&lt;/td&gt;
&lt;td&gt;1.54&lt;/td&gt;
&lt;td&gt;1.58&lt;/td&gt;
&lt;td&gt;2.91&lt;/td&gt;
&lt;td&gt;2.27&lt;/td&gt;
&lt;td&gt;2.1&lt;/td&gt;
&lt;td&gt;1.54&lt;/td&gt;
&lt;td&gt;2.91&lt;/td&gt;
&lt;td&gt;2.08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Aguila Super Maximum&lt;/td&gt;
&lt;td&gt;$8.06&lt;/td&gt;
&lt;td&gt;5.48&lt;/td&gt;
&lt;td&gt;3.64&lt;/td&gt;
&lt;td&gt;6.84&lt;/td&gt;
&lt;td&gt;3.96&lt;/td&gt;
&lt;td&gt;6.3&lt;/td&gt;
&lt;td&gt;3.64&lt;/td&gt;
&lt;td&gt;6.84&lt;/td&gt;
&lt;td&gt;5.244&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;枪的精度在1MOA以下&lt;/li&gt;
&lt;li&gt;fps不能超过声速Group大到没法看, impact target 时候存在超声速-声速转换区。&lt;/li&gt;
&lt;li&gt;SK Pistol Match Special 最好结果&lt;/li&gt;
&lt;li&gt;Eley Match应该是操作问题导致outlier比较大，除去outlier Eley Match结果最好。&lt;/li&gt;
&lt;li&gt;性价比最高的CCI Standard Velocity&lt;/li&gt;
&lt;/ul&gt;
">自装KIDD-10/22不同品牌子弹Group分析 </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/system-design/"" data-c="
          &lt;p&gt;System Design 资源汇总&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PdtlXdse7pw&amp;amp;list=PL4KdJM8LzAMecwInbBK5GJ3Anz-ts75RQ&#34;&gt;DDIA书视频总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.interviewbit.com/courses/system-design/&#34;&gt;InterviewBit系统设计题汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/donnemartin/system-design-primer&#34;&gt;system design primer github repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.hiredintech.com/classrooms/system-design/lesson/52&#34;&gt;system design class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.educative.io/courses/grokking-the-system-design-interview&#34;&gt;付费 grokking system design interview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://luanjunyi.medium.com/the-table-of-contents-416d2240fa8e&#34;&gt;大佬的medium文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.gainlo.co/index.php/category/system-design-interview-questions/&#34;&gt;已经解决的系统设计问题合集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://highscalability.com/blog/2022/1/25/designing-uber.html/&#34;&gt;Design Uber&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://highscalability.com/blog/2022/1/17/designing-tinder.html&#34;&gt;Design Tinder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://highscalability.com/blog/2022/1/11/designing-instagram.html&#34;&gt;Design Instagram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://highscalability.com/blog/2022/1/3/designing-whatsapp.html&#34;&gt;Design Whatsapp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://highscalability.com/blog/2021/12/13/designing-netflix.html&#34;&gt;Design Netflix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://leetcode.com/company/facebook/discuss/229177/My-System-Design-Template&lt;br&gt;
(1) FEATURE EXPECTATIONS [5 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) Use cases
    (2) Scenarios that will not be covered
    (3) Who will use
    (4) How many will use
    (5) Usage patterns
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2) ESTIMATIONS [5 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) Throughput (QPS for read and write queries)
    (2) Latency expected from the system (for read and write queries)
    (3) Read/Write ratio
    (4) Traffic estimates
            - Write (QPS, Volume of data)
            - Read  (QPS, Volume of data)
    (5) Storage estimates
    (6) Memory estimates
            - If we are using a cache, what is the kind of data we want to store in cache
            - How much RAM and how many machines do we need for us to achieve this ?
            - Amount of data you want to store in disk/ssd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3) DESIGN GOALS [5 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) Latency and Throughput requirements
    (2) Consistency vs Availability  [Weak/strong/eventual =&amp;gt; consistency | Failover/replication =&amp;gt; availability]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(4) HIGH LEVEL DESIGN [5-10 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) APIs for Read/Write scenarios for crucial components
    (2) Database schema
    (3) Basic algorithm
    (4) High level design for Read/Write scenario
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(5) DEEP DIVE [15-20 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) Scaling the algorithm
    (2) Scaling individual components: 
            -&amp;gt; Availability, Consistency and Scale story for each component
            -&amp;gt; Consistency and availability patterns
    (3) Think about the following components, how they would fit in and how it would help
            a) DNS
            b) CDN [Push vs Pull]
            c) Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
            d) Reverse Proxy
            e) Application layer scaling [Microservices, Service Discovery]
            f) DB [RDBMS, NoSQL]
                    &amp;gt; RDBMS 
                        &amp;gt;&amp;gt; Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
                    &amp;gt; NoSQL
                        &amp;gt;&amp;gt; Key-Value, Wide-Column, Graph, Document
                            Fast-lookups:
                            -------------
                                &amp;gt;&amp;gt;&amp;gt; RAM  [Bounded size] =&amp;gt; Redis, Memcached
                                &amp;gt;&amp;gt;&amp;gt; AP [Unbounded size] =&amp;gt; Cassandra, RIAK, Voldemort
                                &amp;gt;&amp;gt;&amp;gt; CP [Unbounded size] =&amp;gt; HBase, MongoDB, Couchbase, DynamoDB
            g) Caches
                    &amp;gt; Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
                    &amp;gt; Eviction policies:
                            &amp;gt;&amp;gt; Cache aside
                            &amp;gt;&amp;gt; Write through
                            &amp;gt;&amp;gt; Write behind
                            &amp;gt;&amp;gt; Refresh ahead
            h) Asynchronism
                    &amp;gt; Message queues
                    &amp;gt; Task queues
                    &amp;gt; Back pressure
            i) Communication
                    &amp;gt; TCP
                    &amp;gt; UDP
                    &amp;gt; REST
                    &amp;gt; RPC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(6) JUSTIFY [5 min]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (1) Throughput of each layer
    (2) Latency caused between each layer
    (3) Overall latency justification
&lt;/code&gt;&lt;/pre&gt;
">系统设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-08/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-471-encode-string-with-shortest-length-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 471. Encode String with Shortest Length （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, encode the string such that its encoded length is the shortest.&lt;br&gt;
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. k should be a positive integer.&lt;br&gt;
If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    @lru_cache(None)
    def encode(self, s: str) -&amp;gt; str:
        i=(s+s).find(s,1)
        encoded=str(len(s)//i)+&#39;[&#39;+self.encode(s[:i])+&#39;]&#39; if i&amp;lt;len(s) else s
        splitEncoded=[self.encode(s[:i])+self.encode(s[i:]) for i in range(1,len(s))]
        return min(splitEncoded+[encoded],key=len)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案绝了。。。&lt;br&gt;
For any s, you can either&lt;br&gt;
Do not encode it&lt;br&gt;
Or encode it to one string if possible&lt;br&gt;
Or, split it into two, encode the two substring to their shortest possible length, and combine them&lt;br&gt;
Pick up the shortest result from 1~3.&lt;br&gt;
During this process, you should remember the best encoding result for all substrings so that it can be reused.&lt;br&gt;
For #2, you can use LeetCode 459: Repeated Substring Pattern to find out whether the &amp;quot;s&amp;quot; is repeated or not, and how many times it is repeated:&lt;br&gt;
&amp;quot;i=(s+s).find(s,1)&amp;quot;&lt;br&gt;
&amp;quot;i&amp;quot; is the length of repeating pattern. If i&amp;gt;=len(s), then s is not repeated.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-472-concatenated-words-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 472. Concatenated Words （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.&lt;br&gt;
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -&amp;gt; List[str]:
        d = set(words)
        @lru_cache(None)
        def dfs(word):
            for i in range(1, len(word)):
                prefix = word[:i]
                suffix = word[i:]
                
                if prefix in d and suffix in d:
                    return True
                if prefix in d and dfs(suffix):
                    return True
                if suffix in d and dfs(prefix):
                    return True
            
            return False
        
        res = []
        for word in words:
            if dfs(word):
                res.append(word)
        
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看答案捐膝盖。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-473-matchsticks-to-square-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 473. Matchsticks to Square (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.&lt;br&gt;
Return true if you can make this square and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def makesquare(self, matchsticks: List[int]) -&amp;gt; bool:
        length = sum(matchsticks)//4
        if length*4!= sum(matchsticks): return False
        
        holds=[[],[],[],[]]
        self.result=False
        def bt(i):
            if i&amp;gt;=len(matchsticks): return
            for hold in holds:
                val=matchsticks[i]
                hold.append(val)
                if len(set(map(sum,holds)))==1 and i==len(matchsticks)-1:
                    self.result=True
                    return 
                bt(i+1)
                hold.pop()
        
        bt(0)
        
        return self.result

#ANSWER
class Solution:
    def makesquare(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;

        # If there are no matchsticks, then we can&#39;t form any square
        if not nums:
            return False

        # Number of matchsticks we have
        L = len(nums)

        # Perimeter of our square (if one can be formed)
        perimeter = sum(nums)

        # Possible side of our square.
        possible_side =  perimeter // 4

        # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).
        if possible_side * 4 != perimeter:
            return False

        # Reverse sort the matchsticks because we want to consider the biggest one first.
        nums.sort(reverse=True)

        # This array represents the 4 sides and their current lengths
        sums = [0 for _ in range(4)]

        # Our recursive dfs function.
        def dfs(index):

            # If we reach the end of matchsticks array, we check if the square was formed or not
            if index == L:
                # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.
                return sums[0] == sums[1] == sums[2] == possible_side

            # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are &amp;gt;= the size of the current matchstick)
            for i in range(4):
                # If this matchstick can fir in the space left for the current side
                if sums[i] + nums[index] &amp;lt;= possible_side:
                    # Recurse
                    sums[i] += nums[index]
                    if dfs(index + 1):
                        return True
                    # Revert the effects of recursion because we no longer need them for other recursions.
                    sums[i] -= nums[index]
            return False        
        return dfs(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试backtracking TLE。。。答案same idea with trick can pass， reverse sorting and early stopping。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-474-ones-and-zeroes-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 474. Ones and Zeroes （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of binary strings strs and two integers m and n.&lt;br&gt;
Return the size of the largest subset of strs such that there are at most m 0&#39;s and n 1&#39;s in the subset.&lt;br&gt;
A set x is a subset of a set y if all elements of x are also elements of y.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&amp;gt; int:
        
        dp=[[0 for _ in range(n+1)] for __ in range(m+1)]
        for s in strs:
            c0=s.count(&#39;0&#39;)
            c1=s.count(&#39;1&#39;)
            for zeros in range(m,c0-1,-1):
                for ones in range(n,c1-1,-1):
                    dp[zeros][ones] = max(1+dp[zeros-c0][ones-c1],dp[zeros][ones])
        
        return dp[m][n]
#ANSWER
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&amp;gt; int:
        @lru_cache(None)
        def calculate(i,zeroes,ones):
            if i==len(strs): return 0
            c1=strs[i].count(&#39;1&#39;)
            c0=strs[i].count(&#39;0&#39;)        
            taken=-1
            if zeroes-c0&amp;gt;=0 and ones-c1&amp;gt;=0:
                taken = calculate(i+1,zeroes-c0,ones-c1) +1
            not_taken=calculate(  i + 1, zeroes, ones )
            return max(taken, not_taken)
        return calculate(0, m, n) 
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;greedy failed....   DP? Should have got this one.   dp[i][j] denotes the maximum number of strings that can be included in the subset given only i 0&#39;s and j 1&#39;s are available. 从后向前因为不能覆盖之前的结果。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-475-heaters-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 475. Heaters （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.&lt;br&gt;
Every house can be warmed, as long as the house is within the heater&#39;s warm radius range.&lt;br&gt;
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#TLE
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&amp;gt; int:
        #bfs
        visited=set()
        houses=set(houses)-set(heaters)
        dis=0
        while visited!=houses:
            #print(visited,houses)
            dis+=1
            for cur in heaters: 
                if cur+dis in houses and cur+dis not in visited:
                    visited.add(cur+dis)    
                if cur-dis in houses  and cur-dis not in visited:
                    visited.add(cur-dis)
        return dis
            
#ANSWER
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&amp;gt; int:
        
         
               
        def binsearch(nums, target) :
            l, r = 0, len(nums)
            while l &amp;lt; r:
                m = (l + r) // 2
                if nums[m] &amp;lt; target :
                    l = m + 1
                else:
                    r = m
            return l
            
        heaters.sort()
        
        result = float(&#39;-inf&#39;)
        
        for house in houses :
            index = binsearch(heaters, house)
            leftHeaterDistance = house - heaters[index - 1] if index &amp;gt; 0 else float(&#39;inf&#39;)
            rightHeaterDistance = heaters[index] - house if index &amp;lt; len(heaters) else float(&#39;inf&#39;)
            result = max(result , min(leftHeaterDistance, rightHeaterDistance))
        
        return result
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变种FBS 每次增加1 distance，TLE。看答案。max min + binary search&lt;/p&gt;
&lt;h1 id=&#34;476-number-complement-easy&#34;&gt;476. Number Complement (Easy)&lt;/h1&gt;
&lt;p&gt;The complement of an integer is the integer you get when you flip all the 0&#39;s to 1&#39;s and all the 1&#39;s to 0&#39;s in its binary representation.&lt;br&gt;
For example, The integer 5 is &amp;quot;101&amp;quot; in binary and its complement is &amp;quot;010&amp;quot; which is the integer 2.&lt;br&gt;
Given an integer num, return its complement.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findComplement(self, num: int) -&amp;gt; int:
        mask= 2**len(bin(num)[2:])-1
        print(bin(mask),bin(num))
        return mask^num
#ANSWER
from math import log2
class Solution:
    def findComplement(self, num):
        # n is a length of num in binary representation
        n = floor(log2(num)) + 1        
        # bitmask has the same length as num and contains only ones 1...1
        bitmask = (1 &amp;lt;&amp;lt; n) - 1
        # flip all bits
        return bitmask ^ num
#ANSWER
class Solution:
    def findComplement(self, num):
        todo, bit = num, 1
        while todo:
            # flip current bit
            num = num ^ bit
            # prepare for the next run
            bit = bit &amp;lt;&amp;lt; 1
            todo = todo &amp;gt;&amp;gt; 1
        return num
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred477-total-hamming-distance-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;477. Total Hamming Distance (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The Hamming distance between two integers is the number of positions at which the corresponding bits are different.&lt;br&gt;
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&amp;gt; int:
        nums.sort()
        @lru_cache(None)
        def cal(a,b):
            val=a^b
            c=0
            while val:
                if val%2==1:
                    c+=1
                val&amp;gt;&amp;gt;=1
            return c
        res=0
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                res+=cal(nums[i],nums[j])
        return res


#ANSWER
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&amp;gt; int:
        if not nums: return 0
        res=0
        n=len(nums)
        count = [0]*32
        
        for num in nums:
            i=0
            while num:
                count[i]+= num &amp;amp; 1
                num &amp;gt;&amp;gt;=1
                i+=1
        
        for k in count:
            res+=k*(n-k)
        
        return res
        
         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试 TLE,应该按照bit loop。Say for any particular bit position, count the number of elements with this bit ON (i.e. this particular bit is 1). Let this count be k. Hence the number of elements with this bit OFF (i.e. 0) is (n−k)(n - k) (in an n element array).&lt;br&gt;
Certainly unique pairs of elements exists where one element has this particular bit ON while the other element has this OFF (i.e. this particular bit differs for the two elements of this pair).&lt;/p&gt;
&lt;h1 id=&#34;478-generate-random-point-in-a-circle-medium&#34;&gt;478. Generate Random Point in a Circle （Medium）&lt;/h1&gt;
&lt;p&gt;Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.&lt;br&gt;
Implement the Solution class:&lt;br&gt;
Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).&lt;br&gt;
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&amp;gt; List[float]:
        r=self.r
        x=r*(random()-0.5)*2
        y=r*(random()-0.5)*2
        while x*x+y*y&amp;gt;r*r:
            x=r*(random()-0.5)*2
            y=r*(random()-0.5)*2
            
        
        return [self.x+x,self.y+y]
#ANSWER hard
from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&amp;gt; List[float]:
        r=self.r*math.sqrt(random())
        theta = 2*math.pi*random()
        x=r*math.cos(theta)
        y=r*math.sin(theta)
     
        return [self.x+x,self.y+y]
#ANSWER
import math
import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x = x_center
        self.y = y_center
        self.area = math.pi * radius ** 2

    def randPoint(self) -&amp;gt; List[float]:
        theta = 2 * math.pi * random.random()
        R = math.sqrt(random.uniform(0, self.area) / math.pi)
        return [self.x + R * math.cos(theta), self.y + R * math.sin(theta)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The area under any probability density function curve must be 1 . Therefore, the equation must be f(x)=2x Using our probability density function f , we can compute the cumulative distribution function F , where F(x) is the probability of sampling a point within a distance of x from the origin.F(x)=∫f(x)=∫2x=x2&lt;br&gt;
Lastly, we can use our cumulative distribution function F  to compute the inverse cumulative distribution function  F^{-1} , which accepts uniform random value between 0  and 1  and returns a random distance from origin in accordance with f&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-479-largest-palindrome-product-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 479. Largest Palindrome Product (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def largestPalindrome(self, n: int) -&amp;gt; int:
        max_=10**n-1
        min_=max_//10
        for h in range(max_,min_,-1):
            left=h
            right=0
            #// construct the palindrome
            i=h
            while i:
                right=right*10+i%10
                left*=10
                i//=10
            
            palindrom=left+right
            #print(palindrom)
            for i in range(max_,min_,-1):
                j=palindrom//i
                #// terminate if the other number is greater than current number
                if j&amp;gt;i: break
                if  palindrom%i==0: return palindrom%1337
        #// account for case n = 1
        return 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。&lt;/p&gt;
&lt;h1 id=&#34;480-sliding-window-median-hard&#34;&gt;480. Sliding Window Median （Hard）&lt;/h1&gt;
&lt;p&gt;The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.&lt;br&gt;
For examples, if arr = [2,3,4], the median is 3.&lt;br&gt;
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.&lt;br&gt;
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&lt;br&gt;
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&amp;gt; List[float]:
        odd=False
        pos1=0
        pos2=0
        if k%2==1:
            odd=True
            pos1=k//2
        else:
            pos1=k//2-1
            pos2=k//2
        
        res = []
        for i in range(k,len(nums)+1):
            tmp = sorted(nums[i-k:i])
            if odd: 
                res.append(tmp[pos1])
            else:
                res.append( (tmp[pos1]+tmp[pos2])/2)
        return res

#ANSWER O(nk)
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&amp;gt; List[float]:
        window = sorted(nums[:k])
        medians = []
        for a, b in zip(nums, nums[k:] + [0]):
            if k&amp;amp;1:
                medians.append( window[k//2])
            else:
                medians.append( (window[k//2]+window[k//2-1])/2.0)
            window.remove(a)
            bisect.insort(window, b)
        return medians

#ANSWER O(nlogk)
import heapq
from collections import defaultdict
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&amp;gt; List[float]:
        if not nums or not k:
            return []
        #lo  hi
        lo = [] # max heap   
        hi = [] # min heap
        for i in range(k):
            if len(lo) == len(hi):
                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))
            else:
                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))
        ans = [float(hi[0])] if k &amp;amp; 1 else [(hi[0] - lo[0]) / 2.0]
        to_remove = defaultdict(int)
        for i in range(k, len(nums)): # right bound of window
            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo
            out_num = nums[i-k]
            #out_num恰巧在lo的边界上，所以要更新边界
            if out_num &amp;gt; -lo[0]:
                heapq.heappush(hi, -heapq.heappop(lo))
            to_remove[out_num] += 1

            #在lo边界上可以直接去掉
            while lo and to_remove[-lo[0]]:
                to_remove[-lo[0]] -= 1
                heapq.heappop(lo)
            #在hi边界上可以直接去掉
            while to_remove[hi[0]]:
                to_remove[hi[0]] -= 1
                heapq.heappop(hi)
            if k % 2:
                ans.append(float(hi[0]))
            else:
                ans.append((hi[0] - lo[0]) / 2.0)
        return ans
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：维持small ，large 连个queue， 所有samll中元素都小于large， 所以median是 （max（small）+min（large））除以2，如果small ，large等长， 如果large长，则返回min（large）&lt;br&gt;
所以用heap， small用的是maxheap， large用的是minheap。&lt;/p&gt;
">Leetcode 2022-03-08</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-07/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;461-hamming-distance-easy&#34;&gt;461. Hamming Distance (Easy)&lt;/h1&gt;
&lt;p&gt;The Hamming distance between two integers is the number of positions at which the corresponding bits are different.&lt;br&gt;
Given two integers x and y, return the Hamming distance between them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hammingDistance(self, x: int, y: int) -&amp;gt; int:
        res=x^y
        c=0
        for i in range(32):
            if res &amp;gt;&amp;gt;i &amp;amp; 1:
                c+=1
        return c
#
class Solution(object):
    def hammingDistance(self, x, y):
        &amp;quot;&amp;quot;&amp;quot;
        :type x: int
        :type y: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        xor = x ^ y
        distance = 0
        while xor:
            # mask out the rest bits
            if xor &amp;amp; 1:
                distance += 1
            xor = xor &amp;gt;&amp;gt; 1
        return distance

#
class Solution:
    def hammingDistance(self, x, y):
        xor = x ^ y
        distance = 0
        while xor:
            distance += 1
            # remove the rightmost bit of &#39;1&#39;
            xor = xor &amp;amp; (xor - 1)
        return distance
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;462-minimum-moves-to-equal-array-elements-ii-medium&#34;&gt;462. Minimum Moves to Equal Array Elements II (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.&lt;br&gt;
In one move, you can increment or decrement an element of the array by 1.&lt;br&gt;
Test cases are designed so that the answer will fit in a 32-bit integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minMoves2(self, nums: List[int]) -&amp;gt; int:
        # nums[i]-mid
        nums.sort()
        mid= nums[len(nums)//2]
        return sum([abs(val-mid) for val in nums])
#JAVA ANSWER good to know
public class Solution {
    public int minMoves2(int[] nums) {
        int l = 0, r = nums.length - 1, sum = 0;
        Arrays.sort(nums);
        while (l &amp;lt; r) {
            sum += nums[r] - nums[l];
            l++;
            r--;
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;463-island-perimeter-easy&#34;&gt;463. Island Perimeter (Easy)&lt;/h1&gt;
&lt;p&gt;You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.&lt;br&gt;
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).&lt;br&gt;
The island doesn&#39;t have &amp;quot;lakes&amp;quot;, meaning the water inside isn&#39;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&amp;gt; int:
        # find a neighor + neighbor4 but contact need to -contact number.
        visited=set()
        def nei(i,j):
            neis=[]
            for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if ii&amp;lt;0 or ii&amp;gt;=len(grid) or jj&amp;lt;0 or jj&amp;gt;=len(grid[0]) or grid[ii][jj]==0: 
                        continue
                neis.append((ii,jj))
            return neis
        
        res = [0]
        
        def dfs(i,j):
            if (i,j) in visited: return
            res[0]+=4
            neis = nei(i,j)
            res[0]-=len(neis)
            visited.add((i,j))
            for ne in neis:
                if ne not in visited:
                    dfs(*ne)
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    dfs(i,j)
                    break
        return res[0]
            
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-464-can-i-win-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 464. Can I Win (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;In the &amp;quot;100 game&amp;quot; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.&lt;br&gt;
What if we change the game so that players cannot re-use integers?&lt;br&gt;
For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &amp;gt;= 100.&lt;br&gt;
Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&amp;gt; bool:
        @lru_cache(None)
        def check(nums, t):
            if nums[-1] &amp;gt;= t: return True
            res = any(not check(tuple(nums[:i]+nums[i+1:]),t-nums[i]) for i in range(len(nums)))
            return res
            
        if maxChoosableInteger * (1 + maxChoosableInteger) // 2 &amp;lt; desiredTotal: return False
        nums = tuple(range(1, maxChoosableInteger + 1))
        return check(nums, desiredTotal)

#ANSWER 2 TLE
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&amp;gt; bool:
        dic = dict()
        used = [False]*(maxChoosableInteger+1)
        
        sum_=(1+maxChoosableInteger)*maxChoosableInteger//2
        if sum_&amp;lt;desiredTotal: return False
        if desiredTotal&amp;lt;=0: return True
        
        def formatkey(used):
            n=0
            for bl in used:
                n&amp;lt;&amp;lt;=1
                if bl:
                    n |=1
            return n
            
        def helper(desiredTotal):
            if desiredTotal&amp;lt;=0: return False
            key = formatkey(used)
            if key not in dic:
                for i in range(1,len(used)):
                    if not used[i]:
                        used[i]=True
                        #check whether this lead to a win (i.e. the other player lose)
                        if not helper(desiredTotal-i):
                            dic[key]=True
                            used[i]=False
                            return True
                        used[i]=False
                dic[key]=False
            
            return dic[key]
        
        return helper(desiredTotal)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;can not reuse integer， 答案 pythonic写法。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-465-optimal-account-balancing-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 465. Optimal Account Balancing （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.&lt;br&gt;
Return the minimum number of transactions required to settle the debt.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def minTransfers(self, transactions):
        &amp;quot;&amp;quot;&amp;quot;
        :type transactions: List[List[int]]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        m = collections.defaultdict(int)
        
        for t in transactions:
            m[t[0]]-=t[2]
            m[t[1]]+=t[2]
        
        debt = m.values()
        
        def dfs(s):
            while(s&amp;lt;len(debt) and debt[s]==0):
                s+=1
            if s==len(debt): return 0
            
            r = float(&#39;inf&#39;)
            for i in range(s+1,len(debt)):
                if debt[i]*debt[s]&amp;lt;0:
                    # settle s with i
                    debt[i]+=debt[s]
                    r=min(r,1+dfs(s+1))
                    # backtrack
                    debt[i]-=debt[s]
            return r
        
        return dfs(0)



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;idea is tricky...  person index s have debt[s] for other person from s+1, if other person have neg sign then person s. update debt[i] with debt[s] (so person i will take full responsiblity of person s). r=min(r,1+dfs(s+1))&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-466-count-the-repetitions-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 466. Count The Repetitions (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;We define str = [s, n] as the string str which consists of the string s concatenated n times.&lt;br&gt;
For example, str == [&amp;quot;abc&amp;quot;, 3] ==&amp;quot;abcabcabc&amp;quot;.&lt;br&gt;
We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.&lt;br&gt;
For example, s1 = &amp;quot;abc&amp;quot; can be obtained from s2 = &amp;quot;abdbec&amp;quot; based on our definition by removing the bolded underlined characters.&lt;br&gt;
You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].&lt;br&gt;
Return the maximum integer m such that str = [str2, m] can be obtained from str1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def getMaxRepetitions(self, s1, n1, s2, n2):
        d, l1, l2, i1, i2 = {}, len(s1), len(s2), 0, 0
        tot = l1 * n1

        while i1 &amp;lt; tot:
            if s1[i1 % l1] == s2[i2 % l2]:
                if (i1 % l1, i2 % l2) in d:
                    prev1, prev2 = d[(i1 % l1, i2 % l2)]
                    cir1, cir2 = i1 - prev1, i2 - prev2
                    count_cir1 = (tot - i1) // cir1
                    i1 += count_cir1 * cir1
                    i2 += count_cir1 * cir2
                    if i1 &amp;gt;= tot: break
                else:
                    d[(i1 % l1, i2 % l2)] = (i1, i2)
                i2 += 1
            i1 += 1
        return i2 // l2 // n2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接数出现的次数算重复不行，因为还有字母出现次序问题。。。 得找重复pattern。 答案厉害。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-467-unique-substrings-in-wraparound-string-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 467. Unique Substrings in Wraparound String (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;We define the string s to be the infinite wraparound string of &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;, so s will look like this:&lt;br&gt;
&amp;quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&amp;quot;.&lt;br&gt;
Given a string p, return the number of unique non-empty substrings of p are present in s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def findSubstringInWraproundString(self, p):
        res = {i: 1 for i in p}
        l = 1
        for i, j in zip(p, p[1:]):
            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
            res[j] = max(res[j], l)
        return sum(res.values())
#
class Solution:
    def findSubstringInWraproundString(self, p: str) -&amp;gt; int:
        if not p: return 0
        count = [0]*26
        #initally, count is 1 for each unique char
        for char in p:
            count[ord(char)-ord(&#39;a&#39;)]=1
        
        res=1
        #for each sub sequence ending in char2, if it is connected, res+=1 else res=1
        for char1,char2 in zip(p,p[1:]):
            if (ord(char2)-ord(char1))%26==1:
                res+=1
            else:
                res=1
            #prevent duplicate char2
            count[ord(char2)-ord(&#39;a&#39;)] = max(count[ord(char2)-ord(&#39;a&#39;)], res)
                
        return sum(count)

#ANSWER DP 思路：若字符连续，当前可形成的substring个数+1，若不连续substring个数=1，更新count 为防止重复字符overwrite，更新时候取max。 
class Solution:
    def findSubstringInWraproundString(self, p: str) -&amp;gt; int:
        count=[0]*26
        cur_maxlen=0
        for i in range(len(p)):
            if i&amp;gt;0 and (ord(p[i])-ord(p[i-1]))%26==1:
                cur_maxlen+=1
            else:
                cur_maxlen=1
            
            index=ord(p[i])-ord(&#39;a&#39;)
            count[index]=max(count[index],cur_maxlen)
        
        return sum(count)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看答案了。。。&lt;br&gt;
Each single charecter contribution is initialized to 1&lt;br&gt;
if the order is continued, the contribution is increased by 1 from previous character contribution&lt;/p&gt;
&lt;p&gt;example string zabce&lt;/p&gt;
&lt;p&gt;Values got incremented in the following way&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;z -&amp;gt; 1
a -&amp;gt; 1 + 1 (or) z + 1 -&amp;gt; 2
b -&amp;gt; 1 + 1 + 1 (or) a + 1 -&amp;gt; 3
c -&amp;gt; 1 + 1 + 1 + 1 (or) b + 1 -&amp;gt; 4
e -&amp;gt; 1 (ord(j) - ord(i)) % 26 != 1 here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the final answer is contribution from z + a + b + c + e (1 + 2 + 3 + 4 + 1 = 11)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;max(res[j], l) is required to handle cases where the character is repeated.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example in zaba, since each each unique character is assigned as key to res, the 2nd a contribution should not replace the 1st a contribution until it exceeds the 1st a contribution&lt;/p&gt;
&lt;h1 id=&#34;468-validate-ip-address-medium&#34;&gt;468. Validate IP Address （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string queryIP, return &amp;quot;IPv4&amp;quot; if IP is a valid IPv4 address, &amp;quot;IPv6&amp;quot; if IP is a valid IPv6 address or &amp;quot;Neither&amp;quot; if IP is not a correct IP of any type.&lt;br&gt;
A valid IPv4 address is an IP in the form &amp;quot;x1.x2.x3.x4&amp;quot; where 0 &amp;lt;= xi &amp;lt;= 255 and xi cannot contain leading zeros. For example, &amp;quot;192.168.1.1&amp;quot; and &amp;quot;192.168.1.0&amp;quot; are valid IPv4 addresses but &amp;quot;192.168.01.1&amp;quot;, while &amp;quot;192.168.1.00&amp;quot; and &amp;quot;192.168@1.1&amp;quot; are invalid IPv4 addresses.&lt;br&gt;
A valid IPv6 address is an IP in the form &amp;quot;x1:x2:x3:x4:x5:x6:x7:x8&amp;quot; where:&lt;br&gt;
1 &amp;lt;= xi.length &amp;lt;= 4&lt;br&gt;
xi is a hexadecimal string which may contain digits, lower-case English letter (&#39;a&#39; to &#39;f&#39;) and upper-case English letters (&#39;A&#39; to &#39;F&#39;).&lt;br&gt;
Leading zeros are allowed in xi.&lt;br&gt;
For example, &amp;quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&amp;quot; and &amp;quot;2001:db8:85a3:0:0:8A2E:0370:7334&amp;quot; are valid IPv6 addresses, while &amp;quot;2001:0db8:85a3::8A2E:037j:7334&amp;quot; and &amp;quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&amp;quot; are invalid IPv6 addresses.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def validIPAddress(self, queryIP: str) -&amp;gt; str:
        
        def convert4(string):
            # in range 0~255
            # cannot leading zeros
            # number only
            if not string: return False
            if len(string)&amp;gt;1 and string[0]==&#39;0&#39;: return False
            val=0
            for s in string:
                if s not in &#39;0123456789&#39;:
                    return False
                val=val*10+int(s)
            
            #return True if success, else False
            if val&amp;gt;=0 and val&amp;lt;=255:
                return True
            return False
        
        def convert6(string):
            if not string: return False
            #length 1~4
            # hexadecial string 0~9 a~f A~F
            if len(string)&amp;gt;4: return False
            for s in string:
                if s not in &#39;0123456789abcdefABCDEF&#39;:
                    return False
            return True
        
        if &#39;.&#39; in queryIP:
            data = queryIP.split(&#39;.&#39;)
            if len(data)==4 and all([convert4(string) for string in data]):
                return &#39;IPv4&#39;        
            
        elif &#39;:&#39; in queryIP:
            data = queryIP.split(&#39;:&#39;)
            if len(data)==8 and all([convert6(string) for string in data]):
                return &#39;IPv6&#39;
        
        return &#39;Neither&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只需要细心的题目&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-469-convex-polygon-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 469. Convex Polygon （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of points on the X-Y plane points where points[i] = [xi, yi]. The points form a polygon when joined sequentially.&lt;br&gt;
Return true if this polygon is convex and false otherwise.&lt;br&gt;
You may assume the polygon formed by given points is always a simple polygon. In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don&#39;t intersect each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def isConvex(self, p: List[List[int]]) -&amp;gt; bool:
    def ccw(a, b, c):
        # (b-a) X (c-a)
        return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) 
    res = [ccw(p[i-2], p[i-1], p[i]) for i in range(len(p))]
    return abs(sum(res)) == sum(abs(i) for i in res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;convex...beyond my knowledge  CCW算法。。。Note: |Σxi| = Σ|xi| is only true when all xi are the same sign.&lt;/p&gt;
&lt;h1 id=&#34;470-implement-rand10-using-rand7-medium&#34;&gt;470. Implement Rand10() Using Rand7() (Medium)&lt;/h1&gt;
&lt;p&gt;Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn&#39;t call any other API. Please do not use a language&#39;s built-in random API.&lt;br&gt;
Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        # rand1  1~7   取1~6  奇偶决定生成左区间1~5 还是右区间6~10
        # rand2        取1~5  
        rand1=rand7()
        while rand1==7:
            rand1=rand7()
        flag = rand1%2==1
        rand2=rand7()
        while rand2&amp;gt;5:
            rand2=rand7()
        return 5+rand2 if flag else rand2

#ANSWER
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n1=rand7()
        n2=rand7()
        while n1+(n2-1)*7 &amp;gt;40:
            n1=rand7()
            n2=rand7()
        return (n1+(n2-1)*7)%10 +1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(n2-1)乘7+n1&lt;/p&gt;
">Leetcode 2022-03-07</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-06/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;451-sort-characters-by-frequency-medium&#34;&gt;451. Sort Characters By Frequency （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.&lt;br&gt;
Return the sorted string. If there are multiple answers, return any of them&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def frequencySort(self, s: str) -&amp;gt; str:
        d=Counter(s)
        res=&#39;&#39;
        for k in sorted(d,key=lambda x: d[x],reverse=True):
            res+=k*d[k]
        return res
#O(n) bucket sort
class Solution:
    def frequencySort(self, s: str) -&amp;gt; str:
        if not s: return s
        counts=collections.Counter(s)
        max_freq=max(counts.values())
        
        buckets=[[] for _ in range(max_freq+1)]
        for c,i in counts.items():
            buckets[i].append(c)
        
        string_builder=[]
        for i in range(len(buckets)-1,0,-1):
            for c in buckets[i]:
                string_builder.append(c*i)
        return &#39;&#39;.join(string_builder)
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案的On解法好。bucketsort&lt;/p&gt;
&lt;h1 id=&#34;452-minimum-number-of-arrows-to-burst-balloons-medium&#34;&gt;452. Minimum Number of Arrows to Burst Balloons (Medium)&lt;/h1&gt;
&lt;p&gt;There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.&lt;br&gt;
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &amp;lt;= x &amp;lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.&lt;br&gt;
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&amp;gt; int:
        #merge points by &amp;amp; return how many distinct points
        
        points=sorted(points,key=lambda x:x[0])
        res=[]
        for p in points:
            if res:
                # 1    1
                #    2   2 
                if res[-1][1]&amp;gt;=p[0]:
                    res[-1][0]=max(res[-1][0],p[0])
                    res[-1][1]=min(res[-1][1],p[1])
                    
                else:
                    res.append(p)
            else:
                res.append(p)
        #print(res)
        return len(res)
                
#ANSWER WAY OF WRITTING
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&amp;gt; int:
        if not points:
            return 0
        
        # sort by x_end
        points.sort(key = lambda x : x[1])
        
        arrows = 1
        first_end = points[0][1]
        for x_start, x_end in points:
            # if the current balloon starts after the end of another one,
            # one needs one more arrow
            if first_end &amp;lt; x_start:
                arrows += 1
                first_end = x_end
        
        return arrows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的思路是找到相交的区间，看总共多少个就行。。。答案思路是track球右边位置，让碰到新气球左边大于cur end位置+1，更新end位置的greedy算法。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-453-minimum-moves-to-equal-array-elements-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 453. Minimum Moves to Equal Array Elements （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.&lt;br&gt;
In one move, you can increment n - 1 elements of the array by 1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE naive solution
class Solution:
    def minMoves(self, nums: List[int]) -&amp;gt; int:
        c=0
        while len(set(nums))!=1:
            ind = nums.index(max(nums))
            for i in range(len(nums)):
                if i!=ind:
                    nums[i]+=1
            #print(nums)
            c+=1
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&amp;gt; int:
        nums.sort()
        c=0
        for i in range(len(nums)-1,0,-1):
            c+=nums[i]-nums[0]
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&amp;gt; int: 
        moves=0
        min_=float(&#39;inf&#39;)
        for i in range(len(nums)):
            moves+=nums[i]
            min_=min(min_,nums[i])
        return moves-min_*len(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案很巧妙，如果是答案1） 思路先sort，那么每次需要move是nums【i】-nums【0】，这样move后nums【i】和nums【0】相等，然后其余数字都加上了move次，再次move时候，求nums【i-1】-nums【0】，这样nums【0】就和nums【i-1】相等，自然也和nums【i】相等。 以此类推，可求出总共move数目。 如果是答案2）所有加1除了1个不加，和只有一个减去1是等效的。 所以就是减多少次能使所有数平衡，sum（all）-min（all）乘n。&lt;/p&gt;
&lt;h1 id=&#34;454-4sum-ii-medium&#34;&gt;454. 4Sum II （Medium）&lt;/h1&gt;
&lt;p&gt;Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:&lt;br&gt;
0 &amp;lt;= i, j, k, l &amp;lt; n&lt;br&gt;
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&amp;gt; int:
        dic2sum=collections.defaultdict(int)
        for i in nums1:
            for j in nums2:
                dic2sum[i+j]+=1
        
        res=0
        for k in nums3:
            for l in nums4:
                if -k-l in dic2sum:
                    res+=dic2sum[-k-l]
        return res



#ANSWER GENERALIZED 
class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&amp;gt; int:
        m = collections.defaultdict(int)
        lists = [A, B, C, D]

        def nSumCount() -&amp;gt; int:
            addToHash(0, 0)
            return countComplements(len(lists) // 2, 0)

        def addToHash(i: int, total: int) -&amp;gt; None:
            if i == len(lists) // 2:
                m[total] = m[total] + 1
            else:
                for a in lists[i]:
                    addToHash(i + 1, total + a)

        def countComplements(i: int, complement: int) -&amp;gt; int:
            if i == len(lists):
                return m[complement]
            cnt = 0
            for a in lists[i]:
                cnt += countComplements(i + 1, complement - a)
            return cnt

        return nSumCount()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;455-assign-cookies-easy&#34;&gt;455. Assign Cookies (Easy)&lt;/h1&gt;
&lt;p&gt;Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.&lt;br&gt;
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &amp;gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -&amp;gt; int:
        g.sort()
        s.sort()
        c=0
        while g:
            cur=g.pop(0)
            while s and s[0]&amp;lt;cur:
                s.pop(0)
            if s:
                s.pop(0)
                c+=1
        return c
#
# 先对g, s两个数组进行排序
# 贪心算法
# 贪心思想1 优先满足需求因子较小的孩子。因为如果较小需求的孩子无法被满足，则之后的较大的需求更不可能能被满足了。
#贪心思想2 尽量用较小的糖果去优先满足孩子。

class Solution:
    def findContentChildren(self, g, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type g: List[int]
        :type s: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        g.sort()    # 对需求因子进行排序，从小到大
        s.sort()    # 对糖果数组进行排序，从小到大
        child  = 0  # 记录可以被满足孩子数
        cookie = 0  # 记录可以满足的糖果数
        while  child &amp;lt;len(g) and cookie &amp;lt; len(s):
            if g[child] &amp;lt;= s[cookie]: 
                child += 1
            cookie += 1
        return child
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-456-132-pattern-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 456. 132 Pattern （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j].&lt;br&gt;
Return true if there is a 132 pattern in nums, otherwise, return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def find132pattern(self, nums: List[int]) -&amp;gt; bool:
        if len(nums) &amp;lt; 3:
            return False
        stack=[]
        min_array = [-1] * len(nums)
        min_array[0] = nums[0]
        for i in range(1, len(nums)):
            min_array[i] = min(min_array[i - 1], nums[i])
        
        
        for j in range(len(nums) - 1, -1, -1):
            if nums[j] &amp;lt;= min_array[j]:
                continue
            while stack and stack[-1] &amp;lt;= min_array[j]:
                stack.pop()
            if stack and stack[-1] &amp;lt; nums[j]:
                return True
            stack.append(nums[j])
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;估计是用stack但是。。。看答案思路：从前往后算minarry，从后往前用stack。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-457-circular-array-loop-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 457. Circular Array Loop （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:&lt;br&gt;
If nums[i] is positive, move nums[i] steps forward, and&lt;br&gt;
If nums[i] is negative, move nums[i] steps backward.&lt;br&gt;
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.&lt;br&gt;
A cycle in the array consists of a sequence of indices seq of length k where:&lt;br&gt;
Following the movement rules above results in the repeating index sequence seq[0] -&amp;gt; seq[1] -&amp;gt; ... -&amp;gt; seq[k - 1] -&amp;gt; seq[0] -&amp;gt; ...&lt;br&gt;
Every nums[seq[j]] is either all positive or all negative.&lt;br&gt;
k &amp;gt; 1&lt;br&gt;
Return true if there is a cycle in nums, or false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def circularArrayLoop(self, nums: List[int]) -&amp;gt; bool:
        #two pointer
        n=len(nums)
        #check every start location
        for start in range(n):
            if nums[start]==0: continue
                
            slow=start
            fast=(slow+nums[slow])%n
            
            #if sign of fast and fast.next is the same we do the while loop
            while nums[start]*nums[fast]&amp;gt;0 and  nums[start] * nums[(fast+nums[fast])%n] &amp;gt; 0:
                if slow == fast:
                    if slow == (slow+nums[slow])%n:  
                        break #  1-element loop
                    return True 


                slow = (slow+nums[slow])%n
                fast = (fast+nums[fast])%n
                fast = (fast+nums[fast])%n
            
            #we are here know start from start have no loop so mark visited as 0
            slow = start 
            sgn = nums[start] 
            while sgn * nums[slow] &amp;gt; 0:
                nxt = (slow+nums[slow])%n
                nums[slow] = 0 
                slow = nxt 

        return False
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer, but tricky ....if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.&lt;/p&gt;
&lt;h1 id=&#34;458-poor-pigs-hard&#34;&gt;458. Poor Pigs (Hard)&lt;/h1&gt;
&lt;p&gt;There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.&lt;br&gt;
You can feed the pigs according to these steps:&lt;br&gt;
Choose some live pigs to feed.&lt;br&gt;
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.&lt;br&gt;
Wait for minutesToDie minutes. You may not feed any other pigs during this time.&lt;br&gt;
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.&lt;br&gt;
Repeat this process until you run out of time.&lt;br&gt;
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&amp;gt; int:
        return int(math.ceil(math.log(buckets, 2) / math.log(minutesToTest / minutesToDie + 1, 2)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;good to knwo but not algorithm..&lt;/p&gt;
&lt;h1 id=&#34;459-repeated-substring-pattern-easy&#34;&gt;459. Repeated Substring Pattern （Easy）&lt;/h1&gt;
&lt;p&gt;Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def repeatedSubstringPattern(self, s: str) -&amp;gt; bool:
        for i in range(1,len(s)//2+1):
            if s[:i]*(len(s)//i)==s:
                return True
        return False
#ANSWER
def repeatedSubstringPattern(self, str):

        &amp;quot;&amp;quot;&amp;quot;
        :type str: str
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        if not str:
            return False
            
        ss = (str + str)[1:-1]
        return ss.find(str) != -1
#ANSWER
def repeatedSubstringPattern(self, str):
    return s in (s+s)[1:-1]
    

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案思路很好， If the string S has repeated block, it could be described in terms of pattern.&lt;br&gt;
S = SpSp (For example, S has two repeatable block at most)&lt;br&gt;
If we repeat the string, then SS=SpSpSpSp.&lt;br&gt;
Destroying first and the last pattern by removing each character, we generate a new S2=SxSpSpSy.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-460-lfu-cache-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 460. LFU Cache （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Design and implement a data structure for a Least Frequently Used (LFU) cache.&lt;br&gt;
Implement the LFUCache class:&lt;br&gt;
LFUCache(int capacity) Initializes the object with the capacity of the data structure.&lt;br&gt;
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.&lt;br&gt;
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.&lt;br&gt;
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.&lt;br&gt;
When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.&lt;br&gt;
The functions get and put must each run in O(1) average time complexity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import collections

class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.freq = 1
        self.prev = self.next = None

class DLinkedList:
    &amp;quot;&amp;quot;&amp;quot; An implementation of doubly linked list.
	
	Two APIs provided:
    
    append(node): append the node to the head of the linked list.
    pop(node=None): remove the referenced node. 
                    If None is given, remove the one from tail, which is the least recently used.
                    
    Both operation, apparently, are in O(1) complexity.
    &amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        self._sentinel = Node(None, None) # dummy node
        self._sentinel.next = self._sentinel.prev = self._sentinel
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def append(self, node):
        node.next = self._sentinel.next
        node.prev = self._sentinel
        node.next.prev = node
        self._sentinel.next = node
        self._size += 1
    
    def pop(self, node=None):
        if self._size == 0:
            return
        
        if not node:
            node = self._sentinel.prev

        node.prev.next = node.next
        node.next.prev = node.prev
        self._size -= 1
        
        return node
        
class LFUCache:
    def __init__(self, capacity):
        &amp;quot;&amp;quot;&amp;quot;
        :type capacity: int
        
        Three things to maintain:
        
        1. a dict, named as `self._node`, for the reference of all nodes given key.
           That is, O(1) time to retrieve node given a key.
           
        2. Each frequency has a doubly linked list, store in `self._freq`, where key
           is the frequency, and value is an object of `DLinkedList`
        
        3. The min frequency through all nodes. We can maintain this in O(1) time, taking
           advantage of the fact that the frequency can only increment by 1. Use the following
		   two rules:
           
           Rule 1: Whenever we see the size of the DLinkedList of current min frequency is 0,
                   the min frequency must increment by 1.
           
           Rule 2: Whenever put in a new (key, value), the min frequency must 1 (the new node)
           
        &amp;quot;&amp;quot;&amp;quot;
        self._size = 0
        self._capacity = capacity
        
        self._node = dict() # key: Node
        self._freq = collections.defaultdict(DLinkedList)
        self._minfreq = 0
        
        
    def _update(self, node):
        &amp;quot;&amp;quot;&amp;quot; 
        This is a helper function that used in the following two cases:
        
            1. when `get(key)` is called; and
            2. when `put(key, value)` is called and the key exists.
         
        The common point of these two cases is that:
        
            1. no new node comes in, and
            2. the node is visited one more times -&amp;gt; node.freq changed -&amp;gt; 
               thus the place of this node will change
        
        The logic of this function is:
        
            1. pop the node from the old DLinkedList (with freq `f`)
            2. append the node to new DLinkedList (with freq `f+1`)
            3. if old DlinkedList has size 0 and self._minfreq is `f`,
               update self._minfreq to `f+1`
        
        All of the above opeartions took O(1) time.
        &amp;quot;&amp;quot;&amp;quot;
        freq = node.freq
        
        self._freq[freq].pop(node)
        if self._minfreq == freq and not self._freq[freq]:
            self._minfreq += 1
        
        node.freq += 1
        freq = node.freq
        self._freq[freq].append(node)
    
    def get(self, key):
        &amp;quot;&amp;quot;&amp;quot;
        Through checking self._node[key], we can get the node in O(1) time.
        Just performs self._update, then we can return the value of node.
        
        :type key: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if key not in self._node:
            return -1
        
        node = self._node[key]
        self._update(node)
        return node.val

    def put(self, key, value):
        &amp;quot;&amp;quot;&amp;quot;
        If `key` already exists in self._node, we do the same operations as `get`, except
        updating the node.val to new value.
        
        Otherwise, the following logic will be performed
        
        1. if the cache reaches its capacity, pop the least frequently used item. (*)
        2. add new node to self._node
        3. add new node to the DLinkedList with frequency 1
        4. reset self._minfreq to 1
        
        (*) How to pop the least frequently used item? Two facts:
        
        1. we maintain the self._minfreq, the minimum possible frequency in cache.
        2. All cache with the same frequency are stored as a DLinkedList, with
           recently used order (Always append at head)
          
        Consequence? ==&amp;gt; The tail of the DLinkedList with self._minfreq is the least
                         recently used one, pop it...
        
        :type key: int
        :type value: int
        :rtype: void
        &amp;quot;&amp;quot;&amp;quot;
        if self._capacity == 0:
            return
        
        if key in self._node:
            node = self._node[key]
            self._update(node)
            node.val = value
        else:
            if self._size == self._capacity:
                node = self._freq[self._minfreq].pop()
                del self._node[node.key]
                self._size -= 1
                
            node = Node(key, value)
            self._node[key] = node
            self._freq[1].append(node)
            self._minfreq = 1
            self._size += 1


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each key is mapping to the corresponding node (self._node), where we can retrieve the node in O(1) time.&lt;/p&gt;
&lt;p&gt;Each frequency freq is mapped to a Doubly Linked List (self._freq), where all nodes in the DLinkedList have the same frequency, freq. Moreover, each node will be always inserted in the head (indicating most recently used).&lt;/p&gt;
&lt;p&gt;A minimum frequency self._minfreq is maintained to keep track of the minimum frequency of across all nodes in this cache, such that the DLinkedList with the min frequency can always be retrieved in O(1) time.&lt;/p&gt;
&lt;p&gt;Here is how the algorithm works&lt;/p&gt;
&lt;p&gt;get(key)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query the node by calling self._node[key]
find the frequency by checking node.freq, assigned as f, and query the DLinkedList that this node is in, through calling self._freq[f]
pop this node
update node&#39;s frequence, append the node to the new DLinkedList with frequency f+1
if the DLinkedList is empty and self._minfreq == f, update self._minfreq to f+1.
return node.val
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;put(key, value)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;If key is already in cache, do the same thing as get(key), and update node.val as value
Otherwise:
    if the cache is full, pop the least frequenly used element (*)
    add new node to self._node
    add new node to self._freq[1]
    reset self._minfreq to 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(*) The least frequently used element is the tail element in the DLinkedList with frequency self._minfreq&lt;/p&gt;
">Leetcode 2022-03-06</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-05/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;441-arranging-coins-easy&#34;&gt;441. Arranging Coins （Easy）&lt;/h1&gt;
&lt;p&gt;You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.&lt;br&gt;
Given the integer n, return the number of complete rows of the staircase you will build.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def arrangeCoins(self, n: int) -&amp;gt; int:
        r=0
        while n&amp;gt;0:
            r+=1
            n-=r
        return r-1 if n&amp;lt;0 else r

class Solution:
    def arrangeCoins(self, n: int) -&amp;gt; int:
        
        # (1+ x) x /2 &amp;lt;= n
        #      (1+x)x &amp;lt;= 2n
        # max x which (1+x)x &amp;lt;=2n
        
        l, r = 0, n
        
        while l &amp;lt;= r:
            
            m = (l + r) // 2
            
            if (m+1)*m &amp;lt;= 2*n and (m+2)*(m+1) &amp;gt; 2*n:
                return m
            
            if (m+1)*m &amp;lt; 2*n:
                l = m + 1
            else:
                r = m - 1
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案是binary  search啊。。&lt;/p&gt;
&lt;h1 id=&#34;442-find-all-duplicates-in-an-array-medium&#34;&gt;442. Find All Duplicates in an Array （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.&lt;br&gt;
You must write an algorithm that runs in O(n) time and uses only constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findDuplicates(self, nums: List[int]) -&amp;gt; List[int]:
        # 0 1 2 3 4 5 6 7
        # 4 3 2 7 8 2 3 1
        
        # -4 3 2-7    -3-1 
        
        n=len(nums)
        
        for i in range(n):
            ind=(abs(nums[i])%n-1)
            nums[ind] =   abs(nums[ind])+n if nums[ind]&amp;lt;0 else -abs(nums[ind])-n
        
        #print(nums)
        res=[]
        for i in range(n):
            if nums[i]&amp;gt;n:
                res.append(i+1)
        return res

#ANSWER
class Solution:
    def findDuplicates(self, nums: List[int]) -&amp;gt; List[int]:
        res=[]
        for n in nums:
            if nums[abs(n)-1]&amp;lt;0: #seen before
                res.append(abs(n))
            
            nums[abs(n)-1]*=-1
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊的bookkeeping。 答案写的更好&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-443-string-compression-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 443. String Compression （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of characters chars, compress it using the following algorithm:&lt;br&gt;
Begin with an empty string s. For each group of consecutive repeating characters in chars:&lt;br&gt;
If the group&#39;s length is 1, append the character to s.&lt;br&gt;
Otherwise, append the character followed by the group&#39;s length.&lt;br&gt;
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.&lt;br&gt;
After you are done modifying the input array, return the new length of the array.&lt;br&gt;
You must write an algorithm that uses only constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def compress(self, chars: List[str]) -&amp;gt; int:
        #two pointer
        l=0
        lchar=0
        r=0
        while r&amp;lt;len(chars):
            c=0
            while r&amp;lt;len(chars) and chars[r]==chars[l]:
                c+=1
                r+=1
            
            if c&amp;gt;0:r-=1
            
            if c==1:
                chars[lchar]=chars[l]
                l+=1
                lchar=lchar+1
            elif c&amp;gt;1 and c&amp;lt;10:
                chars[lchar]=chars[l]
                chars[lchar+1]=str(c)
                l=l+c
                lchar=lchar+2
            elif c&amp;gt;=10:
                chars[lchar]=chars[l]
                l=l+c
                for j,cc in enumerate(str(c)):
                    chars[lchar+1+j]=cc
                 
                lchar=lchar+len(str(c))+1
            r+=1    
            
        return lchar 
#ANSWER 更简单
 
class Solution:
    def compress(self, chars: List[str]) -&amp;gt; int:
        walker, runner = 0, 0
        while runner &amp;lt; len(chars):
		
            chars[walker] = chars[runner]
            count = 1
			
            while runner + 1 &amp;lt; len(chars) and chars[runner] == chars[runner+1]:
                runner += 1
                count += 1
			
            if count &amp;gt; 1:
                for c in str(count):
                    chars[walker+1] = c
                    walker += 1
            
            runner += 1
            walker += 1
        
        return walker

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 写出来了，但是cornercase很多边test边写的。。。。答案很简单。。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-444-sequence-reconstruction-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 444. Sequence Reconstruction (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.&lt;br&gt;
Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.&lt;br&gt;
For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].&lt;br&gt;
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.&lt;br&gt;
Return true if nums is the only shortest supersequence for sequences, or false otherwise.&lt;br&gt;
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -&amp;gt; bool:
        values = {x for seq in sequences for x in seq}
        graph = {x: [] for x in values}
        indegrees = {x: 0 for x in values}
        for seq in sequences:
            for i in range(len(seq) - 1):
                s = seq[i]
                t = seq[i+1]
                graph[s].append(t)
                indegrees[t] += 1
        queue = collections.deque()
        for node, count in indegrees.items():
            if count == 0:
                queue.append(node)
        res = []
        while queue:
            if len(queue) != 1:
                return False
            source = queue.popleft()
            res.append(source)
            for target in graph[source]:
                indegrees[target] -= 1
                if indegrees[target] == 0:
                    queue.append(target)
        return len(res) == len(values) and res == nums


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉题就没读懂。。。。topological sort... 第一步建立dependency graph， 第二部toposort，每一步检查是否只有一个node的可能性，如果比一个多，return False。 第三步，在得到toposortlist 后，检查长度是否和sequence中所有unique 元素个数一样而且 是input nums。&lt;br&gt;
解释：&lt;br&gt;
TopSort order exists&lt;br&gt;
Whether the TopSort order is the only one (Uniqueness of Topological sort, Hamilton path, see https://en.wikipedia.org/wiki/Topological_sorting#Uniqueness).如果不是，那么说明有些pair只有偏序关系，没有全序关系，这样不能完全确定元素之间的顺序&lt;br&gt;
the only top sort order constructed should be equal to the org.&lt;/p&gt;
&lt;p&gt;index == org.length (check condition 3) &amp;amp;&amp;amp; index == map.size() (check all the vertex in the graph has been visited, so the top sort order exists, check condition 1)&lt;/p&gt;
&lt;p&gt;How to check only one order? queue.size() should always be one, then only one element at a time has indegree to be 0, so you only have one choice (check condition 2)&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-445-add-two-numbers-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 445. Add Two Numbers II （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;br&gt;
You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        l1=rev(l1)
        l2=rev(l2)
        
        carry=0
        head=ListNode(val=None)
        savehead=head
        while l1 or l2:
            v1= l1.val if l1 else 0
            v2= l2.val if l2 else 0
            val=(v1+v2+carry)%10
            carry=(v1+v2+carry)//10
            head.next=ListNode(val)
            head=head.next
            
            l1=l1.next if l1 else None
            l2=l2.next if l2 else None
            
        if carry:
            head.next=ListNode(carry)
            head=head.next
        
        return rev(savehead.next)

#
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
        
 #####
 class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;followup 是不revlist能否。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-446-arithmetic-slices-ii-subsequence-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 446. Arithmetic Slices II - Subsequence (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the number of all the arithmetic subsequences of nums.&lt;br&gt;
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&lt;br&gt;
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.&lt;br&gt;
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.&lt;br&gt;
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.&lt;br&gt;
For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].&lt;br&gt;
The test cases are generated so that the answer fits in 32-bit integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&amp;gt; int:
        
        #f[i][d] denotes the number of weak arithmetic subsequences that ends with A[i] and its common difference is d.
        #Now the state transitions are quite straightforward:

        # for all j &amp;lt; i, f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1).
        # The 1 appears here because we can form a new weak arithmetic subsequence for the pair (i, j)
        
        #when we are appending new elements to existing weak arithmetic subsequences, we are forming arithmetic subsequences. So the first part, f[j][A[i] - A[j]] is the number of new formed arithmetic subsequences, and can be added to the answer.

        
        n=len(nums)
        res=0
        cnt=dict()
        for i in range(n):
            cnt[i]=dict()
            for j in range(i):
                delta=nums[i]-nums[j]
                
                diff=delta
                sum_=cnt[j].get(diff,0)
                origin=cnt[i].get(diff,0)
                cnt[i][diff]=origin+sum_+1
                res+=sum_
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是应该用DP但看答案。。。答案这个DP解法不是一般的DP。。。先dp【i】【diff】是以ith nums为最终位置的weak arithmetic subsequences的个数，这个weak值2个元素也能形成subsequence。 要想得到真正的3个元素的arithmetic subsequences个数，每次可以把nums【i】添加到dp【j】【diff】时候这个dp【j】【diff】个数就是arithmetic subsequences个数。很难想到这个方法啊。。。&lt;br&gt;
backtracking 方法超时&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    private int n;
    private int ans;
    private void dfs(int dep, int[] A, List&amp;lt;Long&amp;gt; cur) {
        if (dep == n) {
            if (cur.size() &amp;lt; 3) {
                return;
            }
            long diff = cur.get(1) - cur.get(0);
            for (int i = 1; i &amp;lt; cur.size(); i++) {                
                if (cur.get(i) - cur.get(i - 1) != diff) {
                    return;
                }
            }
            ans ++;
            return;
        }
        dfs(dep + 1, A, cur);
        cur.add((long)A[dep]);
        dfs(dep + 1, A, cur);
        cur.remove((long)A[dep]);
    }
    public int numberOfArithmeticSlices(int[] A) {
        n = A.length;
        ans = 0;
        List&amp;lt;Long&amp;gt; cur = new ArrayList&amp;lt;Long&amp;gt;();
        dfs(0, A, cur);
        return (int)ans;        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue-447-number-of-boomerangs-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 447. Number of Boomerangs (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).&lt;br&gt;
Return the number of boomerangs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&amp;gt; int:
        
        def dis(p1,p2):
            return (p1[0]-p2[0])**2+(p1[1]-p2[1])**2
        
        
        dic=collections.defaultdict(set)
        
        for i,p1 in enumerate(points):
            for j,p2 in enumerate(points):
                if i!=j:
                    dic[dis(p1,p2)].add((i,j))
                    dic[dis(p1,p2)].add((j,i))
        #print(dic)
        res=0
        for k, s in dic.items():
            #find i,j i,k
            d=dict()
            for t in s:
                d[t[0]]=d.get(t[0],0)+1
            
            #print(d)
            
            for key,val in d.items():
                res+= val*(val-1) if val&amp;gt;1 else 0
        
        return res
#ANSWER 同样思路但超级简单
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&amp;gt; int:
        res = 0
        for p in points:
            cmap = {}
            for q in points:
                f = p[0]-q[0]
                s = p[1]-q[1]
                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)
            for k in cmap:
                res += cmap[k] * (cmap[k] -1)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pass了 hashmap先按照距离分类， 然后每个距离下按照起始点分类，比如距离为1下 其实点为0的edge总共有n个，那么组成三角形能组成n*n-1个。&lt;/p&gt;
&lt;h1 id=&#34;448-find-all-numbers-disappeared-in-an-array-easy&#34;&gt;448. Find All Numbers Disappeared in an Array (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]:
        #
        n=len(nums)
        
        for i in range(n):
            ind = abs(nums[i])-1
            nums[ind]=-abs(nums[ind])
        
        res=[]
        for i in range(n):
            if nums[i]&amp;gt;0:
                res.append(i+1)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;449-serialize-and-deserialize-bst-medium&#34;&gt;449. Serialize and Deserialize BST (Medium)&lt;/h1&gt;
&lt;p&gt;Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;br&gt;
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.&lt;br&gt;
The encoded string should be as compact as possible.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: Optional[TreeNode]) -&amp;gt; str:
        &amp;quot;&amp;quot;&amp;quot;Encodes a tree to a single string.
        &amp;quot;&amp;quot;&amp;quot;
        res=[]
        def pre(root):
            if not root: 
                res.append(&#39;#&#39;)
                return
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
        return &#39;,&#39;.join(res)
        

    def deserialize(self, data: str) -&amp;gt; Optional[TreeNode]:
        &amp;quot;&amp;quot;&amp;quot;Decodes your encoded data to tree.
        &amp;quot;&amp;quot;&amp;quot;
        data=data.split(&#39;,&#39;)
        def pre(data):
            if not data: return None
            cur=data.pop(0) 
            root=None
            if cur!=&#39;#&#39;:
                root=TreeNode(int(cur))
            
            if root and data:
                root.left=pre(data)
            if root and data:
                root.right=pre(data)
            return root
        return pre(data)
            
#答案用postorder compressed string 更好
class Codec:
    def serialize(self, root):
        &amp;quot;&amp;quot;&amp;quot;
        Encodes a tree to a single string.
        &amp;quot;&amp;quot;&amp;quot;
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return &#39; &#39;.join(map(str, postorder(root)))

    def deserialize(self, data):
        &amp;quot;&amp;quot;&amp;quot;
        Decodes your encoded data to tree.
        &amp;quot;&amp;quot;&amp;quot;
        def helper(lower = float(&#39;-inf&#39;), upper = float(&#39;inf&#39;)):
            if not data or data[-1] &amp;lt; lower or data[-1] &amp;gt; upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(&#39; &#39;) if x]
        return helper()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用的pre order encode没想到写出来了。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-450-delete-node-in-a-bst-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 450. Delete Node in a BST （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.&lt;br&gt;
Basically, the deletion can be divided into two stages:&lt;br&gt;
Search for a node to remove.&lt;br&gt;
If the node is found, delete the node.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def successor(self, root):
        &amp;quot;&amp;quot;&amp;quot;
        One step right and then always left
        &amp;quot;&amp;quot;&amp;quot;
        root = root.right
        while root.left:
            root = root.left
        return root.val
    
    def predecessor(self, root):
        &amp;quot;&amp;quot;&amp;quot;
        One step left and then always right
        &amp;quot;&amp;quot;&amp;quot;
        root = root.left
        while root.right:
            root = root.right
        return root.val
        
    def deleteNode(self, root: TreeNode, key: int) -&amp;gt; TreeNode:
        if not root:
            return None
        
        # delete from the right subtree
        if key &amp;gt; root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key &amp;lt; root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # the node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是很经典的一个题目。recursion方法很经典。&lt;/p&gt;
">Leetcode 2022-03-05</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-04/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;431-encode-n-ary-tree-to-binary-tree-hard&#34;&gt;431. Encode N-ary Tree to Binary Tree （Hard）&lt;/h1&gt;
&lt;p&gt;Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&amp;quot;&amp;quot;&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
&amp;quot;&amp;quot;&amp;quot;

class Codec:
    # Encodes an n-ary tree to a binary tree.
    def encode(self, root: &#39;Optional[Node]&#39;) -&amp;gt; Optional[TreeNode]:
        if not root: return []
        rootnode = TreeNode(root.val)
        return_rootnode=rootnode
       
        first=True
        for node in root.children:
            if first:
                first=False
                rootnode.left=self.encode(node)
                rootnode=rootnode.left
            else:
                rootnode.right=self.encode(node)
                rootnode=rootnode.right
        
        return return_rootnode
	
	# Decodes your binary tree to an n-ary tree.
    def decode(self, data: Optional[TreeNode]) -&amp;gt; &#39;Optional[Node]&#39;:
        if not data: return None
        #print(data)
        #print(&#39;#&#39;*20)
        root=data
        root_node=Node(root.val,[])
        if root.left:
            root_node.children.append(self.decode(root.left))
            root=root.left
            while root.right:
                root_node.children.append(self.decode(root.right))
                root=root.right
        
        return root_node
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(root))


#ANSWER 
class Codec:

    def encode(self, root):
        if not root:
            return None

        binary = TreeNode(root.val)                 # create a binary root
        if not root.children:
            return binary
        #Python - left child for children, right child for siblings
        
        binary.left = self.encode(root.children[0]) # left child of binary is the encoding of all n-ary children,
        node = binary.left                          #     starting with the first child.
        for child in root.children[1:]:             # other children of n-ary root are right child of previous child
            node.right = self.encode(child)
            node = node.right

        return binary

    def decode(self, data):
        if not data:
            return None

        nary = Node(data.val, [])                   # create n-ary root
        node = data.left                            # move to first child of n-ary root
        while node:                                 # while more children of n-ary root
            nary.children.append(self.decode(node)) # append to list
            node = node.right                       # and move to next child
            
        return nary
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我得方法，把所有孩子都包含在下一层，  root的left通向下一层，root.left.right和之后所有的right都是同一层的保存孩子。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-432-all-oone-data-structure-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 432. All O`one Data Structure （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Design a data structure to store the strings&#39; count with the ability to return the strings with minimum and maximum counts.&lt;br&gt;
Implement the AllOne class:&lt;br&gt;
AllOne() Initializes the object of the data structure.&lt;br&gt;
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.&lt;br&gt;
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.&lt;br&gt;
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string &amp;quot;&amp;quot;.&lt;br&gt;
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string &amp;quot;&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from collections import defaultdict
class Node(object):
    def __init__(self):
        self.key_set = set([])
        self.prev, self.nxt = None, None 

    def add_key(self, key):
        self.key_set.add(key)

    def remove_key(self, key):
        self.key_set.remove(key)        

    def get_any_key(self):
        if self.key_set:
            result = self.key_set.pop()
            self.add_key(result)
            return result
        else:
            return None
    
    def count(self):
        return len(self.key_set)

    def is_empty(self):
        return len(self.key_set) == 0


class DoubleLinkedList(object):
    def __init__(self):
        self.head_node, self.tail_node = Node(), Node()
        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node
        return

    def insert_after(self, x):
        node, temp = Node(), x.nxt
        x.nxt, node.prev = node, x
        node.nxt, temp.prev = temp, node
        return node
    
    def insert_before(self, x):
        return self.insert_after(x.prev)

    def remove(self, x):
        prev_node = x.prev
        prev_node.nxt, x.nxt.prev = x.nxt, prev_node
        return

    def get_head(self):
        return self.head_node.nxt
    
    def get_tail(self):
        return self.tail_node.prev

    def get_sentinel_head(self):
        return self.head_node

    def get_sentinel_tail(self):
        return self.tail_node
    
class AllOne(object):
    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        &amp;quot;&amp;quot;&amp;quot;
        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)
        self.node_freq = {0:self.dll.get_sentinel_head()}

    def _rmv_key_pf_node(self, pf, key):
        node = self.node_freq[pf]
        node.remove_key(key)
        if node.is_empty():
            self.dll.remove(node)
            self.node_freq.pop(pf)
        return

    def inc(self, key):
        &amp;quot;&amp;quot;&amp;quot;
        Inserts a new key &amp;lt;Key&amp;gt; with value 1. Or increments an existing key by 1.
        :type key: str
        :rtype: void
        &amp;quot;&amp;quot;&amp;quot;
        self.key_counter[key] += 1
        cf, pf = self.key_counter[key], self.key_counter[key]-1
        if cf not in self.node_freq:
            # No need to test if pf = 0 since frequency zero points to sentinel node
            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])
        self.node_freq[cf].add_key(key)
        if pf &amp;gt; 0:
            self._rmv_key_pf_node(pf, key)

    def dec(self, key):
        &amp;quot;&amp;quot;&amp;quot;
        Decrements an existing key by 1. If Key&#39;s value is 1, remove it from the data structure.
        :type key: str
        :rtype: void
        &amp;quot;&amp;quot;&amp;quot;
        if key in self.key_counter:
            self.key_counter[key] -= 1
            cf, pf = self.key_counter[key], self.key_counter[key]+1
            if self.key_counter[key] == 0:
                self.key_counter.pop(key)
            if cf != 0:
                if cf not in self.node_freq:
                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])
                self.node_freq[cf].add_key(key)
            self._rmv_key_pf_node(pf, key)

    def getMaxKey(self):
        &amp;quot;&amp;quot;&amp;quot;
        Returns one of the keys with maximal value.
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &amp;gt; 0 else &amp;quot;&amp;quot;

    def getMinKey(self):
        &amp;quot;&amp;quot;&amp;quot;
        Returns one of the keys with Minimal value.
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() &amp;gt; 0 else &amp;quot;&amp;quot;




&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是个maxheap minheap。。。但不是all o（1）。。。 看答案了。。。答案果然完美&lt;/p&gt;
&lt;h1 id=&#34;433-minimum-genetic-mutation-medium&#34;&gt;433. Minimum Genetic Mutation (Medium)&lt;/h1&gt;
&lt;p&gt;A gene string can be represented by an 8-character long string, with choices from &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.&lt;br&gt;
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.&lt;br&gt;
For example, &amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot; is one mutation.&lt;br&gt;
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.&lt;br&gt;
Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.&lt;br&gt;
Note that the starting point is assumed to be valid, so it might not be included in the bank.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&amp;gt; int:
        #BFS search neighbor
        # neighor is 1 char off current also in bank
        if   end not in bank: return -1
        if not bank and start!=end: return -1
        bank=set(bank)
        bank.add(end)
        q=[]
        visited=set()
        def nei(me):
            neighbors=[]
            for other in bank:
                if other not in visited:
                    valid=0
                    for a,b in zip(me,other):
                        valid+=bool(ord(a)^ord(b))
                    if valid==1:
                        neighbors.append(other)
            return neighbors
        
        
        q.append(start)
        visited.add(start)
        level=0
        while q:
            level+=1
            for _ in range(len(q)):
                cur=q.pop(0)
                print(cur,nei(cur))
                for ne in nei(cur):
                    if ne==end: return level
                    visited.add(ne)
                    q.append(ne)
        
        return  -1
        
#ANSWER
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&amp;gt; int:
        &amp;quot;&amp;quot;&amp;quot;
        :type start: str
        :type end: str
        :type bank: List[str]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        queue = []
        queue.append((start,0))
        bankSet = set(bank)
        
        while queue:
            curr, step = queue.pop(0)
            if curr == end:
                return step
            for i in range(len(curr)):
                for c in &amp;quot;AGCT&amp;quot;:
                    mutation = curr[:i] + c + curr[i+1:]
                    if mutation in bankSet:
                        bankSet.remove(mutation)
                        queue.append((mutation,step+1))
                        
        return -1
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs注意corner case，end必须in bank。 答案用remove mutaton方式避免用visited set，而且mutaion是直接算的，不是从bank中找的。&lt;/p&gt;
&lt;h1 id=&#34;434-number-of-segments-in-a-string-easy&#34;&gt;434. Number of Segments in a String （Easy）&lt;/h1&gt;
&lt;p&gt;Given a string s, return the number of segments in the string.&lt;br&gt;
A segment is defined to be a contiguous sequence of non-space characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countSegments(self, s: str) -&amp;gt; int:
        beforeisspace=True
        c=0
        while s:
            if s[0]==&#39; &#39;:
                s=s[1:]
                beforeisspace=True
            else:
                if beforeisspace:
                    c+=1
                    beforeisspace=False
                
                s=s[1:]
        return c

class Solution:
    def countSegments(self, s: str) -&amp;gt; int:
        return len(s.split())

class Solution:
    def countSegments(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == &#39; &#39;) and s[i] != &#39; &#39;:
                segment_count += 1

        return segment_count
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-435-non-overlapping-intervals-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 435. Non-overlapping Intervals (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&amp;gt; int:
        #sort by start
        # [1,2] [1,3] [2,3],[3,4]
        #sort by end
        # 找最小删除相当于找最大不overlap有多少个interval
        #变成dp问题 dp[i]是最大的interval个数 用到ith interval
        # dp【i】= max（dp【j】）+1 j&amp;lt;i  interval i，j不overlap
        intervals=sorted(intervals,key=lambda x:x[0])
        dp = [0]*len(intervals)
        dp[0]=1
        ans=1
        for i in range(1,len(dp)):
            max_=0
            for j in range(i):
                if intervals[j][1]&amp;lt;=intervals[i][0]:
                    max_=max(dp[j],max_)
            
            dp[i]=max_+1
            ans=max(ans,dp[i])
        return len(intervals)-ans

#PASS ANSWER
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&amp;gt; int:
 
        intervals=sorted(intervals,key=lambda x:x[0])
        end=intervals[0][1]
        prev=0
        c=0
        for i in range(1,len(intervals)):
            if intervals[prev][1]&amp;gt;intervals[i][0]:
                #overlap
                if intervals[prev][1]&amp;gt;intervals[i][1]:
                    #include,bust del prev so c+=1 prev renew to i
                    prev=i
                
                #if pure overlap do greedy, prev still the same, del i, c+=1
                c+=1
            else:
                #case 1 two interval non overlapping
                prev=i
                
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没想出来如何处理~~ DP可以n^2， greedy也可以，Greedy nlogn&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-436-find-right-interval-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 436. Find Right Interval (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.&lt;br&gt;
The right interval for an interval i is an interval j such that startj &amp;gt;= endi and startj is minimized. Note that i may equal j.&lt;br&gt;
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#TIME LIMIT EXCEEDED
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&amp;gt; List[int]:
        maps=dict()
        for i,interval in enumerate(intervals):
            maps[tuple(interval)]=i
        
        ans=[-1]*len(intervals)
        intervals=sorted(intervals,key=lambda x:x[0])
        for i in range(len(intervals)-1):
            #i&#39;s right
            j=i+1
            while j&amp;lt;len(intervals) and intervals[j][0]&amp;lt;intervals[i][1]:
                j+=1
            if j&amp;lt;len(intervals):
                ans[maps[tuple(intervals[i])]]=maps[tuple(intervals[j])]
        return ans


#ANSWER BINARY SERACH 

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&amp;gt; List[int]:
        
        l = sorted((e[0], i) for i, e in enumerate(intervals))
        res = []
        for e in intervals:
            r = bisect.bisect_left(l, (e[1],))
            res.append(l[r][1] if r &amp;lt; len(l) else -1)
        return res

#Heap法
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&amp;gt; List[int]:
        heap, result = [], [-1] * len(intervals)
        for idx, interval in sorted(enumerate(intervals), key=lambda enum: enum[1][0]):
            while heap and heap[0][0] &amp;lt;= interval[0]:
                _, i = heapq.heappop(heap)
                if intervals[i][0]!=intervals[i][1]:
                    result[i] = idx
                else:
                    result[i] = i
            heapq.heappush(heap, (interval[1], idx))
        return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试 time limit exceeded 答案的bianry search法太厉害。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-437-path-sum-iii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 437. Path Sum III （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.&lt;br&gt;
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; int:
        #post order  botoom up save node val
        
        c=[0]
        def post(root):
            if not root: return 
            post(root.left)
            post(root.right)
            root.vals=defaultdict(int)
            if root.left:
                for v in root.left.vals:
                    root.vals[v+root.val]+=root.left.vals[v]
            if root.right:
                for v in root.right.vals:
                    root.vals[v+root.val]+=root.right.vals[v]
            root.vals[root.val]+=1
            if targetSum in root.vals:
                #print(root.val,root.vals)
                c[0]+=root.vals[targetSum]
       
        post(root)
        return c[0]  
#ANSWER PREFIX SUM in tree
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&amp;gt; int:
        def preorder(node: TreeNode, curr_sum) -&amp;gt; None:
            nonlocal count
            if not node:
                return 
            
            # current prefix sum
            curr_sum += node.val
            
            # here is the sum we&#39;re looking for
            if curr_sum == k:
                count += 1
            
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a path with sum k 
            # has occurred up to the current node
            count += h[curr_sum - k]
            
            # add the current sum into hashmap
            # to use it during the child nodes processing
            h[curr_sum] += 1
            
            # process left subtree
            preorder(node.left, curr_sum)
            # process right subtree
            preorder(node.right, curr_sum)
            
            # remove the current sum from the hashmap
            # in order not to use it during 
            # the parallel subtree processing
            h[curr_sum] -= 1
            
        count, k = 0, sum
        h = defaultdict(int)
        preorder(root, 0)
        return count       

#上面这个解决方法基于
class Solution:
    def subarraySum(self, nums, k):
        count = curr_sum = 0
        h = defaultdict(int)
        
        for num in nums:
            # current prefix sum
            curr_sum += num
            
            # situation 1:
            # continuous subarray starts 
            # from the beginning of the array
            if curr_sum == k:
                count += 1
            
            # situation 2:
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a subarray with sum k 
            # has occurred up to the current index
            count += h[curr_sum - k]
            
            # add the current sum
            h[curr_sum] += 1
                
        return count
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的解决方案是post order bottom up 扫，每个node存可以生成的pathsum值。答案是prefixsum。。&lt;/p&gt;
&lt;h1 id=&#34;438-find-all-anagrams-in-a-string-medium&#34;&gt;438. Find All Anagrams in a String （Medium）&lt;/h1&gt;
&lt;p&gt;Given two strings s and p, return an array of all the start indices of p&#39;s anagrams in s. You may return the answer in any order.&lt;br&gt;
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&lt;br&gt;
Input: s = &amp;quot;cbaebabacd&amp;quot;, p = &amp;quot;abc&amp;quot;&lt;br&gt;
Output: [0,6]&lt;br&gt;
Explanation:&lt;br&gt;
The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.&lt;br&gt;
The substring with start index = 6 is &amp;quot;bac&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findAnagrams(self, s: str, p: str) -&amp;gt; List[int]:
        if len(s)&amp;lt;len(p): return []
        dicp=collections.Counter(p)
        lp=len(p)
        dic=dict()
        for i in range(lp):
            dic[s[i]]=dic.get(s[i],0)+1
        res=[]
        if dic==dicp: res.append(0)
        for i in range(lp,len(s)):
            #remove first
            dic[s[i-lp]]-=1
            if dic[s[i-lp]]==0:
                del  dic[s[i-lp]]
            #add last
            dic[s[i]]=dic.get(s[i],0)+1
            #
            if dic==dicp:
                res.append(i-lp+1)
        return res
            
#ANSWER 写的更简单
from collections import Counter
class Solution:
    def findAnagrams(self, s: str, p: str) -&amp;gt; List[int]:
        ns, np = len(s), len(p)
        if ns &amp;lt; np:
            return []

        p_count = Counter(p)
        s_count = Counter()
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[s[i]] += 1
            # remove one letter 
            # from the left side of the window
            if i &amp;gt;= np:
                if s_count[s[i - np]] == 1:
                    del s_count[s[i - np]]
                else:
                    s_count[s[i - np]] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output

#ANSWER
class Solution:
    def findAnagrams(self, s: str, p: str) -&amp;gt; List[int]:
        ns, np = len(s), len(p)
        if ns &amp;lt; np:
            return []

        p_count, s_count = [0] * 26, [0] * 26
        # build reference array using string p
        for ch in p:
            p_count[ord(ch) - ord(&#39;a&#39;)] += 1
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[ord(s[i]) - ord(&#39;a&#39;)] += 1
            # remove one letter 
            # from the left side of the window
            if i &amp;gt;= np:
                s_count[ord(s[i - np]) - ord(&#39;a&#39;)] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sliding window保持counter dict和p一样就可以。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-439-ternary-expression-parser-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 439. Ternary Expression Parser （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string expression representing arbitrarily nested ternary expressions, evaluate the expression, and return the result of it.&lt;br&gt;
You can always assume that the given expression is valid and only contains digits, &#39;?&#39;, &#39;:&#39;, &#39;T&#39;, and &#39;F&#39; where &#39;T&#39; is true and &#39;F&#39; is false. All the numbers in the expression are one-digit numbers (i.e., in the range [0, 9]).&lt;br&gt;
The conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, &#39;T&#39; or &#39;F&#39;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def parseTernary(self, expression: str) -&amp;gt; str:
        #思路用stack，而且从后向前iterate
        #T?a:b
        if not expression: return expression
        stack=[]
        for char in expression[::-1]:
            if stack and stack[-1]==&#39;?&#39;:
                stack.pop() #?
                first=stack.pop()
                stack.pop() #:
                second=stack.pop()
                
                if char==&#39;T&#39;:
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(char)
        #print(stack)
        return stack[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;T？（a）：（b） 形式，但a，b可以包含再包含。。。很难分辨哪个冒号是分界线。 用stack应该，看答案。关键是从后向前。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-440-k-th-smallest-in-lexicographical-order-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 440. K-th Smallest in Lexicographical Order （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].&lt;br&gt;
Example 1:&lt;br&gt;
Input: n = 13, k = 2&lt;br&gt;
Output: 10&lt;br&gt;
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findKthNumber(self, n: int, k: int) -&amp;gt; int:
        class Trie:
            def __init__(self):
                self.children=collections.defaultdict(Trie)
                self.val=0
        trie=Trie()
        
        def insert(i):
            i=str(i)
            root=trie
            while i:
                cur=i[0]
                root=root.children[cur]
                root.val+=1
                i=i[1:]
        for i in range(1,n+1):
            insert(i)
        
        path=[]
        def search(k):
            current_rank=0
            children=trie.children
            i=0
            while current_rank&amp;lt;k:
                key=sorted(children)[i]
                if children[key].val+current_rank&amp;lt;k:
                    current_rank+=children[key].val
                    i+=1
                else:
                    path.append(key)
                    current_rank+=1
                    children=children[key].children
                    i=0
                
                
                 
                
                        
        search(k)
        return int(&#39;&#39;.join(path))
        
        
        
        
#ANSWER
&#39;&#39;&#39;
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don&#39;t really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.
&#39;&#39;&#39;
def findKthNumber(self, n, k):
        cur = 1
        k = k - 1
        while k &amp;gt; 0:
            steps = self.calSteps(n, cur)
            if steps &amp;lt;= k:
                cur += 1
                k -= steps
            else:
                cur *= 10
                k -= 1
        return cur

    def calSteps(self, n, cur):
        steps = 0
        n1, n2 = cur, cur + 1
        while n1 &amp;lt;= n:
            steps += min(n + 1, n2) - n1
            n1 *= 10
            n2 *= 10
        return steps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据提示用了trie，思路是对的，但是写seasrch func时候卡住了，given k，what is the node positon of kth node。就算写出来也是TLE。。。看答案。&lt;/p&gt;
&lt;p&gt;Main function&lt;br&gt;
Firstly, calculate how many steps curr need to move to curr + 1.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if the steps &amp;lt;= k, we know we can move to curr + 1, and narrow down k to k - steps.

else if the steps &amp;gt; k, that means the curr + 1 is actually behind the target node x in the preorder path, we can&#39;t jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;calSteps function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;how to calculate the steps between curr and curr + 1?
Here we come up a idea to calculate by level.
Let n1 = curr, n2 = curr + 1.
n2 is always the next right node beside n1&#39;s right most node (who shares the same ancestor &amp;quot;curr&amp;quot;)
(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).

so, if n2 &amp;lt;= n, what means n1&#39;s right most node exists, we can simply add the number of nodes from n1 to n2 to steps.

else if n2 &amp;gt; n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to steps.

organize this flow to &amp;quot;steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the code snippet:&lt;/p&gt;
&lt;p&gt;public int findKthNumber(int n, int k) {&lt;br&gt;
int curr = 1;&lt;br&gt;
k = k - 1;&lt;br&gt;
while (k &amp;gt; 0) {&lt;br&gt;
int steps = calSteps(n, curr, curr + 1);&lt;br&gt;
if (steps &amp;lt;= k) {&lt;br&gt;
curr += 1;&lt;br&gt;
k -= steps;&lt;br&gt;
} else {&lt;br&gt;
curr *= 10;&lt;br&gt;
k -= 1;&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
return curr;&lt;br&gt;
}&lt;br&gt;
//use long in case of overflow&lt;br&gt;
public int calSteps(int n, long n1, long n2) {&lt;br&gt;
int steps = 0;&lt;br&gt;
while (n1 &amp;lt;= n) {&lt;br&gt;
steps += Math.min(n + 1, n2) - n1;&lt;br&gt;
n1 *= 10;&lt;br&gt;
n2 *= 10;&lt;br&gt;
}&lt;br&gt;
return steps;&lt;br&gt;
}&lt;/p&gt;
">Leetcode 2022-03-04</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-03/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-421-maximum-xor-of-two-numbers-in-an-array-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 421. Maximum XOR of Two Numbers in an Array （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &amp;lt;= i &amp;lt;= j &amp;lt; n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; class Solution:
    def findMaximumXOR(self, nums: List[int]) -&amp;gt; int:
        res=0
        L=len(bin(max(nums)))-2
        for i in range(L-1,-1,-1):
            res &amp;lt;&amp;lt;=1
            cur_xor = res | 1
            prefixes = {n &amp;gt;&amp;gt; i  for n in nums}
            res |= any(cur_xor^p in prefixes for p in prefixes)
        return res
        
class Solution:
    def findMaximumXOR(self, nums: List[int]) -&amp;gt; int:
        L = len(bin(max(nums))) - 2
        max_xor = 0
        
        for i in reversed(range(L)):
            max_xor &amp;lt;&amp;lt;= 1
            # Set comprehension is used for speed purposes
            # List comprehension is what most pythonic users are used too imo
            prefixes = {num &amp;gt;&amp;gt; i for num in nums}
            curr_xor = max_xor | 1
            
            for p in prefixes:
                # if p1 ^ p2 == curr_xor then
                # p1 ^ curr_xor == p2 ( p2 is in prefixes)
                if p ^ curr_xor in prefixes:
                    # Set the last bit to 1
                    max_xor |= 1
                    
            
        return max_xor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路，看答案。&lt;/p&gt;
&lt;h1 id=&#34;422-valid-word-square-easy&#34;&gt;422. Valid Word Square (Easy)&lt;/h1&gt;
&lt;p&gt;Given an array of strings words, return true if it forms a valid word square.&lt;br&gt;
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &amp;lt;= k &amp;lt; max(numRows, numColumns).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def validWordSquare(self, words: List[str]) -&amp;gt; bool:
        rows=len(words)
        cols=max(map(len,words))
        for i,w in enumerate(words):
            if len(w)!=cols:
                words[i]=w+&#39;#&#39;*(cols-len(w))
        if rows!=cols: return False   
        
        for row in range(rows):
            for col in range(cols):
                if row&amp;gt;col:
                    if words[row][col]!=words[col][row]:
                        return False
        return True


public class Solution {
    public boolean validWordSquare(List&amp;lt;String&amp;gt; words) {
        if(words == null || words.size() == 0){
            return true;
        }
        int n = words.size();
        for(int i=0; i&amp;lt;n; i++){
            for(int j=0; j&amp;lt;words.get(i).length(); j++){
                if(j &amp;gt;= n || words.get(j).length() &amp;lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j))
                    return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有corner case。。。Java 答案更正确&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-423-reconstruct-original-digits-from-english-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 423. Reconstruct Original Digits from English （Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def originalDigits(self, s: &#39;str&#39;) -&amp;gt; &#39;str&#39;:
        # building hashmap letter -&amp;gt; its frequency
        count = collections.Counter(s)
        
        # building hashmap digit -&amp;gt; its frequency 
        out = {}
        # letter &amp;quot;z&amp;quot; is present only in &amp;quot;zero&amp;quot;
        out[&amp;quot;0&amp;quot;] = count[&amp;quot;z&amp;quot;]
        # letter &amp;quot;w&amp;quot; is present only in &amp;quot;two&amp;quot;
        out[&amp;quot;2&amp;quot;] = count[&amp;quot;w&amp;quot;]
        # letter &amp;quot;u&amp;quot; is present only in &amp;quot;four&amp;quot;
        out[&amp;quot;4&amp;quot;] = count[&amp;quot;u&amp;quot;]
        # letter &amp;quot;x&amp;quot; is present only in &amp;quot;six&amp;quot;
        out[&amp;quot;6&amp;quot;] = count[&amp;quot;x&amp;quot;]
        # letter &amp;quot;g&amp;quot; is present only in &amp;quot;eight&amp;quot;
        out[&amp;quot;8&amp;quot;] = count[&amp;quot;g&amp;quot;]
        # letter &amp;quot;h&amp;quot; is present only in &amp;quot;three&amp;quot; and &amp;quot;eight&amp;quot;
        out[&amp;quot;3&amp;quot;] = count[&amp;quot;h&amp;quot;] - out[&amp;quot;8&amp;quot;]
        # letter &amp;quot;f&amp;quot; is present only in &amp;quot;five&amp;quot; and &amp;quot;four&amp;quot;
        out[&amp;quot;5&amp;quot;] = count[&amp;quot;f&amp;quot;] - out[&amp;quot;4&amp;quot;]
        # letter &amp;quot;s&amp;quot; is present only in &amp;quot;seven&amp;quot; and &amp;quot;six&amp;quot;
        out[&amp;quot;7&amp;quot;] = count[&amp;quot;s&amp;quot;] - out[&amp;quot;6&amp;quot;]
        # letter &amp;quot;i&amp;quot; is present in &amp;quot;nine&amp;quot;, &amp;quot;five&amp;quot;, &amp;quot;six&amp;quot;, and &amp;quot;eight&amp;quot;
        out[&amp;quot;9&amp;quot;] = count[&amp;quot;i&amp;quot;] - out[&amp;quot;5&amp;quot;] - out[&amp;quot;6&amp;quot;] - out[&amp;quot;8&amp;quot;]
        # letter &amp;quot;n&amp;quot; is present in &amp;quot;one&amp;quot;, &amp;quot;nine&amp;quot;, and &amp;quot;seven&amp;quot;
        out[&amp;quot;1&amp;quot;] = count[&amp;quot;n&amp;quot;] - out[&amp;quot;7&amp;quot;] - 2 * out[&amp;quot;9&amp;quot;]

        # building output string
        output = [key * out[key] for key in sorted(out.keys())]
        return &amp;quot;&amp;quot;.join(output)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接做会出现是否要再次使用当前数字然后继续，或者直接使用下个数字，当前数字不重复使用的问题。&lt;br&gt;
解决方法。。。醉了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Letter &amp;quot;z&amp;quot; is present only in &amp;quot;zero&amp;quot;.
Letter &amp;quot;w&amp;quot; is present only in &amp;quot;two&amp;quot;.
Letter &amp;quot;u&amp;quot; is present only in &amp;quot;four&amp;quot;.
Letter &amp;quot;x&amp;quot; is present only in &amp;quot;six&amp;quot;.
Letter &amp;quot;g&amp;quot; is present only in &amp;quot;eight&amp;quot;.

Hence there is a good way to count even numbers.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is actually the key how to count 3s, 5s and 7s since some letters are present only in one odd and one even number (and all even numbers has already been counted) :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Letter &amp;quot;h&amp;quot; is present only in &amp;quot;three&amp;quot; and &amp;quot;eight&amp;quot;.
Letter &amp;quot;f&amp;quot; is present only in &amp;quot;five&amp;quot; and &amp;quot;four&amp;quot;.
Letter &amp;quot;s&amp;quot; is present only in &amp;quot;seven&amp;quot; and &amp;quot;six&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now one needs to count 9s and 1s only, and the logic is basically the same :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Letter &amp;quot;i&amp;quot; is present in &amp;quot;nine&amp;quot;, &amp;quot;five&amp;quot;, &amp;quot;six&amp;quot;, and &amp;quot;eight&amp;quot;.
Letter &amp;quot;n&amp;quot; is present in &amp;quot;one&amp;quot;, &amp;quot;seven&amp;quot;, and &amp;quot;nine&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-424-longest-repeating-character-replacement-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 424. Longest Repeating Character Replacement （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.&lt;br&gt;
Return the length of the longest substring containing the same letter you can get after performing the above operations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def characterReplacement(self, s: str, k: int) -&amp;gt; int:
        #   p
        # AABCBBA  k=2
        #       p
        #
        l = len(s)
        count = [0]*26
        start = 0
        maxCount = 0
        maxLength = 0
        for end in range(l):
            count[ord(s[end]) - ord(&#39;A&#39;)]+=1
            maxCount = max(maxCount, count[ord(s[end]) - ord(&#39;A&#39;)])
            while end - start + 1 - maxCount &amp;gt; k:
                count[ord(s[start]) - ord(&#39;A&#39;)]-=1
                start+=1
            
            maxLength = max(maxLength, end - start + 1);
        
        return maxLength
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉用dp的。。 感觉不对好像，提示是用two pointer sliding window， 不死磕看答案。&lt;br&gt;
end-start+1 = size of the current window&lt;br&gt;
maxCount = largest count of a single, unique character in the current window&lt;br&gt;
The main equation is: end-start+1-maxCount&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-425-word-squares-hard-font&#34;&gt;&lt;font  color=&#39;blue&#39;&gt; 425. Word Squares (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of unique strings words, return all the word squares you can build from words. The same word from words can be used multiple times. You can return the answer in any order.&lt;br&gt;
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &amp;lt;= k &amp;lt; max(numRows, numColumns).&lt;br&gt;
For example, the word sequence [&amp;quot;ball&amp;quot;,&amp;quot;area&amp;quot;,&amp;quot;lead&amp;quot;,&amp;quot;lady&amp;quot;] forms a word square because each word reads the same both horizontally and vertically.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wordSquares(self, words: List[str]) -&amp;gt; List[List[str]]:
        # a b c d
        # b d e f
        # c e g h 
        # d f h k
        
        # select abcd
        # next must select b
        # select abcd
        #        bdef
        # next must select ce
        # select abcd
        #        bdef
        #        cegh
        # next must selct dfh
        # select abcd
        #        bdef
        #        cegh
        #        dfhk
        #
        # need a trie tree to find prefix is valid or not
        # if valid prefix, for childern path, need to explore all possible combinations using bt
        
        class Trie:
            def __init__(self):
                self.children=dict()
                self.words=set()
                
            def search(self,string):
                if not string: return True
                if string[0] not in self.children:
                    return False
                return self.children[string[0]].search(string[1:])
            
            def getwords(self,string):
                if string is False: return True
                if len(string)==1:
                    return self.children[string].words
                
                return self.children[string[0]].getwords(string[1:])
                
                
        trie=Trie()
        #insert words to trie
        for word in words:
            cur=trie
            for w in word:
                if w not in cur.children:
                    cur.children[w] = Trie()
                cur.words.add(word)
                cur=cur.children[w]
            
        
        res=[]
        size=len(words[0])
        
        def bt(tmp,words):
            #backtracking to generate all possible word squares
            if len(tmp)==size:
                res.append(tmp[:])
                return
            if not words: return
            
            for word in words:
                tmp.append(word)
                level=len(tmp)
                searchkey=&#39;&#39;.join([e[level] for e in tmp]) if level&amp;lt;size else False
                if trie.search(searchkey):
                    validwords=trie.getwords(searchkey)
                    bt(tmp,validwords)
                tmp.pop()
        
        bt([],set(words))
        
        return res

#ANSWER is faster...
class Solution:
    def wordSquares(self, words: &#39;List[str]&#39;) -&amp;gt; &#39;List[List[str]]&#39;:
        
        dic= collections.defaultdict(list)
        n=len(words[0])
        for word in words:
            for i in range(1,n):
                key=word[:i]
                dic[key].append(word)
        
        res=[]        
        def build(squre):
            #print(len(squre))
            if len(squre)==n:
                res.append(squre)
                return
            #print(n,len(squre),squre)
            for word in dic[&#39;&#39;.join(list(zip(*squre))[len(squre)])]:
                new=squre[:]
                new.append(word)
                build(new)
        
        for word in words:
            build([word])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显backtracking问题。。。unbelievable 做出来了。。。&lt;/p&gt;
&lt;h1 id=&#34;426-convert-binary-search-tree-to-sorted-doubly-linked-list-medium&#34;&gt;426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium)&lt;/h1&gt;
&lt;p&gt;Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.&lt;br&gt;
You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.&lt;br&gt;
We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def treeToDoublyList(self, root: &#39;Optional[Node]&#39;) -&amp;gt; &#39;Optional[Node]&#39;:
        if not root: return root
        stack=[]
        head=None
        pre=None
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            cur=stack.pop()
            if head is None: head=cur
            cur.left=pre
            if pre:
                pre.right=cur 
            pre=cur
            
            root=cur.right
        
        
        #print(head.val, pre.val)
        
        head.left=pre
        pre.right=head
        
        return head


#ANSER RECURSION METHOD
class Solution:
    def treeToDoublyList(self, root: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        def helper(node):
            &amp;quot;&amp;quot;&amp;quot;
            Performs standard inorder traversal:
            left -&amp;gt; node -&amp;gt; right
            and links all nodes into DLL
            &amp;quot;&amp;quot;&amp;quot;
            nonlocal last, first
            if node:
                # left
                helper(node.left)
                # node 
                if last:
                    # link the previous node (last)
                    # with the current one (node)
                    last.right = node
                    node.left = last
                else:
                    # keep the smallest node
                    # to close DLL later on
                    first = node        
                last = node
                # right
                helper(node.right)
        
        if not root:
            return None
        
        # the smallest (first) and the largest (last) nodes
        first, last = None, None
        helper(root)
        # close DLL
        last.right = first
        first.left = last
        return first
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;corner case 要想清楚。。 而且node要call right left时候node必须存在。&lt;/p&gt;
&lt;h1 id=&#34;427-construct-quad-tree-medium&#34;&gt;427. Construct Quad Tree （Medium）&lt;/h1&gt;
&lt;p&gt;Given a n * n matrix grid of 0&#39;s and 1&#39;s only. We want to represent the grid with a Quad-Tree.&lt;br&gt;
Return the root of the Quad-Tree representing the grid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def construct(self, grid: List[List[int]]) -&amp;gt; &#39;Node&#39;:
        size=len(grid)
        if len({e for row in grid for e in row})==1:
            val=grid[0][0]==1
            isLeaf=True
            topLeft=None
            topRight=None
            bottomLeft=None
            bottomRight=None
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)
        else:
            isLeaf=False
            val=True
            topLeft=self.construct([row[:size//2] for row in grid[:size//2]])
            topRight=self.construct([row[size//2:] for row in grid[:size//2]])
            bottomLeft=self.construct([row[:size//2] for row in grid[size//2:]])
            bottomRight=self.construct([row[size//2:] for row in grid[size//2:]])
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-428-serialize-and-deserialize-n-ary-tree-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 428. Serialize and Deserialize N-ary Tree (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;br&gt;
Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&amp;quot;&amp;quot;&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&amp;quot;&amp;quot;&amp;quot;

class Codec:
    def serialize(self, root):
        &amp;quot;&amp;quot;&amp;quot;Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        r=[]
        if not root: return r
        q=[root]
        while q:
            node=q.pop(0)
            if node !=&#39;,&#39;:
                r.append(str(node.val))
                for child in node.children:
                    q.append(child)
                q.append(&#39;,&#39;)
            else:
                r.append(&#39;,&#39;)
                
        return &#39;#&#39;.join(r)
        
 
    
    def deserialize(self, data):
        &amp;quot;&amp;quot;&amp;quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        &amp;quot;&amp;quot;&amp;quot;
        if not data: return None
        pieces=data.split(&#39;#&#39;)
        root = Node(int(pieces[0]), [])
        idx = 1
        q=[root]
        while q:
            node=q.pop(0)
            while pieces[idx] != &#39;,&#39;:
                child=Node(int(pieces[idx]), [])
                node.children.append(child)
                q.append(child)
                idx += 1
            idx += 1
        return root
# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;first try failed， 若val可以重复，以val为key找parent的方法不再适用。 看答案。&lt;/p&gt;
&lt;h1 id=&#34;429-n-ary-tree-level-order-traversal-medium&#34;&gt;429. N-ary Tree Level Order Traversal (Medium)&lt;/h1&gt;
&lt;p&gt;Given an n-ary tree, return the level order traversal of its nodes&#39; values.&lt;br&gt;
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&amp;gt; List[List[int]]:
        if not root: return []
        q=[root]
        res=[]
        while q:
            l=len(q)
            level=[]
            for _ in range(l):
                cur=q.pop(0)
                level.append(cur.val)
                for child in cur.children:
                    q.append(child)
            res.append(level)
        return res

#RECURSION ANSWER
class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&amp;gt; List[List[int]]:

        def traverse_node(node, level):
            if len(result) == level:
                result.append([])
            result[level].append(node.val)
            for child in node.children:
                traverse_node(child, level + 1)

        result = []

        if root is not None:
            traverse_node(root, 0)
        return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BFS&lt;/p&gt;
&lt;h1 id=&#34;430-flatten-a-multilevel-doubly-linked-list-medium&#34;&gt;430. Flatten a Multilevel Doubly Linked List (Medium)&lt;/h1&gt;
&lt;p&gt;You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.&lt;br&gt;
Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.&lt;br&gt;
Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def flatten(self, head: &#39;Optional[Node]&#39;) -&amp;gt; &#39;Optional[Node]&#39;:
        
        stack=[]
        cur=head
        pre=None
        while cur or stack:
            if not cur:
                cur=stack.pop()
                cur.prev=pre
                pre.next=cur
                
            while cur.child:
                if cur.next:
                    stack.append(cur.next)
                curnext=cur.child
                curchild=cur.child
                cur.child=None
                curchild.prev=cur
                cur.next=curnext
                cur=curnext
               
            if not cur.child:
                pre=cur
                cur=cur.next
                
            
        return head


#

class Solution:
    def flatten(self, head: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        
        #DFS...
        curr=head
        tempStack = []
        while curr:
            if curr.child:
                if curr.next:
                    tempStack.append(curr.next);
                curr.next, curr.child.prev, curr.child = curr.child, curr, None;
            if not curr.next and len(tempStack):
                temp = tempStack.pop();
                temp.prev, curr.next = curr, temp
            curr = curr.next
        return head


 #ANSWER PREORDER   child is left tree next is right tree
 &amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&amp;quot;&amp;quot;&amp;quot;
class Solution(object):

    def flatten(self, head):
        if not head:
            return head

        # pseudo head to ensure the `prev` pointer is never none
        pseudoHead = Node(None, None, head, None)
        self.flatten_dfs(pseudoHead, head)

        # detach the pseudo head from the real head
        pseudoHead.next.prev = None
        return pseudoHead.next


    def flatten_dfs(self, prev, curr):
        &amp;quot;&amp;quot;&amp;quot; return the tail of the flatten list &amp;quot;&amp;quot;&amp;quot;
        if not curr:
            return prev

        curr.prev = prev
        prev.next = curr

        # the curr.next would be tempered in the recursive function
        tempNext = curr.next
        tail = self.flatten_dfs(curr, curr.child)
        curr.child = None
        return self.flatten_dfs(tail, tempNext)        

#preorder interative 
class Solution(object):
    def flatten(self, head):
        if not head:
            return

        pseudoHead = Node(0,None,head,None)
        prev = pseudoHead

        stack = []
        stack.append(head)

        while stack:
            curr = stack.pop()

            prev.next = curr
            curr.prev = prev

            if curr.next:
                stack.append(curr.next)
 
            if curr.child:
                stack.append(curr.child)
                # don&#39;t forget to remove all child pointers.
                curr.child = None

            prev = curr
        # detach the pseudo head node from the result.
        pseudoHead.next.prev = None
        return pseudoHead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;差点没做出来 写的比答案复杂&lt;/p&gt;
">Leetcode 2022-03-03</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-02/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-411-minimum-unique-word-abbreviation-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 411. Minimum Unique Word Abbreviation （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as &amp;quot;substitution&amp;quot; could be abbreviated as (but not limited to):&lt;br&gt;
&amp;quot;s10n&amp;quot; (&amp;quot;s ubstitutio n&amp;quot;)&lt;br&gt;
&amp;quot;sub4u4&amp;quot; (&amp;quot;sub stit u tion&amp;quot;)&lt;br&gt;
&amp;quot;12&amp;quot; (&amp;quot;substitution&amp;quot;)&lt;br&gt;
&amp;quot;su3i1u2on&amp;quot; (&amp;quot;su bst i t u ti on&amp;quot;)&lt;br&gt;
&amp;quot;substitution&amp;quot; (no substrings replaced)&lt;br&gt;
Note that &amp;quot;s55n&amp;quot; (&amp;quot;s ubsti tutio n&amp;quot;) is not a valid abbreviation of &amp;quot;substitution&amp;quot; because the replaced substrings are adjacent.&lt;br&gt;
The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation &amp;quot;s10n&amp;quot; has a length of 3 (2 letters + 1 substring) and &amp;quot;su3i1u2on&amp;quot; has a length of 9 (6 letters + 3 substrings).&lt;br&gt;
Given a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minAbbreviation(self, target: str, dictionary: List[str]) -&amp;gt; str:

        def abbr(target, num):
            word, count = &#39;&#39;, 0
            for w in target:
                if num &amp;amp; 1 == 1:
                    if count:
                        word += str(count)
                        count = 0
                    word += w
                else:
                    count += 1

                num &amp;gt;&amp;gt;= 1
            if count:
                word += str(count)
            return word

        m = len(target)

        # Figure out the different bits for a same length word in the dictionary
        diffs = []
        for word in dictionary:
            if len(word) != m:
                continue

            # The encoding is opposite
            bits = 0
            for i, char in enumerate(word):
                if char != target[i]:
                    bits += 2 ** i
            diffs.append(bits)

        # No word in dictionary has same length, return the shortest
        if not diffs:
            return str(m)        

        abbrs = []
        for i in range(2 ** m):
            # This abbreviation at least has one word different to every words in the dictionary
            if all(d &amp;amp; i for d in diffs):
                abbrs.append(abbr(target, i))

        return min(abbrs, key=lambda x: len(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路是bit manipulation。 1）找出在字典里同长度但字符和target不同的bit。 然后所有的encoding是0到2^m， 所以  all（encoding&amp;amp;dif for dif in diffs）  encoding的bit能和所有dif bits有交集则是个可能的候选，把 encoding bit转换为string然后加入到abbrs中，最后找出长度最小的abbrs就可以了。&lt;/p&gt;
&lt;h1 id=&#34;412-fizz-buzz-easy&#34;&gt;412. Fizz Buzz （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer n, return a string array answer (1-indexed) where:&lt;br&gt;
answer[i] == &amp;quot;FizzBuzz&amp;quot; if i is divisible by 3 and 5.&lt;br&gt;
answer[i] == &amp;quot;Fizz&amp;quot; if i is divisible by 3.&lt;br&gt;
answer[i] == &amp;quot;Buzz&amp;quot; if i is divisible by 5.&lt;br&gt;
answer[i] == i (as a string) if none of the above conditions are true.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fizzBuzz(self, n: int) -&amp;gt; List[str]:
        def helper(n):
            if n%3==0 and n%5==0:
                return &#39;FizzBuzz&#39;
            elif n%3==0:
                return &#39;Fizz&#39;
            elif n%5==0:
                return &#39;Buzz&#39;
            else:
                return str(n)
        
        return [helper(i) for i in range(1,n+1)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;413-arithmetic-slices-medium&#34;&gt;413. Arithmetic Slices (Medium)&lt;/h1&gt;
&lt;p&gt;An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&lt;br&gt;
For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.&lt;br&gt;
Given an integer array nums, return the number of arithmetic subarrays of nums.&lt;br&gt;
A subarray is a contiguous subsequence of the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&amp;gt; int:
        #   [1,3,5,7,9]
        # dp 0 0 1 
        #          2
        #            3  
        # dp is the number of subarays ending in ith
        if len(nums)&amp;lt;3: return 0
        dp=[0]*len(nums)
        if nums[0]-nums[1]==nums[1]-nums[2]:
            dp[2]=1
        
        if len(nums)==3: return dp[2]
        for i in range(3,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp[i]=1+dp[i-1]
        return sum(dp)
#ANSWER
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&amp;gt; int:
        dp=0
        res=0
        for i in range(2,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp=1+dp
                res+=dp
            else:
                dp=0
        return res        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路和答案一致，DP解决。&lt;/p&gt;
&lt;h1 id=&#34;414-third-maximum-number-easy&#34;&gt;414. Third Maximum Number （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def thirdMax(self, nums: List[int]) -&amp;gt; int:
        if len(set(nums))&amp;lt;3: return max(nums)
        if len(set(nums))==3: return sorted(set(nums))[0]
        res=[]
        for n in set(nums):
            heapq.heappush(res,-n)
        heapq.heappop(res)
        heapq.heappop(res)
        return -heapq.heappop(res)

#
class Solution:
    def thirdMax(self, nums: List[int]) -&amp;gt; int:
        maximums = set()
        for num in nums:
            maximums.add(num)
            if len(maximums) &amp;gt; 3:
                maximums.remove(min(maximums))
        if len(maximums) == 3:
            return min(maximums)
        return max(maximums)
#
class Solution:
    def thirdMax(self, nums: List[int]) -&amp;gt; int:
        min_heap = []
        for num in nums:
            if num in min_heap:
                continue
            if len(min_heap) &amp;lt; 3:
                heapq.heappush(min_heap, num)
            elif len(min_heap) == 3:
                heapq.heappushpop(min_heap, num)        
        
        if len(min_heap) == 3:
            return heapq.heappop(min_heap)
        else:
            while min_heap:
                result = heapq.heappop(min_heap)
            return result

#3pointer...
class Solution:
    def thirdMax(self, nums: List[int]) -&amp;gt; int:
        max=float(&#39;-inf&#39;)
        max2=float(&#39;-inf&#39;)
        max3=float(&#39;-inf&#39;)
        s=set()
        for n in nums:
            if n in s: continue
            if n&amp;gt;max:
                max3=max2
                max2=max
                max=n
            elif n&amp;gt;max2:
                max3=max2
                max2=n
            elif n&amp;gt;max3:
                max3=n
                
            s.add(n)
         
        return max3 if len(s)&amp;gt;=3 else max
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;415-add-strings-easy&#34;&gt;415. Add Strings (Easy)&lt;/h1&gt;
&lt;p&gt;Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.&lt;br&gt;
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def addStrings(self, num1: str, num2: str) -&amp;gt; str:
        
        n1=[int(e) for e in num1]
        n2=[int(e) for e in num2]
        res=[]
        carry=0
        while n1 or n2:
            a=n1.pop() if n1 else 0
            b=n2.pop() if n2 else 0
            val=(a+b+carry)%10
            carry=(a+b+carry)//10
            res.append(val)
        if carry:
            res.append(carry)
        
        return &#39;&#39;.join(map(str,res[::-1]))

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-416-partition-equal-subset-sum-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 416. Partition Equal Subset Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canPartition(self, nums: List[int]) -&amp;gt; bool:
        @lru_cache(None)
        def dfs(n,subset_sum):
            if subset_sum==0:
                return True
            if n==0 or subset_sum&amp;lt;0:
                return False
            result = dfs(n-1,subset_sum-nums[n-1]) or dfs(n-1,subset_sum)
            return result
        
        total_sum=sum(nums)
        if total_sum%2==1: return False
        subset_sum=total_sum//2
        n=len(nums)
        return dfs(n,subset_sum)
###DP
class Solution:
    def canPartition(self, nums: List[int]) -&amp;gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2
        n = len(nums)

        # construct a dp table of size (n+1) x (subset_sum + 1)
        # dp[n][subsetsum] up to nth num can sum to subsetsum
        dp = [[False] * (subset_sum + 1) for _ in range(n + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            curr = nums[i - 1]
            for j in range(subset_sum + 1):
                if j &amp;lt; curr:
                    # subset_sum&amp;lt; nums[i-1]   so, subsetsum not include nums[i-1]
                    dp[i][j] = dp[i - 1][j]
                else:
                    # could not include or include nums[i-1] 
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - curr]
        return dp[n][subset_sum]

#DP
class Solution:
    def canPartition(self, nums: List[int]) -&amp;gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2

        # construct a dp table of size (subset_sum + 1)
        dp = [False] * (subset_sum + 1)
        dp[0] = True
        for curr in nums:
            for j in range(subset_sum,curr-1,-1):
                dp[j] = dp[j] or dp[j - curr]

        return dp[subset_sum]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。 有两种情况，1) num in subset_sum  2) num not in subset_sum 所以dfs&lt;/p&gt;
&lt;h1 id=&#34;417-pacific-atlantic-water-flow-medium&#34;&gt;417. Pacific Atlantic Water Flow （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]:
        
        #two bfs from boundy if hight is higher..
        
        visited=set()
        q=[]
        m=len(heights)
        n=len(heights[0])
        for row in range(m):
            visited.add((row,0))
            q.append((row,0))
        for col in range(1,n):
            visited.add((0,col))
            q.append((0,col))
        
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&amp;gt;row&amp;gt;=0  and n&amp;gt;col&amp;gt;=0 and (row,col) not in visited and heights[row][col]&amp;gt;=heights[r][c]:
                    visited.add((row,col))
                    q.append((row,col))
        
        
        visited2=set()
        q=[]
        for row in range(m):
            visited2.add((row,n-1))
            q.append((row,n-1))
        for col in range(n-1):
            visited2.add((m-1,col))
            q.append((m-1,col))
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&amp;gt;row&amp;gt;=0  and n&amp;gt;col&amp;gt;=0 and (row,col) not in visited2 and heights[row][col]&amp;gt;=heights[r][c]:
                    visited2.add((row,col))
                    q.append((row,col))
        
        return visited&amp;amp;visited2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路，从边界处做两次BFS，相交地方就是结果。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-418-sentence-screen-fitting-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 418. Sentence Screen Fitting （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a rows x cols screen and a sentence represented as a list of strings, return the number of times the given sentence can be fitted on the screen.&lt;br&gt;
The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TIME LIMIT EXCEEDED
class Solution:
    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&amp;gt; int:
        sentence=[len(w) for w in sentence]
        r=0
        c_row=0
        res=0
        i=0
        while r&amp;lt;rows:
            
            l=sentence[i]
            #print(r,c_row,l)
            if c_row+l&amp;lt;cols:
                c_row = c_row+l+1
                if c_row==cols:
                    c_row=0
                    r+=1
                    if r&amp;gt;=rows:
                        if i==len(sentence)-1: res+=1
                        break
            elif c_row+l==cols:
                c_row=0
                r+=1
            elif c_row+l&amp;gt;cols:
                c_row=l+1
                r+=1
                if r&amp;gt;=rows:
                    break
                #print(&#39;#&#39;,c_row,r)
            if i==len(sentence)-1: res+=1
            i=(i+1)%len(sentence)
        return res

#ANSWER
#case 1: sentence_ptr at the end of the screen falls on space in the sentence. Go to the next letter sentence_ptr+1 in the next row of the screen.
#case 2: sentence_ptr at the end of the screen falls on the last letter of a word. We skip the space in the sentence as the last letter coincides with the screen end: sentence_ptr+2
#case 3: sentence_ptr points in the middle of a word at the end of the screen: roll back sentence_ptr till there&#39;s a space in the sentence. his corresponds to starting to fill the word in the next row, as it does not fit into the current. sentence_ptr &amp;gt; 0 is needed for the case when a word is longer than cols; sentence_ptr will be &amp;lt; len(s)

#Code with the comments and the variable change:

    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&amp;gt; int:
        s = &#39; &#39;.join(sentence) + &#39; &#39;
        sentence_ptr = 0
        for i in range(rows):
            sentence_ptr += cols - 1
            # case 1: sentence_ptr at the end of screen falls exactly on the space
            if s[sentence_ptr % len(s)] == &#39; &#39;:
                sentence_ptr += 1
            # case 2: sentence_ptr at the end of screen coincides with the last letter of a word (next is space)
            elif s[(sentence_ptr + 1) % len(s)] == &#39; &#39;:
                sentence_ptr += 2
            else:
                # case 3: sentence_ptr at the end of screen falls in the middle of a word; roll back
                while sentence_ptr &amp;gt; 0 and s[(sentence_ptr - 1) % len(s)] != &#39; &#39;:
                    sentence_ptr -= 1
        return sentence_ptr // len(s)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试是TLE。。。 直接暴力解即使考虑全了cornercase也还是过不了。&lt;br&gt;
答案思路，先组成一个句子 s=‘ ‘.join（sentence）+’‘。  定义sentence_ptr 每过一行，sentence_ptr+= cols-1 这时候分3种情况， 1） 如果恰巧sentence_ptr落的位置是空格，senternce_ptr+1 2)如果 sentence_ptr+1位置是空格，sentence_ptr+=2 3)sentence_ptr落在字符上，那么sentence_ptr得往回缩直到遇到空格。&lt;/p&gt;
&lt;h1 id=&#34;419-battleships-in-a-board-medium&#34;&gt;419. Battleships in a Board （Medium）&lt;/h1&gt;
&lt;p&gt;Given an m x n matrix board where each cell is a battleship &#39;X&#39; or empty &#39;.&#39;, return the number of the battleships on board.&lt;br&gt;
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countBattleships(self, board: List[List[str]]) -&amp;gt; int:
        
        m=len(board)
        n=len(board[0])
        
        visited=set()
        
        
        def dfs(row,col):
            #print(row,col)
            if row&amp;lt;0 or col&amp;lt;0 or row&amp;gt;=m or col&amp;gt;=n or (row,col) in visited: return
            visited.add((row,col))
            if board[row][col]==&#39;X&#39;:
                board[row][col]=&#39;.&#39;
                dfs(row+1,col)
                dfs(row-1,col)
                dfs(row,col+1)
                dfs(row,col-1)

        res=0
        for i in range(m):
            for j in range(n):
                if board[i][j]==&#39;X&#39;:
                    res+=1
                    dfs(i,j)
                    
        
        return res
#ANSWER
class Solution:
    def countBattleships(self, board: List[List[str]]) -&amp;gt; int:
 
        total = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == &#39;X&#39;:
                    flag = 1
                    if j &amp;gt; 0 and board[i][j-1] == &#39;X&#39;: flag = 0
                    if i &amp;gt; 0 and board[i-1][j] == &#39;X&#39;: flag = 0
                    total += flag
        return total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案没用DFS or BFS 但是很完美的解决了，因为只有横的竖的是叫做Battleships，所以如果不是左上角的X就不是一个qualified battlesships。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-420-strong-password-checker-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 420. Strong Password Checker （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A password is considered strong if the below conditions are all met:&lt;br&gt;
It has at least 6 characters and at most 20 characters.&lt;br&gt;
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.&lt;br&gt;
It does not contain three repeating characters in a row (i.e., &amp;quot;...aaa...&amp;quot; is weak, but &amp;quot;...aa...a...&amp;quot; is strong, assuming other conditions are met).&lt;br&gt;
Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.&lt;br&gt;
In one step, you can:&lt;br&gt;
Insert one character to password,&lt;br&gt;
Delete one character from password, or&lt;br&gt;
Replace one character of password with another character.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def strongPasswordChecker(self,s: str) -&amp;gt; int:
        
        missing_type = 3
        if any(&#39;a&#39; &amp;lt;= c &amp;lt;= &#39;z&#39; for c in s): missing_type -= 1
        if any(&#39;A&#39; &amp;lt;= c &amp;lt;= &#39;Z&#39; for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p &amp;lt; len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p &amp;lt; len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) &amp;lt; 6:
            return max(missing_type, 6 - len(s))
        elif len(s) &amp;lt;= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return delete + max(missing_type, change)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这题就头疼~，直接看答案了。&lt;br&gt;
当有20+chars，必须delete=len（s）-20.但是我们能用这些delete中的一部分来处理3char rule violation。&lt;br&gt;
1） aaa ... 这种violation可以del最后一个a。所以， 需要从change里减去这些del。change -= min(delete, one)&lt;br&gt;
2）aaaa ... 这种violation可以del最后2个a。因为已经用了1）中的deletions，所以需要调整,   min(max(delete - one, 0), two * 2) // 2  意思是，如果残留 max(delete - one, 0) 个dels，那么，用这些dels来处理case2的violation。 因为必须del 2 chars  to resolve each violation, 所以只能用 dels // 2&lt;br&gt;
3）aaaaa ...这种 violation可以del最后3个a。   max(delete - one - 2 * two, 0) // 3&lt;/p&gt;
">Leetcode 2022-03-02</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2022-03-01/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;中间搞laser project浪费了不少时间~~~&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-401-binary-watch-easy-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 401. Binary Watch (Easy) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.&lt;br&gt;
Given an integer turnedOn which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def readBinaryWatch(self, turnedOn: int) -&amp;gt; List[str]:
        return [&#39;{}:{}&#39;.format(h, str(m).zfill(2))  for h in range(12) for m in range(60) if (bin(h) + bin(m)).count(&#39;1&#39;) == turnedOn]

#Backtracking way of answer it
class Solution:
    def readBinaryWatch(self, turnedOn: int) -&amp;gt; List[str]:
        res=set()
        nums1=[8,4,2,1]
        nums2=[32,16,8,4,2,1]
        
        
        def generateDigs(nums,count):
            res=set()
            def helper(c,pos,sum_):
                if c==0:
                    res.add(sum_)
                    return
                for i in range(pos,len(nums)):
                    helper(c-1,i+1,sum_+nums[i])
            helper(count,0,0)
            return res
        
        for i in range(turnedOn+1):
            list1=generateDigs(nums1,i)
            list2=generateDigs(nums2,turnedOn-i)
            for num1 in list1:
                if num1&amp;gt;=12: continue
                for num2 in list2:
                    if num2&amp;gt;=60: continue
                    res.add(&#39;{}:{}&#39;.format(num1,str(num2).zfill(2)))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是一个backtracking问题， 写起来难度很大，然而是一个easy问题。。。直接暴力解即可。&lt;br&gt;
但用backtracking就是一个比较难的问题了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-402-remove-k-digits-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 402. Remove K Digits （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeKdigits(self, num: str, k: int) -&amp;gt; str:
        #
        # 2     1    4
        # left  cur
        # if cur&amp;lt;left, we know left must be removed
        
        stack=[]
        for n in num:
            while k and stack and n&amp;lt;stack[-1]:
                stack.pop()
                k-=1
            stack.append(n)
        
        #truncate remaining k digits at the end
        # if k==0 return entire list
        final_stack=stack[:-k] if k else stack
        
        return &#39;&#39;.join(final_stack).lstrip(&#39;0&#39;) or &#39;0&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;greedy+stack 这个方法第一次比较难想到，需要考虑corner case。&lt;/p&gt;
&lt;h1 id=&#34;403-frog-jump-hard&#34;&gt;403. Frog Jump （Hard）&lt;/h1&gt;
&lt;p&gt;A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&lt;br&gt;
Given a list of stones&#39; positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.&lt;br&gt;
If the frog&#39;s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canCross(self, stones: List[int]) -&amp;gt; bool:
       
        dp=[False]*len(stones)
        dic={s:i for i,s in enumerate(stones)}
        
        @lru_cache(None)
        def can(ith,k):
            if k&amp;lt;=0: return
            if ith==0:
                dp[0]=True
                if stones[0]+1 in dic:
                    jth=dic[stones[0]+1] 
                    can(jth,1)
            else:
                for i,step in enumerate([k+1,k,k-1]):
                    if stones[ith]+step in dic:
                        stone_ind=dic[stones[ith]+step]
                        dp[stone_ind]=True
                        can(stone_ind,[k+1,k,k-1][i])
            
        can(0,1)
        return dp[-1]

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&amp;gt; bool:
        
        dic=dict()
        for s in stones:
            dic[s]=set()
        dic[0].add(0)
        
        for i in range(len(stones)):
            for k in dic[stones[i]]:
                for step in range(k-1,k+2):
                    if step&amp;gt;0 and stones[i]+step in dic:
                        dic[stones[i]+step].add(step)
                        
        return len(dic[stones[-1]])&amp;gt;0

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&amp;gt; bool:
        
        seen = set()
        stoneSet = set(stones)
        end = stones[-1]
        stack = [(0, 0)]
        while len(stack) &amp;gt; 0:
            loc, steps = stack.pop()
            if (loc, steps) in seen:
                continue
            seen.add((loc, steps))
            if loc == end:
                return True
            elif loc &amp;lt; end:
                for i in range(steps-1, steps+2):
                    if i &amp;lt;= 0:
                        continue
                    if loc + i in stoneSet:
                        stack.append((loc+i, i))
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没想到做出来了。。。。。dp  with mem。。。&lt;br&gt;
答案更好。答案3思路： each node has 3 children. The goal is to check if we can reach to the end along the edges. We can do it with a Depth First Search with a Hashtable(to avoid redundant calculation)&lt;/p&gt;
&lt;h1 id=&#34;404-sum-of-left-leaves-easy&#34;&gt;404. Sum of Left Leaves （Easy）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the sum of all left leaves.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        if root.left and root.left.left is None and root.left.right is None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        return  self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;405-convert-a-number-to-hexadecimal-easy&#34;&gt;405. Convert a Number to Hexadecimal (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.&lt;br&gt;
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def toHex(self, num: int) -&amp;gt; str:
        if num&amp;lt;0:
            num=4294967295 +num+1
        map=[&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]
        res=&#39;&#39;
        while num:
            ind=num%16
            res+=map[ind]
            num=num//16
        #26=1a  16 11
        return res[::-1]   if res else &#39;0&#39;  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-406-queue-reconstruction-by-height-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 406. Queue Reconstruction by Height (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.&lt;br&gt;
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reconstructQueue(self, people: List[List[int]]) -&amp;gt; List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        output = []
        for p in people:
            output.insert(p[1], p)
        return output

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：最高的sort完了，插入次高的，插入位置？&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-407-trapping-rain-water-ii-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 407. Trapping Rain Water II （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -&amp;gt; int:
        
        class Cell:
            def __init__(self,row,col,h):
                self.row=row
                self.col=col
                self.h=h
            
            def __lt__(self,other):
                return self.h&amp;lt;other.h
            
        
        if not heightMap or len(heightMap)==0 or len(heightMap[0])==0:
            return 0
        
        q=[]
        m=len(heightMap)
        n=len(heightMap[0])
        visited=[[False]*n for _ in range(m)]
        #Initially, add all the Cells which are on borders to the queue.
        for i in range(m):
            visited[i][0]=True
            visited[i][n-1]=True
            heapq.heappush(q, Cell(i,0,heightMap[i][0]))
            heapq.heappush(q, Cell(i,n-1,heightMap[i][n-1]))
        for j in range(n):
            visited[0][j]=True
            visited[m-1][j]=True
            heapq.heappush(q, Cell(0,j,heightMap[0][j]))
            heapq.heappush(q, Cell(m-1,j,heightMap[m-1][j]))
        #from the borders, pick the shortest cell visited and check its neighbors: if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped add all its neighbors to the queue.
        dirs = [[-1,0],[1,0],[0,-1],[0,1]]
        res=0
        while q:
            cur_cell=heapq.heappop(q)
            for dir in dirs:
                row=cur_cell.row+dir[0]
                col=cur_cell.col+dir[1]
                if row&amp;gt;=0 and row&amp;lt;m and col&amp;gt;=0 and col&amp;lt;n and not visited[row][col]:
                    visited[row][col]=True
                    res+=max(0,cur_cell.h-heightMap[row][col])
                    heapq.heappush(q,Cell(row,col,max(cur_cell.h,heightMap[row][col])))
                    
        
        return res
                    
#ANSWER
class Solution(object):
    def trapRainWater(self, heightMap):
        if not heightMap or not heightMap[0]:
            return 0
        
        import heapq    
        m, n = len(heightMap), len(heightMap[0])
        heap = []
        visited = [[0]*n for _ in xrange(m)]

        # Push all the block on the border into heap
        for i in xrange(m):
            for j in xrange(n):
                if i == 0 or j == 0 or i == m-1 or j == n-1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = 1
        
        result = 0
        while heap:
            height, i, j = heapq.heappop(heap)    
            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and not visited[x][y]:
                    result += max(0, height-heightMap[x][y])
                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))
                    visited[x][y] = 1
        return result      
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：边界最低的板子是开始点，BFS，如果邻居低说明能存水，做计算，然后埋土。&lt;/p&gt;
&lt;h1 id=&#34;408-valid-word-abbreviation-easy&#34;&gt;408. Valid Word Abbreviation （Easy）&lt;/h1&gt;
&lt;p&gt;A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.&lt;br&gt;
For example, a string such as &amp;quot;substitution&amp;quot; could be abbreviated as (but not limited to):&lt;br&gt;
&amp;quot;s10n&amp;quot; (&amp;quot;s ubstitutio n&amp;quot;)&lt;br&gt;
&amp;quot;sub4u4&amp;quot; (&amp;quot;sub stit u tion&amp;quot;)&lt;br&gt;
&amp;quot;12&amp;quot; (&amp;quot;substitution&amp;quot;)&lt;br&gt;
&amp;quot;su3i1u2on&amp;quot; (&amp;quot;su bst i t u ti on&amp;quot;)&lt;br&gt;
&amp;quot;substitution&amp;quot; (no substrings replaced)&lt;br&gt;
The following are not valid abbreviations:&lt;br&gt;
&amp;quot;s55n&amp;quot; (&amp;quot;s ubsti tutio n&amp;quot;, the replaced substrings are adjacent)&lt;br&gt;
&amp;quot;s010n&amp;quot; (has leading zeros)&lt;br&gt;
&amp;quot;s0ubstitution&amp;quot; (replaces an empty substring)&lt;br&gt;
Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation.&lt;br&gt;
A substring is a contiguous non-empty sequence of characters within a string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -&amp;gt; bool:
        
        dig=0
        while abbr:
            
            if abbr[0].isdigit():
                if dig==0 and abbr[0]==&#39;0&#39;: return False
                dig=dig*10+int(abbr[0])
                abbr=abbr[1:]
            else:
                if dig!=0:
                    if len(word)&amp;lt;dig: return False
                    word=word[dig:]
                    dig=0
                else:
                    if not word: return False
                    if abbr[0]!=word[0]: return False
                    abbr=abbr[1:]
                    word=word[1:]
        if dig:
            if len(word)&amp;lt;dig: return False
            if not word: return False
            word=word[dig:]
         
        return not abbr and not word


&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-409-longest-palindrome-easy-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 409. Longest Palindrome (Easy) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.&lt;br&gt;
Letters are case sensitive, for example, &amp;quot;Aa&amp;quot; is not considered a palindrome here.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; int:
        dic=Counter(s)
        res=0
        for k,v in dic.items():
            res+=v//2*2
            if res%2==0 and v%2==1:
                res+=1
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到能组成palindrom的最长组合方式，如果是奇数个，可以变成偶数个，比如bbb只用bb。 但当res%2==0时候，遇到奇数情况可以加1.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-410-split-array-largest-sum-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 410. Split Array Largest Sum （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.&lt;br&gt;
Write an algorithm to minimize the largest sum among these m subarrays.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def splitArray(self, nums: List[int], m: int) -&amp;gt; int:
        # F[currIndex, subarrayCount] = 
        #  min(max(sum[currIndex, i], F[i + 1, subarrayCount - 1]))
        #        For all i in range [currIndex, n - subarrayCount]
        
        n=len(nums)
        prefix_sum=nums[:]
        for i in range(1,len(prefix_sum)):
            prefix_sum[i]+=prefix_sum[i-1]
        prefix_sum=[0]+prefix_sum
        
        @lru_cache(None)
        def get_min_largest_split_sum(cur_ind, m):
            if m==1:
                return prefix_sum[n]-prefix_sum[cur_ind]
            
            minimum_largest_split_sum=prefix_sum[n]
            for i in range(cur_ind,n-m+1):
                # Store the sum of the first subarray.
                first_split_sum=prefix_sum[i+1]-prefix_sum[cur_ind]
                # find the maxinum subaray sum ffor current frist split
                largest_split_sum=max(first_split_sum,get_min_largest_split_sum(i+1,m-1))
                #find the minum among all possible combinations
                minimum_largest_split_sum=min(minimum_largest_split_sum,largest_split_sum)
                
                if first_split_sum &amp;gt;= minimum_largest_split_sum: break
            
            return minimum_largest_split_sum
        
        return get_min_largest_split_sum(0,m)


#。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&amp;gt; int:
        n = len(nums)
        memo = [[0] * (m + 1) for _ in range(n)]
        
        # Create a prefix sum array of nums.
        prefix_sum = [0] + list(itertools.accumulate(nums))
        
        for subarray_count in range(1, m + 1):
            for curr_index in range(n):
                # Base Case: If there is only one subarray left, then all of the remaining numbers
                # must go in the current subarray. So return the sum of the remaining numbers.
                if subarray_count == 1:
                    memo[curr_index][subarray_count] = prefix_sum[n] - prefix_sum[curr_index]
                    continue

                # Otherwise, use the recurrence relation to determine the minimum largest subarray sum
                # between curr_index and the end of the array with subarray_count subarrays remaining.
                minimum_largest_split_sum = prefix_sum[n]
                for i in range(curr_index, n - subarray_count + 1):
                    # Store the sum of the first subarray.
                    first_split_sum = prefix_sum[i + 1] - prefix_sum[curr_index]

                    # Find the maximum subarray sum for the current first split.
                    largest_split_sum = max(first_split_sum, memo[i + 1][subarray_count - 1])

                    # Find the minimum among all possible combinations.
                    minimum_largest_split_sum = min(minimum_largest_split_sum, largest_split_sum)

                    if first_split_sum &amp;gt;= minimum_largest_split_sum:
                        break
            
                memo[curr_index][subarray_count] = minimum_largest_split_sum
        
        return memo[0][m]

#。。。。。。。。。。。。。。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&amp;gt; int:
        
        def min_subarrays_required(max_sum_allowed: int) -&amp;gt; int:
            current_sum = 0
            splits_required = 0
            
            for element in nums:
                # Add element only if the sum doesn&#39;t exceed max_sum_allowed
                if current_sum + element &amp;lt;= max_sum_allowed:
                    current_sum += element
                else:
                    # If the element addition makes sum more than max_sum_allowed
                    # Increment the splits required and reset sum
                    current_sum = element
                    splits_required += 1

            # Return the number of subarrays, which is the number of splits + 1
            return splits_required + 1
        
        # Define the left and right boundary of binary search
        left = max(nums)
        right = sum(nums)
        while left &amp;lt;= right:
            # Find the mid value
            max_sum_allowed = (left + right) // 2
            
            # Find the minimum splits. If splits_required is less than
            # or equal to m move towards left i.e., smaller values
            if min_subarrays_required(max_sum_allowed) &amp;lt;= m:
                right = max_sum_allowed - 1
                minimum_largest_split_sum = max_sum_allowed
            else:
                # Move towards right if splits_required is more than m
                left = max_sum_allowed + 1
        
        return minimum_largest_split_sum
###Binary Seasrch


class Solution(object):
    def splitArray(self, nums, m):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type m: int
        :rtype: int
        https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1042/discuss/89817/Clear-Explanation:-8ms-Binary-Search-Java?page=1
        &amp;quot;&amp;quot;&amp;quot;
 
        max_ = sum=0
        for  num in nums:
            max_ = max(num, max_);
            sum += num
            
            
        def valid(target, nums, m):
            count = 1
            total = 0
            for num in nums:
                total += num
                if total &amp;gt; target: 
                    total = num
                    count+=1
                    if count &amp;gt; m:
                        return False
                    
            return True
        
        if m == 1: return sum
        #binary search
        l = max_ 
        r = sum
        while l &amp;lt;= r:
            mid = (l + r)// 2;
            if  valid(mid, nums, m): 
                r = mid - 1 
            else: 
                l = mid + 1
            
        return l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无思路。。。m=2时候很容易，sort然后找到左右平衡点。m=3，4？&lt;br&gt;
DP很好， bianry search是最优解法。&lt;/p&gt;
">Leetcode 2022-03-01</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-12/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;91-perfect-rectangle-hard&#34;&gt;91. Perfect Rectangle （Hard）&lt;/h1&gt;
&lt;p&gt;Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).&lt;br&gt;
Return true if all the rectangles together form an exact cover of a rectangular region.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -&amp;gt; bool:
        x1 = float(&#39;inf&#39;)
        y1 = float(&#39;inf&#39;)
        x2 = float(&#39;-inf&#39;)
        y2 = float(&#39;-inf&#39;)
        _set = set()
        
        area = 0
        for rect in rectangles:
            x1 = min(x1, rect[0])
            y1 = min(y1, rect[1])
            x2 = max(x2, rect[2])
            y2 = max(y2, rect[3])
            
            area += (rect[2] - rect[0]) * (rect[3] - rect[1])
            
            for x, y in [(rect[0],rect[1]),(rect[0],rect[3]),(rect[2],rect[3]),(rect[2],rect[1])]:
                if (x, y) in _set:
                    _set.remove((x, y))
                else:
                    _set.add((x, y))
        return all((x, y) in _set for x, y in [(x1,y1),(x2,y2),(x1,y2),(x2,y1)]) and len(_set) == 4 and area == (x2 - x1) * (y2 - y1)

#MY ANSWER
class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -&amp;gt; bool:
        dic = dict()
        minx = miny = float(&#39;inf&#39;)
        maxx = maxy = float(&#39;-inf&#39;)
        area = 0 
        for x,y, a,b in rectangles:
            area+= (a-x) * (b-y)
            def add(x,y):
                if (x,y) not in dic: 
                    dic[(x,y)] =1
                else:
                    dic[(x,y)] -=1
                    if dic[(x,y)]==0:
                        del dic[(x,y)]
            
            add(x,y)
            add(x,b)
            add(a,b)
            add(a,y)
            
            minx=min(minx,x)
            miny=min(miny,y)
            maxx=max(maxx,a)
            maxy=max(maxy,b)

        return set(dic.keys()) == {(minx,miny),(minx,maxy),(maxx,miny),(maxx,maxy)}  and area== (maxx-minx)*(maxy-miny)

            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是exact cover of rectangular region 1）大的rectangle面积是所有小rectangle面积和 2） 所有的图中的点应该是偶数个，除了边界的4个点。&lt;/p&gt;
&lt;h1 id=&#34;392-is-subsequence-easy&#34;&gt;392. Is Subsequence (Easy)&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, return true if s is a subsequence of t, or false otherwise.&lt;br&gt;
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot; while &amp;quot;aec&amp;quot; is not).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
 #ANSWER           
class Solution:
    def isSubsequence(self, s: str, t: str) -&amp;gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&amp;lt;len(s) and p2&amp;lt;len(t):
            if s[p1]==t[p2]:
                p1+=1
            p2+=1
        if p1==len(s):
            return True
        return False
                     
#My ANSWER
class Solution:
    def isSubsequence(self, s: str, t: str) -&amp;gt; bool:
        if not s: return True
        start = 0
        for i, n in enumerate(t):
            if start&amp;lt;len(s) and s[start]==n:
                start+=1
        return start == len(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题竟然卡了，用了two pointer。。 答案写的更好。 只有相等时候s的pointer才跳，t的pointer一直跳，判断s的pointer到头就可以了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred393-utf-8-validation-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;393. UTF-8 Validation （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array data representing the data, return whether it is a valid UTF-8 encoding.&lt;br&gt;
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:&lt;br&gt;
For a 1-byte character, the first bit is a 0, followed by its Unicode code.&lt;br&gt;
For an n-bytes character, the first n bits are all one&#39;s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.&lt;/p&gt;
&lt;p&gt;This is how the UTF-8 encoding would work:&lt;/p&gt;
&lt;p&gt;Char. number range  |        UTF-8 octet sequence&lt;br&gt;
(hexadecimal)    |              (binary)&lt;br&gt;
--------------------+---------------------------------------------&lt;br&gt;
0000 0000-0000 007F | 0xxxxxxx&lt;br&gt;
0000 0080-0000 07FF | 110xxxxx 10xxxxxx&lt;br&gt;
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx&lt;br&gt;
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/p&gt;
&lt;p&gt;Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def validUtf8(self, data: List[int]) -&amp;gt; bool:
        
        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # For each integer in the data array.
        for num in data:

            # Get the binary representation. We only need the least significant 8 bits
            # for any given number.
            bin_rep = format(num, &#39;#010b&#39;)[-8:]

            # If this is the case then we are to start processing a new UTF-8 character.
            if n_bytes == 0:

                # Get the number of 1s in the beginning of the string.
                for bit in bin_rep:
                    if bit == &#39;0&#39;: break
                    n_bytes += 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &amp;gt; 4:
                    return False
            else:
                # Else, we are processing integers which represent bytes which are a part of
                # a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.
                if not (bin_rep[0] == &#39;1&#39; and bin_rep[1] == &#39;0&#39;):
                    return False

            # We reduce the number of bytes to process by 1 after each integer.
            n_bytes -= 1

        # This is for the case where we might not have the complete data for
        # a particular UTF-8 character.
        return n_bytes == 0  



#ANSWER BIT Manipulation
class Solution:
    def validUtf8(self, data):
        &amp;quot;&amp;quot;&amp;quot;
        :type data: List[int]
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;

        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # Mask to check if the most significant bit (8th bit from the left) is set or not
        mask1 = 1 &amp;lt;&amp;lt; 7

        # Mask to check if the second most significant bit is set or not
        mask2 = 1 &amp;lt;&amp;lt; 6
        for num in data:

            # Get the number of set most significant bits in the byte if
            # this is the starting byte of an UTF-8 character.
            mask = 1 &amp;lt;&amp;lt; 7
            if n_bytes == 0:
                while mask &amp;amp; num:
                    n_bytes += 1
                    mask = mask &amp;gt;&amp;gt; 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &amp;gt; 4:
                    return False
            else:

                # If this byte is a part of an existing UTF-8 character, then we
                # simply have to look at the two most significant bits and we make
                # use of the masks we defined before.
                if not (num &amp;amp; mask1 and not (num &amp;amp; mask2)):
                    return False
            n_bytes -= 1
        return n_bytes == 0     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看答案了，down vote比较多不是什么好题&lt;/p&gt;
&lt;h1 id=&#34;394-decode-string-medium&#34;&gt;394. Decode String （Medium）&lt;/h1&gt;
&lt;p&gt;Given an encoded string, return its decoded string.&lt;br&gt;
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.&lt;br&gt;
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.&lt;br&gt;
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        # 3[a2[c]]
        #
        # stack=[]
        #       [3]
        #       [3 [ a 2 [ c   ] 
        # 
        
        dig=&#39;&#39;
        stack=[]
        for char in s:
            if char.isdigit():
                dig+=char
            elif char==&#39;[&#39;:
                if dig:
                    stack.append(int(dig))
                stack.append(&#39;[&#39;)
                dig=&#39;&#39;
            elif char==&#39;]&#39;:
                string=[]
                while stack[-1]!=&#39;[&#39;:
                    string.append(stack.pop())
                string=&#39;&#39;.join(string[::-1])
                stack.pop() #pop掉【
                if type(stack[-1])==int:
                    string=stack.pop()*string
                stack.append(string)
                
                
            else:
                stack.append(char)
        
        return &#39;&#39;.join(stack)



 #3年前的答案估计是看的别人的一样的思路
 class Solution(object):
    def decodeString(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        num=&#39;0123456789&#39;
        s=[e for e in s]
        
        stack=[]
        
        while s:
            
            cur=s.pop(0)
            if cur in num:
                stack.append(int(cur))
            elif cur==&#39;[&#39;:
                stack.append(cur)
            elif cur==&#39;]&#39;:
                temp=[]
                while stack and stack[-1]!=&#39;[&#39;:
                    me=stack.pop()
                    temp.append(me)
                stack.pop()
                temp=&#39;&#39;.join(temp[::-1])
                number=0
                time=1
                while stack and type(stack[-1])==int:
                    number+=stack.pop()*time
                    time*=10
                stack.append(temp*number)
            else:
                stack.append(cur)
        return &#39;&#39;.join(stack)           


#MY ANSWER
class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        # 3 [ a2[c] ]
        # 
        
        stack = []
     
        i=0
        while i&amp;lt;len(s):
            if s[i].isdigit():
                val = s[i]
                while i+1&amp;lt;len(s) and s[i+1].isdigit():
                    i+=1
                    val+=s[i]
                stack.append(int(val))
            elif s[i] == &#39;[&#39;:
                stack.append(s[i])
            elif s[i] == &#39;]&#39;:
                #do calculation
                tmp = []
                while stack[-1]!=&#39;[&#39;:
                    tmp.append(stack.pop())
                tmp = &#39;&#39;.join(tmp[::-1]) #rev order due to stack
                #pop [    
                stack.pop()
                if type(stack[-1])==int:
                    tmp = tmp*stack.pop()
                stack.append(tmp)
               
            elif s[i].isalpha():
                tmp =s[i]
                while i+1&amp;lt;len(s) and s[i+1].isalpha():
                    i+=1
                    tmp+=s[i]
                stack.append(tmp)
               
            i+=1
     
        return &#39;&#39;.join(stack)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是用stack的确写出来了~~&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-395-longest-substring-with-at-least-k-repeating-characters-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 395. Longest Substring with At Least K Repeating Characters （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestSubstring(self, s: str, k: int) -&amp;gt; int:
        
        def helper(start,end):
            if end&amp;lt;k:return 0
            countMap=[0]*26
            for i in range(start,end):
                countMap[ord(s[i])-ord(&#39;a&#39;)]+=1
            for mid in range(start,end):
                if countMap[ord(s[mid])-ord(&#39;a&#39;)]&amp;gt;=k: continue
                midnext=mid+1
                while midnext&amp;lt;end and countMap[ord(s[midnext])-ord(&#39;a&#39;)]&amp;lt;k:
                    midnext+=1
                return max(helper(start,mid),helper(midnext,end))
            return end-start
        
        return helper(0,len(s))
            
#Perfect ANSWER
class Solution:
    def longestSubstring(self, s: str, k: int) -&amp;gt; int:
        for c in set(s):
            if s.count(c) &amp;lt; k:
                return max(self.longestSubstring(t, k) for t in s.split(c))
        return len(s)

#Sliding WIndow
class Solution:
    def longestSubstring(self, s: str, k: int) -&amp;gt; int:
        
        maxunique=len(set(s))
        res=0
        for cur_unique in range(1,maxunique+1):
            countmap=[0]*26
            start=end=unique=idx=countAtLeasetK=0
            while end &amp;lt;len(s):
                #expanding sliding window
                if unique&amp;lt;=cur_unique:
                    idx=ord(s[end])-ord(&#39;a&#39;)
                    if countmap[idx]==0:
                        unique+=1
                    countmap[idx]+=1
                    if countmap[idx]==k:
                        countAtLeasetK+=1
                    end+=1
                else:
                    #shrink sliding window
                    idx=ord(s[start])-ord(&#39;a&#39;)
                    if countmap[idx]==k:
                        countAtLeasetK-=1
                    countmap[idx]-=1
                    if countmap[idx]==0:
                        unique-=1
                    start+=1
                
                if unique==cur_unique and unique==countAtLeasetK:
                    res=max(res,end-start)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案的分治法很好，&lt;br&gt;
的确是tow pointer啊，但写不出来。。。思路：第一层for loop 用来扫 cur_unique 。 while  end 小于len(s)； 当unique小于cur_unique而且不到s末尾时， expand。记录unique he countAtLeastK大小，否则当unique大于cur_unique就收缩， 更新countAtLeastK和unique。 如果unique等于cur_unique 而且unique等于countAtLeastK，更新结果。&lt;br&gt;
最简单的是方法2解法，如果count（char)小于K就用char作为分界char，recursive call function。&lt;/p&gt;
&lt;h1 id=&#34;396-rotate-function-medium&#34;&gt;396. Rotate Function （Medium）&lt;/h1&gt;
&lt;p&gt;You are given an integer array nums of length n.&lt;br&gt;
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:&lt;br&gt;
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].&lt;br&gt;
Return the maximum value of F(0), F(1), ..., F(n-1).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxRotateFunction(self, nums: List[int]) -&amp;gt; int:
        #nums = [4,3,2,6]
        #F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
        #F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
        #     = F[0]+sum-4*6
        #F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
        #     = F[1]+sum-4*2
        #F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
        #     = F[2]+sum-4*3
        
        f0=0
        sum_=0
        for i,n in enumerate(nums):
            f0+=i*n
            sum_+=n
        res=f0
        for j in range(len(nums)-1,0,-1):
            f1=f0+sum_-len(nums)*nums[j]
            res=max(res,f1)
            f0=f1
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;397-integer-replacement-medium&#34;&gt;397. Integer Replacement (Medium)&lt;/h1&gt;
&lt;p&gt;Given a positive integer n, you can apply one of the following operations:&lt;br&gt;
If n is even, replace n with n / 2.&lt;br&gt;
If n is odd, replace n with either n + 1 or n - 1.&lt;br&gt;
Return the minimum number of operations needed for n to become 1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; #MY ANSWER
 class Solution:
    @lru_cache(None)
    def integerReplacement(self, n: int) -&amp;gt; int:
        if n==1: return 0
        if n%2==0:
            return 1+self.integerReplacement(n//2)
        else:
            return 1+min(self.integerReplacement(n+1),self.integerReplacement(n-1))       
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;398-random-pick-index-medium&#34;&gt;398. Random Pick Index （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.&lt;br&gt;
Implement the Solution class:&lt;br&gt;
Solution(int[] nums) Initializes the object with the array nums.&lt;br&gt;
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i&#39;s, then each index should have an equal probability of returning.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:

    def __init__(self, nums: List[int]):
        self.dic=collections.defaultdict(list)
        for i,n in enumerate(nums):
            self.dic[n].append(i)
        

    def pick(self, target: int) -&amp;gt; int:
        return random.choice(self.dic[target])
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;399-evaluate-division-medium&#34;&gt;399. Evaluate Division (Medium)&lt;/h1&gt;
&lt;p&gt;ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.&lt;br&gt;
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.&lt;br&gt;
Return the answers to all queries. If a single answer cannot be determined, return -1.0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&amp;gt; List[float]:
        
        # a-val-&amp;gt;b--val-&amp;gt;c
        

        graph = defaultdict(defaultdict)

        def backtrack_evaluate(curr_node, target_node, acc_product, visited):
            visited.add(curr_node)
            ret = -1.0
            neighbors = graph[curr_node]
            if target_node in neighbors:
                ret = acc_product * neighbors[target_node]
            else:
                for neighbor, value in neighbors.items():
                    if neighbor in visited:
                        continue
                    ret = backtrack_evaluate(
                        neighbor, target_node, acc_product * value, visited)
                    if ret != -1.0:
                        break
            visited.remove(curr_node)
            return ret

        # Step 1). build the graph from the equations
        for (dividend, divisor), value in zip(equations, values):
            # add nodes and two edges into the graph
            graph[dividend][divisor] = value
            graph[divisor][dividend] = 1 / value

        # Step 2). Evaluate each query via backtracking (DFS)
        #  by verifying if there exists a path from dividend to divisor
        results = []
        for dividend, divisor in queries:
            if dividend not in graph or divisor not in graph:
                # case 1): either node does not exist
                ret = -1.0
            elif dividend == divisor:
                # case 2): origin and destination are the same node
                ret = 1.0
            else:
                visited = set()
                ret = backtrack_evaluate(dividend, divisor, 1, visited)
            results.append(ret)

        return results


###UNIONFIND 变种
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&amp;gt; List[float]:

        gid_weight = {}

        def find(node_id):
            if node_id not in gid_weight:
                gid_weight[node_id] = (node_id, 1)
            group_id, node_weight = gid_weight[node_id]
            # The above statements are equivalent to the following one
            #group_id, node_weight = gid_weight.setdefault(node_id, (node_id, 1))

            if group_id != node_id:
                # found inconsistency, trigger chain update
                new_group_id, group_weight = find(group_id)
                gid_weight[node_id] =  (new_group_id, node_weight * group_weight)
            return gid_weight[node_id]

        def union(dividend, divisor, value):
            dividend_gid, dividend_weight = find(dividend)
            divisor_gid, divisor_weight = find(divisor)
            if dividend_gid != divisor_gid:
                # merge the two groups together,
                # by attaching the dividend group to the one of divisor
                gid_weight[dividend_gid] =  (divisor_gid, divisor_weight * value / dividend_weight)

        # Step 1). build the union groups
        for (dividend, divisor), value in zip(equations, values):
            union(dividend, divisor, value)

        results = []
        # Step 2). run the evaluation, with &amp;quot;lazy&amp;quot; updates in find() function
        for (dividend, divisor) in queries:
            if dividend not in gid_weight or divisor not in gid_weight:
                # case 1). at least one variable did not appear before
                results.append(-1.0)
            else:
                dividend_gid, dividend_weight = find(dividend)
                divisor_gid, divisor_weight = find(divisor)
                if dividend_gid != divisor_gid:
                    # case 2). the variables do not belong to the same chain/group
                    results.append(-1.0)
                else:
                    # case 3). there is a chain/path between the variables
                    results.append(dividend_weight / divisor_weight)
        return results

#MY SOLUTION
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&amp;gt; List[float]:

        #  a/b = 2     b/c =3
        #    2   3
        # a---&amp;gt;b---&amp;gt;c 
        #  &amp;lt;--- &amp;lt;---   
        #   0.5   1/3

        #graph problem 

        neis = defaultdict(set)
        ew = dict() #edge_weights = dict()

        for [a,b], v in zip(equations,values):
            neis[a].add(b)
            neis[b].add(a)
            key = &#39;-&#39;.join([a,b])
            ew[key] = v
            key = &#39;-&#39;.join([b,a])
            ew[key] = 1.0/v
        
        res = []
        
        def dfs(a,b, visited =set(),val=1):
            key = &#39;-&#39;.join([a,b])
            if  key in ew:
                return True,val*ew[key]
            
            else:
                for c in neis[a]:
                    if c not in visited:
                        visited.add(c)
                        key_ac = &#39;-&#39;.join([a,c])
                        tmp = dfs(c,b, visited,val*ew[key_ac])
                        visited.remove(c)
                        if tmp[0]:
                            return tmp
                        
            return False, -1.0



        for a, b in queries:
            if a==b and a in neis:
                res.append(1.0)
            elif a not in neis or b not in neis:
                res.append(-1.0)
            else:
                res.append(dfs(a,b)[1])
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看提示，是graph问题， 一开始就偏了。。。若是graph问题，则a-val-》b-val-》c，&lt;br&gt;
那么a-》c就是val1*val2，如果是c-》a找不到，就找a-c然后1/结果. 如果node不在里面就return -1，如果是自己-》自己return1&lt;br&gt;
还是第一种方法graph比较标准用DFS。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred400-nth-digit-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;400. Nth Digit （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findNthDigit(self, n: int) -&amp;gt; int:
        #1 ~ 9 include 9 one digit number;
        #10 ~ 99 include 90 two digits number;
        #100 ~ 999 include 900 three digits number;
        #1000 ~ 9999 include 9000 four digits number;
        #...
        #length is how many digits:1 or 2 or 3 ..., range is 9 or 90 or 900 ...
        
        length = 1
        num = 1 
        range_ = 9
        while n &amp;gt; length * range_:
            n -= length * range_
            length+=1
            range_ *= 10
            num *= 10
        num += (n - 1) // length
        return str(num)[ (n-1)%length]
		 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道思路，写时候卡。。。&lt;/p&gt;
">Leetcode 2021-12-12</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-11/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;381-insert-delete-getrandom-o1-duplicates-allowed-hard&#34;&gt;381. Insert Delete GetRandom O(1) - Duplicates allowed （Hard）&lt;/h1&gt;
&lt;p&gt;RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also removing a random element.&lt;br&gt;
Implement the RandomizedCollection class:&lt;br&gt;
RandomizedCollection() Initializes the empty RandomizedCollection object.&lt;br&gt;
bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.&lt;br&gt;
bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.&lt;br&gt;
int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of same values the multiset contains.&lt;br&gt;
You must implement the functions of the class such that each function works on average O(1) time complexity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RandomizedCollection:

    def __init__(self):
        self.lst = []
        self.idx = defaultdict(set)
        

    def insert(self, val: int) -&amp;gt; bool:
        self.idx[val].add(len(self.lst))
        self.lst.append(val)
        return len(self.idx[val]) == 1

    def remove(self, val: int) -&amp;gt; bool:
        if not self.idx[val]: return False
        remove, last = self.idx[val].pop(), self.lst[-1]
        self.lst[remove] = last
        self.idx[last].add(remove)
        self.idx[last].remove(len(self.lst) - 1)

        self.lst.pop()
        return True

    def getRandom(self) -&amp;gt; int:
        return choice(self.lst)


# MY ANSWER
class RandomizedCollection:

    def __init__(self):
        self.dic = defaultdict(set)
        self.li = []
        
    def insert(self, val: int) -&amp;gt; bool:
        res = True
        if val in self.dic:
            res = False
        self.dic[val].add(len(self.li))
        self.li.append(val)
        return res
        
    def remove(self, val: int) -&amp;gt; bool:
        if val in self.dic:
            if val == self.li[-1]:
                self.li.pop()
                idx = len(self.li)
                self.dic[val].remove(idx)
                if len(self.dic[val])==0:
                    del self.dic[val]
            else:
                pos_val = self.dic[val].pop()
                if len(self.dic[val])==0:
                    del self.dic[val]
                last_val = self.li[-1]
                pos_last_val = len(self.li)-1
                #move val to last_val
                self.li[pos_val],self.li[pos_last_val] = self.li[pos_last_val],self.li[pos_val]
                #update lastval pos to pos_val
                self.dic[last_val].remove(pos_last_val)
                self.dic[last_val].add(pos_val)
                #li pop
                self.li.pop()
            return True
        return False
        

    def getRandom(self) -&amp;gt; int:
        idx = random.randint(0,len(self.li)-1)
        return self.li[idx]


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用list和defaultdict（set），insert很简单，难的是remove。 先找出remove val的index并从dict中pop，和array last 元素交换， array last元素的dict添加index，array last 元素dict.remove(len(self.lst) - 1）, len(self.lst) - 1是last元素的idx。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-382-linked-list-random-node-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 382. Linked List Random Node （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a singly linked list, return a random node&#39;s value from the linked list. Each node must have the same probability of being chosen.&lt;br&gt;
Implement the Solution class:&lt;br&gt;
Solution(ListNode head) Initializes the object with the head of the singly-linked list head.&lt;br&gt;
int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.dic=dict()
        ind=0
        while head:
            self.dic[ind]=head.val
            ind+=1
            head=head.next
        self.ind=ind
        

    def getRandom(self) -&amp;gt; int:
        return self.dic[random.randint(0,self.ind-1)]  

#ANSER of Reservor sampling      
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.head = head
        

    def getRandom(self) -&amp;gt; int:
        scope = 1
        chosen_value = 0
        curr = self.head

        while curr:
            # decide whether to include the element in reservoir
            if random.random() &amp;lt; 1 / scope:
                chosen_value = curr.val
            # move on to the next node
            curr = curr.next
            scope += 1
        return chosen_value
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;follow up说如果linkedlist很大而且不知道长度。。。如何random 取样。。。&lt;br&gt;
忘记了有一个随机取样法 Reservoir sampling，需要复习, 当rand小于1/scope时候，说明当前值可以以1/scope的概率保留下来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# S has items to sample, R will contain the result
def ReservoirSample(S[1..n], R[1..k])
  # fill the reservoir array
  for i := 1 to k
      R[i] := S[i]

  # replace elements with gradually decreasing probability
  for i := k+1 to n
    # randomInteger(a, b) generates a uniform integer
    #   from the inclusive range {a, ..., b} *)
    j := randomInteger(1, i)
    if j &amp;lt;= k
        R[j] := S[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;383-ransom-note-easy&#34;&gt;383. Ransom Note （Easy）&lt;/h1&gt;
&lt;p&gt;Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.&lt;br&gt;
Each letter in magazine can only be used once in ransomNote.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&amp;gt; bool:
        a = Counter(ransomNote)
        b = Counter(magazine)
        for k,v in a.items():
            if k not in b or b[k]&amp;lt;v:
                return False
        return  True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred384-shuffle-an-array-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;384. Shuffle an Array (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.&lt;br&gt;
Implement the Solution class:&lt;br&gt;
Solution(int[] nums) Initializes the object with the integer array nums.&lt;br&gt;
int[] reset() Resets the array to its original configuration and returns it.&lt;br&gt;
int[] shuffle() Returns a random shuffling of the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&amp;gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&amp;gt; List[int]:
        aux = self.array[:]

        for idx in range(len(self.array)):
            remove_idx = random.randint(0,len(aux)-1)
            self.array[idx] = aux.pop(remove_idx)

        return self.array

#BEST ANSWER  Fisher-Yates Algorithm
class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&amp;gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&amp;gt; List[int]:
        for idx in range(len(self.array)):
            swap_idx=random.randint(idx,len(self.array)-1)
            self.array[idx],self.array[swap_idx]=self.array[swap_idx],self.array[idx]
        return self.array

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉思路是找到以n！为base的数，然后还原出suffled array但是写不出来。。。想的过于复杂了。这个就是个随机算法。 元素e在第k轮被抽中概率是  k在前k-1轮不中但在k轮中。 (n-1/n ) (n-2/n-1)...(n-k)/(n-k+1))* 1/n-k = 1/n   所以按照  剩下的有效数字中选1个的概率去组成array就可以保证每个数字是等概率选取。这样总体就是random shuffle了。&lt;br&gt;
1）先建立一个AUX array， 2）从AUX中无放回随机选一个数字  重复直到填满list。&lt;br&gt;
第二个算法高明在用了two pointer 思想，一个是顺序扫填入数字，另一个是找到要填入的数字，这样填入时候，自然没被用到的数字被swap到后面去了，相当于无放回抽样。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred385-mini-parser-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;385. Mini Parser （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.&lt;br&gt;
Each element is either an integer or a list whose elements may also be integers or other lists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &amp;quot;&amp;quot;&amp;quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def isInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def add(self, elem):
#        &amp;quot;&amp;quot;&amp;quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def setInteger(self, value):
#        &amp;quot;&amp;quot;&amp;quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getList(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &amp;quot;&amp;quot;&amp;quot;

class Solution:
    def deserialize(self, s: str) -&amp;gt; NestedInteger:
        # &#39;-1&#39; is not digit
        if s and s[-1].isdigit():
            return  NestedInteger(int(s))

        nested_integer = None
        digits = &#39;&#39;
        stack = []
        for c in s:
            if c.isdigit() or c == &#39;-&#39;:
                digits += c
            elif c == &#39;[&#39;:
                if nested_integer:
                    stack.append(nested_integer)
                nested_integer = NestedInteger()
            elif c == &#39;]&#39;:
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = &#39;&#39;
                if stack:
                    previous_nested_integer = stack.pop()
                    previous_nested_integer.add(nested_integer)
                    nested_integer = previous_nested_integer
            elif c == &#39;,&#39;:
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = &#39;&#39;

        return nested_integer

#作弊写法用eval
def deserialize(self, s):
    def nestedInteger(x):
        if isinstance(x, int):
            return NestedInteger(x)
        lst = NestedInteger()
        for y in x:
            lst.add(nestedInteger(y))
        return lst
    return nestedInteger(eval(s))




# MY ANSWER
class Solution:
    def deserialize(self, s: str) -&amp;gt; NestedInteger:
        #1) convert string to list using stack
        res =  []
        stack = []
        sign = 1
        i=0
        while i&amp;lt;len(s):
            
            if s[i]==&#39;-&#39;:
                sign = -1
            elif s[i].isdigit():
                i_old = i
                while i+1&amp;lt;len(s) and s[i+1].isdigit():
                    i+=1
                stack.append(sign*int(s[i_old:i+1]))
                sign=1
            elif s[i]==&#39;[&#39;:
                stack.append(&#39;[&#39;) 
            elif s[i]==&#39;]&#39;:
                tmp = []
                while stack[-1]!=&#39;[&#39;:
                    tmp.append(stack.pop())
                #pop [
                stack.pop()
                tmp = tmp[::-1]    
                stack.append(tmp)

            i+=1
 
        while stack:
            res.append(stack.pop())

        result = res[0]
        print(result)

        #2) convert to NestedInteger()
        def convert(res):
            if type(res)==int:
                return  NestedInteger(res)
            else:
                r = NestedInteger()
                for x in res:
                    r.add(convert(x))
                return r
        return  convert(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想写正确并不容易。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue386-lexicographical-numbers-median-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;386. Lexicographical Numbers （median） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.&lt;br&gt;
You must write an algorithm that runs in O(n) time and uses O(1) extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Trie:
    def __init__(self):
        self.data = collections.defaultdict(Trie)
        self.isword = False
    
    def insert(self,w):
        if not w:
            self.isword = True
            return
        head =w[0]
        rest =w[1:]
        if head not in self.data:
            self.data[head] = Trie()
        self.data[head].insert(rest)


class Solution:
    def lexicalOrder(self, n: int) -&amp;gt; List[int]:

        res = []
        T =Trie()

        for i in range(1,n+1):
            T.insert(str(i))

        
        def pre(node,tmp):
            
            if node.isword:
                res.append(int(tmp))
                node.isword=False
            
            for key in sorted(node.data):
                pre(node.data[key],tmp+key)
        
        pre(T,&#39;&#39;)

        return res

#ANSWER DFS
class Solution:
    def lexicalOrder(self, n: int) -&amp;gt; List[int]:
        self.res = []
        for i in range(1, 10):
            self.helper(i, n)
        return self.res
    
    def helper(self, start, end):
        if start &amp;gt; end:
            return
        self.res.append(start)
        for i in range(0, 10):
            if 10 * start + i &amp;gt; end:
                return
            self.helper(10 * start + i, end)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用的trie做出来的，写的磕磕绊绊。。。&lt;br&gt;
答案用的DFS， 很好的思路。。。&lt;br&gt;
The idea is pretty simple. If we look at the order we can find out we just keep adding digit from 0 to 9 to every digit and make it a tree.&lt;br&gt;
Then we visit every node in pre-order.&lt;br&gt;
1        2        3    ...&lt;br&gt;
/\        /\       /&lt;br&gt;
10 ...19  20...29  30...39   ....&lt;/p&gt;
&lt;h1 id=&#34;387-first-unique-character-in-a-string-easy&#34;&gt;387. First Unique Character in a String （Easy）&lt;/h1&gt;
&lt;p&gt;Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def firstUniqChar(self, s: str) -&amp;gt; int:
        c=Counter(s)
        for i,char in enumerate(s):
            if c[char]==1:
                return i
        return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;388-longest-absolute-file-path-medium&#34;&gt;388. Longest Absolute File Path (Medium)&lt;/h1&gt;
&lt;p&gt;Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:&lt;br&gt;
Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.&lt;/p&gt;
&lt;p&gt;In text form, it looks like this (with ⟶ representing the tab character):&lt;/p&gt;
&lt;p&gt;dir&lt;br&gt;
⟶ subdir1&lt;br&gt;
⟶ ⟶ file1.ext&lt;br&gt;
⟶ ⟶ subsubdir1&lt;br&gt;
⟶ subdir2&lt;br&gt;
⟶ ⟶ subsubdir2&lt;br&gt;
⟶ ⟶ ⟶ file2.ext&lt;/p&gt;
&lt;p&gt;If we were to write this representation in code, it will look like this: &amp;quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&amp;quot;. Note that the &#39;\n&#39; and &#39;\t&#39; are the new-line and tab characters.&lt;br&gt;
Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by &#39;/&#39;s. Using the above example, the absolute path to file2.ext is &amp;quot;dir/subdir2/subsubdir2/file2.ext&amp;quot;. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.&lt;br&gt;
Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthLongestPath(self, input: str) -&amp;gt; int:
        maxlen = 0
        pathlen = {0: 0}
        for line in input.split(&#39;\n&#39;):
            depth = line.count(&#39;\t&#39;)
            name = line.lstrip(&#39;\t&#39;)
            if &#39;.&#39; in name:
                maxlen = max(maxlen, pathlen[depth] + len(name))
            else:
                pathlen[depth + 1] = pathlen[depth] + len(name) + 1
        return maxlen


#MY ANSWER
class Solution:
    def lengthLongestPath(self, input: str) -&amp;gt; int:

        level_length =  dict()
        res = 0
        for me in input.split(&#39;\n&#39;):
            c = 0
            while me[0]==&#39;\t&#39;:
                c+=1
                me=me[1:]
            
            level_length[c] = len(me)
            #print( &#39;#&#39;+me+&#39;#&#39;,len(me),c, level_length)
            if &#39;.&#39; in me:
                res = max(res, len(me)+c+ sum([level_length[ii] for ii in range(c)]))
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;level根据string前有多少个tab定，长度是 当前string长度+depth+比depth小的的父目录长度，跳转到下一个folder时候字典更新了level的长度，这样直接继续计算。。。&lt;/p&gt;
&lt;h1 id=&#34;389-find-the-difference-easy&#34;&gt;389. Find the Difference （Easy）&lt;/h1&gt;
&lt;p&gt;You are given two strings s and t.&lt;br&gt;
String t is generated by random shuffling string s and then add one more letter at a random position.&lt;br&gt;
Return the letter that was added to t.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findTheDifference(self, s: str, t: str) -&amp;gt; str:
        s=Counter(s)
        t=Counter(t)
        for key in s:
            t[key]-=s[key]
            if t[key]==0:
                del t[key]
        
        return  list(t.keys())[0]

#ANSER NLOGN
class Solution:
    def findTheDifference(self, s: str, t: str) -&amp;gt; str:

        # Sort both the strings
        sorted_s = sorted(s)
        sorted_t = sorted(t)

        # Character by character comparison
        i = 0
        while i &amp;lt; len(s):
            if sorted_s[i] != sorted_t[i]:
                return sorted_t[i]
            i += 1

        return sorted_t[i]

#DICT O(n)
from collections import Counter

class Solution:
    def findTheDifference(self, s: str, t: str) -&amp;gt; str:
        # Prepare a counter for string s.
        # This holds the characters as keys and respective frequency as value.
        counter_s = Counter(s)

        # Iterate through string t and find the character which is not in s.
        for ch in t:
            if ch not in counter_s or counter_s[ch] == 0:
                return ch
            else:
                # Once a match is found we reduce frequency left.
                # This eliminates the possibility of a false match later.
                counter_s[ch] -= 1

#XOR O（n）
class Solution:
    def findTheDifference(self, s: str, t: str) -&amp;gt; str:

        # Initialize ch with 0, because 0 ^ X = X
        # 0 when XORed with any bit would not change the bits value.
        ch = 0

        # XOR all the characters of both s and t.
        for char_ in s:
            ch ^= ord(char_)

        for char_ in t:
            ch ^= ord(char_)

        # What is left after XORing everything is the difference.
        return chr(ch)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-390-elimination-game-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 390. Elimination Game （Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:&lt;br&gt;
Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.&lt;br&gt;
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.&lt;br&gt;
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.&lt;br&gt;
Given the integer n, return the last number that remains in arr.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#Navie not work memery exceeded
class Solution:
    def lastRemaining(self, n: int) -&amp;gt; int:
        li = [i for i in range(1,n+1)]
        
        def helper(li,forward=True):
            if len(li)==1: return li[0]
            if forward:
                #print(li[1::2],not forward)
                return helper(li[1::2],not forward)
            else:
                li=li[::-1]
                li=li[1::2]
                #print(li[::-1],not forward)
                return helper(li[::-1],not forward)
                
        return helper(li,True)


#Perfect ANSWER
class Solution:
    def lastRemaining(self, n: int) -&amp;gt; int:
 
        head, left, step, remaining = 1, True, 1, n
        while remaining &amp;gt; 1:
            if left or remaining % 2: 
                #when to update head
                #go from left or remaining is odd
                head += step
            left = not left
            step *= 2
            remaining //= 2
        return head
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照题目意思直接搞时间复杂度和空间复杂度都太大。。，&lt;br&gt;
看答案：&lt;br&gt;
update and record head in each turn. when the total number becomes 1, head is the only number left.&lt;/p&gt;
&lt;p&gt;When will head be updated?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if we move from left
if we move from right and the total remaining number % 2 == 1
like 2 4 6 8 10, we move from 10, we will take out 10, 6 and 2, head is deleted and move to 4
like 2 4 6 8 10 12, we move from 12, we will take out 12, 8, 4, head is still remaining 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then we find a rule to update our head.&lt;/p&gt;
">Leetcode 2021-12-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-10/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-371-sum-of-two-integers-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 371. Sum of Two Integers （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers a and b, return the sum of the two integers without using the operators + and -.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getSum(self, a: int, b: int) -&amp;gt; int:
        x, y = abs(a), abs(b)
        # ensure that abs(a) &amp;gt;= abs(b)
        if x &amp;lt; y:
            return self.getSum(b, a)
        
        # abs(a) &amp;gt;= abs(b) --&amp;gt; 
        # a determines the sign
        sign = 1 if a &amp;gt; 0 else -1
        
        if a * b &amp;gt;= 0:
            # sum of two positive integers x + y
            # where x &amp;gt; y
            while y:
                answer = x ^ y
                carry = (x &amp;amp; y) &amp;lt;&amp;lt; 1
                x, y = answer, carry
        else:
            # difference of two integers x - y
            # where x &amp;gt; y
            while y:
                answer = x ^ y
                borrow = ((~x) &amp;amp; y) &amp;lt;&amp;lt; 1
                x, y = answer, borrow
        
        return x * sign
#ANSWER
class Solution:
    def getSum(self, a: int, b: int) -&amp;gt; int:
        mask = 0xFFFFFFFF
        
        while b != 0:
            a, b = (a ^ b) &amp;amp; mask, ((a &amp;amp; b) &amp;lt;&amp;lt; 1) &amp;amp; mask
        
        max_int = 0x7FFFFFFF
        return a if a &amp;lt; max_int else ~(a ^ mask)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bit manipulation 初见感觉是。 但不知道怎么处理。思路，borrow 是 x&amp;amp;y《《1， 没borrow的sum是x^y.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-372-super-pow-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 372. Super Pow (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def superPow(self, a: int, b: List[int]) -&amp;gt; int:
        base=1337
        def f(a,b):
            res=1
            for i in range(b):
                res*=(a%base)
                res%=base
            return res
        if not b: return 1
        last_digit=b.pop()
        return f(self.superPow(a, b), 10) * f(a, last_digit) % base;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mod 有结合律交换律吗？。。不太清楚。。。 答案用了1） ab % k = (a%k)(b%k)%k&lt;br&gt;
2）a&lt;sup&gt;b%k=(a%k)&lt;/sup&gt;b%k&lt;br&gt;
推到递推关系：&lt;br&gt;
a^1234567 % k = (a^1234560 a^7)%k= ((a^1234560)%k )  ((a^7)%k ) %k&lt;br&gt;
= ((a&lt;sup&gt;123456)&lt;/sup&gt;10)%k )  ((a^7)%k ) %k&lt;br&gt;
= ((((a&lt;sup&gt;123456)%k)&lt;/sup&gt;10 )% k)  ((a^7)%k ) %k&lt;br&gt;
设 a^b%k=f(a,b)&lt;br&gt;
f(a,1234567)=  f(f(a,123456),10) f(a,7)%k&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-373-find-k-pairs-with-smallest-sums-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 373. Find K Pairs with Smallest Sums （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.&lt;br&gt;
Define a pair (u, v) which consists of one element from the first array and one element from the second array.&lt;br&gt;
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[List[int]]:
        res = []
        if not nums1 or not nums2 or not k:
            return res
        
        heap = []
        visited = set()
        
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        
        visited.add((0, 0))
        
        while len(res) &amp;lt; k and heap:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            
            if i+1 &amp;lt; len(nums1) and (i+1, j) not in visited:
                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))
                visited.add((i+1, j))
            
            if j+1 &amp;lt; len(nums2) and (i, j+1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
                visited.add((i, j+1))
        return res
        
           

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;暴力解肯定TLE。。。也想到了是k-way merge sort 但怎么写出来？直接抄答案了，用到了heapq.heappush, heapq.heappop, visited.  先从（0，0）开始push，然后是（1，0）（0，1）， i.e.   (i,j) then (i+1,j),(i,j+1)... 通过visited 去重。&lt;br&gt;
TWO POINTER 思路是错的，因为 0 1 2 |  1 2 3 一旦pointer1 移动到+1位置，所有pointer1之后位置能匹配p2的都会lost。 所以用heapq去做。&lt;/p&gt;
&lt;h1 id=&#34;374-guess-number-higher-or-lower-easy&#34;&gt;374. Guess Number Higher or Lower （Easy）&lt;/h1&gt;
&lt;p&gt;We are playing the Guess Game. The game is as follows:&lt;br&gt;
I pick a number from 1 to n. You have to guess which number I picked.&lt;br&gt;
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.&lt;br&gt;
You call a pre-defined API int guess(int num), which returns three possible results:&lt;br&gt;
-1: Your guess is higher than the number I picked (i.e. num &amp;gt; pick).&lt;br&gt;
1: Your guess is lower than the number I picked (i.e. num &amp;lt; pick).&lt;br&gt;
0: your guess is equal to the number I picked (i.e. num == pick).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&amp;gt; int:

class Solution:
    def guessNumber(self, n: int) -&amp;gt; int:
        l=1
        r=n
        while l&amp;lt;=r:
            m=(l+r)//2
            if guess(m)==0:
                return m
            elif guess(m)==1:
                l=m+1
            else:
                r=m-1
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&amp;gt; int:

class Solution:
    def guessNumber(self, n: int) -&amp;gt; int:
        l=1
        r=n
        while l&amp;lt;=r:
            m1=l+(r-l)//3
            m2=r-(r-l)//3
            res1=guess(m1)
            res2=guess(m2)
            if res1==0:
                return m1
            if res2==0:
                return m2
            elif res1&amp;lt;0:
                r=m1-1
            elif res2&amp;gt;0:
                l=m2+1
            else:
                l=m1+1
                r=m2-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二分法，三分法。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred375-guess-number-higher-or-lower-ii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;375. Guess Number Higher or Lower II （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;We are playing the Guessing Game. The game will work as follows:&lt;br&gt;
I pick a number between 1 and n.&lt;br&gt;
You guess a number.&lt;br&gt;
If you guess the right number, you win the game.&lt;br&gt;
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.&lt;br&gt;
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.&lt;br&gt;
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getMoneyAmount(self, n: int) -&amp;gt; int:
        #dp[i][j] will save the min cost guessing from i to j
        dp=[[0]*(n+1) for _ in range(n+1)]
         
        def helper(start,end):
            if start&amp;gt;=end: return 0
            if dp[start][end]!=0: return dp[start][end]
            res=float(&#39;inf&#39;)
            for x in range(start,end+1):
                #try select x,the cost will be
                tmp=x+max(helper(start,x-1),helper(x+1,end))
                res=min(res,tmp)
            dp[start][end]=res
            return res
            
        return helper( 1, n)
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。看答案，用了DP 关键是DP【i】【j】定义为从i猜到j，花费的最小cost。 那么如果X在i，j之间，选定了X，则cost为 X+max（dp【start】【x-1】，dp【x+1】【end】）因为dp这时候还没值，所以用helper（start，x-1），helper（x+1，end）代替，用max是因为不确定是左面还是右面，只能按照最坏情况准备钱。扫描所有X，然后最小的作为dp【i】【j】cost结果。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue376-wiggle-subsequence-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;376. Wiggle Subsequence （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.&lt;br&gt;
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.&lt;br&gt;
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.&lt;br&gt;
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.&lt;br&gt;
Given an integer array nums, return the length of the longest wiggle subsequence of nums.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int:
        #dp[i]   the max length of wiggle including nums[i]
        # 1 17 5 10 13 15 10 5 16 8
        # 0 +  - +  +   +  - - +  -
        # 1 2  3 4  4   4  5 5 6  7   
        
        # 1 7 4 9 2 5
        # 0 + - + - +
        #sign[i] the sign of max length of nums[i-1] to nums[i] if increasing 1 decresasing -1
        if len(nums)&amp;lt;2: return len(nums)
        if len(nums)==2 and nums[0]!=nums[1]:return 2
        if len(nums)==2 and nums[0]==nums[1]:return 1
        
        
        count_plus=0
        count_minus=0
        presign=None
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]: continue
            sign= nums[i]-nums[i-1]&amp;gt;0
            if sign:
                #positive
                if presign is None:
                    count_minus=1
                
                if presign!=sign:
                    
                    count_plus=count_minus+1
            else:
                #negtive
                if presign is None:
                    count_plus=1
                if presign!=sign:
                    count_minus=count_plus+1 
            
            presign=sign
        
        return max([1,count_plus,count_minus])

#ANSWER DP O（n*n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int:
        if len(nums)&amp;lt;2: return len(nums)
        up=[1]*len(nums)
        down=[1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]&amp;gt;nums[j]:
                    up[i]=max(up[i],down[j]+1)
                elif nums[i]&amp;lt;nums[j]:
                    down[i]=max(down[i],up[j]+1)
        return max(up[-1],down[-1])

#ANSWER DP O（n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int:
        if len(nums)&amp;lt;2: return len(nums)
        up=[0]*len(nums)
        down=[0]*len(nums)
        up[0]=1
        down[0]=1
        for i in range(1,len(nums)):
            if nums[i]&amp;gt;nums[i-1]:
                up[i]=down[i-1]+1
                down[i]=down[i-1]
            elif nums[i]&amp;lt;nums[i-1]:
                down[i]=up[i-1]+1
                up[i]=up[i-1]
            else:
                down[i]=down[i-1]
                up[i]=up[i-1]
        return max(up[-1],down[-1])

#ANSWER DP O（n） space O（1）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int:
        if len(nums)&amp;lt;2: return len(nums)
        up=1
        down=1
       
        for i in range(1,len(nums)):
            if nums[i]&amp;gt;nums[i-1]:
                up =down +1
           
            elif nums[i]&amp;lt;nums[i-1]:
                down =up +1
              
        return max(up ,down )

#Greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int:
        if len(nums)&amp;lt;2: return len(nums)
        maxLen=1
        sign=0
        for i in range(1,len(nums)):
            if nums[i]&amp;lt;nums[i-1] and sign!=-1:
                # find a peak nums[i-1] is peak, now it is a decreasing sequence sign=-1
                sign=-1
                maxLen+=1
           
            elif nums[i]&amp;gt;nums[i-1] and sign!=1:
                #valley
                sign=1
                maxLen+=1
              
        return maxLen
         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本来想用DP做，但发现只用保持 count+ 和 count- 两个计数器就够了。  如果发现增加2元序列，count-加1. 如果发现减小2元序列，count+加1，最后返回count+,count-中最大的就可以了，注意corner case。答案用了多种方法，贴上来开阔思路。第三个方法和我的一样但是写的更简单&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-377-combination-sum-iv-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 377. Combination Sum IV （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.&lt;br&gt;
The test cases are generated so that the answer can fit in a 32-bit integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&amp;gt; int:
        @lru_cache(None)
        def dp(remain):
            if remain==0:
                return 1
            res=0
            for n in nums:
                if remain-n&amp;gt;=0:
                    res+=dp(remain-n)
            return res
        return dp(target)
    
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&amp;gt; int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):

            for num in nums:
                if comb_sum - num &amp;gt;= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道是DP，而且知道DP【i】是能sum到i的组合个数，那么dp【i】=dp【i-n】+dp【n】为啥不对？？ n是添加的最后一个数。而且扫的是所有n in nums。 如果再拆分n，那么会有重复。&lt;br&gt;
思路卡了， 应该是dp【i】+=dp【i-n】   要往组合里加n能到i，那么多出来的组合数就是dp【i-n】。应该求的是和。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred378-kth-smallest-element-in-a-sorted-matrix-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;378. Kth Smallest Element in a Sorted Matrix （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.&lt;br&gt;
Note that it is the kth smallest element in the sorted order, not the kth distinct element.&lt;br&gt;
You must find a solution with a memory complexity better than O(n2).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int:

        n = len(matrix)
        minheap = []
        for r in range(min(k,n)):
            minheap.append((matrix[r][0], r, 0 ))
        heapq.heapify(minheap)
    
        e = None
        while k:
            e, r,c  = heapq.heappop(minheap)
            if c&amp;lt;n-1:
                heapq.heappush(minheap, (matrix[r][c+1], r, c+1))
            k-=1
        return e

#ANSWER II
class Solution:
    
    def countLessEqual(self, matrix, mid, smaller, larger):
        
        count, n = 0, len(matrix)
        row, col = n - 1, 0
        
        while row &amp;gt;= 0 and col &amp;lt; n:
            if matrix[row][col] &amp;gt; mid:
               
                # As matrix[row][col] is bigger than the mid, let&#39;s keep track of the
                # smallest number greater than the mid
                larger = min(larger, matrix[row][col])
                row -= 1
                
            else:
                
                # As matrix[row][col] is less than or equal to the mid, let&#39;s keep track of the
                # biggest number less than or equal to the mid
                
                smaller = max(smaller, matrix[row][col])
                count += row + 1
                col += 1

        return count, smaller, larger
    
    def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int:
        
        n = len(matrix)
        start, end = matrix[0][0], matrix[n - 1][n - 1]
        while start &amp;lt; end:
            mid =  (end + start) // 2
            smaller, larger = matrix[0][0], matrix[n - 1][n - 1]

            count, smaller, larger = self.countLessEqual(matrix, mid, smaller, larger)

            if count == k:
                return smaller
            if count &amp;lt; k:
                start = larger  # search higher
            else:
                end = smaller  # search lower

        return start

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法一，用minheap去merge n行rows。&lt;br&gt;
方法二，左上和右下是min max，找到middle，  从左下角开始， 这时候计数多少数字小于middle，如果当前值小于middle，说明当前row以上的col元素都小于middle值，计数，并把当前元素指针向右移动， 并同时计算小于middle值的最大元素，同理， 如果当前元素大于mid， 当前元素指针向上移动，&lt;br&gt;
起码minheap方法应该想出来。&lt;/p&gt;
&lt;h1 id=&#34;379-design-phone-directory-medium&#34;&gt;379. Design Phone Directory （Medium）&lt;/h1&gt;
&lt;p&gt;Design a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.&lt;br&gt;
Implement the PhoneDirectory class:&lt;br&gt;
PhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.&lt;br&gt;
int get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.&lt;br&gt;
bool check(int number) Returns true if the slot number is available and false otherwise.&lt;br&gt;
void release(int number) Recycles or releases the slot number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n=maxNumbers
        self.avaliable=set([i for i in range(self.n)])
        self.used=set()
        self.current=-1
        

    def get(self) -&amp;gt; int:
        if not self.avaliable: return -1
        while not self.check(self.current):
            self.current= (self.current+1)%self.n
        
        #current in self.avaliable
        # remove from self.avaliable
        self.avaliable.remove(self.current)
        self.used.add(self.current)
        
        res = self.current
        self.current= (self.current+1)%self.n
        return res

    def check(self, number: int) -&amp;gt; bool:
        return  number in self.avaliable 

    def release(self, number: int) -&amp;gt; None:
        self.avaliable.add(number)
        if number in self.used:
            self.used.remove(number)
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)

   def __init__(self, maxNumbers):
        self.available = set(range(maxNumbers))

    def get(self):
        return self.available.pop() if self.available else -1

    def check(self, number):
        return number in self.available

    def release(self, number):
        self.available.add(number)

#MY ANSWER
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n = maxNumbers
        self.circular = list(range(maxNumbers))
        self.head = 0
        

    def get(self) -&amp;gt; int:
        if self.circular[self.head%self.n]!=-1:
            val =  self.circular[self.head%self.n]
            self.circular[self.head%self.n] = -1
            self.head+=1
            return val
        else:
            c=0
            while self.circular[self.head %self.n]==-1:
                c+=1
                self.head+=1
                if c&amp;gt;=self.n:
                    return -1
            val = self.circular[self.head%self.n]
            self.circular[self.head%self.n]=-1
            return val
              
        

    def check(self, number: int) -&amp;gt; bool:
        return self.circular[number]!=-1
        

    def release(self, number: int) -&amp;gt; None:
        self.circular[number] = number
        

#ANSWER PERFECT
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.pos=0
        self.next=[0]*maxNumbers
        for i in range(maxNumbers):
            self.next[i]=(i+1)%maxNumbers
        

    def get(self) -&amp;gt; int:
        if self.next[self.pos]==-1: return -1
        res=self.pos
        self.pos=self.next[self.pos]
        self.next[res]=-1
        return res
        

    def check(self, number: int) -&amp;gt; bool:
        return self.next[number]!=-1

    def release(self, number: int) -&amp;gt; None:
        if self.next[number]!=-1: return
        self.next[number]=self.pos
        self.pos=number
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number) int[] next;
   
  


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案很完美的写法：Use a linked list to track available numbers, and a pointer to head. If head is still available, get() would return it and move to the next available number. Release would re-add a node to the beginning of the linked list and update head&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-380-insert-delete-getrandom-o1-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 380. Insert Delete GetRandom O(1) （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Implement the RandomizedSet class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You must implement the functions of the class such that each function works in average O(1) time complexity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from random import choice
class RandomizedSet():
    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        &amp;quot;&amp;quot;&amp;quot;
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &amp;quot;&amp;quot;&amp;quot;
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &amp;quot;&amp;quot;&amp;quot;
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -&amp;gt; int:
        &amp;quot;&amp;quot;&amp;quot;
        Get a random element from the set.
        &amp;quot;&amp;quot;&amp;quot;
        return choice(self.list)


#MY SOLUTION
class RandomizedSet:

    def __init__(self):
        self.dic = dict()
        self.rev_dic = dict()
        self.i = 0
        self.i_store = set()

    def insert(self, val: int) -&amp;gt; bool:
        if val in self.dic:
            return False
        
        if not self.i_store:
            self.dic[val] = self.i
            self.rev_dic[self.i] = val
            self.i+=1
        else:
            self.dic[val] = self.i_store.pop()
            self.rev_dic[ self.dic[val] ] = val
        return True

    def remove(self, val: int) -&amp;gt; bool:
        if val not in self.dic:
            return False
        
        i = self.dic[val]
        self.i_store.add(i)
        del self.dic[val]
        del self.rev_dic[i]

        return True

    def getRandom(self) -&amp;gt; int:
        
        
        idx = random.randint(0,self.i)
        while idx not in self.rev_dic:
            idx = random.randint(0,self.i)
        
        return self.rev_dic[idx]


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案思路好，用dic保存插入元素位置方便找出index， 删除时候找出index，然后和list中最后一个元素交换位置，然后pop list del dict【val】&lt;/p&gt;
&lt;p&gt;我的思路， 用dic和rev_dic作为存储val - pos的mapping， 当remove时候， 位置会多余出来，存在i_store中， 当插入时候优先用i_store的pos， 这样random找的时候大概率从0到i是连续存储的，这样random一个int就能找到val。&lt;/p&gt;
&lt;p&gt;还是答案思路好。&lt;/p&gt;
">Leetcode 2021-12-10</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-09/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;361-bomb-enemy-medium&#34;&gt;361. Bomb Enemy （Medium）&lt;/h1&gt;
&lt;p&gt;Given an m x n matrix grid where each cell is either a wall &#39;W&#39;, an enemy &#39;E&#39; or empty &#39;0&#39;, return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.&lt;/p&gt;
&lt;p&gt;The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&amp;gt; int:
        m=len(grid)
        n=len(grid[0])
        dp=[[0]*n for _ in range(m) ]
        #look from left for each row
        for i in range(m):
            c=0
            for j in range(n):
                dp[i][j]+=c
                if grid[i][j]==&#39;E&#39;:
                    c+=1
                elif grid[i][j]==&#39;W&#39;:
                    dp[i][j]=0
                    c=0
        #look from right for each row
        for i in range(m):
            c=0
            for j in range(n-1,-1,-1):
                dp[i][j]+=c
                if grid[i][j]==&#39;E&#39;:
                    c+=1
                elif grid[i][j]==&#39;W&#39;:
                    dp[i][j]=0
                    c=0
        #look from up for each col
        for i in range(n):
            c=0
            for j in range(m):
                dp[j][i]+=c
                if grid[j][i]==&#39;E&#39;:
                    c+=1
                elif grid[j][i]==&#39;W&#39;:
                    dp[j][i]=0
                    c=0
        #look from bottom for each col
        for i in range(n):
            c=0
            for j in range(m-1,-1,-1):
                dp[j][i]+=c
                if grid[j][i]==&#39;E&#39;:
                    c+=1
                elif grid[j][i]==&#39;W&#39;:
                    dp[j][i]=0
                    c=0
         
        res=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==&#39;0&#39;:
                    res=max(res,dp[i][j])
        return res
                
 #ANSWER
 class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&amp;gt; int:
        if len(grid) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        max_count = 0
        row_hits = 0
        col_hits = [0] * cols

        for row in range(0, rows):
            for col in range(0, cols):
                # reset the hits on the row, if necessary.
                if col == 0 or grid[row][col - 1] == &#39;W&#39;:
                    row_hits = 0
                    for k in range(col, cols):
                        if grid[row][k] == &#39;W&#39;:
                            # stop the scan when we hit the wall.
                            break
                        elif grid[row][k] == &#39;E&#39;:
                            row_hits += 1

                # reset the hits on the col, if necessary.
                if row == 0 or grid[row - 1][col] == &#39;W&#39;:
                    col_hits[col] = 0
                    for k in range(row, rows):
                        if grid[k][col] == &#39;W&#39;:
                            break
                        elif grid[k][col] == &#39;E&#39;:
                            col_hits[col] += 1

                # count the hits for each empty cell.
                if grid[row][col] == &#39;0&#39;:
                    total_hits = row_hits + col_hits[col]
                    max_count = max(max_count, total_hits)

        return max_count       




&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和答案思路是一致的，写的更简洁些。&lt;/p&gt;
&lt;h1 id=&#34;362-design-hit-counter-medium&#34;&gt;362. Design Hit Counter （Medium）&lt;/h1&gt;
&lt;p&gt;Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).&lt;br&gt;
Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). Several hits may arrive roughly at the same time.&lt;br&gt;
Implement the HitCounter class:&lt;br&gt;
HitCounter() Initializes the object of the hit counter system.&lt;br&gt;
void hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.&lt;br&gt;
int getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#NOT WORKING DUE TO timestamp range up to 2*10^9
class HitCounter:
    class BIT:
        def __init__(self,size):
            self.size=size
            self.tree=[0]*(size+1)
            
        def update(self,ind):
            #index in BIT is 1 more than original index
            while ind&amp;lt;=self.size:
                self.tree[ind]+=1
                ind+= ind&amp;amp;-ind
        def query(self,ind):
            #index in BIT is 1 more than original index
            res=0
            while ind&amp;gt;0:
                res+=self.tree[ind]
                ind-= ind&amp;amp;-ind
            return res


    def __init__(self):
        self.tree=self.BIT(2000)
    def hit(self, timestamp: int) -&amp;gt; None:
        self.tree.update(timestamp)
        

    def getHits(self, timestamp: int) -&amp;gt; int:
        return self.tree.query(timestamp)-self.tree.query(timestamp-300 if timestamp-300&amp;gt;0 else 0)
        
#ANOTHER WAY...
class HitCounter:

    def __init__(self):
        self.data=[]
        
        

    def hit(self, timestamp: int) -&amp;gt; None:
        self.data.append(timestamp)
        

    def getHits(self, timestamp: int) -&amp;gt; int:
        return bisect.bisect_right(self.data,timestamp)-bisect.bisect_left(self.data,timestamp-299)


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)

class HitCounter(object):

def __init__(self):
    &amp;quot;&amp;quot;&amp;quot;
    Initialize your data structure here.
    &amp;quot;&amp;quot;&amp;quot;
    self.deque = collections.deque()

def hit(self, timestamp):
    &amp;quot;&amp;quot;&amp;quot;
    Record a hit.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: None
    &amp;quot;&amp;quot;&amp;quot;
    self.deque.append(timestamp)
    

def getHits(self, timestamp):
    &amp;quot;&amp;quot;&amp;quot;
    Return the number of hits in the past 5 minutes.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;

    while self.deque and timestamp - self.deque[0] &amp;gt;= 300:
        self.deque.popleft()
    return len(self.deque)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉用Seg Tree 或者Binary Indexed Tree 但忘记怎么写。。。遇到memory out of bond 问题，因为timestamp 范围太大。。。换思路。。。直接用binary search。。。或者用queue&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-363-max-sum-of-rectangle-no-larger-than-k-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 363. Max Sum of Rectangle No Larger Than K （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#TIME LIMIT EXCEEDED
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&amp;gt; int:
        m=len(matrix)
        n=len(matrix[0])
        res=[]
        for i in range(m):
            for j in range(n):
                area=matrix[i][j]
                if area&amp;lt;=k:
                    heapq.heappush(res,-area)
                if i==0 and j==0:continue
                if j&amp;gt;0 and i==0 :
                    matrix[i][j]+=matrix[i][j-1]
                elif i&amp;gt;0 and j==0:
                    matrix[i][j]+=matrix[i-1][j]
                else:
                    matrix[i][j]+=matrix[i][j-1]+matrix[i-1][j]-matrix[i-1][j-1]
                
                area=matrix[i][j]
                if area&amp;lt;=k:
                    heapq.heappush(res,-area)
        
        #for row in matrix:
        #    print(row)
        #print(res)
   
        for row in range(m):
            for col in range(n):
                for row_p in range(row):
                    area=matrix[row][col]-matrix[row_p][col]
                    if area&amp;lt;=k:
                            heapq.heappush(res,-area)
                    for col_p in range(col):
                        area=matrix[row][col]-matrix[row][col_p]
                        if area&amp;lt;=k:
                            heapq.heappush(res,-area)
                        area=matrix[row][col]-matrix[row_p][col]-matrix[row][col_p]+matrix[row_p][col_p]
                        if area&amp;lt;=k:
                            heapq.heappush(res,-area)

        return -heapq.heappop(res)

#ANSWER
import sortedcontainers
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&amp;gt; int:
        self.result=float(&#39;-inf&#39;)
        def updateresult(nums,k):
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&amp;lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result

#ANSWER 
import sortedcontainers
class Solution:
    
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&amp;gt; int:
        self.result=float(&#39;-inf&#39;)
        
        def getmaxkadane(nums):
            maxkadane=float(&#39;-inf&#39;)
            currentmaxsum=0
            for num in nums:
                currentmaxsum=max(currentmaxsum+num,num)
                maxkadane=max(maxkadane,currentmaxsum)
            return maxkadane
        def updateresult(nums,k):
            kadanesum=getmaxkadane(nums)
            if kadanesum&amp;lt;=k:
                self.result=max(self.result,kadanesum)
                return
            
            
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&amp;lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result
                      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试heapq+cumsum time limit exceeded，因为还是属于暴力解法。。。看答案。答案用python去解也是TLE， 答案思路，先考虑1D问题，要寻找加和小于等于K的，相当于找当前的runningsum-X小于等于K，所以要寻找X大于等于runningsum-K，这样用orderedset和binary seasrch可以从runningsum中找到这个X，runningsum-X就是要求的小于等于K的累加和。 再还原成2d问题，对于每一个起始点为ith row的数据，初始化一个rowsum。然后每添加一个row就update一下答案。 Time complexity: O(m2nlog⁡n)&lt;br&gt;
另一种方法增加改进用Kadane&#39;s algorithm gets the max possible sum of a sub-array in O(n) time，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
        # Initialize our variables using the first element.
        current_subarray = max_subarray = nums[0]
        # Start with the 2nd element since we already used the first one.
        for num in nums[1:]:
            # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
            current_subarray = max(num, current_subarray + num)
            max_subarray = max(max_subarray, current_subarray)
        return max_subarray
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一种DP的方法求maxsubarray。。。因为一个row如果maxsumarry已经小于等于K了就没必要用nlogn方法的updateresult再去求了，算一步时间复杂度上的小优化。这样写出来能pass。&lt;/p&gt;
&lt;h1 id=&#34;364-nested-list-weight-sum-ii-medium&#34;&gt;364. Nested List Weight Sum II （Medium）&lt;/h1&gt;
&lt;p&gt;You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.&lt;br&gt;
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer&#39;s value set to its depth. Let maxDepth be the maximum depth of any integer.&lt;br&gt;
The weight of an integer is maxDepth - (the depth of the integer) + 1.&lt;br&gt;
Return the sum of each integer in nestedList multiplied by its weight.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &amp;quot;&amp;quot;&amp;quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def isInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def add(self, elem):
#        &amp;quot;&amp;quot;&amp;quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def setInteger(self, value):
#        &amp;quot;&amp;quot;&amp;quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getList(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &amp;quot;&amp;quot;&amp;quot;

class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -&amp;gt; int:
        #[[1,1],2,[1,1]]
        
        def depth(nestedList):
            d=1
            for li in nestedList:
                if not li.isInteger():
                    d=max(d,1+depth(li.getList()))
            return d
                    
                    
                
        maxd=depth(nestedList)    
        #print(maxd)
    
        
        def helper(nestedList,depth):
            res=0
            for li in nestedList:
                if li.isInteger():
                    #print(li.getInteger(),(maxd-depth+1))
                    res+=li.getInteger()*(maxd-depth+1)
                else:
                    
                    res+=helper(li.getList(),depth+1)
                   
            return res
        
        return helper(nestedList,1)

            
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算maxdepth时候卡壳了。。。。写出的算法同答案1，double DFS。 算法2，3用了math+BFS。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred365-water-and-jug-problem-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;365. Water and Jug Problem （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;ou are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.&lt;/p&gt;
&lt;p&gt;If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.&lt;/p&gt;
&lt;p&gt;Operations allowed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fill any of the jugs with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&amp;gt; bool:
     
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
        if x + y &amp;lt; z: return False
        if  x == z or y == z or x + y == z : return True
        
        def GCD(a,b):
            while b:
                a,b=b,a%b
            return a
        return z%GCD(x, y) == 0 

#ANSWER BFS
class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&amp;gt; bool:
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
     
        if x&amp;gt;y:
            #make sure x&amp;lt;y
            x,y=y,x
            
        if z &amp;gt; x + y: return False
        
        # set the initial state will empty jars;
        queue = [(0, 0)]
        visited = set((0, 0))
        while queue:
            a, b = queue.pop(0);
            if a + b == z:
                return True;
            
            states = set()
            
            states.add((x, b)) # fill jar x;
            states.add((a, y)) # fill jar y;
            states.add((0, b)) # empty jar x;
            states.add((a, 0)) # empty jar y;
            states.add((min(x, b + a), 0 if a+b &amp;lt; x  else a+b - x)) # pour jar y to x;
            states.add((0 if a + b &amp;lt; y else a +b- y , min(b + a, y))) # pour jar x to y;

            for state in states:
                if state in visited:
                    continue;
                queue.append(state)
                visited.add(state);
                
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一眼看上去好像是个dp问题。但提示是DFS，BFS, MATH。 答案用了 Bézout&#39;s identity and check if z is a multiple of GCD(x, y)&lt;br&gt;
Bézout&#39;s identity (also called Bézout&#39;s lemma) is a theorem in the elementary theory of numbers:&lt;br&gt;
let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x and y such that ax+by=d，In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by every integer of the form ax + by is a multiple of the greatest common divisor d.&lt;br&gt;
Bezout&#39;s Lemma states that if x and y are nonzero integers and g = gcd(x,y), then there exist integers a and b such that ax+by=g. In other words, there exists a linear combination of x and y equal to g.&lt;br&gt;
Furthermore, g is the smallest positive integer that can be expressed in this form, i.e. g = min{ax+by | a, b in Z, ax+by &amp;gt; 0}.&lt;br&gt;
BFS解法也很经典&lt;/p&gt;
&lt;h1 id=&#34;366-find-leaves-of-binary-tree-medium&#34;&gt;366. Find Leaves of Binary Tree （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, collect a tree&#39;s nodes as if you were doing this:&lt;br&gt;
Collect all the leaf nodes.&lt;br&gt;
Remove all the leaf nodes.&lt;br&gt;
Repeat until the tree is empty.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:

        res = []
        #TOPO SORT
        indegree = collections.defaultdict(int)
        neighbor = collections.defaultdict(list)
        q =[ ]
        def pre(node):
            if not node: return
            if node not in indegree:
                indegree[node] = 0
            if node.left:
                indegree[node]+=1
                neighbor[node.left].append(node)
            if node.right:
                indegree[node]+=1
                neighbor[node.right].append(node)
            pre(node.left)
            pre(node.right)

        pre(root)

        for node, indeg in indegree.items():
            if indeg==0:
                q.append(node)
        
        for n in q:
            del indegree[n]
        

        while q:
            level = []
            for _ in range(len(q)):
                node = q.pop(0)
                level.append(node.val)
                for nei in neighbor[node]:
                    indegree[nei]-=1
                    if indegree[nei]==0:
                        q.append(nei)
                        del indegree[nei]
            res.append(level)
        
        return res


#ANSWER
def findLeaves(self, root: TreeNode) -&amp;gt; List[List[int]]:
    output = collections.defaultdict(list)
    
    def dfs(node, layer):
        if not node: 
            return layer 
        left = dfs(node.left, layer)
        right = dfs(node.right, layer)
        layer = max(left, right)
        output[layer].append(node.val)
        return layer + 1
    
    dfs(root, 0)
    return output.values() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TOPO SORT, OVERKILL, 答案把所有的都放在后序遍历里了。&lt;/p&gt;
&lt;h1 id=&#34;367-valid-perfect-square-easy&#34;&gt;367. Valid Perfect Square （Easy）&lt;/h1&gt;
&lt;p&gt;Given a positive integer num, write a function which returns True if num is a perfect square else False.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPerfectSquare(self, num: int) -&amp;gt; bool:
        l=1
        r=num//2+1
        while l&amp;lt;=r:
            m= (l+r)//2
            if m*m==num:
                return True
            elif m*m&amp;gt;num:
                r=m-1
            else:
                l=m+1
        return False
#ANSWER
class Solution:
    def isPerfectSquare(self, num: int) -&amp;gt; bool:
        if num &amp;lt; 2:
            return True
        
        x = num // 2
        while x * x &amp;gt; num:
            x = (x + num // x) // 2
        return x * x == num
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了牛顿法，更快收敛比二分法。找出f（x）= x^2-num=0的根。 设一个猜测值Xk  ，f（Xk）是y值，f‘（Xk）是对比底，所以底= f（Xk）/f&#39;(Xk)  新的猜测Xk+1= Xk- f（Xk）/f&#39;(Xk) 所以 xk+1​=0.5*(xk​+num/xk​​)&lt;br&gt;
牛顿法也是O(log⁡N)&lt;/p&gt;
&lt;h1 id=&#34;font-colorred368-largest-divisible-subset-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;368. Largest Divisible Subset （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:&lt;br&gt;
answer[i] % answer[j] == 0, or&lt;br&gt;
answer[j] % answer[i] == 0&lt;br&gt;
If there are multiple solutions, return any of them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -&amp;gt; List[int]:
        #dp[i]= maxsubset include nums[i] from 0 to i
        # dp[i]=      nums[0] to nums[i] are divisible by nums[i] find max(dp)+1
        nums.sort()
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i]%nums[j]==0 or nums[j]%nums[i]==0:
                    dp[i]=max(dp[i],dp[j]+1)
               
        ind=dp.index(max(dp))
        while ind+1&amp;lt;len(dp) and dp[ind+1]==max(dp):
            ind+=1
        #print(nums)
        #print(dp)
        #reconstruct res
        res=[]
        cursize=max(dp)
        curtail=nums[ind]
        for i in range(ind,-1,-1):
            if cursize==dp[i] and curtail%nums[i]==0:
                res.append(nums[i])
                cursize-=1
                curtail=nums[i]
        return res[::-1]

 #ANSWER WAY OF WRITING        
class Solution(object):
    def largestDivisibleSubset(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        # The container that holds all intermediate solutions.
        # key: the largest element in a valid subset.
        subsets = {-1: set()}
        
        for num in sorted(nums):
            subsets[num] = max([subsets[k] for k in subsets if num % k == 0], key=len) | {num}
        
        return list(max(subsets.values(), key=len))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用dp可以算出长度，但没法正确给出一个result。问题出在了reconstruct这一步。 看了答案写出来了。&lt;br&gt;
答案写出算法用了2个定理。假设【E，F，G】已经是从小到大排序好的而且是divisible subset，那么1）对于h大于G， h%G等于0则【E，F，G，h】满足divisible subset  2）对于 d小于E，若 E%d==0则【d，E，F，G】满足divisible subset。&lt;/p&gt;
&lt;h1 id=&#34;369-plus-one-linked-list-medium&#34;&gt;369. Plus One Linked List （Medium）&lt;/h1&gt;
&lt;p&gt;Given a non-negative integer represented as a linked list of digits, plus one to the integer.&lt;br&gt;
The digits are stored such that the most significant digit is at the head of the list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def plusOne(self, head: ListNode) -&amp;gt; ListNode:
        
        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
        revlist_head = rev(head)
        cur=revlist_head
        first=True
        carry=0
        pre=None
        while cur:
            if first:
                val=cur.val+carry+1
                cur.val=val%10
                carry=val//10
                first=False
            else:
                val=cur.val+carry
                cur.val=val%10
                carry=val//10
            pre=cur
            cur=cur.next
        
        if carry:
            pre.next=ListNode(val=carry)
        
        return rev(revlist_head)

#ANSWER WAY OF WRITING
class Solution:
    def plusOne(self, head: ListNode) -&amp;gt; ListNode:
        
        # sentinel head
        sentinel = ListNode(0)
        sentinel.next = head
        not_nine = sentinel

        # find the rightmost not-nine digit
        while head:
            if head.val != 9:
                not_nine = head
            head = head.next

        # increase this rightmost not-nine digit by 1
        not_nine.val += 1
        not_nine = not_nine.next

        # set all the following nines to zeros
        while not_nine:
            not_nine.val = 0
            not_nine = not_nine.next

        return sentinel if sentinel.val else sentinel.next

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先rev了加1，然后再rev回去。&lt;br&gt;
答案做法用哨兵0node，找到最右面不是9的node+1，后面是9的一律变0.&lt;/p&gt;
&lt;h1 id=&#34;370-range-addition-medium&#34;&gt;370. Range Addition （Medium）&lt;/h1&gt;
&lt;p&gt;You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].&lt;/p&gt;
&lt;p&gt;You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.&lt;/p&gt;
&lt;p&gt;Return arr after applying all the updates.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -&amp;gt; List[int]:

        res = [0]*length

        for a,b,v in updates:
            res[a]+=v
            if b+1&amp;lt;length:
                res[b+1]-=v

        for i in range(1,length):
            res[i]+=res[i-1]

        return res  
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-12-09</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-08/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred351-android-unlock-patterns-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;351. Android Unlock Patterns (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an &amp;quot;unlock pattern&amp;quot; by connecting the dots in a specific sequence, forming a series of joined line segments where each segment&#39;s endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true:&lt;br&gt;
All the dots in the sequence are distinct.&lt;br&gt;
If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.&lt;br&gt;
For example, connecting dots 2 and 9 without dots 5 or 6 appearing beforehand is valid because the line from dot 2 to dot 9 does not pass through the center of either dot 5 or 6.&lt;br&gt;
However, connecting dots 1 and 3 without dot 2 appearing beforehand is invalid because the line from dot 1 to dot 3 passes through the center of dot 2.&lt;br&gt;
Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys.&lt;/p&gt;
&lt;p&gt;Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberOfPatterns(self, m: int, n: int) -&amp;gt; int:
        skip = [[0]*10 for _ in range(10)]
        skip[1][3] = skip[3][1] = 2 
        skip[1][7] = skip[7][1] = 4 
        skip[3][9] = skip[9][3] = 6 
        skip[7][9] = skip[9][7] = 8 
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5 
        visited = [False]*10
        res=0
        def DFS(cur,remain):
            if remain&amp;lt;0: return 0
            if remain==0: return 1
            visited[cur]=True
            res=0
            for i in range(1,10):
                if not visited[i] and (skip[cur][i]==0 or visited[skip[cur][i]]):
                    res+=DFS(i,remain-1)
            visited[cur]=False
            return res
        
        for i in range(m,n+1):
            res+=DFS(1,i-1)*4 # 1,3,7, 9 sym 
            res+=DFS(2,i-1)*4 # 2 4 6 8  sym
            res+=DFS(5,i-1) 
            
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题是奇怪的问题，解决方法大概是DP，但递归关系不好找。思路错误， 答案用DFS+BT  简化思路是 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred352-data-stream-as-disjoint-intervals-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;352. Data Stream as Disjoint Intervals （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.&lt;br&gt;
Implement the SummaryRanges class:&lt;br&gt;
SummaryRanges() Initializes the object with an empty stream.&lt;br&gt;
void addNum(int val) Adds the integer val to the stream.&lt;br&gt;
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SummaryRanges:

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        &amp;quot;&amp;quot;&amp;quot;
        self.interval = [] # record the interval
        self.s = set() # record the number we have added before
        return 

    def addNum(self, val: int) -&amp;gt; None:
        if val in self.s:
            return 
        self.s.add(val)
        index = bisect_left(self.interval,[val,val])

        # check whether we could extend the interval on its left and right 
        if index &amp;lt; len(self.interval) and self.interval[index][0]-1 == val:
            self.interval[index][0] = self.interval[index][0] - 1
        elif index &amp;gt; 0 and self.interval[index-1][1]+1 == val:
            self.interval[index-1][1] = self.interval[index-1][1] + 1
        else:
            self.interval.insert(index, [val,val])

    def getIntervals(self) -&amp;gt; List[List[int]]:
        # update the intervals in getIntervals function 
        connect = []
        for x in self.interval:
            if connect and connect[-1][1] == x[0]-1:
                connect[-1][1] = x[1]
            else:
                connect.append(x)
        self.interval = connect
        return self.interval 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： binary search for interval， interval update when getIntervals。&lt;/p&gt;
&lt;h1 id=&#34;353-design-snake-game-medium&#34;&gt;353. Design Snake Game （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SnakeGame:

    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.food=food
        self.w=width
        self.h=height
        self.score=0
        self.body = [[0,0]]
        self.pos=[0,0]

    def move(self, direction: str) -&amp;gt; int:
        #outofbound check
        if direction==&#39;R&#39;:
            self.pos[1]+=1
        elif direction==&#39;L&#39;:
            self.pos[1]-=1
        elif direction==&#39;U&#39;:
            self.pos[0]-=1
        elif direction==&#39;D&#39;:
            self.pos[0]+=1
        
        if not (self.h&amp;gt;self.pos[0]&amp;gt;=0): return -1
        if not (self.w&amp;gt;self.pos[1]&amp;gt;=0): return -1
        
        #hadle food
       
        if not (self.food and self.pos==self.food[0]):
            #no food
            self.body.pop(0)
            if self.pos in self.body: return -1
            self.body.append(self.pos[:])
        else:
            #food
            self.food.pop(0)
            self.body.append(self.pos[:])
            self.score+=1
        return self.score
            
# Your SnakeGame object will be instantiated and called as such:
# obj = SnakeGame(width, height, food)
# param_1 = obj.move(direction)

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;354-russian-doll-envelopes-hard&#34;&gt;354. Russian Doll Envelopes (Hard)&lt;/h1&gt;
&lt;p&gt;You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.&lt;/p&gt;
&lt;p&gt;One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.&lt;/p&gt;
&lt;p&gt;Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bisect import bisect_left
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&amp;gt; int:
        arr = envelopes
        arr.sort(key=lambda x: (x[0], -x[1]))

        def lis(nums):
            dp = []
            for i in range(len(nums)):
                idx = bisect_left(dp, nums[i])
                if idx == len(dp):
                    dp.append(nums[i])
                else:
                    dp[idx] = nums[i]
            return len(dp)
        # extract the second dimension and run the LIS
        return lis([i[1] for i in arr])

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试用greedy解决但失败了，感觉是个DP问题。。。思路看答案了。  2D longest increasing subsequence problem (LIS).  KEY： &#39;&#39;we also sort decreasing on the second dimension, so two envelopes that are equal in the first dimension can never be in the same increasing subsequence&#39;&#39; 关键是NlogN的 LIS 没用过。。。，需要记住写法。dp[i] 存储的是长度是i+1的LIS末尾元素。&lt;/p&gt;
&lt;h1 id=&#34;355-design-twitter-medium&#34;&gt;355. Design Twitter （Medium）&lt;/h1&gt;
&lt;p&gt;Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user&#39;s news feed.&lt;br&gt;
Implement the Twitter class:&lt;br&gt;
Twitter() Initializes your twitter object.&lt;br&gt;
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.&lt;br&gt;
List&lt;Integer&gt; getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.&lt;br&gt;
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.&lt;br&gt;
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Twitter:

    def __init__(self):
        self.follows=collections.defaultdict(set)
        self.tweets=collections.defaultdict(list)
        self.time=0
   

    def postTweet(self, userId: int, tweetId: int) -&amp;gt; None:
        self.tweets[userId].append([tweetId,self.time])
        self.time+=1
        

    def getNewsFeed(self, userId: int) -&amp;gt; List[int]:
        res=[]
        followers=self.follows[userId]
        for f in list(followers)+[userId]:
            res.extend(self.tweets[f])
        
        return [ e[0] for e in sorted(res,key=lambda x:-x[1])][:10] 

    def follow(self, followerId: int, followeeId: int) -&amp;gt; None:
        self.follows[followerId].add(followeeId)
    

    def unfollow(self, followerId: int, followeeId: int) -&amp;gt; None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
        


&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;356-line-reflection-medium&#34;&gt;356. Line Reflection (Medium)&lt;/h1&gt;
&lt;p&gt;Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.&lt;/p&gt;
&lt;p&gt;In other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points&#39; set is the same as the reflected ones.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isReflected(self, points: List[List[int]]) -&amp;gt; bool:
        s=set()
        min_=float(&#39;inf&#39;)
        max_=float(&#39;-inf&#39;)
        for p in points:
            min_=min(p[0],min_)
            max_=max(p[0],max_)
            s.add(tuple(p))
        sum_=min_+max_
        for p in points:
            if s and (sum_-p[0],p[1]) not in s:
                return False
        return True
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路竟然和two sum类似， 用一个set先保存点，然后找reflect点是否在set里。 中心位置一定是min+max的中点。&lt;/p&gt;
&lt;h1 id=&#34;357-count-numbers-with-unique-digits-medium&#34;&gt;357. Count Numbers with Unique Digits (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the count of all numbers with unique digits, x, where 0 &amp;lt;= x &amp;lt; 10n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&amp;gt; int:
        #Let f(k) = count of numbers with unique digits with length equals k.
        # f(1)=10
        # f(2)=9*9   choose 1~9, choose 0~9 except first choose
        # f(3)=9*9*8
        # f(k)=9*9*8*...(9-k+2)
        if n==0: return 1
        if n==1: return 10 
        if n==2: return 91
        f=[0]*(n+1)
        f[1]=10
        f[2]=81
        for i in range(3,n+1):
            f[i]=f[i-1]*(9-i+2)
        
         
        res=0
        for j in range(1,n+1):
            #print(j,f[j])
            res+=f[j]
        return res
    
#排列组合。。
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&amp;gt; int:
        if n==0: return 1
        if n==1: return 10
        
        def helper(i):
            res = 1
            canchoose = 10
            for j in range(i):
                if j==0:
                    res*=9
                    canchoose-=1
                else:
                    res*=canchoose
                    canchoose-=1
            return res

        res =0
        for i in range(n+1):
            res+=helper(i)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义f（x） ，意思是长度为x的string，有多少种不同组合方式。答案就是f1+f2+。。。+fn&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-358-rearrange-string-k-distance-apart-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 358. Rearrange String k Distance Apart (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s and an integer k, rearrange s such that the same characters are at least distance k from each other. If it is not possible to rearrange the string, return an empty string &amp;quot;&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rearrangeString(self, s: str, k: int) -&amp;gt; str:
     
        if k == 0:
            return s
        n = len(s)
        count = collections.Counter(s)
        max_val = max(count.values())
        max_count = sum(1 for val in count.values() if val == max_val)
        if (max_val-1)*k+max_count &amp;gt; n:
            return &amp;quot;&amp;quot;
        
        buckets = [[] for _ in range(max_val)]
        cnt = 0
        for key in sorted(count, key = lambda x: -count[x]):
            divisor = max_val if count[key] == max_val else max_val-1
            for _ in range(count[key]):
                buckets[cnt% divisor].append(key)
                cnt += 1
        return &amp;quot;&amp;quot;.join([&amp;quot;&amp;quot;.join(bucket) for bucket in buckets])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刚开始想用bt做，看了答案用的是比较巧妙的bucket。 而且要从数目多的char到数目少的char来排。 排的位置如果是频率最大的，则能排到所有buket，否则只能排到n-1 buket。&lt;br&gt;
aaabbcccd  k=2&lt;br&gt;
count={a：3，c：3，b：2，d：1}&lt;br&gt;
max_val=3 所以有3个buket&lt;br&gt;
【】 【】 【】&lt;br&gt;
先排a，divisor=3&lt;br&gt;
【a】 【a】 【a】&lt;br&gt;
再排c，divisor=3&lt;br&gt;
【ac】【ac】【ac】&lt;br&gt;
再排b，divisor=2 最后一个位置排满了&lt;br&gt;
【acb】【acb】【ac】&lt;br&gt;
再排d，divisor=2&lt;br&gt;
【acbd】【acb】【ac】&lt;/p&gt;
&lt;p&gt;这个思路比较难想出来。。。buket+变divisor。。。&lt;/p&gt;
&lt;h1 id=&#34;359-logger-rate-limiter-easy&#34;&gt;359. Logger Rate Limiter （Easy）&lt;/h1&gt;
&lt;p&gt;Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).&lt;br&gt;
All messages will come in chronological order. Several messages may arrive at the same timestamp.&lt;br&gt;
Implement the Logger class:&lt;br&gt;
Logger() Initializes the logger object.&lt;br&gt;
bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Logger:

    def __init__(self):
        self.dic=dict()
        

    def shouldPrintMessage(self, timestamp: int, message: str) -&amp;gt; bool:
        res=True
        if message in self.dic and timestamp-self.dic[message]&amp;lt;10:
            res=False
        if res:
            self.dic[message]=timestamp
        return res
# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)


#ANSWER WAY OF WRITTING
class Logger(object):

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        &amp;quot;&amp;quot;&amp;quot;
        self._msg_dict = {}
    
    def shouldPrintMessage(self, timestamp, message):
        &amp;quot;&amp;quot;&amp;quot;
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        &amp;quot;&amp;quot;&amp;quot;
        if message not in self._msg_dict:
            # case 1). add the message to print
            self._msg_dict[message] = timestamp
            return True

        if timestamp - self._msg_dict[message] &amp;gt;= 10:
            # case 2). update the timestamp of the message
            self._msg_dict[message] = timestamp
            return True
        else:
            return False

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;360-sort-transformed-array-medium&#34;&gt;360. Sort Transformed Array (Medium)&lt;/h1&gt;
&lt;p&gt;Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 
#ANSWER WAY
class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&amp;gt; List[int]:
 
        
        f=lambda x: a*x**2+b*x+c
        n=len(nums)
        res=[&#39;NULL&#39;]*n
        l=0
        r=n-1
        index= n-1 if a&amp;gt;=0 else 0
        while l&amp;lt;=r:
            if a&amp;gt;=0:
                res[index]=f(nums[l]) if f(nums[l])&amp;gt;=f(nums[r]) else f(nums[r])
                index-=1
                if f(nums[l])&amp;gt;=f(nums[r]):
                    l+=1
                else:
                    r-=1
             
            else:
                res[index]=f(nums[r]) if f(nums[l])&amp;gt;=f(nums[r]) else f(nums[l])
                index+=1
                if f(nums[l])&amp;gt;=f(nums[r]):
                    r-=1
                else:
                    l+=1
        return res
      

#MY ANSWER
class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&amp;gt; List[int]:
        nums = sorted(nums,key = lambda x: abs(x+b/2.0/a) if a!=0 else x )
        nums = list(map(lambda x: a*x*x+b*x+c,nums))
        if a!=0:
            return nums if a&amp;gt;0 else nums[::-1]
        else:
            return nums if b&amp;gt;0 else nums[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;考二次函数，答案更精巧 用two pointer，关键点在于如果a大于0, 最大值肯定在head tail之间的一个，如果a小于0，最小值肯定在head tail中的一个。&lt;/p&gt;
">Leetcode 2021-12-08</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-07/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;341-flatten-nested-list-iterator-medium&#34;&gt;341. Flatten Nested List Iterator （Medium）&lt;/h1&gt;
&lt;p&gt;You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#MY ANSWER
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.res = []
        def helper(nli):
            for e in nli:
                if e.isInteger():
                    self.res.append(e.getInteger())
                else:
                    helper(e.getList())
        helper(nestedList)
            
    def next(self) -&amp;gt; int:
        return self.res.pop(0)
         
    def hasNext(self) -&amp;gt; bool:
        return bool(self.res)
         
#USING STACK
class NestedIterator(object):
    def __init__(self, nestedList):
        self.stack = nestedList[::-1]
        
    def next(self):
        return self.stack.pop().getInteger()
        
    def hasNext(self):
        while self.stack:
            top = self.stack[-1]
            if top.isInteger():
                return True
            self.stack = self.stack[:-1] + top.getList()[::-1]
        return False

#USING GENERTOR
class NestedIterator:

    def __init__(self, nestedList: [NestedInteger]):
        # Get a generator object from the generator function, passing in
        # nestedList as the parameter.
        self._generator = self._int_generator(nestedList)
        # All values are placed here before being returned.
        self._peeked = None

    # This is the generator function. It can be used to create generator
    # objects.
    def _int_generator(self, nested_list) -&amp;gt; &amp;quot;Generator[int]&amp;quot;:
        # This code is the same as Approach 1. It&#39;s a recursive DFS.
        for nested in nested_list:
            if nested.isInteger():
                yield nested.getInteger()
            else:
                # We always use &amp;quot;yield from&amp;quot; on recursive generator calls.
                yield from self._int_generator(nested.getList())
        # Will automatically raise a StopIteration.
    
    def next(self) -&amp;gt; int:
        # Check there are integers left, and if so, then this will
        # also put one into self._peeked.
        if not self.hasNext(): return None
        # Return the value of self._peeked, also clearing it.
        next_integer, self._peeked = self._peeked, None
        return next_integer
        
    def hasNext(self) -&amp;gt; bool:
        if self._peeked is not None: return True
        try: # Get another integer out of the generator.
            self._peeked = next(self._generator)
            return True
        except: # The generator is finished so raised StopIteration.
            return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;generator 解法没见过， 普通解法，要么初始化时候分解，要么用stack倒序，保证栈顶是integer。&lt;/p&gt;
&lt;h1 id=&#34;342-power-of-four-easy&#34;&gt;342. Power of Four （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer n, return true if it is a power of four. Otherwise, return false.&lt;br&gt;
An integer n is a power of four, if there exists an integer x such that n == 4^x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPowerOfFour(self, n: int) -&amp;gt; bool:
        if n==0: return False 
        while n:
            if n==1: return True
            if n%4!=0:
                return False
            n//=4
        return True

class Solution(object):
    def isPowerOfFour(self, n):
        if n == 0:
            return False
        while n % 4 == 0:
            n /= 4
        return n == 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;343-integer-break-medium&#34;&gt;343. Integer Break (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer n, break it into the sum of k positive integers, where k &amp;gt;= 2, and maximize the product of those integers.&lt;br&gt;
Return the maximum product you can get.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def integerBreak(self, n: int) -&amp;gt; int:
        dp = [0]*(n+1)
        dp[1]=1
        for i in range(2,n+1):
            for j in range(1,i):
                dp[i]=max(dp[i],max(dp[j],j)*max(i-j,dp[i-j]))
        return dp[n]
  
class Solution:
    def integerBreak(self, n: int) -&amp;gt; int:
        if n==2: return 1
        if n==3: return 2
        product = 1
        while n&amp;gt;4:
            product*=3;
            n-=3
        product*=n;
        return product

#
class Solution:
    def integerBreak(self, n: int) -&amp;gt; int:
        if n == 2: 
            return 1 
        elif n == 3:
            return 2
        elif n%3 == 0:
            return 3**(n//3)
        elif n%3 == 1:
            return 4* 3**((n - 4) // 3)
        else: 
            #n%3==2
            return 2 * (3** (n//3))


#MY SOLUTION
class Solution:
    def integerBreak(self, n: int) -&amp;gt; int:
        # 2(1+1)   1
        # 3(1+2)   2
        # 4(2+2,1+3) 4
        # 5(2+3,1+4) 6
        # 6(2+4)     9
        # 7 (2+5,3+4)   12
        # 8             16
        # 9             20
        # 10             36

        # dp[i] = maximum product by breaking i
        # max( i-2*2 , 2*dp[i-2] , 3*dp[i-3]...)

        dp = [0]*(n+1)
        dp[2]=1

        for i in range(3,n+1):
            for j in range(2,n+1):
                if i-j&amp;gt;0:
                    dp[i] = max(dp[i], (i-j)*j)
                    dp[i] = max(dp[i], j*dp[i-j])
                else:
                    break
        
        #print(dp)
        return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路,答案一，dp，dp【i】保存i可以被分解的最大乘集，假设i被分解成 a和b的和， 那么a或者b可以选中集训分解dp【a/b】或者不分解保留原始值a/b. 思路2： 用3 as many as possible. 比如 6, 3 乘 3大于2 乘 2 乘 2. 因此答案不会有超过3个的2. 尽力用3.   答案3： 有了思路2 ，和容易写出答案3.但dp这种方法应该想出来。。。&lt;/p&gt;
&lt;h1 id=&#34;344-reverse-string-easy&#34;&gt;344. Reverse String (Easy)&lt;/h1&gt;
&lt;p&gt;Write a function that reverses a string. The input string is given as an array of characters s.&lt;br&gt;
You must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseString(self, s: List[str]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify s in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        l=0
        r=len(s)-1
        while l&amp;lt;r:
            s[l],s[r]=s[r],s[l]
            l+=1
            r-=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;345-reverse-vowels-of-a-string-easy&#34;&gt;345. Reverse Vowels of a String (Easy)&lt;/h1&gt;
&lt;p&gt;Given a string s, reverse only all the vowels in the string and return it.&lt;br&gt;
The vowels are &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39;, and they can appear in both cases.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseVowels(self, s: str) -&amp;gt; str:
        s=[e for e in s]
        l=0
        r=len(s)-1
        vowels={&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;}
        while l&amp;lt;r:
            while l&amp;lt;r and s[l].lower() not in vowels:
                l+=1
            while l&amp;lt;r and s[r].lower() not in vowels:
                r-=1
            
            s[l],s[r]=s[r],s[l]
            r-=1
            l+=1
        
        return &#39;&#39;.join(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;346-moving-average-from-data-stream-easy&#34;&gt;346. Moving Average from Data Stream (Easy)&lt;/h1&gt;
&lt;p&gt;Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.&lt;br&gt;
Implement the MovingAverage class:&lt;br&gt;
MovingAverage(int size) Initializes the object with the size of the window size.&lt;br&gt;
double next(int val) Returns the moving average of the last size values of the stream.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MovingAverage:

    def __init__(self, size: int):
        self.size=size
        self.q=[]
    def next(self, val: int) -&amp;gt; float:
        if len(self.q)&amp;lt;self.size:
            self.q.append(val)
            return sum(self.q)/len(self.q)
        else:
            self.q.pop(0)
            self.q.append(val)
            return sum(self.q)/len(self.q)
        
from collections import deque
class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = deque()
        # number of elements seen so far
        self.window_sum = 0
        self.count = 0

    def next(self, val: int) -&amp;gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        self.queue.append(val)
        tail = self.queue.popleft() if self.count &amp;gt; self.size else 0

        self.window_sum = self.window_sum - tail + val

        return self.window_sum / min(self.size, self.count)

class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = [0] * self.size
        self.head = self.window_sum = 0
        # number of elements seen so far
        self.count = 0

    def next(self, val: int) -&amp;gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        tail = (self.head + 1) % self.size
        self.window_sum = self.window_sum - self.queue[tail] + val
        # move on to the next head
        self.head = (self.head + 1) % self.size
        self.queue[self.head] = val
        return self.window_sum / min(self.size, self.count)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用queue 和 Circular Queue 都是好想法。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue347-top-k-frequent-elements-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;347. Top K Frequent Elements （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&lt;br&gt;
Your algorithm&#39;s time complexity must be better than O(n log n), where n is the array&#39;s size&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
        dic_c = collections.Counter(nums)
        return sorted(dic_c.keys(),key=lambda x: dic_c[x],reverse=True)[:k]

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:        
        from heapq import heappush, heappop
        c = Counter(nums)
        res = []
        for kk,vv in c.items():
            heappush(res, (-vv,kk) )
        r = []
        for i in range(k):
            r.append( heappop(res)[1])
        return r


#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
        count = Counter(nums)
        unique = list(count.keys())
        
        def partition(left, right, pivot_index) -&amp;gt; int:
            pivot_frequency = count[unique[pivot_index]]
            # 1. move pivot to end
            unique[pivot_index], unique[right] = unique[right], unique[pivot_index]  
            
            # 2. move all less frequent elements to the left
            store_index = left
            for i in range(left, right):
                if count[unique[i]] &amp;lt; pivot_frequency:
                    unique[store_index], unique[i] = unique[i], unique[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            unique[right], unique[store_index] = unique[store_index], unique[right]  
            
            return store_index
        
        def quickselect(left, right, k_smallest) -&amp;gt; None:
            &amp;quot;&amp;quot;&amp;quot;
            Sort a list within left..right till kth less frequent element
            takes its place. 
            &amp;quot;&amp;quot;&amp;quot;
            # base case: the list contains only one element
            if left == right: 
                return
            
            # select a random pivot_index
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # if the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return 
            # go left
            elif k_smallest &amp;lt; pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            # go right
            else:
                quickselect(pivot_index + 1, right, k_smallest)
         
        n = len(unique) 
        # kth top frequent element is (n - k)th less frequent.
        # Do a partial sort: from less frequent to the most frequent, till
        # (n - k)th less frequent element takes its place (n - k) in a sorted array. 
        # All element on the left are less frequent.
        # All the elements on the right are more frequent.  
        quickselect(0, n - 1, n - k)
        # Return top k frequent elements
        return unique[n - k:]

#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
        
        bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: 
            bucket[freq].append(num) 
        flat_list = [item for sublist in bucket for item in sublist]
        return flat_list[::-1][:k]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案给出了quick selelct的解法O（n）。但bucket 方法更好。 也是O（n）。&lt;/p&gt;
&lt;h1 id=&#34;348-design-tic-tac-toe-medium&#34;&gt;348. Design Tic-Tac-Toe （Medium）&lt;/h1&gt;
&lt;p&gt;Assume the following rules are for the tic-tac-toe game on an n x n board between two players:&lt;br&gt;
A move is guaranteed to be valid and is placed on an empty block.&lt;br&gt;
Once a winning condition is reached, no more moves are allowed.&lt;br&gt;
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.&lt;br&gt;
Implement the TicTacToe class:&lt;br&gt;
TicTacToe(int n) Initializes the object the size of the board n.&lt;br&gt;
int move(int row, int col, int player) Indicates that the player with id player plays at the cell (row, col) of the board. The move is guaranteed to be a valid move.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TicTacToe:

    def __init__(self, n: int):
        self.n=n
        self.rows_p1 = [0]*n
        self.rows_p2 = [0]*n
        self.cols_p1 = [0]*n
        self.cols_p2 = [0]*n
        self.i_plus_j_n_1_p1=0
        self.i_plus_j_n_1_p2=0
        self.i_equal_j_p1=0
        self.i_equal_j_p2=0
                
    def move(self, row: int, col: int, player: int) -&amp;gt; int:
        if player==1:
            self.rows_p1[row]+=1
            if self.rows_p1[row]==self.n: return player
            self.cols_p1[col]+=1
            if self.cols_p1[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p1+=1
                if self.i_plus_j_n_1_p1==self.n: return player
            if row==col:
                self.i_equal_j_p1+=1
                if self.i_equal_j_p1==self.n: return player
        else:
            self.rows_p2[row]+=1
            if self.rows_p2[row]==self.n: return player
            self.cols_p2[col]+=1
            if self.cols_p2[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p2+=1
                if self.i_plus_j_n_1_p2==self.n: return player
            if row==col:
                self.i_equal_j_p2+=1
                if self.i_equal_j_p2==self.n: return player
        
        return 0


#MY ANSWER
class TicTacToe:

    def __init__(self, n: int):
        self.n = n
        self.p1 = {&#39;row&#39;:[0]*n, &#39;col&#39;:[0]*n, &#39;rpc&#39;:0 ,&#39;rmc&#39;:0} 
        self.p2 = {&#39;row&#39;:[0]*n, &#39;col&#39;:[0]*n, &#39;rpc&#39;:0 ,&#39;rmc&#39;:0} 
    
    def check(self):
        if self._check(self.p1):
            return 1
        if self._check(self.p2):
            return 2
        return 0
    
    def _check(self, info):
        for n in info[&#39;row&#39;]:
            if n==self.n:
                return True
        for n in info[&#39;col&#39;]:
            if n==self.n:
                return True
        if info[&#39;rpc&#39;]==self.n:
            return True
        if info[&#39;rmc&#39;]==self.n:
            return True
        return False

    def move(self, row: int, col: int, player: int) -&amp;gt; int:
        if player==1:
            info = self.p1
        else:
            info = self.p2

        info[&#39;row&#39;][row]+=1
        info[&#39;col&#39;][col]+=1
        if row+col==self.n-1:
            info[&#39;rpc&#39;]+=1 
        if row-col==0:
            info[&#39;rmc&#39;]+=1
        return self.check()
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;349-intersection-of-two-arrays-easy&#34;&gt;349. Intersection of Two Arrays (Easy)&lt;/h1&gt;
&lt;p&gt;Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        return list(set(nums1)&amp;amp;set(nums2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;folowup, solve in O(n) time O(1) space given nums1,nums2 are sorted.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def intersection(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
    # if the lists are already sorted and you&#39;re told to solve in O(n) time and O(1) space:
    nums1.sort() # assume sorted
    nums2.sort() # assume sorted

    # iterate both nums backwards till at least 1 is empty
    # if num2[j] &amp;gt; num1[i], pop num2
    # if num2[j] &amp;lt; num1[i], pop num1
    # if equal and num not last appended to result, append to result and pop both nums
    
    result = []
            
    while nums1 and nums2:
        if nums2[-1] &amp;gt; nums1[-1]:
            nums2.pop()
        elif nums2[-1] &amp;lt; nums1[-1]:
            nums1.pop()
        else:
            # to avoid duplicates
            if not result or (result and nums1[-1] != result[-1]):
                result.append(nums1[-1])
            nums1.pop()
            nums2.pop()

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;350-intersection-of-two-arrays-ii-easy&#34;&gt;350. Intersection of Two Arrays II （Easy）&lt;/h1&gt;
&lt;p&gt;Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        c1=collections.Counter(nums1)
        c2=collections.Counter(nums2)
        res=[]
        for k in c1:
            if k in c2:
                res.extend([k]*min(c1[k],c2[k]))
        return res

#Bad but save space answer
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        nums1.sort()
        nums2.sort()
        result = []
    
        while nums1 and nums2:
            if nums2[-1] &amp;gt; nums1[-1]:
                nums2.pop()
            elif nums2[-1] &amp;lt; nums1[-1]:
                nums1.pop()
            else:
                result.append(nums1[-1])
                nums1.pop()
                nums2.pop()

        return result
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-12-07</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-06/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue331-verify-preorder-serialization-of-a-binary-tree-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;331. Verify Preorder Serialization of a Binary Tree &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as &#39;#&#39;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSerialization(self, preorder: str) -&amp;gt; bool:
        
        stack = []
        for char in preorder.split(&#39;,&#39;):
            while char==&#39;#&#39; and stack and stack[-1]==&#39;#&#39;:
                if len(stack)&amp;lt;2: return False
                stack.pop()
                stack.pop()
            
            stack.append(char)
        
        return stack==[&#39;#&#39;]
                
 #ANSWER           
 class Solution:
    def isValidSerialization(self, preorder: str) -&amp;gt; bool:
        # number of available slots
        slots = 1

        for node in preorder.split(&#39;,&#39;):
            # one node takes one slot
            slots -= 1
            
            # no more slots available
            if slots &amp;lt; 0:
                return False
            
            # non-empty node creates two children slots
            if node != &#39;#&#39;:
                slots += 2
        
        # all slots should be used up
        return slots == 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路初看， 但是用stack解决了， 如果遇到‘X,#,#’ X一定是个leave，出栈，但X本身可能是其他人的child，所以补一个#。  最后如果valid，应该stack为【#】。答案思路没用stack用了计算slot的方法。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred332-reconstruct-itinerary-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;332. Reconstruct Itinerary （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.&lt;br&gt;
All of the tickets belong to a man who departs from &amp;quot;JFK&amp;quot;, thus, the itinerary must begin with &amp;quot;JFK&amp;quot;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&amp;gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
        
        self.visitBitmap=dict()
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
            self.visitBitmap[origin]=[False]*len(itinerary)
        
        self.flights=len(tickets)
        self.result=[]
        route=[&#39;JFK&#39;]
        self.backtracking(&#39;JFK&#39;,route)
        return self.result
    
    def backtracking(self,origin,route):
        if len(route)==self.flights+1:
            self.result=route
            return True
        
        for i, nextDest in enumerate(self.flightMap[origin]):
            if not self.visitBitmap[origin][i]:
                self.visitBitmap[origin][i]=True
                ret=self.backtracking(nextDest,route+[nextDest])
                self.visitBitmap[origin][i]=False
                if ret:
                    return True
        return False

#
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&amp;gt; List[str]:
        dic = collections.defaultdict(list)
        for f,t in tickets:
            dic[f].append(t)
        for f in dic:
            dic[f].sort()

        
        res = []
        def dfs(node=&#39;JFK&#39;):
            destlist =  dic[node]
            while destlist:
                dfs(destlist.pop(0))
            #only when all outgoing to node visited, then add node to result
            res.append(node)

        dfs()
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个明显是个一笔画问题，不知道答案。。。有两个问题，判断能否是一笔画，怎么能画出一笔画。一笔画算法：&lt;br&gt;
It starts with a random node and then follows an arbitrary unvisited edge to a neighbor. This step is repeated until one returns to the starting node. This yields a first circle in the graph.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;If this circle covers all nodes it is an Eulerian cycle and the algorithm is finished. Otherwise, one chooses another node among the cycles&#39; nodes with unvisited edges and constructs another circle, called subtour.
By connecting all the circles in the above process, we build the Eulerian cycle at the end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案1：backtracking+greedy  答案2： 在倒序添加一个机场前，必须已经visited 所有这个机场的outgoing edge。否则就是还有路径没有浏览过。 所以算法是postorder DFS&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue333-largest-bst-subtree-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;333. Largest BST Subtree （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -&amp;gt; int:
         
        self.res=0
        
        def isBST(root):
            if not root: 
                return True
            res=[]
            def inorder(root):
                if not root: return 
                inorder(root.left)
                res.append(root.val)
                inorder(root.right)
            inorder(root)
            for i in range(1,len(res)):
                if res[i-1] &amp;gt;= res[i]:
                    return False
            root.size=len(res)
            return True
            
        
        def helper(root):
            if not root: return
            helper(root.left)
            helper(root.right)
            if isBST(root):
                self.res=max(self.res,root.size)  
     
        helper(root)
        return self.res          

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为要判断isBST，call很多次，自己写的时间复杂度感觉比较大。。。 isBST同时设置了 BST大小，所以call完isBST后直接更新self.res.  看答案思路：答案是preorder 和postorder 。。。 postorder优于preorder，因为没有重复判断isvalidBST. 但需要通知parent node maxleft minright是多少，感觉更繁琐，不如自己的答案。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred334-increasing-triplet-subsequence-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;334. Increasing Triplet Subsequence （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. If no such indices exists, return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def increasingTriplet(self, nums: List[int]) -&amp;gt; bool:
        if len(nums)&amp;lt;3: return False
        
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                 if nums[i]&amp;gt;nums[j]:
                    dp[i]= max(dp[j]+1,dp[i])  
                    if dp[i]&amp;gt;=3: return True
        
        return False


class Solution:
    def increasingTriplet(self, nums: List[int]) -&amp;gt; bool:
        first_num = float(&amp;quot;inf&amp;quot;)
        second_num = float(&amp;quot;inf&amp;quot;)
        for n in nums:
            if n &amp;lt;= first_num:
                first_num = n
            elif n &amp;lt;= second_num:
                second_num = n
            else:
                return True
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试用increasing subsequence DP方法， time limit exceeded。。。直接看答案了。。。直接比较难相到这个方法，思路：scan num list。 边scan边保存看到的最小的和次小的数字，如果遇到比这两个数字都大的，那么找到了答案，如果都没有return False。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred335-self-crossing-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;335. Self Crossing （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of integers distance.&lt;br&gt;
You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.&lt;br&gt;
Return true if your path crosses itself, and false if it does not.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isSelfCrossing(self, distance: List[int]) -&amp;gt; bool:
        
        x=distance
        for i in range(3,len(x)):
            
            if i &amp;gt;= 3 and x[i] &amp;gt;= x[i - 2] and x[i - 1] &amp;lt;= x[i - 3]:
                return True
            
            if i &amp;gt;= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] &amp;gt;= x[i - 2]:
                return True
            
            if i &amp;gt;= 5 and x[i - 2] &amp;gt;= x[i - 4] and x[i - 5] + x[i - 1] &amp;gt;= x[i - 3] and x[i - 1] &amp;lt;= x[i - 3] and x[i - 4] + x[i] &amp;gt;= x[i - 2]:
                return True
        
        return False

#GREAT ANSWER
def isSelfCrossing(self, x):
    b = c = d = e = 0
    for a in x:
        if d &amp;gt;= b &amp;gt; 0 and (a &amp;gt;= c or a &amp;gt;= c-e &amp;gt;= 0 and f &amp;gt;= d-b):
            return True
        b, c, d, e, f = a, b, c, d, e
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接看答案， 只有3种情况会crossing， 第一种包含4条线段 最后一条穿过第一条， 第二种包括5条线段，最后一条嵌入第一条。 第三种包含6条线段，最后一条与第一条十字交叉穿过。&lt;/p&gt;
&lt;p&gt;第二种解法：&lt;/p&gt;
&lt;pre&gt;
            b                              b
   +----------------+             +----------------+
   |                |             |                |
   |                |             |                | a
 c |                |           c |                |
   |                | a           |                |    f
   +-----------&gt;    |             |                | &lt;----+
            d       |             |                |      | e
                    |             |                       |
                                  +-----------------------+
                                               d
&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred336-palindrome-pairs-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;336. Palindrome Pairs (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#TLE
class Solution:
    def palindromePairs(self, words: List[str]) -&amp;gt; List[List[int]]:
        res= []
        def isp(w):
            res = [e for e in w]
            return res==res[::-1]
        for i in range(len(words)):
            for j in range(i+1,len(words)):
                if not words[i] or not words[j] or words[i][0]==words[j][-1]:
                    if isp(words[i]+words[j]):
                        res.append([i,j])
                if not words[i] or not words[j] or words[j][0]==words[i][-1]:
                    if isp(words[j]+words[i]):
                        res.append([j,i])
        return res
#BEST Answer                  
class Solution:
    def palindromePairs(self, words: List[str]) -&amp;gt; List[List[int]]:
      
        def all_valid_prefixes(word):
            valid_prefixes = []
            for i in range(len(word)):
                if word[i:] == word[i:][::-1]:
                    valid_prefixes.append(word[:i])
            return valid_prefixes

        def all_valid_suffixes(word):
            valid_suffixes = []
            for i in range(len(word)):
                if word[:i+1] == word[:i+1][::-1]:
                    valid_suffixes.append(word[i + 1:])
            return valid_suffixes

        word_lookup = {word: i for i, word in enumerate(words)}
        solutions = []

        for word_index, word in enumerate(words):
            reversed_word = word[::-1]

            # Build solutions of case #1. This word will be word 1.
            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:
                solutions.append([word_index, word_lookup[reversed_word]])

            # Build solutions of case #2. This word will be word 2.
            for suffix in all_valid_suffixes(word):
                reversed_suffix = suffix[::-1]
                if reversed_suffix in word_lookup:
                    solutions.append([word_lookup[reversed_suffix], word_index])

            # Build solutions of case #3. This word will be word 1.
            for prefix in all_valid_prefixes(word):
                reversed_prefix = prefix[::-1]
                if reversed_prefix in word_lookup:
                    solutions.append([word_index, word_lookup[reversed_prefix]])

        return solutions
#ANSWER TRIE

class TrieNode:
    def __init__(self):
        self.next = collections.defaultdict(TrieNode)
        self.ending_word = -1
        self.palindrome_suffixes = []

class Solution:
    def palindromePairs(self, words):

        # Create the Trie and add the reverses of all the words.
        trie = TrieNode()
        for i, word in enumerate(words):
            word = word[::-1] # We want to insert the reverse.
            current_level = trie
            for j, c in enumerate(word):
                # Check if remainder of word is a palindrome.
                if word[j:] == word[j:][::-1]:# Is the word the same as its reverse?
                    current_level.palindrome_suffixes.append(i)
                # Move down the trie.
                current_level = current_level.next[c]
            current_level.ending_word = i

        # Look up each word in the Trie and find palindrome pairs.
        solutions = []
        for i, word in enumerate(words):
            current_level = trie
            for j, c in enumerate(word):
                # Check for case 3.
                if current_level.ending_word != -1:
                    if word[j:] == word[j:][::-1]: # Is the word the same as its reverse?
                        solutions.append([i, current_level.ending_word])
                if c not in current_level.next:
                    break
                current_level = current_level.next[c]
            else: # Case 1 and 2 only come up if whole word was iterated.
                # Check for case 1.
                if current_level.ending_word != -1 and current_level.ending_word != i:
                    solutions.append([i, current_level.ending_word])
                # Check for case 2.
                for j in current_level.palindrome_suffixes:
                    solutions.append([i, j])
        return solutions


#ANSWER EASY TO WRITE version
#  case 1) PALINDROME
#                aba
#         a
#         /
#       b
#     /
#    a
#

#  case 2) AB_PALINDROM    BA            rse = [0,1]
    #       
#                     P          A
#                    /             \
#                  lindrom...        B.1
#


#  case 3)  PALINDROM_BA   AB  res = [1,0]
#     
#                  A     B
#                /         \
#         B[idx0]           A.1
        #
        
class TrieNode:
    def __init__(self):
        self.word_id = -1
        self.children = collections.defaultdict(TrieNode)
        self.palindrome_word_ids = []

class Trie:
    def __init__(self):
        self.root = TrieNode()

    @staticmethod
    def is_palindrome(word):
        return word == word[::-1]
 
    def insert(self, index, word):
        node = self.root
        #PALINDROM_BA
        for i, char in enumerate(reversed(word)):
            if self.is_palindrome(word[0:len(word) - i]):
                node.palindrome_word_ids.append(index)
            node = node.children[char]
        node.word_id = index
            
    def search(self, index, word):
        result = []
        node = self.root
        
        #case2
        while word:
            if node.word_id &amp;gt;= 0:
                if self.is_palindrome(word):
                    result.append([index, node.word_id])
            
            if not word[0] in node.children:
                return result
            
            node = node.children[word[0]]
            word = word[1:]

        #case1
        if node.word_id &amp;gt;= 0 and node.word_id != index:
                result.append([index, node.word_id])
        
        #case3
        for palindrome_word_id in node.palindrome_word_ids:
            result.append([index, palindrome_word_id])
        
        return result

class Solution:
    def palindromePairs(self, words: List[str]) -&amp;gt; List[List[int]]:
        trie = Trie()

        for i, word in enumerate(words):
            trie.insert(i, word)

        results = []

        for i, word in enumerate(words):
            results.extend(trie.search(i, word))
            
        return results
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试，time limit exceeded。 基本暴力解，无优化。如何优化？  感觉是用Trie。。。看答案了。思路1： 三种情况，1）word本身是palindrome，2）AB_PALINDROME     BA  找到第一个词所有满足第一个pattern的prefix，然后找prefix[::-1]  3)    BA    PALINDROM_AB,找第二个词所有满足第二个patern的suffix，然后找suffix[::-1]&lt;br&gt;
思路2： Trie， case1） CAT TAC     case2）  CAT   PALINDROME_TAC case3） CAT_PALINDROME  TAC.     只有在扫过所有word1字符情况都不break情况下才会再检查case1和2. 逆序在tire保存word和保存满足palindrome suffix的word ids是简化算法的关键。&lt;/p&gt;
&lt;h1 id=&#34;337-house-robber-iii-medium&#34;&gt;337. House Robber III （Medium）&lt;/h1&gt;
&lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.&lt;br&gt;
Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;br&gt;
Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -&amp;gt; int:
        # root.val =  root.left_rob+root.right.rob                         1)rob2child
        # root.val =  root.left_norob + root.right.norob + root.val        2)rob root no rob child
        # root.val = root.left/right.rob   root.right/left.norob      3) rob one of child norob root
        
    
        #postorder transversal  add two value, rob  norob
        
        def helper(root):
            if not root: return 
            helper(root.left)
            helper(root.right)
            
            #processing leaves
            if not root.left and not root.right:
                root.rob=root.val
                root.norob=0
            
            #if decide rob root:
            root_left_max = root.left.norob if root.left else 0
            root_right_max= root.right.norob if root.right else 0
            root.rob = root.val + root_left_max + root_right_max
            #if decide norob root:
            root_left_max =max([root.left.norob,root.left.rob]) if root.left else 0
            root_right_max= max([root.right.norob,root.right.rob]) if root.right else 0
            root.norob = root_left_max + root_right_max
        
        helper(root)
        return max([root.rob,root.norob])


#ANSWER
class Solution:
    def rob(self, root: TreeNode) -&amp;gt; int:
        def helper(node):
            # return [rob this node, not rob this node]
            if not node:
                return (0, 0)
            left = helper(node.left)
            right = helper(node.right)
            # if we rob this node, we cannot rob its children
            rob = node.val + left[1] + right[1]
            # else we could choose to either rob its children or not
            not_rob = max(left) + max(right)
            return [rob, not_rob]

        return max(helper(root))

#MY ANSWER
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -&amp;gt; int:
        @lru_cache(None)
        def helper(node,flag):
            if not node: return 0
            res = 0
            if flag:
                res+=node.val
                res+=helper(node.left,not flag)+helper(node.right, not flag)
            else:
                # only left
                # only right
                #left+right
                left = max(helper(node.left, not flag),helper(node.left,flag))
                right = max(helper(node.right, not flag),helper(node.right,flag))
                res = max([left,right,left+right])
            return res
        
        return max(helper(root,True),helper(root,False))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;338-counting-bits-easy&#34;&gt;338. Counting Bits (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return an array ans of length n + 1 such that for each i (0 &amp;lt;= i &amp;lt;= n), ans[i] is the number of 1&#39;s in the binary representation of i.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countBits(self, n: int) -&amp;gt; List[int]:
        if n==0: return [0]
        if n==1: return [0,1]
        cur=[0,1]
        while len(cur)&amp;lt;=n:
            cur = cur+[1+e for e in cur]
        return cur[:n+1]
        
#ANSWER
class Solution:
    def countBits(self, n: int) -&amp;gt; List[int]:
        ans = [0] * (n + 1)
        for x in range(1, n + 1):
            ans[x] = ans[x &amp;amp; (x - 1)] + 1
        return ans 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案更优雅，x&amp;amp;x-1 得到去掉最后一个significant bit的数字  X&amp;gt; X&amp;amp;(X-1) 然后从1遍历到n用dp。&lt;/p&gt;
&lt;h1 id=&#34;339-nested-list-weight-sum-medium&#34;&gt;339. Nested List Weight Sum （Medium）&lt;/h1&gt;
&lt;p&gt;You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.&lt;br&gt;
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer&#39;s value set to its depth.&lt;br&gt;
Return the sum of each integer in nestedList multiplied by its depth.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -&amp;gt; int:
        def helper(nestli,level):
            res=0
            for nl in nestli:
                if nl.isInteger():
                    res+=nl.getInteger() * level
                else:
                    res+=helper(nl.getList(),level+1)
            
            return res
        return helper(nestedList,1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue340-longest-substring-with-at-most-k-distinct-characters-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;340. Longest Substring with At Most K Distinct Characters (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&amp;gt; int:
        #  e c e b a  a a a a a a c d a a 
        # two pointer
        #   
        dic=dict()
        start=0
        res=0
        for j,char in enumerate(s):
            #process over k case
            if dic and char not in dic and len(dic)==k:
                while len(dic)==k:
                    dic[s[start]]-=1
                    if dic[s[start]]==0:
                        del dic[s[start]]
                    start+=1
            
            elif char in dic and len(dic)&amp;lt;=k:
                res=max(res,j-start+1)
            
            
            elif len(dic)&amp;lt;k:
                res+=1
        
            
            dic[char]=dic.get(char,0)+1
        
        return res



#ANSWER
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&amp;gt; int:
        n = len(s)
        if n * k == 0:
            return 0

        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -&amp;gt; its rightmost position
        # in the sliding window
        hashmap = defaultdict()

        max_len = 1

        while right &amp;lt; n:
            # add new character and move right pointer
            hashmap[s[right]] = right
            right += 1

            if len(hashmap) == k + 1:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len


#MY ANSWER
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&amp;gt; int:

        dic = dict()
        res = 0
        start = 0
        for i,n in enumerate(s):
            
            # add n  
            dic[n]=i

            #break condtion fix
            if len(dic)&amp;gt;k:
                min_key =None
                min_val = float(&#39;inf&#39;)
                for kk,vv in dic.items():
                    if vv&amp;lt;min_val:
                        min_val =vv
                        min_key = kk
                del dic[min_key]

                start = min_val+1
            #do calculaton
            res = max(res, i-start+1)
        
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型的two pointer 写的磕磕绊绊 但写出来了。。。dic存放window中遇到字符的个数，  case1）如果目前dic有内容而且当前char不在dic而且window已经达到容量，start得向前移动，每前进一位，dic中s【start】数目减少一个，如果减少到0需要删除key。 退出while循环现在len（dic）小于k，后续这个不在dic中的char会加入dic。 case2）char in dic and len（dic）小于等于k，直接算结果 case3） len（dic）小于k，res+1.  答案方法思路也差不多。&lt;/p&gt;
">Leetcode 2021-12-06</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-05/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred321-create-maximum-number-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;321. Create Maximum Number (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.&lt;br&gt;
Create the maximum number of length k &amp;lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.&lt;br&gt;
Return an array of the k digits representing the answer.&lt;br&gt;
Example&lt;br&gt;
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5&lt;br&gt;
Output: [9,8,6,5,3]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[int]:
        # 思路。。。
        # 最大需要每个位置数字最大，
        # 但选择最大的数字有顺序约束
        # 而且当可选最大数字相同时，需要程序tracking 2种不同结果。
        

        def prep(nums, k):
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] &amp;lt; num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            return [max(a, b).pop(0) for _ in a+b]

        return max(merge(prep(nums1, i), prep(nums2, k-i))  for i in range(k+1)   if i &amp;lt;= len(nums1) and k-i &amp;lt;= len(nums2))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。看到答案用了greedy方法。。。  prep function只是在一个数组中按照顺序找出K个最大的数。先算一下需要drop多少个数， 如果当前值大于栈顶元素，说明需要更新栈顶。  merge function这一步是按照a，b的lexcial顺序找到最大的元素，a+b总共有K个元素，所以pop k次。 最后return所有K+1个分割可能产生的结果取最大的。基本不可能现想出来解法。&lt;/p&gt;
&lt;h1 id=&#34;322-coin-change-medium&#34;&gt;322. Coin Change （Medium）&lt;/h1&gt;
&lt;p&gt;You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.&lt;br&gt;
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;br&gt;
You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def coinChange(self, coins: List[int], amount: int) -&amp;gt; int:
        if amount==0: return 0 if coins else -1
        dp = dict()
        for c in coins:
            dp[c]=1
        for a in range(1,amount+1):
            for c in coins:
                if a+c&amp;lt;=amount and a in dp:
                    if a+c in dp:
                        dp[a+c]=min(dp[a+c],dp[a]+1) 
                    else:
                        dp[a+c]=dp[a]+1
        return dp[amount] if   amount in dp else -1

#ANSWER
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&amp;gt; int:
        dp = [float(&#39;inf&#39;)] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float(&#39;inf&#39;) else -1 

#MY ANSWER
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&amp;gt; int:
        if amount==0: return 0
        
        #dp[i] = min(dp[i-coin] + 1)
        dp = [float(&#39;inf&#39;)]*(1+amount)
        
        for i in range(1,amount+1):
            for c in coins:
                if c==i: dp[i]=1
                dp[i] = min(dp[i],dp[i-c]+1) if i-c&amp;gt;=0 else dp[i]
          
        print(dp)
        return dp[amount] if dp[amount]!=float(&#39;inf&#39;) else -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是个DP问题，递归关系？  dp【i】是需要达到amount i需要的次数。 初始coins值的dp【coins_val】=1.   对于每一个有dp值的位置，都用coints_val 更新， dp【i+val】=min（dp【i+val】，dp【i】+1）直到amount。 由于不能开过大内存，所以dp变成dict。&lt;br&gt;
答案写法更标准， dp【x】=min（dp【x】，dp【x-coin】+1） x大于等于coin小于等于amount。&lt;/p&gt;
&lt;h1 id=&#34;323-number-of-connected-components-in-an-undirected-graph-medium&#34;&gt;323. Number of Connected Components in an Undirected Graph （Medium）&lt;/h1&gt;
&lt;p&gt;You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.&lt;br&gt;
Return the number of connected components in the graph.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int:
        
        dic = collections.defaultdict(set)
        for a ,b in edges:
            dic[a].add(b)
            dic[b].add(a)
        
        visited = set()
        
        def dfs(i):
            visited.add(i)
            for j in dic[i]:
                if j not in visited:
                    dfs(j)

        c = 0
        for i in range(n):
            if i not in visited:
                c+=1
                dfs(i)
        

        return c
#UNIONFIND
class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&amp;lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&amp;gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1
                    
    def countComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int:
        uf=self.UnionFind(n)
        for edge in edges:
            uf.union(*edge)
        return uf.n

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意unionfind中   if x!=self.parent[x]   爸爸=找爸爸（爸爸）  self.parent[x]=self.find(self.parent[x])， union只有rank相同时候才需要+rank。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred324-wiggle-sort-ii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;324. Wiggle Sort II （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]....&lt;br&gt;
You may assume the input array always has a valid answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;     def wiggleSort(self, nums):
        count = [0]*5001
        
        for n in nums:
            count[n]+=1
        
        odd = 1
        even = 0
        for n in range(5000,-1,-1):
            if odd &amp;gt;= len(nums) and even &amp;gt;= len(nums):
                break
                
            if count[n] == 0:
                continue
            
            while count[n] and (odd &amp;lt; len(nums) or even &amp;lt; len(nums)):
                count[n]-=1
                if odd &amp;lt; len(nums):
                    nums[odd] = n
                    odd+=2
                else:
                    nums[even] = n
                    even+=2
        
 class Solution(object):
    def wiggleSort(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
      
        arr = sorted(nums)
        for i in range(1, len(nums), 2): nums[i] = arr.pop() 
        for i in range(0, len(nums), 2): nums[i] = arr.pop() 

class Solution:
    def wiggleSort(self, A: List[int]) -&amp;gt; None:        
        N = len(A)                    
        count = [0] * 5001        
        self.curr_val = A[0]
        
        for v in A:
            count[v] += 1
            self.curr_val = max(self.curr_val, v)
        
        def next_val():
            while count[self.curr_val] == 0: self.curr_val -= 1            
            count[self.curr_val] -= 1
            return self.curr_val
                            
        for i in range(1, N, 2): A[i] = next_val()     
        for i in range(0, N, 2): A[i] = next_val() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：从sorted 最大到最小，奇数位置放置，然后偶数位置放置数字。时间要降低到O（n）只能用count sort了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred325-maximum-size-subarray-sum-equals-k-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;325. Maximum Size Subarray Sum Equals k （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there isn&#39;t one, return 0 instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -&amp;gt; int:
        nums = [0]+nums
        for i in range(1,len(nums)):
            nums[i] = nums[i]+nums[i-1]
     
        dic = dict()
        res = 0
        for i ,n in enumerate(nums):
            # n-b = k
            if n-k in dic:
                res = max(res, i-dic[n-k])
            
            #because max length, so n only update at the first time
            if n not in dic:
                dic[n]=i
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该保留更早的index使长度更长。&lt;/p&gt;
&lt;h1 id=&#34;326-power-of-three-easy&#34;&gt;326. Power of Three （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer n, return true if it is a power of three. Otherwise, return false.&lt;br&gt;
An integer n is a power of three, if there exists an integer x such that n == 3x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPowerOfThree(self, n: int) -&amp;gt; bool:
        if n==0: return False
        while n:
            if n==1: return True
            if n%3!=0:
                return False
            n//=3
        return True

class Solution:
    def isPowerOfThree(self, n: int) -&amp;gt; bool:
        if n&amp;lt;1: return False
        while n%3==0:
            n//=3
            
        return n==1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred327-count-of-range-sum-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;327. Count of Range Sum (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.&lt;br&gt;
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i &amp;lt;= j.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&amp;gt; int:
        presum = [0]*(len(nums)+1)
        for i,n in enumerate(nums):
            presum[i+1]=presum[i]+n
        
        res=0
        for i in range(1,len(nums)+1):
            for j in range(i):
                if upper&amp;gt;=presum[i]-presum[j]&amp;gt;=lower:
                    res+=1
        return res
#ANSWER 1 PrefixSum+MergeSort
class Solution:
    def countRangeSum(self, nums, lower, upper):
        cumsum = [0]*(len(nums)+1)
        for i,num in enumerate(nums):
            cumsum[i+1]=cumsum[i]+num
        def sort(lo, hi):
            mid = (lo + hi) // 2
            if mid == lo:
                return 0
            count = sort(lo, mid) + sort(mid, hi)
            i = j = mid
            for left in cumsum[lo:mid]:
                while i &amp;lt; hi and cumsum[i] - left &amp;lt;  lower: i += 1
                while j &amp;lt; hi and cumsum[j] - left &amp;lt;= upper: j += 1
                count += j - i
            cumsum[lo:hi] = sorted(cumsum[lo:hi])
            return count
        return sort(0, len(cumsum))


#ANSER Binary Indexed Tree + Binary Search
class BIT:
    def __init__(self,size):
        self.size = size
        self.bit = [0]*(self.size+1)

    
    def update(self,ind):
        while ind &amp;lt;= self.size:
            self.bit[ind] += 1
            ind += (ind &amp;amp; -ind)
    
                
    def query(self,ind):
        res = 0
        while ind&amp;gt;0:
            res += self.bit[ind]
            ind -= ind &amp;amp; -ind
        return res

class Solution:
    def countRangeSum(self, nums, lower, upper):
        cumsum = [0]
        for n in nums:
            cumsum.append(cumsum[-1]+n)

        res = 0
        sorted_cumsum = sorted(cumsum)
        bit= BIT(len(sorted_cumsum))

        for sum_j in cumsum:
            sum_i_count = bit.query(bisect.bisect_right(sorted_cumsum, sum_j - lower)) - bit.query(bisect.bisect_left(sorted_cumsum, sum_j - upper))
            res += sum_i_count
            bit.update(bisect.bisect_left(sorted_cumsum, sum_j)+1)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首次尝试O（n^2）time limit exccded。  看来得低于O（n^2）才可以。。。改进方法是增加mergesort。 思路：先算cumsum。 目标找出cumsum【right】-cumsum【left】在upper lower 之间的这样的pair个数。 定义helper function merge sort。 返回值是满足条件的个数，先递归找出只在lo&lt;sub&gt;mid和mid&lt;/sub&gt;hi之间的个数。若left~right横跨mid， 对于每一个left in sumsum【lo：mid】 找出满足upper lower bond的 right。其中满足lower bound的index 是i， 满足upper bound 的index 是j 所以 count+=j-i。&lt;br&gt;
又忘记了有segment tree 和binary indexed tree这两种数据结构。。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;collection = empty
for sum_j in Sum:
    sum_i_count = how many sum_i in this collection that sum_j - upper &amp;lt;= sum_i &amp;lt;= sum_j - lower
    res += sum_i_count
    put sum_j into this collection
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;328-odd-even-linked-list-medium&#34;&gt;328. Odd Even Linked List (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.&lt;br&gt;
The first node is considered odd, and the second node is even, and so on.&lt;br&gt;
Note that the relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;
You must solve the problem in O(1) extra space complexity and O(n) time complexity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        if not head: return head
        odd_head=head
        even_head=head.next
        
        cur=head
        odd_tail=None
        c=0
        while cur:
            curnext=cur.next
            c+=1
            if c%2==1:
                #cur is odd node
                cur.next=cur.next.next if cur.next else None
                odd_tail=cur
            else:
                #cur is even node
                cur.next=cur.next.next if cur.next else None
            
            cur=curnext
        
        if odd_tail:
            odd_tail.next=even_head
        
        return odd_head


#ANSWER 
class Solution:
    def oddEvenList(self, head: ListNode) -&amp;gt; ListNode:
        
        if not head: return head
        
        odd  = head
        even = head.next
        evenhead = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        return head

#MY ANSWER
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        if not head : return head
        if not head.next: return head 
        
        A = head
        B = head.next
        
        c = 0
        odd = A
        even = B
        while head and head.next:
            headnext = head.next
            head.next=head.next.next
            head = headnext
            
            c+=1
            if c%2==0:
                odd = head
            else:
                even = head

        odd.next = B 
        return A
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred329-longest-increasing-path-in-a-matrix-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;329. Longest Increasing Path in a Matrix (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n integers matrix, return the length of the longest increasing path in matrix.&lt;br&gt;
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&amp;gt; int:
        dirs = [[0,1],[1,0],[0,-1],[-1,0]]
        m=len(matrix)
        n=len(matrix[0])
        if not matrix: return 0
        cache= [[0]*n for _ in range(m)]
        res=0
        
        def dfs(i,j):
            if cache[i][j]!=0: return cache[i][j]
            for d in dirs:
                x=i+d[0]
                y=j+d[1]
                if m&amp;gt;x&amp;gt;=0 and n&amp;gt;y&amp;gt;=0 and matrix[x][y]&amp;gt;matrix[i][j]:
                    cache[i][j]=max(cache[i][j],dfs(x,y))
            
            cache[i][j]+=1
            return cache[i][j] 
        
        
        for i in range(m):
            for j in range(n):
                res=max(res,dfs(i,j))
                
        return res

#DFS+MEM
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&amp;gt; int:
        m,n = len(matrix),len(matrix[0])
        res = 0

        @lru_cache(None)
        def dfs(i,j):
            res = 0
            for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if m&amp;gt;ii&amp;gt;=0 and n&amp;gt;jj&amp;gt;=0 and matrix[i][j]&amp;lt;matrix[ii][jj]:
                    res = max(res, dfs(ii,jj))
            return res+1
            
        for i in range(m):
            for j in range(n):
                res = max(res, dfs(i,j))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DFS+mem  太晚了直接看答案了。。。因为是strictly increasing path 所以是DAG，所以dfs（i，j） path length 是可以用mem记住的。 但通常的DFS是不能用mem的。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred330-patching-array-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;330. Patching Array （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.&lt;br&gt;
Return the minimum number of patches required.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minPatches(self, nums: List[int], n: int) -&amp;gt; int:
        
        &#39;&#39;&#39;Initialize the range [1, miss) = [1, 1) = empty
        While n is not covered yet
            if the current element nums[i] is less than or equal to miss
                extends the range to [1, miss + nums[i])
                increase i by 1
            otherwise
                patch the array with miss, extends the range to [1, miss + miss)
                increase the number of patches
        Return the number of patches
        &#39;&#39;&#39;
        
        patches=0
        i=0
        miss=1
        while miss&amp;lt;=n:
            if i&amp;lt;len(nums) and nums[i]&amp;lt;=miss:
                #miss is covered
                miss+=nums[i]
                i+=1
            else:
                #patch miss to aray
                miss+=miss
                patches+=1
        return patches

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;太晚没思路直接看答案， 答案思路：假设miss 是最小的missing number， 但我们知道【1，miss） 已经covered。 要cover miss，需要添加小于等于miss的数字。&lt;br&gt;
假设我们添加的数字是x，那么区间【1，miss） 【x，x+miss）都covered。由于x小于等于miss。 所以两个区间可以合并为【1，x+miss）我们想选一个range cover最大的x，显然当x=miss时候区间最大。所以算法是：&lt;br&gt;
初始化区间【1，miss）=【1，1）&lt;br&gt;
当n还没covered，如果 nums【i】小于等于miss，增加区间为【1，miss+nums【i】），i++ 否则， 数组里添加miss， 增加区间为【1，miss+miss), res+=1&lt;/p&gt;
">Leetcode 2021-12-05</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-04/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;311-sparse-matrix-multiplication-medium&#34;&gt;311. Sparse Matrix Multiplication (Medium)&lt;/h1&gt;
&lt;p&gt;Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -&amp;gt; List[List[int]]:
        l=len(mat1)
        m=len(mat1[0])
        n=len(mat2[0])
        #1m*mn = ln
        res = [[0]*n for _ in range(l)]
        
        for i in range(l):
            for j in range(n):
                for k in range(m):
                    res[i][j]+=mat1[i][k]*mat2[k][j]
        return res

####
class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -&amp;gt; List[List[int]]:
        def compress_matrix(matrix: List[List[int]]) -&amp;gt; List[List[int]]:
            rows, cols = len(matrix), len(matrix[0])
            compressed_matrix = [[] for _ in range(rows)]
            for row in range(rows):
                for col in range(cols):
                    if matrix[row][col]:
                        compressed_matrix[row].append([matrix[row][col], col])
            return compressed_matrix
        
        m = len(mat1)
        k = len(mat1[0])
        n = len(mat2[0])
        
        # Store the non-zero values of each matrix.
        A = compress_matrix(mat1)
        B = compress_matrix(mat2)
        
        ans = [[0] * n for _ in range(m)]
        
        for mat1_row in range(m):
            # Iterate on all current &#39;row&#39; non-zero elements of mat1.
            for element1, mat1_col in A[mat1_row]:
                # Multiply and add all non-zero elements of mat2
                # where the row is equal to col of current element of mat1.
                for element2, mat2_col in B[mat1_col]:
                    ans[mat1_row][mat2_col] += element1 * element2
                    
        return ans
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为题目是sparse table 所以更好的做饭是把table 存成hashmap。&lt;/p&gt;
&lt;h1 id=&#34;312-burst-balloonsfont&#34;&gt;312. Burst Balloons&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.&lt;br&gt;
If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.&lt;br&gt;
Return the maximum coins you can collect by bursting the balloons wisely&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxCoins(self, nums: List[int]) -&amp;gt; int: 
        #ith is the last to burst
        nums = [1]+nums+[1]
        n=len(nums)
        dp=[[0]*n for _ in range(n)]
        for left in range(n-2,0,-1):
            for right in range(left,n-1):
                for i in range(left,right+1):
                    gain=nums[left-1]*nums[i]*nums[right+1]
                    remaining=dp[left][i-1]+dp[i+1][right]
                    dp[left][right]=max(dp[left][right],gain+remaining)
        return dp[1][n-2]

#MY ANSWER
class Solution:
    def maxCoins(self, nums: List[int]) -&amp;gt; int:
        @lru_cache(None)
        def dp(i,j):
            res = 0
            for k in range(i,j+1):
                a = nums[k]
                b = nums[i-1] if i-1&amp;gt;=0 else 1
                c = nums[j+1] if j+1&amp;lt;len(nums) else 1
                res = max(res, a*b*c+ dp(i,k-1)+dp(k+1,j))
            return res
        
        return dp(0,len(nums)-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试，backtraking 方法会time limit exceeded， 需要更优方法。 答案1） top down dp， ith气球是最后一个burst的，所以left到i-1，i+1到right先burst。 思路是分治法，能拆分为互相不干扰的left，right部分是因为ith定义是最后一个burst，要ith定义是先burst，就会出现left，right部分dependent关系，right部分数值取决于left最右一个气球是否burst。所以定义ith气球最后一个burst是很聪明的解决了分治法左右depenent问题。2）Bottom-Up dp 算 dp【left】【right】必须知道dp【left】【i-1】和dp【i+1】【right】 i在left right之间，所以dp更新路线是从右下角zigzag更新。&lt;/p&gt;
&lt;h1 id=&#34;313-super-ugly-number-medium&#34;&gt;313. Super Ugly Number （Medium）&lt;/h1&gt;
&lt;p&gt;A super ugly number is a positive integer whose prime factors are in the array primes.&lt;br&gt;
Given an integer n and an array of integers primes, return the nth super ugly number.&lt;br&gt;
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&amp;gt; int:
        dp = [0]*n
        t = [0]*len(primes)
        dp[0]=1
        for i in range(1,n):
            dp[i]=min(dp[t[ii]]*primes[ii] for ii in range(len(primes)))
            for j in range(len(primes)):
                if dp[i]==dp[t[j]]*primes[j]:
                    t[j]+=1
        return dp[-1]
 
        
        # dp = [0] * n
        # t2 = t3 = t5 = 0
        # dp[0] = 1
        # for i in range(1,n):
        #     dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
        #     if(dp[i] == dp[t2]*2): t2 += 1
        #     if(dp[i] == dp[t3]*3): t3 += 1
        #     if(dp[i] == dp[t5]*5): t5 += 1
        # return dp[-1]
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&amp;gt; int:
 
        dp=[1]
        res=1
        s=set()
        for _ in range(n):
            while res in s:
                res = heapq.heappop(dp)
            s.add(res)
            for p in primes:
                heapq.heappush(dp,res*p)
        return res
 
#ANSWER
 class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&amp;gt; int:

        uglies = [1]
        def gen(prime):
            for ugly in uglies:
                yield ugly * prime
        merged = heapq.merge(*map(gen, primes))
        while len(uglies) &amp;lt; n:
            ugly = next(merged)
            if ugly != uglies[-1]:
                uglies.append(ugly)
        return uglies[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仿照ugly unmber II 写出一个dp的解但time limit excceded。   用heapq还是time limit excceded。 这个题目python不友好， 答案用了generator。&lt;/p&gt;
&lt;h1 id=&#34;314-binary-tree-vertical-order-traversal-medium&#34;&gt;314. Binary Tree Vertical Order Traversal （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the vertical order traversal of its nodes&#39; values. (i.e., from top to bottom, column by column).&lt;br&gt;
If two nodes are in the same row and column, the order should be from left to right.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        dic = dict()
        def pre(root,level,hight):
            hight+=1
            if not root: return 
            if level not in dic:
                dic[level]=[]
            dic[level].append((root.val,hight))
            pre(root.left,level-1,hight) 
            pre(root.right,level+1,hight)
        pre(root,0,0)
        res= [ [val[0] for val in sorted(v,key=lambda x:x[1])] for k,v in  sorted(dic.items(),key=lambda x:x[0])]
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记录左右移动同时记录上下移动。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-315-count-of-smaller-numbers-after-self-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 315. Count of Smaller Numbers After Self （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].&lt;br&gt;
Input: nums = [5,2,6,1]&lt;br&gt;
Output: [2,1,1,0]&lt;br&gt;
Explanation:&lt;br&gt;
To the right of 5 there are 2 smaller elements (2 and 1).&lt;br&gt;
To the right of 2 there is only 1 smaller element (1).&lt;br&gt;
To the right of 6 there is 1 smaller element (1).&lt;br&gt;
To the right of 1 there is 0 smaller element.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 
        #  找出 i-1 到 -inf 的cumsum ，而且update 从右往左。
        #  -OFFSET ~0 ~ OFFSET
      class Solution:
    def countSmaller(self, nums: List[int]) -&amp;gt; List[int]:
        class ST:
            def __init__(self,n):
                self.n = n
                self.bit = [0]*(2*self.n)
                #      1
                #     2  3
                #   4  5 6 7 
                #  @ 1 2 3 4 5 6 7
                #
            def update(self,ind):
                ind = ind+self.n
                self.bit[ind]+=1
                while ind&amp;gt;0:
                    l = ind
                    r = ind
                    if ind%2==0:
                        r+=1
                    else:
                        l-=1
                    if ind//2&amp;gt;0:
                        self.bit[ind//2] = self.bit[l]+self.bit[r]
                    ind//=2
            
            def query(self,l,r):
                res = 0
                l+=self.n
                r+=self.n
                while l&amp;lt;=r:
                    if r%2 ==0:
                        res+=self.bit[r]
                        r-=1
                    if l%2==1:
                        res+=self.bit[l]
                        l+=1
                    l//=2
                    r//=2
                return res

          
        OFFSET = 10000
        size = 1+ 2*OFFSET
        st = ST(size)

        res = []
        for n in reversed(nums):
            n = n+OFFSET
            res.append(st.query(0,n-1))
            st.update(n)
    
        return res[::-1]




#ANSWER 2
class Solution:
    def countSmaller(self, nums: List[int]) -&amp;gt; List[int]:
        class BIT:
            def __init__(self,size):
                self.size = size
                self.bit = [0]*(self.size+1)
            def update(self,ind):
                while ind&amp;lt;= self.size:
                    self.bit[ind]+=1
                    ind += ind&amp;amp;-ind
            def query(self,ind):
                res =0 
                while ind&amp;gt;0:
                    res+=self.bit[ind]
                    ind -= ind&amp;amp;-ind
                return res
        

        OFFSET = 10000
        size = 1+ 2*OFFSET
        bit = BIT(size)

        res = []
        for n in reversed(nums):
            n = n+OFFSET+1
            res.append(bit.query(n-1))
            bit.update(n)
        return res[::-1]

#ANSWER3
class Solution:
    def countSmaller(self, nums: List[int]) -&amp;gt; List[int]:    
        def sort(enum):
            half = len(enum) // 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                m, n = len(left), len(right)
                i = j = 0
                while i &amp;lt; m or j &amp;lt; n:
                    if j == n or i &amp;lt; m and left[i][1] &amp;lt;= right[j][1]:
                        enum[i+j] = left[i]
                        smaller[left[i][0]] += j
                        i += 1
                    else:
                        enum[i+j] = right[j]
                        j += 1
            return enum
        smaller = [0] * len(nums)
        sort(list(enumerate(nums)))
        return smaller
 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误以为用stack可以解决~~，答案方法1）Segment Tree 2）Binary index Tree 3)Merge Sort,当选取左边元素，记录 smaller[left[i][0]] += j  ；  left【i】【0】是左边元素在原始数组种的index， j是right中未被选中元素的index，恰巧是小于左边被选中元素的在右边需要变换位置元素的长度。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred316-remove-duplicate-letters-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;316. Remove Duplicate Letters （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.&lt;br&gt;
Example 1:&lt;br&gt;
Input: s = &amp;quot;bcabc&amp;quot;&lt;br&gt;
Output: &amp;quot;abc&amp;quot;&lt;br&gt;
Example 2:&lt;br&gt;
Input: s = &amp;quot;cbacdcbc&amp;quot;&lt;br&gt;
Output: &amp;quot;acdb&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeDuplicateLetters(self, s: str) -&amp;gt; str:
        # maintain smalleset lexicographical order How?
        
        # find pos - the index of the leftmost letter in our solution
        # we create a counter and end the iteration once the suffix doesn&#39;t have each unique character
        # pos will be the index of the smallest character we encounter before the iteration ends
        c=Counter(s)
        pos=0
        for i in range(len(s)):
            if s[i]&amp;lt;s[pos]:
                pos=i
            c[s[i]]-=1
            if c[s[i]]==0:
                break
        return s[pos]+self.removeDuplicateLetters(s[pos:].replace(s[pos],&amp;quot;&amp;quot;)) if s  else &#39;&#39;

#ANSWER
class Solution:
    def removeDuplicateLetters(self, s: str) -&amp;gt; str:
        stack=[]
        seen=set()
        last_occurrence = {c:i for i,c in enumerate(s)}
        for i,c in enumerate(s):
            if c not in seen:
                #只有c不在seen中才能试图在stack中加c
                while stack and c&amp;lt;stack[-1] and i&amp;lt;last_occurrence[stack[-1]]:  
                    # 如果当前试图加入的c&amp;lt;stack[-1] 而且 c的位置&amp;lt; stack[-1]最后出现位置
                    # 可以安全移除stack【-1】
                    val=stack.pop()
                    seen.discard(val)
                    
                seen.add(c)
                stack.append(c)
                
        return &#39;&#39;.join(stack)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路1） 找到第一个qualify的pos，s【i】小于s【pos】需要更新pos成i，当counter s【i】==0时候说明s【i】是当前必须加入结果的字符，然后找下一个字符用recursive方法。&lt;br&gt;
思路2）  见代码 Greedy 方法的应用&lt;/p&gt;
&lt;h1 id=&#34;font-colorred317-shortest-distance-from-all-buildings-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;317. Shortest Distance from All Buildings （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an m x n grid grid of values 0, 1, or 2, where:&lt;br&gt;
each 0 marks an empty land that you can pass by freely,&lt;br&gt;
each 1 marks a building that you cannot pass through, and&lt;br&gt;
each 2 marks an obstacle that you cannot pass through.&lt;br&gt;
You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.&lt;br&gt;
Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#METHOD 1 BFS from Biulding
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&amp;gt; int:
        
        
        #Use hit to record how many times a 0 grid has been reached and use distSum to record the sum of distance from all 1 grids to this 0 grid. A powerful pruning is that during the BFS we use count1 to count how many 1 grids we reached. If count1 &amp;lt; buildings then we know not all 1 grids are connected are we can return -1 immediately, which greatly improved speed (beat 100% submissions).

 
        if not grid or not grid[0]: return -1
        M, N, buildings = len(grid), len(grid[0]), sum(val for line in grid for val in line if val == 1)
        hit, distSum = [[0] * N for i in range(M)], [[0] * N for i in range(M)]

        def BFS(start_x, start_y):
            visited = [[False] * N for k in range(M)]
            visited[start_x][start_y], count1, queue = True, 1, collections.deque([(start_x, start_y, 0)])
            while queue:
                x, y, dist = queue.popleft()
                for i, j in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if 0 &amp;lt;= i &amp;lt; M and 0 &amp;lt;= j &amp;lt; N and not visited[i][j]:
                        visited[i][j] = True
                        if not grid[i][j]:
                            queue.append((i, j, dist + 1))
                            hit[i][j] += 1
                            distSum[i][j] += dist + 1
                        elif grid[i][j] == 1:
                            count1 += 1
            return count1 == buildings  

        for x in range(M):
            for y in range(N):
                if grid[x][y] == 1:
                    if not BFS(x, y): return -1
        return min([distSum[i][j] for i in range(M) for j in range(N) if not grid[i][j] and hit[i][j] == buildings] or [-1])
    

#METHOD 2 BFS from Empty space
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&amp;gt; int:
        M=len(grid)
        N=len(grid[0])
        totalHouses = sum([v for row in grid for v in row if v==1])
        minDistance=float(&#39;inf&#39;)
        def bfs(row,col):
            distanceSum=0
            housesReached=0
            visited =[[False]*N for _ in range(M)]
            q=collections.deque()
            q.append((row,col))
            step=0
            while q and housesReached!=totalHouses:
                l=len(q)
                for _ in range(l):
                    row,col=q.popleft()
                    
                    if grid[row][col]==1:
                        distanceSum+=step
                        housesReached+=1
                        continue
                    
                    for new_row,new_col in [(row+1,col),(row-1,col),(row,col+1),(row,col-1)]:
                        if M&amp;gt;new_row&amp;gt;=0 and N&amp;gt;new_col&amp;gt;=0:
                            if not visited[new_row][new_col] and grid[new_row][new_col]!=2:
                                visited[new_row][new_col]=True
                                q.append((new_row,new_col))
                                
                step+=1
            
            if housesReached!=totalHouses:
                for row in  range(M):
                    for col in range(N):
                        if grid[row][col]==0 and visited[row][col]:
                            grid[row][col]=2
                
                return float(&#39;inf&#39;)
            return distanceSum
        
        
        
        #main
        for row in range(M):
            for col in range(N):
                if grid[row][col]==0:
                    minDistance=min(minDistance,bfs(row,col))
        
        if minDistance==float(&#39;inf&#39;):
            return -1
        return minDistance         

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接看答案了。。。。方法一更好点， 从building处做BFS，保存hits数目。BFS返回count1==#Buildings 这样可以提前截断如果存在不能完全到达所有building情况。&lt;br&gt;
关键是在每一个点都做BFS。不能做一次BFS就出结果。&lt;/p&gt;
&lt;h1 id=&#34;318-maximum-product-of-word-lengths-medium&#34;&gt;318. Maximum Product of Word Lengths （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProduct(self, words: List[str]) -&amp;gt; int:
        ss  = [set() for _ in range(len(words))]
        for i,word in enumerate(words):
            for w in word:
                ss[i].add(w)
        res=float(&#39;-inf&#39;)
        for i in range(len(words)-1):
            for j in range(i+1,len(words)):
                if not ss[i] &amp;amp; ss[j]:
                    res=max(res,len(words[i])*len(words[j]))
        return res if res!=float(&#39;-inf&#39;) else 0
#ANSWER
from collections import defaultdict
class Solution:
    def maxProduct(self, words: List[str]) -&amp;gt; int:
        hashmap = defaultdict(int)
        bit_number = lambda ch : ord(ch) - ord(&#39;a&#39;)
        
        for word in words:
            bitmask = 0
            for ch in word:
                # add bit number bit_number in bitmask
                bitmask |= 1 &amp;lt;&amp;lt; bit_number(ch)
            # there could be different words with the same bitmask
            # ex. ab and aabb
            hashmap[bitmask] = max(hashmap[bitmask], len(word))
        
        max_prod = 0
        for x in hashmap:
            for y in hashmap:
                if x &amp;amp; y == 0:
                    max_prod = max(max_prod, hashmap[x] * hashmap[y])
        return max_prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了bitmask作为key来优化。思路很好。&lt;/p&gt;
&lt;h1 id=&#34;319-bulb-switcher-medium&#34;&gt;319. Bulb Switcher （Medium）&lt;/h1&gt;
&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.&lt;br&gt;
On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.&lt;br&gt;
Return the number of bulbs that are on after n rounds.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def bulbSwitch(self, n: int) -&amp;gt; int:
        return int(math.sqrt(n))
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题比较tricky， 灯泡1到n， 只有灯泡被拨动奇数次才会亮， 比如第i个灯泡，i%round==0时候会被拨动一次， 这样第i个灯泡比如第12个，1，12，2，6，3，4轮时候会被拨到，但是对于完全平方数，比如36个灯泡，1，36，2，18，3，12，4，9，6轮时候会被拨到但为奇数轮。所以找到有多少个完全平方数在1到n之间就可以了。&lt;/p&gt;
&lt;h1 id=&#34;320-generalized-abbreviation-medium&#34;&gt;320. Generalized Abbreviation （Medium）&lt;/h1&gt;
&lt;p&gt;A word&#39;s generalized abbreviation can be constructed by taking any number of non-overlapping and non-adjacent substrings and replacing them with their respective lengths.&lt;br&gt;
For example, &amp;quot;abcde&amp;quot; can be abbreviated into:&lt;br&gt;
&amp;quot;a3e&amp;quot; (&amp;quot;bcd&amp;quot; turned into &amp;quot;3&amp;quot;)&lt;br&gt;
&amp;quot;1bcd1&amp;quot; (&amp;quot;a&amp;quot; and &amp;quot;e&amp;quot; both turned into &amp;quot;1&amp;quot;)&lt;br&gt;
&amp;quot;5&amp;quot; (&amp;quot;abcde&amp;quot; turned into &amp;quot;5&amp;quot;)&lt;br&gt;
&amp;quot;abcde&amp;quot; (no substrings replaced)&lt;br&gt;
However, these abbreviations are invalid:&lt;br&gt;
&amp;quot;23&amp;quot; (&amp;quot;ab&amp;quot; turned into &amp;quot;2&amp;quot; and &amp;quot;cde&amp;quot; turned into &amp;quot;3&amp;quot;) is invalid as the substrings chosen are adjacent.&lt;br&gt;
&amp;quot;22de&amp;quot; (&amp;quot;ab&amp;quot; turned into &amp;quot;2&amp;quot; and &amp;quot;bc&amp;quot; turned into &amp;quot;2&amp;quot;) is invalid as the substring chosen overlap.&lt;br&gt;
Given a string word, return a list of all the possible generalized abbreviations of word. Return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#ANSWER
class Solution:
    def generateAbbreviations(self, word: str) -&amp;gt; List[str]:
        def rec(idx, curr_list):
            if idx == L:
                res.append(&#39;&#39;.join(curr_list))
                return
            
            #Abbreviate
            if curr_list and curr_list[-1].isdigit():
                curr_list[-1] = str(int(curr_list[-1]) + 1)
                rec(idx + 1, curr_list)
                curr_list[-1] = str(int(curr_list[-1]) - 1)
            else:
                rec(idx + 1, curr_list + [&#39;1&#39;])
            
            #Not to abbreviate
            rec(idx + 1, curr_list + [word[idx]])
                
        L = len(word)
        res = []
        rec(0, [])
        return res

#MY ANSWER
class Solution:
    def generateAbbreviations(self, word: str) -&amp;gt; List[str]:
        if len(word)==1: return [&amp;quot;1&amp;quot;,word]

        head = word[0]
        rest = word[1:]
        res = []
        for tmp in self.generateAbbreviations(rest):
            if tmp[0].isdigit():
                i = 0
                while i&amp;lt;len(tmp) and tmp[i].isdigit():
                    i+=1
                res.append(str(int(tmp[:i])+1)+tmp[i:]) 
                res.append(head+tmp)
            else:
                res.append(&#39;1&#39;+tmp)
                res.append(head+tmp)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题只能backtracking解，从第一个位置开始逐个击破。&lt;/p&gt;
">Leetcode 2021-12-04</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-02/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue291-word-pattern-ii-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;291. Word Pattern II （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a pattern and a string s, return true if s matches the pattern.&lt;br&gt;
A string s matches a pattern if there is some bijective mapping of single characters to strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -&amp;gt; bool:
        
        
        
        def helper(pattern,s,dic1,dic2):
            if not s: return not pattern
            if not pattern: return not s
            key = pattern[0]
            res=False
            for i in range(1,len(s)+1):
                dic1_copy=dic1.copy() 
                dic2_copy=dic2.copy()
                s_val = s[:i]
                
                #print(key,s_val)
                if key in dic1_copy and dic1_copy[key]!=s_val: 
                    res=res or False
                    continue
                else:
                    dic1_copy[key]=s_val
                
                if s_val in dic2_copy and dic2_copy[s_val]!=key: 
                    res=res or False
                    continue
                else:
                    dic2_copy[s_val]=key
                    
                s_rest = s[i:]
                res = res or helper(pattern[1:],s_rest,dic1_copy,dic2_copy)
            #if res:
            #    print(pattern,s)
            return res
        
        return helper(pattern,s,dict(),dict())


#MY ANSWER
class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -&amp;gt; bool:

        def bt(p,s, a2b,b2a):
            #print(p,s,a2b,b2a)
            if not p and not s: return True
            if not p: return not s
            res = False
            a = p[0]
            a_rest = p[1:]
            a2b_copy=a2b.copy()
            b2a_copy=b2a.copy()
            for i in range(1,len(s)+1):
                b = s[:i]
                print(b)
                b_rest = s[i:]
                if a in a2b and a2b[a]!=b: 
                    continue
                if b in b2a and b2a[b]!=a:
                    continue
                a2b_copy[a] = b
                b2a_copy[b] = a
                res = res or bt(a_rest,b_rest,a2b_copy,b2a_copy)
            return res
        
        return bt(pattern,s,dict(),dict())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道使用backtracking，但是得小心 dic1 dic2 copy问题，以及res = res or False， 既然当前s[:i] 已经是False了就skip，所以用cotinue。&lt;/p&gt;
&lt;h1 id=&#34;292-nim-game-easy&#34;&gt;292. Nim Game （Easy）&lt;/h1&gt;
&lt;p&gt;You are playing the following Nim Game with your friend:&lt;br&gt;
Initially, there is a heap of stones on the table.&lt;br&gt;
You and your friend will alternate taking turns, and you go first.&lt;br&gt;
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.&lt;br&gt;
The one who removes the last stone is the winner.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canWinNim(self, n: int) -&amp;gt; bool:
        # dp [0]   [1]     [2]   [3]    [4]     [5]
        #    True   True   True  True   False  
        
        dp = [False] * (n+1)
        if n&amp;lt;=3: return True
        dp[0]=True
        dp[1]=True
        dp[2]=True
        dp[3]=True
        for nn in range(2,n+1):
            for i_select in [1,2,3]:
                dp[nn] = dp[nn] or  (not dp[nn-i_select])
        
        #print(dp)
        return dp[n]
    
class Solution:
    def canWinNim(self, n: int) -&amp;gt; bool:
        # 只要对方等于4个 对方必然输。
        # 我先开始，如何让对方等于4个
        # n=4 我输
        # n=5 我选1
        # n=6 我选2
        # n=7 我选3
        # n=8 我选1 不行 我选2 不行 我选3 还是不行
        # n=9 选1
        # n=10 选2
        # n=11 选3
        # n=12 都不行
        
        return  not n%4==0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用dp写了一个答案，但time limit exceeded。 逐渐发现规律。。。就是是否被4整除。&lt;/p&gt;
&lt;h1 id=&#34;293-flip-game-easy&#34;&gt;293. Flip Game （Easy）&lt;/h1&gt;
&lt;p&gt;You are playing a Flip Game with your friend.&lt;br&gt;
You are given a string currentState that contains only &#39;+&#39; and &#39;-&#39;. You and your friend take turns to flip two consecutive &amp;quot;++&amp;quot; into &amp;quot;--&amp;quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.&lt;br&gt;
Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generatePossibleNextMoves(self, currentState: str) -&amp;gt; List[str]:
        res= []
        for i in range(len(currentState)-1):
            if currentState[i]==&#39;+&#39; and currentState[i+1]==&#39;+&#39;:
                res.append(currentState[:i]+&#39;--&#39;+currentState[i+2:])
        return res
class Solution:
    def generatePossibleNextMoves(self, currentState: str) -&amp;gt; List[str]:
        res = []
        for i in range(1,len(currentState)):
            if currentState[i]==&#39;+&#39; and currentState[i-1]==&#39;+&#39;:
                res.append(currentState[:i-1]+&#39;--&#39;+currentState[i+1:])
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;294-flip-game-ii-medium&#34;&gt;294. Flip Game II (Medium)&lt;/h1&gt;
&lt;p&gt;You are playing a Flip Game with your friend.&lt;br&gt;
You are given a string currentState that contains only &#39;+&#39; and &#39;-&#39;. You and your friend take turns to flip two consecutive &amp;quot;++&amp;quot; into &amp;quot;--&amp;quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.&lt;br&gt;
Return true if the starting player can guarantee a win, and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canWin(self, currentState: str) -&amp;gt; bool:
            return any(currentState[i:i+2] == &#39;++&#39; and not self.canWin(currentState[:i] + &#39;--&#39; + currentState[i+2:])  for i in range(len(currentState)))
#ANSWER
class Solution(object):
    _memo = {}
    def canWin(self, s):
        memo = self._memo
        if s not in memo:
            memo[s] = any(s[i:i+2] == &#39;++&#39; and not self.canWin(s[:i] + &#39;--&#39; + s[i+2:])
                          for i in range(len(s)))
        return memo[s]

#ANSWER
class Solution(object):
    def canWin(self, s):
        memo = {}
        def can(s):
            if s not in memo:
                memo[s] = any(s[i:i+2] == &#39;++&#39; and not can(s[:i] + &#39;--&#39; + s[i+2:])
                              for i in range(len(s)))
            return memo[s]
        return can(s)

#ANSWER
class Solution:
    def canWin(self, currentState: str) -&amp;gt; bool:
        res = False
        for i in range(1,len(currentState)):
            if currentState[i-1:i+1]==&#39;++&#39;:
                res = res or  not self.canWin(currentState[:i-1]+&#39;--&#39;+currentState[i+1:])
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred295-find-median-from-data-stream-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;295. Find Median from Data Stream （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from heapq import *


class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))
        else:
            heappush(self.small, -heappushpop(self.large, num))

    def findMedian(self):
        if len(self.small) == len(self.large):
            return float(self.large[0] - self.small[0]) / 2.0
        else:
            return float(self.large[0])

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最简单方法的是sort， 复杂点的比如答案，用了min heap。 思路： small 保存较小的，large保存较大的， 由于需要small的最大元素，minheap头是最小元素，所以push到small要反向。  large能最多比small多存一个元素。 heappushpop同时 push一个元素取出一个元素。TimeCoplex O(logn).&lt;/p&gt;
&lt;h1 id=&#34;296-best-meeting-point-hard&#34;&gt;296. Best Meeting Point （Hard）&lt;/h1&gt;
&lt;p&gt;Given an m x n binary grid grid where each 1 marks the home of one friend, return the minimal total travel distance.&lt;br&gt;
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.&lt;br&gt;
The distance is calculated using Manhattan Distance&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -&amp;gt; int:
        m = len(grid)
        n = len(grid[0])
        X = []
        Y = []
        for r in range(m):
            for c in range(n):
                if grid[r][c]==1:
                    X.append(r)
                    Y.append(c)
        
        X.sort()
        Y.sort()
        R = X[len(X)//2]
        C = Y[len(Y)//2]

        def mindis1d(xs,o):
            dis = 0
            for x in xs:
                dis += abs(x-o)
            return dis
        
        return mindis1d(X,R)+mindis1d(Y,C)
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一想法多次BFS。。。一次cost mn   最差情况有mn个1， 所以最差有O（mmnn）。 不可行。 答案思路：1）分解成2个1d的问题，最小值点出现在median位置。  O(mnlog⁡mn)    2）只要不sort，时间复杂度还能降低到O(mn) 。 拉出来行和列分别遍历即可。&lt;/p&gt;
&lt;h1 id=&#34;297-serialize-and-deserialize-binary-tree-hard&#34;&gt;297. Serialize and Deserialize Binary Tree （Hard）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        &amp;quot;&amp;quot;&amp;quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        res = []
        def pre(root):
            if not root:
                res.append(&#39;@&#39;) 
                return
            res.append(root.val)
            pre(root.left)
            pre(root.right)
        pre(root)
        return &#39;#&#39;.join(map(str,res))
        

    def deserialize(self, data):
        &amp;quot;&amp;quot;&amp;quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &amp;quot;&amp;quot;&amp;quot;
        data = data.split(&#39;#&#39;)
        def pre(data):
            
            cur = data.pop(0)
            if cur!=&#39;@&#39;:
                root = TreeNode(int(cur))
                root.left = pre(data)
                root.right = pre(data)
                return root
            else:
                return None
        return pre(data)

        
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有个什么儿子兄弟表示法，但忘记了。。。这个题目只用了preorder。 但要注意递归时候，传入data必须是list，这样随着递归list本身会变化，要是str会出错。&lt;/p&gt;
&lt;h1 id=&#34;298-binary-tree-longest-consecutive-sequence-medium&#34;&gt;298. Binary Tree Longest Consecutive Sequence （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -&amp;gt; int:
        res=[0]
        def pre(root,parent, length):
            if not root:
                return 
            if parent and root.val==parent.val+1:
                length+=1
            else:
                length=1
            res[0]=max(res[0],length)
            pre(root.left,root,length)
            pre(root.right,root,length)
        pre(root,None,0)
        
        return res[0]


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -&amp;gt; int:
        res = 0
        if not root: return res
        def helper(node,c):
            nonlocal res
            res = max(res,c)
            if not node:
                return 
            
            if node.left:
                if node.val+1==node.left.val:
                    helper(node.left,c+1)
                else:
                    helper(node.left,1)

            if node.right:
                if node.val+1==node.right.val:
                    helper(node.right,c+1)
                else:
                    helper(node.right,1)
        
        helper(root,1)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;299-bulls-and-cows-medium&#34;&gt;299. Bulls and Cows （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getHint(self, secret: str, guess: str) -&amp;gt; str:

        A = 0
        B = 0
        dicA= collections.defaultdict(int)
        dicB= collections.defaultdict(int)
        for a,b in zip(secret,guess):
            if a==b:
                A+=1
            else:
                dicA[a]+=1
                dicB[b]+=1
                
        for b in dicB:            
            if b in dicA:
                B+= min(dicA[b],dicB[b])
        
        return str(A)+&#39;A&#39;+str(B)+&#39;B&#39;
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue300-longest-increasing-subsequence-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;300. Longest Increasing Subsequence (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLIS(self, nums: List[int]) -&amp;gt; int:
        # dp[i] means the LIS till ith number including i
        # dp[i] =  max(dp[i],dp[j]+1)   j&amp;lt;i and nums[j]&amp;lt;nums[i]
        if not nums: return 0
        if len(nums)==1: return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j]&amp;lt;nums[i]:
                    dp[i]=max(dp[i],dp[j]+1)
        
        return max(dp)

class Solution:
    def lengthOfLIS(self, nums: List[int]) -&amp;gt; int:
        res =[]
        while nums:
            cur = nums.pop(0)
            idx =bisect.bisect_left(res,cur)
            if len(res)==idx:
                res.append(cur)
            else:
                res[idx]=cur
        return len(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classical DP problem O(n^2)  binary search method, O(nlogn)&lt;/p&gt;
">Leetcode 2021-12-02</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-01/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;281-zigzag-iterator-medium&#34;&gt;281. Zigzag Iterator （Medium）&lt;/h1&gt;
&lt;p&gt;Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.up = True
        self.v1=v1
        self.v2=v2

    def next(self) -&amp;gt; int:
        if not self.v1:
            return self.v2.pop(0)
        if not self.v2:
            return self.v1.pop(0)
        
        self.up = not self.up
        if self.up:
            return self.v2.pop(0)
        else:
            return self.v1.pop(0)
 
    def hasNext(self) -&amp;gt; bool:
        return len(self.v1)&amp;gt;0 or len(self.v2)&amp;gt;0
        
        
        

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue282-expression-add-operators-hardfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;282. Expression Add Operators (Hard)&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators &#39;+&#39;, &#39;-&#39;, and/or &#39;*&#39; between the digits of num so that the resultant expression evaluates to the target value.Note that operands in the returned expressions should not contain leading zeros.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#MY ANSWER
class Solution:
    def addOperators(self, num: str, target: int) -&amp;gt; List[str]:
        if not num: return []
        res = []
        def bt(tmp,num):
            if not num:
                res.append(tmp)
            else:
                for i in range(1,len(num)+1):
                    head = num[:i]
                    rest = num[i:]
                    if len(head)&amp;gt;1 and head[0]==&#39;0&#39;: continue
                    if rest:
                        for op in &#39;+-*&#39;:
                            bt( tmp+head+op ,rest)
                    else:
                        bt(tmp+head,rest)
        
        bt(&#39;&#39;,num)
        #print(res)
        return [r for r in res if eval(r)==target]


class Solution:
    def addOperators(self, num: &#39;str&#39;, target: &#39;int&#39;) -&amp;gt; &#39;List[str]&#39;:

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append(&amp;quot;&amp;quot;.join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won&#39;t be a
            # valid operand. Hence this check
            if current_operand &amp;gt; 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append(&#39;+&#39;); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append(&#39;-&#39;); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append(&#39;*&#39;); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一眼感觉是用backtracking，写出了第一版，但是没考虑1） number 可以是1位可以是2位，3位 etc， 2）乘法的优先级高于加减，所以需要tracking operator是什么。 3）不可以backtracking到最后eval结果，太费时间。 直接看答案了。。。答案： 关键在于除了加减乘以外，增加一个不操作operator， 12--&amp;gt;123  是 12乘以10+3     extending 当前值12 by one digit， 12乘以10。  看了答案还是懵逼。细节太多但都符合逻辑。&lt;/p&gt;
&lt;h1 id=&#34;283-move-zeroes-easy&#34;&gt;283. Move Zeroes （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def moveZeroes(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos]=n
                pos+=1
        while pos&amp;lt;len(nums):
            nums[pos]=0
            pos+=1

#SWAP is a better solution
class Solution:
    def moveZeroes(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos],nums[i] = nums[i],nums[pos]
                pos+=1
     
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue284-peeking-iterator-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;284. Peeking Iterator (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         &amp;quot;&amp;quot;&amp;quot;
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         &amp;quot;&amp;quot;&amp;quot;
#
#     def hasNext(self):
#         &amp;quot;&amp;quot;&amp;quot;
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         &amp;quot;&amp;quot;&amp;quot;
#
#     def next(self):
#         &amp;quot;&amp;quot;&amp;quot;
#         Returns the next element in the iteration.
#         :rtype: int
#         &amp;quot;&amp;quot;&amp;quot;

class PeekingIterator:
    def __init__(self, iterator):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        :type iterator: Iterator
        &amp;quot;&amp;quot;&amp;quot;
        self.iterator=iterator
        self.peekval=None

    def peek(self):
        &amp;quot;&amp;quot;&amp;quot;
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if self.peekval:
            return self.peekval
        else:
            self.peekval=self.iterator.next()
            return self.peekval
        

    def next(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        if self.peekval is not None:
            peekval=self.peekval
            self.peekval=None
            return peekval
        else:
            return self.iterator.next()
        

    def hasNext(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        return self.iterator.hasNext() or self.peekval is not None
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;285-inorder-successor-in-bst-medium&#34;&gt;285. Inorder Successor in BST (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;) -&amp;gt; &#39;Optional[TreeNode]&#39;:
        stack = []
        while root and root.val!=p.val:
            stack.append(root)
            if p.val&amp;lt;root.val:
                root=root.left
            else:
                root=root.right
        
        if p.right:
            node=p.right
            while node.left:
                node=node.left
            return node
                
        else:
            while stack:
                node=stack.pop()
                if node.val&amp;gt;p.val:
                    return node
            return None


#ANSWER
class Solution:
    
    def inorderSuccessor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        
        successor = None
        
        while root:
            
            if p.val &amp;gt;= root.val:
                root = root.right
            else:
                successor = root
                root = root.left
                
        return successor
#MY ANSWER
class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -&amp;gt; Optional[TreeNode]:

        stack = []
        pre = None
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            root =stack.pop()
            if pre==p:
                return root
            pre = root

            root = root.right

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案更巧妙。&lt;/p&gt;
&lt;h1 id=&#34;286-walls-and-gates-medium&#34;&gt;286. Walls and Gates （Medium）&lt;/h1&gt;
&lt;p&gt;You are given an m x n grid rooms initialized with these three possible values.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-1 A wall or an obstacle.
0 A gate.
INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify rooms in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        visited = set()
        while q:
            level+=1
            for _ in range(len(q)):
                i,j = q.popleft()
                visited.add((i,j))
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&amp;gt;=0 and ii&amp;lt;m and jj&amp;gt;=0 and jj&amp;lt;n and (ii,jj) not in visited:
                        if rooms[ii][jj]!=0 and rooms[ii][jj]!=-1:
                            rooms[ii][jj] = level
                            q.append((ii,jj))
                            visited.add((ii,jj))

#ANSWER
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify rooms in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        while q:
            for _ in range(len(q)):
                i,j = q.popleft()
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&amp;gt;=0 and ii&amp;lt;m and jj&amp;gt;=0 and jj&amp;lt;n and  rooms[ii][jj]==INF :
                        rooms[ii][jj] = rooms[i][j]+1
                        q.append((ii,jj))
                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一眼感觉用bfs做，从gates 处扫不是墙和gate的rooms距离。 差点忘了bfs 要for _ in range(len(queue))  .....   答案不用visited level 解决， 因为BFS所以只要INF 变成距离就是最短距离， 从什么地方变得距离？就是rooms[ii][jj] = rooms[i][j]+1&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-287-find-the-duplicate-number-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 287. Find the Duplicate Number （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.&lt;br&gt;
There is only one repeated number in nums, return this repeated number.&lt;br&gt;
You must solve the problem without modifying the array nums and uses only constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findDuplicate(self, nums: List[int]) -&amp;gt; int:
        for num in nums:
            cur = abs(num)
            if nums[cur] &amp;lt; 0:
                duplicate = cur
                break
            nums[cur] = -nums[cur]

        # Restore numbers
        for i in range(len(nums)):
            nums[i] = abs(nums[i])

        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&amp;gt; int:
        duplicate = 0
        n = len(nums)
        bits = n.bit_length()
        for bit in range(bits):
            mask = 1 &amp;lt;&amp;lt; bit
            base_count = 0
            nums_count = 0
            for i in range(n):
                # If bit is set in number (i) then add 1 to base_count
                if i &amp;amp; mask:
                    base_count += 1
                    
                # If bit is set in nums[i] then add 1 to nums_count
                if nums[i] &amp;amp; mask:
                    nums_count += 1
                    
            # If the current bit is more frequently set in nums than it is in 
            # the range [1, 2, ..., n] then it must also be set in the duplicate number.
            if nums_count - base_count &amp;gt; 0:
                duplicate |= mask
                
        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: &#39;List[int]&#39;) -&amp;gt; &#39;int&#39;:
        
        low = 1
        high = len(nums)-1
        
        while low &amp;lt; high:
            mid = low+(high-low)//2
            count = 0
            for i in nums:
                if i &amp;lt;= mid:
                    count+=1
            if count &amp;lt;= mid:
                low = mid+1
            else:
                high = mid
        return low

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&amp;gt; int:
        
        #who can think it as cycled two pointer problem?
        
        slow = nums[0]
        fast = nums[0]
        
        while True:
            slow =  nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        
        fast = nums[0]
        while slow!=fast:
            slow=nums[slow]
            fast=nums[fast]
        return slow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一堆double数中找single容易，用xor就可以， 但一堆single中找double。。。 答案思路： 思路1）标负。符号所在位置表示数出现过没。 nums[cur]小于0表示 cur这个数出现过。 2）bitmask 3）binary search 4）Cycle Detection，这个方法最妙。&lt;/p&gt;
&lt;h1 id=&#34;288-unique-word-abbreviation-medium&#34;&gt;288. Unique Word Abbreviation （Medium）&lt;/h1&gt;
&lt;p&gt;The abbreviation of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an abbreviation of itself.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ValidWordAbbr:
    
    
    def __init__(self, dictionary: List[str]):
        import collections 
        self.dic= collections.defaultdict(set)
        for w in dictionary:
            key=self.sort(w)
            self.dic[key].add(w)
        #print(self.dic)
        
    def sort(self,w):
        if len(w)&amp;lt;=2:
            key=w
        else:
            key=w[0]+str(len(w[1:-1])) +w[-1]
        return key
    
    def isUnique(self, word: str) -&amp;gt; bool:
        key=self.sort(word)
        if key not in self.dic or (len(self.dic[key])==1 and list(self.dic[key])[0]==word):
            return True
        return False


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)

#Better solution
class ValidWordAbbr(object):
    
    def getkey(self,word):
        if len(word)&amp;lt;=2: 
            return word
        else:
            return word[0]+str(len(word[1:-1]))+word[-1]
        
    
    def __init__(self, dictionary):
        &amp;quot;&amp;quot;&amp;quot;
        :type dictionary: List[str]
        &amp;quot;&amp;quot;&amp;quot;
         
        self.dic=dict()
        for word in dictionary:
            key=self.getkey(word)
            if key in self.dic and word!=self.dic[key]:
                self.dic[key]=&#39;#&#39;
            else:
                self.dic[key]=word
        

    def isUnique(self, word):
        &amp;quot;&amp;quot;&amp;quot;
        :type word: str
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;

        key=self.getkey(word)
        
        if key in self.dic and self.dic[key]==word:
            return True
        elif key not in self.dic:
            return True
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;289-game-of-life-medium&#34;&gt;289. Game of Life (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def gameOfLife(self, board: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        m=len(board)
        n=len(board[0])
        #solve it in-place
        #rule
        #  live cell =1
        #            #nei &amp;lt;2      die
        #            #nei 2 or 3  live
        #            #nei &amp;gt;3      die
        #  dead cell = 0
        #            #nei 3       live
        #
        #  save live die in next round with (X//10)%2   if live save as 10+old
        #                                               if die  save as 20+old
        #  when get old value   old = old%10
        
        for i in range(m):
            for j in range(n):
                live=0
                old=board[i][j]%10
                if old==1:
                    livecell=True
                else:
                    livecell=False
                    
                for nei in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    ii,jj=nei
                    if ii&amp;lt;m and ii&amp;gt;=0 and jj&amp;lt;n and jj&amp;gt;=0:
                        live+=board[ii][jj]%10
                
                if livecell:
                    if live==2 or live==3:
                        board[i][j]= 10+old
                    else:
                        board[i][j]= 20+old
                else:
                    if live==3:
                        board[i][j] = 10+old
                        
        for i in range(m):
            for j in range(n):
                board[i][j] = (board[i][j]//10)%2
        
#INF CASE
def gameOfLifeInfinite(self, live):
    ctr = collections.Counter((I, J)
                              for i, j in live
                              for I in range(i-1, i+2)
                              for J in range(j-1, j+2)
                              if I != i or J != j)
    return {ij
            for ij in ctr
            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}

def gameOfLife(self, board):
    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}
    live = self.gameOfLifeInfinite(live)
    for i, row in enumerate(board):
        for j in range(len(row)):
            row[j] = int((i, j) in live)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;290-word-pattern-easy&#34;&gt;290. Word Pattern （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wordPattern(self, pattern: str, s: str) -&amp;gt; bool:
        
        dic1=dict()
        dic2=dict()
        if len(pattern)!=len(s.split()): return False
        for k,v in zip(s.split(),pattern):
            if k not in dic1:
                dic1[k]=v
            else:
                if dic1[k]!=v:
                    return False
            
            if v not in dic2:
                dic2[v]=k
            else:
                if dic2[v]!=k:
                    return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意是一一映射，所以需要2个dict检查， 注意corner case。&lt;/p&gt;
">Leetcode 2021-12-01</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-30/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;271-encode-and-decode-strings-medium&#34;&gt;271. Encode and Decode Strings (Medium)&lt;/h1&gt;
&lt;p&gt;Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Codec:
    def encode(self, strs: [str]) -&amp;gt; str:
        &amp;quot;&amp;quot;&amp;quot;Encodes a list of strings to a single string.
        &amp;quot;&amp;quot;&amp;quot;
        candidate=&#39;a&#39;
        set_ = set()
        for str in strs:
            for s in str:
                set_.add(s)
        while candidate in set_:
            candidate = chr(ord(candidate)+1)
        return candidate + candidate.join(strs)
        

    def decode(self, s: str) -&amp;gt; [str]:
        &amp;quot;&amp;quot;&amp;quot;Decodes a single string to a list of strings.
        &amp;quot;&amp;quot;&amp;quot;
        candidate = s[0]
        s = s[1:]
        return s.split(candidate)
        


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue272-closest-binary-search-tree-value-ii-hard-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;272. Closest Binary Search Tree Value II (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;快排法是On解法，的确是个hard&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#ANSWER 1 Recursive Inorder + Sort, O(N log N) time
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        nums = inorder(root)
        nums.sort(key = lambda x: abs(x - target))
        return nums[:k]

#ANSWER 2 
from heapq import heappush, heappop
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            if not r:
                return
            
            inorder(r.left)
            heappush(heap, (- abs(r.val - target), r.val))
            if len(heap) &amp;gt; k:
                heappop(heap)
            inorder(r.right) 
    
        heap = []
        inorder(root)
        return [x for _, x in heap]

#ANSWER 3 QuickSelect, O(N) time.
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&amp;gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        def partition(pivot_idx, left, right):
            pivot_dist = dist(pivot_idx)
            
            # 1. move pivot to end
            nums[right], nums[pivot_idx] = nums[pivot_idx], nums[right]
            store_idx = left
            
            # 2. move more close elements to the left
            for i in range(left, right):
                if dist(i) &amp;lt; pivot_dist:
                    nums[i], nums[store_idx] = nums[store_idx], nums[i]
                    store_idx += 1
                    
            # 3. move pivot to its final place
            nums[right], nums[store_idx] = nums[store_idx], nums[right]
            
            return store_idx
            
        def quickselect(left, right):
            &amp;quot;&amp;quot;&amp;quot;
            Sort a list within left..right till kth less close element
            takes its place.
            &amp;quot;&amp;quot;&amp;quot;
            # base case: the list contains only one element
            if left == right:
                return 
            
            # select a random pivot_index
            pivot_idx = randint(left, right)
            
            # find the pivot position in a sorted list
            true_idx = partition(pivot_idx, left, right)
            
            # if the pivot is in its final sorted position
            if true_idx == k:
                return
            
            if true_idx &amp;lt; k:
                # go left
                quickselect(true_idx, right)
            else:
                # go right
                quickselect(left, true_idx)
        
        nums = inorder(root)
        dist = lambda idx : abs(nums[idx] - target)
        quickselect(0, len(nums) - 1)
        return nums[:k]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，但是感觉用minheap会更好。我的方法得一直sort，时间复杂度太高。  需要记住 from heapq import heappush，heappop 用法 heappush（heap，val） heappop（heap） 每次pop出来的是最小的元素。  O（n）方法用到了快排。&lt;/p&gt;
&lt;h1 id=&#34;273-integer-to-english-words-hard&#34;&gt;273. Integer to English Words （Hard）&lt;/h1&gt;
&lt;p&gt;Convert a non-negative integer num to its English words representation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numberToWords(self, num: int) -&amp;gt; str:
      
        nums = []
      
        if num==0: nums.append(0)
        while num:
            nums.append(num%1000)
            num//=1000
        
    
        res = []
        l=len(nums)
        dic = {0:&#39;&#39;,1:&#39;Thousand&#39;,2:&#39;Million&#39;,3:&#39;Billion&#39;,4:&#39;Trillion&#39;}
        def helper(n):
            if type(n)==str: return &#39;&#39;
            s  = &#39;&#39;
            dic = {0:&#39;Zero&#39;,1:&#39;One&#39;,2:&#39;Two&#39;,3:&#39;Three&#39;,4:&#39;Four&#39;,5:&#39;Five&#39;,6:&#39;Six&#39;,7:&#39;Seven&#39;,8:&#39;Eight&#39;,9:&#39;Nine&#39;,10:&#39;Ten&#39;,11:&#39;Eleven&#39;,12:&#39;Twelve&#39;,13:&#39;Thirteen&#39;,14:&#39;Fourteen&#39;,15:&#39;Fifteen&#39;,16:&#39;Sixteen&#39;,17:&#39;Seventeen&#39;,18:&#39;Eighteen&#39;,19:&#39;Nineteen&#39;,20:&#39;Twenty&#39;,30:&#39;Thirty&#39;,40:&#39;Forty&#39;,50:&#39;Fifty&#39;,60:&#39;Sixty&#39;,70:&#39;Seventy&#39;,80:&#39;Eighty&#39;,90:&#39;Ninety&#39;}
            
            if n&amp;lt;10: return dic[n]
            if n&amp;gt;99:
                s+= dic[n//100]+&#39; Hundred&#39;
            n = n%100
            if n==0: return s
            if n in dic:
                s+= &#39; &#39;+dic[n]
                return s
            else:
                s+=&#39; &#39;+dic[10*(n//10)]
                n=n%10
                if n==0:
                    return s
                else:
                    s+= &#39; &#39;+ dic[n]
                    return s
       
        tmp=[]
        while nums:
            if nums[0]==0:
                nums.pop(0)
                tmp.append(&#39;#&#39;)
            else:
                tmp.append(nums.pop(0))

        nums=tmp
        if nums==[&#39;#&#39;]:
            nums=[0]
        for i,number in enumerate(nums):
            if number!=&#39;#&#39;:
                res.append(helper(number)+ &#39; &#39; + dic[i])
        return &#39; &#39;.join([ e.strip() for e in res[::-1] if e.strip()])
#ANSWER
class Solution:
    def numberToWords(self, num):
        &amp;quot;&amp;quot;&amp;quot;
        :type num: int
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        def one(num):
            switcher = {
                1: &#39;One&#39;,
                2: &#39;Two&#39;,
                3: &#39;Three&#39;,
                4: &#39;Four&#39;,
                5: &#39;Five&#39;,
                6: &#39;Six&#39;,
                7: &#39;Seven&#39;,
                8: &#39;Eight&#39;,
                9: &#39;Nine&#39;
            }
            return switcher.get(num)

        def two_less_20(num):
            switcher = {
                10: &#39;Ten&#39;,
                11: &#39;Eleven&#39;,
                12: &#39;Twelve&#39;,
                13: &#39;Thirteen&#39;,
                14: &#39;Fourteen&#39;,
                15: &#39;Fifteen&#39;,
                16: &#39;Sixteen&#39;,
                17: &#39;Seventeen&#39;,
                18: &#39;Eighteen&#39;,
                19: &#39;Nineteen&#39;
            }
            return switcher.get(num)
        
        def ten(num):
            switcher = {
                2: &#39;Twenty&#39;,
                3: &#39;Thirty&#39;,
                4: &#39;Forty&#39;,
                5: &#39;Fifty&#39;,
                6: &#39;Sixty&#39;,
                7: &#39;Seventy&#39;,
                8: &#39;Eighty&#39;,
                9: &#39;Ninety&#39;
            }
            return switcher.get(num)
        

        def two(num):
            if not num:
                return &#39;&#39;
            elif num &amp;lt; 10:
                return one(num)
            elif num &amp;lt; 20:
                return two_less_20(num)
            else:
                tenner = num // 10
                rest = num - tenner * 10
                return ten(tenner) + &#39; &#39; + one(rest) if rest else ten(tenner)
        
        def three(num):
            hundred = num // 100
            rest = num - hundred * 100
            if hundred and rest:
                return one(hundred) + &#39; Hundred &#39; + two(rest) 
            elif not hundred and rest: 
                return two(rest)
            elif hundred and not rest:
                return one(hundred) + &#39; Hundred&#39;
        
        billion = num // 1000000000
        million = (num - billion * 1000000000) // 1000000
        thousand = (num - billion * 1000000000 - million * 1000000) // 1000
        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000
        
        if not num:
            return &#39;Zero&#39;
        
        result = &#39;&#39;
        if billion:        
            result = three(billion) + &#39; Billion&#39;
        if million:
            result += &#39; &#39; if result else &#39;&#39;    
            result += three(million) + &#39; Million&#39;
        if thousand:
            result += &#39; &#39; if result else &#39;&#39;
            result += three(thousand) + &#39; Thousand&#39;
        if rest:
            result += &#39; &#39; if result else &#39;&#39;
            result += three(rest)
        return result

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;corner case 有点太多了。。。写出来是写出来了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred274-h-index-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;274. H-Index （Medium)&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher&#39;s h-index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
        # [1,3,1]
        # 
        #  0 1 2 3
        # []
        
        dp = [0]*(len(citations)+1)
        for c in citations:
            if c&amp;gt;len(citations):
                c=len(citations)
            dp[c]+=1
        
        for i in range(len(dp)-2,-1,-1):
            dp[i]=dp[i]+dp[i+1]
        
        hindex=[]
        print(dp)
        for ind, n in enumerate(dp):
            if n&amp;gt;=ind:
                hindex.append(ind)
        
        return max(hindex)

#ANSWER reverse SORT
class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
    
        citations.sort(reverse=True)
        print(citations)
        hindex=0
        for ind, cit in enumerate(citations):
            hindex_candidate = ind+1
            if cit&amp;gt;=hindex_candidate:
                hindex = hindex_candidate
                
        return hindex

#MY ANSER
class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
        l=len(citations)
        dp = [0]*(l+1)
        for c in citations:
            if c&amp;gt;l:
                c = l
            dp[c]+=1
        for i in range(l-1,-1,-1):
            dp[i] +=dp[i+1]
        
        candi = 0
        for i,p in enumerate(dp):
            if p&amp;gt;=i:
                candi  =i
        return candi
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue275-h-index-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;275. H-Index II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;sorted citations O(lgn) time to solve&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hIndex(self, citations: List[int]) -&amp;gt; int:
        l = len(citations)
        
        left = 0
        right = l-1
        candi = 0
        while left&amp;lt;=right:
            mid = (left+right)//2
            cit = citations[mid]
            hidx = l-mid
            if cit&amp;gt;=hidx:
                candi = max(candi,hidx)
                right = mid-1
            else:
                left = mid+1
        return candi


#ANSWER
class Solution:
    def hIndex(self, citations):
        &amp;quot;&amp;quot;&amp;quot;
        :type citations: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(citations)
        for idx, c in enumerate(citations):
            if c &amp;gt;= n - idx:
                return n - idx
        return 0
#binary serach
class Solution:
    def hIndex(self, citations):
        &amp;quot;&amp;quot;&amp;quot;
        :type citations: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(citations)
        left, right = 0, n - 1

        # We need to find the rightmost &#39;index&#39; such that: (citations[index] &amp;lt;= n - index)
        while left &amp;lt;= right:
            mid = left + (right - left) // 2

            # There&#39;s (n - mid) papers with an equal or higher citation count than citations[mid]
            # If (citations[mid] == n - mid) it&#39;s the optimal result and can be returned right away
            if citations[mid] == n - mid:
                return n - mid

            # If citations[mid] is less than (n - mid), narrow down on the right half to look for a paper
            # at a future index that meets the h-index criteria. Otherwise, narrow down on the left half
            if citations[mid] &amp;lt; n - mid:
                left = mid + 1
            else:
                right = mid - 1

        # We didn&#39;t find an exact match, so there&#39;s exactly (n - left) papers that have citations
        # greater than or equal to citations[left] and that is our answer
        return n - left
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，但是还是不熟。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred276-paint-fence-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;276. Paint Fence (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are painting a fence of n posts with k different colors. You must paint the posts following these rules:&lt;br&gt;
Every post must be painted exactly one color.&lt;br&gt;
There cannot be three or more consecutive posts with the same color.&lt;br&gt;
Given the two integers n and k, return the number of ways you can paint the fence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numWays(self, n: int, k: int) -&amp;gt; int:
        # dp    
        # n = 0    0  
        # n = 1    k
        # n = 2    k*k    
        # n = 3    diff color  (k-1)*dp[i-1]   same color 1*  (k-1)*dp[i-2]  
        # so, dp[i] = (k-1)dp[i-1]+(k-1)*dp[i-2]
        
        if n==1:
            return k
        if n==2:
            return k*k
        dp=[0]*(n+1)
        dp[1]=k
        dp[2]=k*k
        for i in range(3,n+1):
            dp[i] = (k-1)*(dp[i-1]+dp[i-2])
        
        return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是DP，递推关系是？ 已经想到了，但是没仔细去想。 当前颜色和前一个相同， 当前颜色和前一个不同。&lt;/p&gt;
&lt;h1 id=&#34;277-find-the-celebrity-medium&#34;&gt;277. Find the Celebrity （Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def findCelebrity(self, n: int) -&amp;gt; int:
        self.n = n
        celebrity_candidate = 0
        for i in range(1, n):
            if knows(celebrity_candidate, i):
                celebrity_candidate = i
        if self.is_celebrity(celebrity_candidate):
            return celebrity_candidate
        return -1

    def is_celebrity(self, i):
        for j in range(self.n):
            if i == j: continue
            if knows(i, j) or not knows(j, i):
                return False
        return True

#MY ANSWER
class Solution:
    def findCelebrity(self, n: int) -&amp;gt; int:
        candi = -1
        for i in range(n):
            if candi!=i and  knows(candi,i):
                candi = i
     
        for i in range(n):
           if i!=candi and (not knows(i,candi) or knows(candi,i) ):
                return -1
        return candi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案找possible candidate O（n）时间的方法第一次没想出来。。。&lt;/p&gt;
&lt;h1 id=&#34;278-first-bad-version-easy&#34;&gt;278. First Bad Version （Easy）&lt;/h1&gt;
&lt;p&gt;Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        
        l=1
        r=n
        while l&amp;lt;=r:
            m=(l+r)//2
            if isBadVersion(m):
                r=m-1
            else:
                l=m+1
        return l

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue279-perfect-squares-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;279. Perfect Squares (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the least number of perfect square numbers that sum to n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#ANSWER O（n*sqrt（n））
class Solution(object):
    def numSquares(self, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type n: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float(&#39;inf&#39;)] * (n+1)
        # bottom case
        dp[0] = 0
        
        for i in range(1, n+1):
            for square in square_nums:
                if i &amp;lt; square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]

#MY ANSWER
class Solution:
    @lru_cache(None)
    def numSquares(self, n: int) -&amp;gt; int:
        if n==1:
            return 1
        if int(n**0.5)**2 == n:
            return 1
        res = n
        for i in range(1, int(n**(0.5))+1):
            res=min(res,1+ self.numSquares(n - i*i))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案pre calculate square_nums  省了很多时间也不用判断是否为完全平方数。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred280-wiggle-sort-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;280. Wiggle Sort （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, reorder it such that nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]....&lt;br&gt;
You may assume the input array always has a valid answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wiggleSort(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        nums.sort()
        for i in range(1,len(nums)-1,2):
            nums[i],nums[i+1]=nums[i+1],nums[i]

#ANSWER
class Solution:
    def wiggleSort(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        less=True
        for i in range(len(nums)-1):
            if less:
                if nums[i]&amp;gt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            else:
                if nums[i]&amp;lt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            
            less=not less
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;too late today。  思路1  sort first， 从第二个元素开始swap。 思路2，如果顺序不正确就纠正。&lt;/p&gt;
">Leetcode 2021-11-30</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-12-03/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred301-remove-invalid-parentheses-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;301. Remove Invalid Parentheses (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.&lt;br&gt;
Return all the possible results. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def removeInvalidParentheses(self, s):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :rtype: List[str]
        &amp;quot;&amp;quot;&amp;quot;
        
        res=[] 
        if not s: return [s]
        visited=set()
        q=[]
        
        q.append(s)
        visited.add(s)
        
      
        
        def isValid(s):
            c=0
            for e in s:
                if e==&#39;(&#39;:c+=1
                if e==&#39;)&#39;:c-=1
                
                if c&amp;lt;0: return False
            return c==0

        found=False
        
        while q:
            s=q.pop(0)
            
            if isValid(s):
                res.append(s)
                found=True
            
            if found: continue
            
            for i in range(len(s)):
                if s[i]!=&#39;(&#39; and s[i]!=&#39;)&#39;: continue
                t=s[:i]+s[i+1:]
                
                if not t in visited:
                    q.append(t)
                    visited.add(t)
        
        return res
    
#         def valid(s):
#             stack=[]
#             ss=[ i for i in s if (i in &#39;()&#39;) ]
#             for e in ss:
#                 if e==&#39;)&#39;:
#                     if (not stack) or (not stack.pop()==&#39;(&#39;):
#                         return False
#                 else:
#                     stack.append(e)
#             return not stack

#ANSWER
class Solution:
    
  
    
    def removeInvalidParentheses(self, s: str) -&amp;gt; List[str]:
        #based on hint 
        #1) figure out how many misplaced left and right parenthesis
        left=0
        right=0
        for i,p in enumerate(s):
            if p==&#39;(&#39;:
                left+=1
            elif p==&#39;)&#39;:
                if left&amp;gt;0:
                    left-=1
                else:
                    right+=1
        
        #2)recursion process 
        res =set()
        def bt(left_rem,right_rem,left,right,tmp,index):
            #left_rem is the left error position ( remained
            #right_rem is the right error position ) remained
            #left is # of ( in current expression tmp
            #right is # of ) in current expression tmp
            #tmp is current expression
            #index is the index of char in original string s
            
            #BASE CASE
            if index==len(s):     
                #print(left_rem,right_rem,left,right,tmp)
                if left_rem==0 and right_rem==0:
                    res.add(&amp;quot;&amp;quot;.join(tmp))
                return
            
            #discard current
            if (s[index]==&#39;(&#39; and left_rem&amp;gt;0) or (s[index]==&#39;)&#39; and right_rem&amp;gt;0):
                bt(left_rem-(s[index]==&#39;(&#39;),right_rem-(s[index]==&#39;)&#39;),left,right,tmp,index+1)

            #add current
            tmp.append(s[index])

            #if current is not in {()}
            if s[index] not in [&amp;quot;(&amp;quot;,&amp;quot;)&amp;quot;]:
                bt(left_rem,right_rem,left,right,tmp,index+1)
            elif s[index]==&#39;(&#39;:
                #consider an opening bracket
                bt(left_rem,right_rem,left+1,right,tmp,index+1)
            elif s[index]==&#39;)&#39; and left&amp;gt;right:
                # consider a closing bracket
                bt(left_rem,right_rem,left,right+1,tmp,index+1)

            tmp.pop()                 

         
        bt(left,right,0,0,[],0)
        return list(res)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路1 最快最吊炸天） 类似bfs，用queue 做，验证每一个可能的结果。但为了找到最少的变动就能valid的string，所以一旦找到remove后可以valid的string就不在queue中添加后续元素了。 2）backtracking，先计算错位的left right 括号个数。需要track的， left_remain,right_remain,left_counter,right_counter, tmp=[], index.  比较复杂。&lt;/p&gt;
&lt;h1 id=&#34;302-smallest-rectangle-enclosing-black-pixels-hard&#34;&gt;302. Smallest Rectangle Enclosing Black Pixels （Hard）&lt;/h1&gt;
&lt;p&gt;You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel.&lt;br&gt;
The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.&lt;br&gt;
Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.&lt;br&gt;
You must write an algorithm with less than O(mn) runtime complexity&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    minx=float(&#39;inf&#39;)
    miny=float(&#39;inf&#39;)
    maxx=float(&#39;-inf&#39;)
    maxy=float(&#39;-inf&#39;)
    def minArea(self, image: List[List[str]], x: int, y: int) -&amp;gt; int:
        
        m=len(image)
        n=len(image[0])
        def dfs(x,y):
            self.minx=min(self.minx,x)
            self.miny=min(self.miny,y)
            self.maxx=max(self.maxx,x)
            self.maxy=max(self.maxy,y)
            image[x][y]=&#39;#&#39;
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&amp;gt;=0 and xx&amp;lt;m and yy&amp;gt;=0 and yy&amp;lt;n and image[xx][yy]==&#39;1&#39;:
                    dfs(xx,yy)
        dfs(x,y)
        return (self.maxx-self.minx+1)*(self.maxy-self.miny+1)
#ANSWER WAY of WRITING
class Solution:
    def minArea(self, image: List[List[str]], x: int, y: int) -&amp;gt; int:
        m, n = len(image), len(image[0])
        def has_one(i, is_row=True):
            return any([(image[i][j] if is_row else image[j][i]) == &amp;quot;1&amp;quot; for j in range(n if is_row else m)])

        top = bisect.bisect_left(range(x+1), 1, key=lambda i: has_one(i))
        bottom = bisect.bisect_left(range(x, m), 1, key=lambda i: not has_one(i))+x
        left = bisect.bisect_left(range(y+1), 1, key=lambda i: has_one(i, False))
        right = bisect.bisect_left(range(y, n), 1, key=lambda i: not has_one(i, False))+y

        return (bottom-top)*(right-left)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了bfs ，dfs外 答案给出了一种project 图片到1D，然后用binary search 找上下界，来算面积。&lt;/p&gt;
&lt;h1 id=&#34;303-range-sum-query-immutable-easy&#34;&gt;303. Range Sum Query - Immutable （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class NumArray:

    def __init__(self, nums: List[int]):
        
        for i,n in enumerate(nums):
            if i==0: continue
            nums[i]+=nums[i-1]
        self.cumsum=nums

    def sumRange(self, left: int, right: int) -&amp;gt; int:
        # 1 2 3
        # 1 3 6
        return self.cumsum[right]-self.cumsum[left-1] if left-1&amp;gt;=0 else self.cumsum[right]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)

#OR ANSWER WAY OF WRITTEN
class NumArray(object):

    def __init__(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        
        nums = [0] + nums
        
        for i in range(1,len(nums)):
            nums[i] +=nums[i-1]
        
        self.nums=nums
     

    def sumRange(self, i, j):
        &amp;quot;&amp;quot;&amp;quot;
        :type i: int
        :type j: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        return self.nums[j+1]-self.nums[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;304-range-sum-query-2d-immutable-medium&#34;&gt;304. Range Sum Query 2D - Immutable (Medium)&lt;/h1&gt;
&lt;p&gt;Given a 2D matrix matrix, handle multiple queries of the following type:&lt;br&gt;
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        # original matrix
        # 1 2 3
        # 4 5 6
        # 7 8 9
        #
        #cumsum matrix
        #             c1
        #        0 0  0    0
        #        0 1  3    6
        # row1   0 5  #12  21
        # row2   0 12 27  #45 
        #                 c2
        # do cumsum on row
        # do cumsum on col
        #
        #  row2,col2 -(row1-1)col2 - row2(col1-1) + (row1-1)(col1-1)
        self.matrix = [[0]*(len(matrix[0])+1)]
        for row in matrix:
            self.matrix.append([0]+row)
        
    
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row][col-1]
        
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row-1][col]
        
        
        
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&amp;gt; int:
        return self.matrix[row2+1][col2+1]-self.matrix[row1][col2+1]-self.matrix[row2+1][col1]+self.matrix[row1][col1]
        


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred305-number-of-islands-ii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;305. Number of Islands II (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0&#39;s represent water and 1&#39;s represent land. Initially, all the cells of grid are water cells (i.e., all the cells are 0&#39;s).&lt;br&gt;
We may perform an add land operation which turns the water at position into a land. You are given an array positions where positions[i] = [ri, ci] is the position (ri, ci) at which we should operate the ith operation.&lt;br&gt;
Return an array of integers answer where answer[i] is the number of islands after turning the cell (ri, ci) into a land.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    
    class unionfind:
        
        def __init__(self,m,n):
            self.m=m
            self.n=n
            self.parent=[-1]*(m*n) 
            self.rank = [0]*(m*n)
            self.counter=0
           
        def isvalid(self,row,col):
            ind=row*self.n+col
            return self.parent[ind]&amp;gt;=0
        
        def setparent(self,row,col):
            ind=row*self.n+col
            if self.parent[ind]==-1:
                self.parent[ind]=ind
                self.counter+=1
            
        def find(self,row,col):
            ind= row*self.n+col
            if self.parent[ind]!=ind:
                new_col = self.parent[ind]%self.n
                new_row = (self.parent[ind]-new_col)//self.n
                self.parent[ind]=self.find(new_row,new_col)
            return self.parent[ind]
            
            
        def union(self,p1,p2):
            x1,y1=p1
            x2,y2=p2
            root1=self.find(x1,y1)
            root2=self.find(x2,y2)
            if root1!=root2:
                self.counter-=1
                if self.rank[root1]&amp;gt;self.rank[root2]:
                    self.parent[root2]=root1
                elif self.rank[root1]&amp;lt;self.rank[root2]:
                    self.parent[root1]=root2
                else:
                    self.parent[root1]=root2
                    self.rank[root2]+=1
                    
        def getcount(self):
            return self.counter
         
                    
                
            
    
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -&amp;gt; List[int]:
        
       
        res=[]
        
        uf=self.unionfind(m,n)
    
        def get_nei(pos,uf):
            nei = []
            x,y=pos
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&amp;gt;=0 and xx&amp;lt;m and yy&amp;gt;=0 and yy&amp;lt;n:
                    if uf.isvalid(xx,yy):
                        nei.append((xx,yy))
            return nei
    
        for pos in positions:
            uf.setparent(*pos)
            for nei in get_nei(pos,uf):
                uf.union(nei,pos)
            res.append(uf.getcount())
            
        return res
            

#######################MY ANSWER
class Solution:
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -&amp;gt; List[int]:
        class UF:
            def __init__(self,m,n):
                self.m = m
                self.n = n
                self.parent = [-1 for _ in range(m*n)] 
                self.rank = [0]*(m*n)
                self.c = 0
            
            def setparent(self,i,j):
                index = self.ind(i,j)
                if self.parent[index]==-1:
                    self.parent[index] = index
                    self.c+=1
            
            def isvalid(self,i,j):
                index = self.ind(i,j)
                return self.parent[index]&amp;gt;=0
            
            def nei(self,i,j):
                res = []
                for x, y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if self.m&amp;gt;x&amp;gt;=0 and self.n&amp;gt;y&amp;gt;=0 and self.isvalid(x,y):
                        res.append([x,y])
                return res

            def ind(self, i,j):
                return self.n*i+j
            
            def revind(self,ind):
                col = ind%self.n
                row = (ind-col)//self.n
                return row,col

            def find(self,r,c):
                index = self.ind(r,c)
                if self.parent[index]!=index:
                    self.parent[index] = self.find(*self.revind(self.parent[index]))
                return self.parent[index]
            
            def union(self,i,j , ii,jj):
                rootx = self.find(i,j)
                rooty = self.find(ii,jj)
                if rootx!=rooty:
                    if self.rank[rootx]&amp;lt;self.rank[rooty]:
                        self.parent[rootx] = rooty
                    elif self.rank[rootx]&amp;gt;self.rank[rooty]:
                        self.parent[rooty] = rootx
                    else:
                        self.parent[rootx] = rooty
                        self.rank[rooty]+=1
                    self.c-=1
            def count(self):
                return self.c
        
        uf = UF(m,n)
        res = []
        for x,y in positions:
            uf.setparent(x,y)
            for xx,yy in uf.nei(x,y):
                uf.union(x,y,xx,yy)
            res.append(uf.count())
        return res
         


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试过用neighbor_list做，但是无法分辨新加入的点是否会引起2个或3个不同island合并。 思路不正确， 感觉是用UNIONFIND做。还是不能顺畅写出UNIONFIND calss。这次的unionfind class是个变种。 注意增加相同点的时候，setparent做check，必须self.parent[i]==-1 才能做self.conter+=1 。 思路： 每次增加一个点，做setparent，counter++，找这个点所有valid neighbors，然后做union。没发现以个union则counter--。&lt;/p&gt;
&lt;h1 id=&#34;306-additive-numberfont&#34;&gt;306. Additive Number&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;An additive number is a string whose digits can form an additive sequence.&lt;br&gt;
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.&lt;br&gt;
Given a string containing only digits, return true if it is an additive number or false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isAdditiveNumber(self, num: str) -&amp;gt; bool:
        if not num or len(num)&amp;lt;3: 
            return False
        
        mem=dict()
        def helper(num):
            if not num: return True
            if num in mem: return mem[num]
            Found=False
            for len_a in range(1,len(num)):
                if len_a&amp;gt;1 and num[0]==&#39;0&#39;: continue
                for len_b in range(1,len(num)):
                    if len_b&amp;gt;1 and num[len_a]==&#39;0&#39;: continue
                    temp_flag=False
                    if len_a+len_b&amp;gt;=len(num):continue
                    a = num[:len_a]
                    b = num[len_a:len_a+len_b]
                    c = str(int(a)+int(b))
                    #print(a,b,c)
                    len_c= len(c)
                    if len_a+len_b+len_c&amp;gt;len(num):continue
                    if len_a+len_b+len_c==len(num) and num[len_a+len_b:len_a+len_b+len_c]==c:
                        return True
                    elif num[len_a+len_b:len_a+len_b+len_c]==c:
                        temp_flag = True and helper(num[len_a:])
                    Found=Found or temp_flag
            mem[num]=Found
            print(num,Found)
            return Found
        
        return helper(num)
        
#ANSWER WAY
def isAdditiveNumber(self, num):
    n = len(num)
    for i, j in itertools.combinations(range(1, n), 2):
        a, b = num[:i], num[i:j]
        if a != str(int(a)) or b != str(int(b)):
            continue
        while j &amp;lt; n:
            c = str(int(a) + int(b))
            if not num.startswith(c, j):
                break
            j += len(c)
            a, b = b, c
        if j == n:
            return True
    return False                

#MY SOLUTION
class Solution:
     
    def isAdditiveNumber(self, num: str) -&amp;gt; bool:
        
        res=False
        def helper(A,B,rest):
            nonlocal res
            if res:
                return
            AB = str(int(A)+int(B)) if not (len(A)&amp;gt;1 and A[0]==&#39;0&#39; or len(B)&amp;gt;1 and B[0]==&#39;0&#39;) else None
            if AB is None: return 
            if len(AB)&amp;lt;=len(rest) and rest[:len(AB)]==AB:
                A = B
                B = AB
                rest = rest[len(AB):]
                if not rest:
                    res=True
                else:
                    helper(A,B,rest)  
        

        for i in range(1,len(num)):
            A = num[:i]
            for j in range(i+1,len(num)+1):
                B = num[i:j]
                rest = num[j:]
                helper(A,B,rest)

        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己通过recursion with mem解决的，头部为0问题用2个continue 判断去解决。&lt;br&gt;
答案大神用了itertools.combinatons i 是a的长度，j是 a+b的长度，确定了a，b可以算出来c，如果不满足条件跳出while，如果满足条件，则j+len（c），前进一位做下一次判断。 推出时候如果j==n说明找到了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-307-range-sum-query-mutable-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 307. Range Sum Query - Mutable (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, handle multiple queries of the following types:&lt;br&gt;
Update the value of an element in nums.&lt;br&gt;
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 
#METHOD 1  SQRT DECOMPOSTION
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.len =  len(nums)//int(math.sqrt(len(nums)))+1 
        self.b=[0]*self.len
        for i,n in enumerate(nums):
            self.b[i//self.len]+=n
         

    def update(self, index: int, val: int) -&amp;gt; None:
        block_index = index//self.len
        self.b[block_index] = self.b[block_index] - self.nums[index]+val
        self.nums[index]=val

    def sumRange(self, left: int, right: int) -&amp;gt; int:
        res=0
        startblock=left//self.len
        endblock=right//self.len
        if startblock==endblock:
            for ind in range(left,right+1):
                res+=self.nums[ind]
        else:
            for ind in range(left,(startblock+1)*self.len):
                res+=self.nums[ind]
            for block_ind in range(startblock+1,endblock):
                res+=self.b[block_ind]
            for ind in range(endblock*self.len,right+1):
                res+=self.nums[ind]
        return res
        
# METHOD 2 ＳＥＧＭＥＮＴ　ＴＲＥＥ
class ST:
    def __init__(self,n):
        self.size = n
        self.tree = [0]*(2*self.size)
    
    def update(self,ind,val):
        #       1
        #     2   3
        #    4 5 6 7
        #  self.tree is:
        #  @ 1 2 3 4 5 6 7
        
        #offset index by size, the leave save value node save summation
        ind+=self.size
        self.tree[ind] += val
        while ind&amp;gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&amp;gt;0:
                self.tree[ind//2]=self.tree[left]+self.tree[right]
            ind //=2


    def query(self,left,right):
        left+=self.size
        right+=self.size
        res=0
        while left&amp;lt;=right:
            if right%2==0:
                res+=self.tree[right]
                right-=1
            if left%2==1:
                res+=self.tree[left]
                left+=1
            left//=2
            right//=2
        return res
class NumArray:

    def __init__(self, nums: List[int]):
        self.st = ST(len(nums))
        for i,n in enumerate(nums):
            self.st.update(i,n)
        
    def update(self, index: int, val: int) -&amp;gt; None:
        old_val = self.st.query(index,index)
        self.st.update(index,-old_val+val)

    def sumRange(self, left: int, right: int) -&amp;gt; int:
        return self.st.query(left,right)

        

#MY ANSWER
class BIT:
    def __init__(self,n):
        self.size = n
        self.bit = [0]*(self.size+1)
    
    def update(self,index,val):
        while index&amp;lt;=self.size:
            self.bit[index]+=val
            index += index&amp;amp;-index
    def query(self,index):
        res = 0 
        while index&amp;gt;0:
            res+=self.bit[index]
            index-= index&amp;amp;-index
        return res

class NumArray:

    def __init__(self, nums: List[int]):
        self.bit = BIT(len(nums))
        for i,n in enumerate(nums):
            self.bit.update(i+1,n)
        
    def update(self, index: int, val: int) -&amp;gt; None:
        ind = index+1
        old_val = self.bit.query(ind)-self.bit.query(ind-1)
        self.bit.update(ind,-old_val+val)

    def sumRange(self, left: int, right: int) -&amp;gt; int:
        return self.bit.query(right+1)-self.bit.query(left)


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(index,val)
# param_2 = obj.sumRange(left,right)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路1） Sqrt Decomposition，把nums分成 sqrt（len）个block求和。 思路2） Segment Tree。 这个没见过，是最优解。  构造方法很巧妙。可能需要记住．&lt;/p&gt;
&lt;h1 id=&#34;font-colorred308-range-sum-query-2d-mutable-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;308. Range Sum Query 2D - Mutable (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;1D to 2D of rang sum Query&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.trees=[self.buildtree(nums) for nums in matrix]
        
        #for tree in self.trees:
        #    print(tree)
    
    def buildtree(self,nums):
        #   1
        #  2  3
        # 4 5 6 7
        # 1 2 3 4 5 6 7
        tree=[&#39;#&#39;]*self.n*2
        for i,n in enumerate(nums):
            ind=i+self.n
            tree[ind]=n
        
        for ind in range(self.n-1,0,-1):
            tree[ind]=tree[2*ind]+tree[2*ind+1]
        return tree
    
    def update(self, row: int, col: int, val: int) -&amp;gt; None:
        tree=self.trees[row]
        #   1
        #  2  3
        # 4 5 6 7
        # 1   2  3  4 5 6 7
        # 22  9  13 4 5 6 7
        ind = self.n+col
        self.matrix[row][col]=val
        tree[ind]=val
        while ind&amp;gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&amp;gt;0:
                tree[ind//2]=tree[left]+tree[right]
            ind=ind//2
        self.trees[row]=tree
      

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&amp;gt; int:
        res = 0
        for row in range(row1,row2+1):
            tree=self.trees[row]
            #   1
            #  2  3
            # 4 5 6 7
            # 1   2  3  4 5 6 7
            # 22  9  13 4 5 6 7
            l=col1+self.n
            r=col2+self.n
            while l&amp;lt;=r:
                if l%2==1:
                    res+=tree[l]
                    l+=1
                if r%2==0:
                    res+=tree[r]
                    r-=1
                l//=2
                r//=2
        return res
            
# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)

#MY ANSWER 。。。。。。。。。。。。。。
class BIT:
    def __init__(self,m,n):
        self.m= m
        self.n = n
        self.bit = [[0]*(self.n+1) for _ in range(self.m+1)]
    
    def update(self,r,c,val):
        i = r
        while i&amp;lt;=self.m:
            j = c
            while j&amp;lt;=self.n:
                self.bit[i][j]+=val
                j+= j&amp;amp;-j
            i+= i&amp;amp;-i

    def query(self,r,c):
        res = 0
        i=r
        while i&amp;gt;0:
            j = c
            while j&amp;gt;0:
                res+=self.bit[i][j]
                j-= j&amp;amp;-j
            i-= i&amp;amp;-i
        return res
        

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m = len(matrix)
        n = len(matrix[0])
        self.bit = BIT(m,n)
        for i in range(m):
            for j in range(n):
                ii = i+1
                jj = j+1
                self.bit.update(ii,jj,matrix[i][j])
        
    def update(self, row: int, col: int, val: int) -&amp;gt; None:
        i = row+1
        j = col+1
        old_val = self.sumRegion(row,col,row,col)
        self.bit.update(i,j,-old_val+val)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&amp;gt; int:
        i1=row1+1
        j1=col1+1
        i2=row2+1
        j2=col2+1
        a = self.bit.query(i2,j2)
        b = self.bit.query(i1-1,j1-1)
        c = self.bit.query(i2,j1-1)
        d = self.bit.query(i1-1,j2)
        return a-c-d+b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己套用之前的1d segment tree用在2d问题，可以pass。 但不是最优解。 答案用了 Fenwick Tree (Binary Index Tree)  https://www.youtube.com/watch?v=uSFzHCZ4E-8  没见过。而且最终还是用的2D版本的 Binary Index Tree。bit操作下，X，Y不影响，bit位置是bit，保存的值是partial sum。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred309-best-time-to-buy-and-sell-stock-with-cooldown-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;309. Best Time to Buy and Sell Stock with Cooldown （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array prices where prices[i] is the price of a given stock on the ith day.&lt;br&gt;
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:&lt;br&gt;
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int: 
        
    
        &amp;quot;&amp;quot;&amp;quot;
        state machine  
                  O held    -sell-&amp;gt;  sold 
                    /\                |
                    |_ buy_ O reset &amp;lt;-rest
       
       O is self loop
       
       DP:
         sold[i]=held[i-1]+price[i]
         held[i]=max(held[i-1],reset[i-1]-price[i])
         reset[i]=max(rest[i-1],sold[i-1])
         
         return max(reset[n],sold[n]
         &amp;quot;&amp;quot;&amp;quot;
        sold, held, reset = float(&#39;-inf&#39;), float(&#39;-inf&#39;), 0
        for price in prices:
            pre_sold = sold
            sold = held + price               #sell operation
            held = max(held, reset - price)   #buy operation
            reset = max(reset, pre_sold)      # do nothing operation
            
        return max(sold, reset)
 
        #309 直接看答案了
        # profit on ith day kth transanction 0 means 0 stock at our hand after the end of ith day， 1 means 1 stock at our hand after the end of ith day
        #T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) #sell
        #T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])  # buy 
        #Base cases:
        # T[-1][k][0] = 0, T[-1][k][1] = -Infinity
        # T[i][0][0] = 0, T[i][0][1] = -Infinity
        #constain to cooldown
        
        T_ik0=0
        T_ik0_pre=0
        T_ik1=-float(&#39;inf&#39;)
        
        for p in prices:
            T_ik0_old=T_ik0
            T_ik0 = max(T_ik0, T_ik1+p)
            T_ik1 = max(T_ik1, T_ik0_pre-p)
            T_ik0_pre=T_ik0_old
        
        return T_ik0


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一类问题，很多变种。。。。https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75924/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 答案的state machine 思维方法很有意思。&lt;/p&gt;
&lt;h1 id=&#34;310-minimum-height-trees-medium&#34;&gt;310. Minimum Height Trees （Medium）&lt;/h1&gt;
&lt;p&gt;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&lt;/p&gt;
&lt;p&gt;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).&lt;/p&gt;
&lt;p&gt;Return a list of all MHTs&#39; root labels. You can return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]:
        #remove those leafves what left is root 
        
        
        dic={i:[] for i in range(n)}
        q = []
        for edge in edges:
            n1,n2=edge
            dic[n1].append(n2)
            dic[n2].append(n1)
        
        for i in range(n):
            if len(dic[i])==1:
                q.append(i)
                
        res=q
        while q:
            l=len(q)
            res=q[:]
            for _ in range(l):
                cur=q.pop(0)
                for nei in dic[cur]:
                    dic[nei].remove(cur)
                if len(dic[nei])==1:
                    q.append(nei)
        return res if res else [0]
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一下hint才做出来，思路topological sort，leaves 直接砍掉。&lt;/p&gt;
">Leetcode 2021-12-03</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-29/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;261-graph-valid-tree-medium&#34;&gt;261. Graph Valid Tree （Medium)&lt;/h1&gt;
&lt;p&gt;You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.&lt;br&gt;
Return true if the edges of the given graph make up a valid tree, and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent = [None]*n
            self.rank = [0]*n
            for i in range(n):
                self.parent[i]=i
                
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&amp;gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&amp;lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
    
        
    def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
        #UNIONFIND
        uf =self.UnionFind(n)
        for (a,b) in edges:
            uf.union(a,b)
        
        if len(set( [uf.find(i) for i in range(n)]))!=1:
            return False
    
        return len(edges)==n-1

#answer DFS
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            stack.append(neighbour)
    
    return len(seen) == n
#answer 
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = set()

    def dfs(node):
        if node in seen: return
        seen.add(node)
        for neighbour in adj_list[node]:
            dfs(neighbour)

    dfs(0)
    return len(seen) == n

#answer
def validTree(self, n: int, edges: List[List[int]]) -&amp;gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    queue = collections.deque([0])
    
    while queue:
        node = queue.popleft()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            queue.append(neighbour)
    
    return len(seen) == n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;猜到了使用UnionFind做，但是还是copy了UnionFind Class 代码，还没熟练到自己写出来。 思路很简单，union后同一个parent，#edges+1=#node      答案思路：DFS或者BFS  判断是树1）n-1 edges， 2）graph fully connected。&lt;/p&gt;
&lt;h1 id=&#34;262-trips-and-users-hard&#34;&gt;262. Trips and Users （Hard）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
select   request_at as &#39;Day&#39;, round(sum(counter)/sum(total),2) as &#39;Cancellation Rate&#39; from (
select CASE WHEN Trips.status=&#39;completed&#39; THEN 0 else 1 END as counter, 1 as total, Trips.request_at  from
Trips left join Users c on Trips.client_id=c.users_id left join Users d on Trips.driver_id=d.users_id where c.banned!=&#39;Yes&#39; and d.banned!=&#39;Yes&#39;
) tmp  where Request_at&amp;gt;=&amp;quot;2013-10-01&amp;quot; AND Request_at&amp;lt;=&amp;quot;2013-10-03&amp;quot; group by request_at

#ANSWER 
SELECT Request_at as Day,
ROUND(SUM(CASE WHEN Status!=&amp;quot;completed&amp;quot; THEN 1 ELSE 0 END)/COUNT(*),2) as &amp;quot;Cancellation Rate&amp;quot; 
FROM Trips
WHERE Client_Id NOT IN
(
    SELECT Users_Id FROM Users
    WHERE Banned=&amp;quot;Yes&amp;quot;
)
AND Request_at&amp;gt;=&amp;quot;2013-10-01&amp;quot; AND Request_at&amp;lt;=&amp;quot;2013-10-03&amp;quot;
GROUP BY Request_at;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;263-ugly-number-easy&#34;&gt;263. Ugly Number (Easy)&lt;/h1&gt;
&lt;p&gt;An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.&lt;br&gt;
Given an integer n, return true if n is an ugly number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isUgly(self, n: int) -&amp;gt; bool:
        if n==0: return False
        if n==1: return True
        
        while n%2==0:
            n//=2
        if n==1: return True
        while n%3==0:
            n//=3
        if n==1: return True
        while n%5==0:
            n//=5
        if n==1: return True
        
        return False

class Solution:
    def isUgly(self, n: int) -&amp;gt; bool:
        if n==0: return False
        while n!=1:
            if n%2==0:
                n //=2
            elif n%3==0:
                n//=3
            elif n%5==0:
                n//=5
            else:
                return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred264-ugly-number-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;264. Ugly Number II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.&lt;br&gt;
Given an integer n, return the nth ugly number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nthUglyNumber(self, n: int) -&amp;gt; int:
        dp = [0] * n
        t2 = t3 = t5 = 0
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
            if(dp[i] == dp[t2]*2): t2 += 1
            if(dp[i] == dp[t3]*3): t3 += 1
            if(dp[i] == dp[t5]*5): t5 += 1
        return dp[-1]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路 。。。或者知道思路但写不出代码。  要是添加2倍，3倍，4倍，5倍还是会有空隙当n很大时候。 答案，用了dynamic programming。 思路是多个pointer。 t2，t3，t5记录已经遍历的数字里2，3，5都有多少个。 关键点是找到下一个最小的ugly number当乘以2，3，5时候。 又因为已经存在的数字只能被2，3，5乘1次，所以可以用pointer保持下次2，3，5要乘以的位置。&lt;/p&gt;
&lt;h1 id=&#34;265-paint-house-ii-hard&#34;&gt;265. Paint House II （Hard）&lt;/h1&gt;
&lt;p&gt;There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;br&gt;
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCostII(self, costs: List[List[int]]) -&amp;gt; int:
        #  cost last =     [a1,a2,a3,a4]
        #  cost last-1 =   [a1&#39;+min(a2,a3,a4),a2&#39;+min(a1,a3,a4),...]
        #  ...
        #  cost  0     =    [a1&#39;&#39;&#39;,a2&#39;&#39;&#39;....]
        # ans= min(cost0)
        for i in range(len(costs)-2,-1,-1):
            for ii in range(len(costs[0])):
                costs[i][ii] = costs[i][ii]+min([costs[i+1][jj] for jj in range(len(costs[0])) if jj!=ii])
        
        return min(costs[0])

#ＭＹ　　ＡＮＳＷＥＲ    
class Solution:
    def minCostII(self, costs: List[List[int]]) -&amp;gt; int:
        # dp[i][j] = up to house i,using color j&#39;s min cost
        # dp[0][j] =  costs[0][j]
        # dp[i][j] =  cost[i][j]+min(dp[i-1][k] k!=j)
        # return min(dp[-1])

        m=len(costs)
        n=len(costs[0])
        dp = [[0]*n for _ in range(m)] 
        dp[0] =  costs[0]
        for i in range(1,m):
            for j in range(n):
                dp[i][j] = costs[i][j] + min([dp[i-1][k] for k in range(n) if k!=j])
        return min(dp[-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;266-palindrome-permutation-easy&#34;&gt;266. Palindrome Permutation (Easy)&lt;/h1&gt;
&lt;p&gt;Given a string s, return true if a permutation of the string could form a palindrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canPermutePalindrome(self, s: str) -&amp;gt; bool:
        #odd occurance can not &amp;gt;1
        dic = collections.Counter(s)
        c=0
        for k,v in dic.items():
            if v%2==1:
                c+=1
            if c&amp;gt;1:
                return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;267-palindrome-permutation-ii-medium&#34;&gt;267. Palindrome Permutation II (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generatePalindromes(self, s: str) -&amp;gt; List[str]:
        dic = collections.Counter(s)
        c = 0
        odd_char = &#39;&#39;
        odd_c = 0
        for k,v in dic.items():
            if v%2==1:
                c+=1
                odd_char = k
                odd_c = v
        if c&amp;gt;1: return []
        if len(dic)==1:
            return [list(dic.keys())[0]*dic[list(dic.keys())[0]]]
        if odd_char:
            tmp=odd_char
            dic[odd_char]-=1
            if dic[odd_char]&amp;lt;=0:
                del dic[odd_char]
                 
        res = []
        def bt(dic,tmp):
            if len(tmp)==len(s):
                res.append(tmp)
                return
            
            for k,v in dic.items():
                dic_copy = dic.copy()
                tmp = k+tmp+k
                dic_copy[k]-=2
                if dic_copy[k]==0:
                    del dic_copy[k]
                #print(tmp,dic_copy)
                bt(dic_copy,tmp)
                tmp=tmp[1:-1]

            
        bt(dic,odd_char)
        return  res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 分为odd 元素存在时候，中间位置只能是odd元素，然后从中间向两边扩展。&lt;/p&gt;
&lt;h1 id=&#34;268-missing-number-easy&#34;&gt;268. Missing Number （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        n=len(nums)
        return (0+n)*(n+1)//2 - sum(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred269-alien-dictionary-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;269. Alien Dictionary (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.&lt;br&gt;
You are given a list of strings words from the alien language&#39;s dictionary, where the strings in words are sorted lexicographically by the rules of this new language.&lt;br&gt;
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language&#39;s rules. If there is no solution, return &amp;quot;&amp;quot;. If there are multiple solutions, return any of them.&lt;br&gt;
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length &amp;lt; t.length.&lt;br&gt;
Input: words = [&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;]&lt;br&gt;
Output: &amp;quot;wertf&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
     
    
    from collections import defaultdict, Counter, deque

    def alienOrder(self, words: List[str]) -&amp;gt; str:

        # Step 0: create data structures + the in_degree of each unique letter to 0.
        adj_list = defaultdict(set)
        in_degree = Counter({c : 0 for word in words for c in word})

        # Step 1: We need to populate adj_list and in_degree.
        # For each pair of adjacent words...
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d:
                    if d not in adj_list[c]:
                        adj_list[c].add(d)
                        in_degree[d] += 1
                    break
            else: # Check that second word isn&#39;t a prefix of first word.
                if len(second_word) &amp;lt; len(first_word): return &amp;quot;&amp;quot;

        # Step 2: We need to repeatedly pick off nodes with an indegree of 0.
        output = []
        queue = deque([c for c in in_degree if in_degree[c] == 0])
        while queue:
            c = queue.popleft()
            output.append(c)
            for d in adj_list[c]:
                in_degree[d] -= 1
                if in_degree[d] == 0:
                    queue.append(d)

        # If not all letters are in output, that means there was a cycle and so
        # no valid ordering. Return &amp;quot;&amp;quot; as per the problem description.
        if len(output) &amp;lt; len(in_degree):
            return &amp;quot;&amp;quot;
        # Otherwise, convert the ordering we found into a string and return it.
        return &amp;quot;&amp;quot;.join(output)

#DFS topo sorter reverse adj list and using grey black for node color

class Solution:
    def alienOrder(self, words: List[str]) -&amp;gt; str:

        # Step 0: Put all unique letters into the adj list.
        reverse_adj_list = {c : [] for word in words for c in word}

        # Step 1: Find all edges and put them in reverse_adj_list.
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d: 
                    reverse_adj_list[d].append(c)
                    break
            else: # Check that second word isn&#39;t a prefix of first word.
                if len(second_word) &amp;lt; len(first_word): 
                    return &amp;quot;&amp;quot;

        # Step 2: Depth-first search.
        seen = {} # False = grey, True = black.
        output = []
        def visit(node):  # Return True iff there are no cycles.
            if node in seen:
                return seen[node] # If this node was grey (False), a cycle was detected.
            seen[node] = False # Mark node as grey.
            for next_node in reverse_adj_list[node]:
                result = visit(next_node)
                if not result: 
                    return False # Cycle was detected lower down.
            seen[node] = True # Mark node as black.
            output.append(node)
            return True

        if not all(visit(node) for node in reverse_adj_list):
            return &amp;quot;&amp;quot;

        return &amp;quot;&amp;quot;.join(output)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显图论相关的题，没复习到还，看答案。思路：1）找到dependence rules， 2）topological sort。用queue来存indegree=0的node，然后遍历neighbors。或者DFS，revse adj list 然后为了防止有环，需要标注node color white grey black。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for item in container:
    if search_something(item):
        # Found it!
        process(item)
        break
else:
    # Didn&#39;t find anything..
    not_found_in_container()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语法从来没见过，for后面可以带一个else表明for loop中没有break的条件，else 来执行后续操作。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue270-closest-binary-search-tree-value-easy-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;270. Closest Binary Search Tree Value （Easy） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -&amp;gt; int:
        if not root.left and not root.right: return root.val
        if not root.right:
            if target&amp;lt;root.val:
                res=self.closestValue(root.left,target)
                return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val
            else:
                return root.val
        if not root.left:
            if target&amp;gt;root.val:
                res = self.closestValue(root.right,target)
                return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val
            else:
                return root.val
        
        if target==root.val:
            return root.val
        elif target&amp;lt;root.val:
            res = self.closestValue(root.left,target)
            return res if abs(target-res)&amp;lt;＝abs(root.val-target) else root.val
        else:
            res= self.closestValue(root.right,target)
            return res if abs(target-res)&amp;lt;abs(root.val-target) else root.val

#ANSWER
class Solution:
    def closestValue(self, root: TreeNode, target: float) -&amp;gt; int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: （abs(target - x)，ｘ)）
            root = root.left if target &amp;lt; root.val else root.right
        return closest
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-29</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-28/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;251-flatten-2d-vector-medium&#34;&gt;251. Flatten 2D Vector (Medium)&lt;/h1&gt;
&lt;p&gt;Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.&lt;br&gt;
Implement the Vector2D class:&lt;br&gt;
Vector2D(int[][] vec) initializes the object with the 2D vector vec.&lt;br&gt;
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.&lt;br&gt;
hasNext() returns true if there are still some elements in the vector, and false otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Vector2D:

    def __init__(self, vec: List[List[int]]):
        self.data = vec
        self.cur  =  []
 
        
    def next(self) -&amp;gt; int:
        if self.hasNext():
            return self.cur.pop(0)

    def hasNext(self) -&amp;gt; bool:
        while not self.cur:
            if len(self.data)==0: return False
            self.cur = self.data.pop(0)
        
        return len(self.cur)&amp;gt;0
        


class Vector2D:

    def __init__(self, v: List[List[int]]):
        # We need to iterate over the 2D vector, getting all the integers
        # out of it and putting them into the nums list.
         
        self.nums = []
        for inner_list in v:
            for num in inner_list:
                self.nums.append(num)
        # We&#39;ll keep position 1 behind the next number to return.
        self.position = -1

    def next(self) -&amp;gt; int:
        # Move up to the current element and return it.
        self.position += 1
        return self.nums[self.position]

    def hasNext(self) -&amp;gt; bool:
        # If the next position is a valid index of nums, return True.
        return self.position + 1 &amp;lt; len(self.nums)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己写的这个递归调用比较tricky。。。答案很简答。&lt;/p&gt;
&lt;h1 id=&#34;252-meeting-rooms-easy&#34;&gt;252. Meeting Rooms （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -&amp;gt; bool:
        intervals=sorted(intervals,key=lambda x:x[0])
        pre_end = None
        for interval in intervals:
            if pre_end is not None and interval[0]&amp;lt;pre_end:
                return False
            pre_end = interval[1]
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue253-meeting-rooms-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;253. Meeting Rooms II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&amp;gt; int:
        # max meeting at same time
        res = 1
        dic = dict()
        intervals = sorted(intervals,key=lambda x:x[0])
        for a,b in intervals:
            dic[a] = dic.get(a,0)+1
            dic[b] = dic.get(b,0)-1
        
        c=0
        for k in sorted(dic.keys()):
            c+=dic[k]
            res = max(res,c)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了，感觉下次再做可能会忘记怎么做的， 思路： 把所有时节节点从小到大排序，如果是start， counter+=1 如果是end， counter-=1， 找出counter变化过程中最大值。 答案做的感觉没自己的思路简单。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-254-factor-combinations-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 254. Factor Combinations （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Numbers can be regarded as the product of their factors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, 8 = 2 x 2 x 2 = 2 x 4.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given an integer n, return all possible combinations of its factors. You may return the answer in any order.&lt;/p&gt;
&lt;p&gt;Note that the factors should be in the range [2, n - 1].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Iterative:

def getFactors(self, n):
    todo, combis = [(n, 2, [])], []
    while todo:
        n, i, combi = todo.pop()
        while i * i &amp;lt;= n:
            if n % i == 0:
                combis += combi + [i, n/i],
                todo += (n/i, i, combi+[i]),
            i += 1
    return combis

#Recursive:

class Solution:
    def getFactors(self, n: int) -&amp;gt; List[List[int]]:
        
        res=[]
        def factor(n, i, tmp):
            while i * i &amp;lt;= n:
                if n % i == 0:
                    res.append(tmp + [i, n//i])
                    factor(n//i, i, tmp+[i])
                i += 1
        factor(n, 2, [])
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路类似，但是还是没写粗来，这个不应该， res 先append  tmp+[i,n//i],然后再factor（n//i， i，tmp+【i】，res）&lt;/p&gt;
&lt;h1 id=&#34;font-colorred255-verify-preorder-sequence-in-binary-search-tree-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;255. Verify Preorder Sequence in Binary Search Tree （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def verifyPreorder(self, preorder):
    stack = []
    low = float(&#39;-inf&#39;)
    for p in preorder:
        if p &amp;lt; low:
            return False
        while stack and p &amp;gt; stack[-1]:
            low = stack.pop()
        stack.append(p)
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路，答案思路： 模拟traversal，stack是左子树的栈。 如果下一个数小于栈顶，说明还在左子树，所以append。  如果当前preorder值大于栈顶，所有小于当前值元素出栈。说明当前元素跳到了右子树。low=stack.pop() 很巧妙， lower bound是满足小于当前值的最后一个pop出去的元素。&lt;/p&gt;
&lt;h1 id=&#34;256-paint-house-medium&#34;&gt;256. Paint House （Medium)&lt;/h1&gt;
&lt;p&gt;Input: costs = [[17,2,17],[16,16,5],[14,3,19]]&lt;br&gt;
Output: 10&lt;br&gt;
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.&lt;br&gt;
Minimum cost: 2 + 5 + 3 = 10.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCost(self, costs: List[List[int]]) -&amp;gt; int:
        mem=dict()
        def paint(n,color):
            if (n,color) in mem:
                return mem[(n,color)]
            res = costs[n][color]
            
            if n!=len(costs)-1:
                if color==0:
                    res+=min(paint(n+1,1),paint(n+1,2))
                elif color==1:
                    res+=min(paint(n+1,0),paint(n+1,2))
                else:
                    res+=min(paint(n+1,0),paint(n+1,1))
            mem[(n,color)]=res
            return res
       
        return min([paint(0,0),paint(0,1),paint(0,2)])

#
class Solution:
    def minCost(self, costs: List[List[int]]) -&amp;gt; int:
        if not costs:return 0
        for n in range(len(costs)-2,-1,-1):
            costs[n][0]+=min(costs[n+1][1],costs[n+1][2])
            costs[n][1]+=min(costs[n+1][0],costs[n+1][2])
            costs[n][2]+=min(costs[n+1][0],costs[n+1][1])
        return min(costs[0])

class Solution:
    def minCost(self, costs: List[List[int]]) -&amp;gt; int:
        # dp[i][j] = paint up to ith house with current color j , the min cost
        # dp[i][j] =  cost[i][j] + min(dp[i-1][k]  k !=j )
        # dp[0][j] = cost[0][j]

        m = len(costs)
        n = 3

        dp = [[0]*n for _ in range(m)]
        for j in range(3):
            dp[0][j] = costs[0][j]
        
        for i in range(1,m):
            for j in range(3):
                dp[i][j] = costs[i][j]+min([dp[i-1][k] for k in range(3) if k!=j])
        
        return min(dp[-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个应该是递归mem的经典题和dp的经典题。用dynamic programming，但是写出来一版是错的。。。应该定义dp=【#costs】【#color】。从最后一个房子开始， 倒数第二个 cost红=最后一个min（绿，蓝），。。。&lt;/p&gt;
&lt;h1 id=&#34;257-binary-tree-paths-easy&#34;&gt;257. Binary Tree Paths （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -&amp;gt; List[str]:
        res=[]
        def bt(tmp,node):
            if not node: return
            if not node.left and not node.right:
                tmp.append(str(node.val))
                res.append(&#39;-&amp;gt;&#39;.join(tmp))
                return
            tmp.append(str(node.val))
            bt(tmp[:],node.left)
            bt(tmp[:],node.right)
        bt([],root)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;258-add-digits-easy&#34;&gt;258. Add Digits (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def addDigits(self, num: int) -&amp;gt; int:
        
        while num//10!=0:
            new_num = 0
            while num:
                lastdig = num%10
                num = num//10
                new_num+=lastdig
            num = new_num
        
        return num
# answer way of writing
class Solution:
    def addDigits(self, num: int) -&amp;gt; int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了一个数能被九整除，那么他们所有位数和能被9整除。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue259-3sum-smaller-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;259. 3Sum Smaller （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &amp;lt; target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&amp;gt; int:
        nums.sort()
        res = 0
        for i in range(len(nums)-2):
            l = i+1
            r = len(nums)-1
            
            while l&amp;lt;r:
                if nums[i]+nums[l]+nums[r] &amp;lt; target:
                    res+= r-l
                    l+=1
                else:
                    r-=1
            
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3sum转成2sum，然后定义left=start+1，right=len（nums）-1， 若left +right 值小于target 说明 left 到right所有都满足条件，这样left+1求解下一步， 若left +right 值大于target说明right太大得减1.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred260-single-number-iii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;260. Single Number III （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; List[int]:
        xor=0
        for n in nums:
            xor = xor^n
        
        # rightmost 1-bit diff between a and b
        diff = xor &amp;amp; -xor
        
        a=0
        for n in nums:
            if n&amp;amp;diff:
                # diff means a&#39;s last bit is diff then b&#39;s last bit
                # by using this filter we could get a 
                a= a^n
        return [a,xor^a]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路， one pass 只能找出xor=a^b  但不能确定出a，b具体值。&lt;br&gt;
答案思路：用了一个不知道的trick， x &amp;amp; (-x) 保留x中最右边bit，设置其他bit为0.   这样就能用a，b 的diff bit把所有数字过滤一次，只有a可以被过滤出来，因为a的diff bit是1 其余diff bit是1的都出现了2次抵消了。。&lt;/p&gt;
">Leetcode 2021-11-28</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/shu-dan/"" data-c="
          &lt;p&gt;半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。&lt;br&gt;
ADHD系列图书以及心理学~&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;ADD的人生整理术&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;分心不是我的错&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;分心也有好人生&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;分心也有好婚姻&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;分心的孩子这样教&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;我ADD，怎么了？！&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;人格障碍的认知行为疗法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史4&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画中国史5&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画世界史1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf&#34;&gt;半小时漫画世界史2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学2&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学3&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画经济学4&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画科学史1 2 3全 MOBI&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing&#34;&gt;半小时漫画预防常见病&lt;/a&gt;&lt;/p&gt;
">书单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-27/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-241-different-ways-to-add-parentheses-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 241. Different Ways to Add Parentheses （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def diffWaysToCompute(self, expression: str) -&amp;gt; List[int]:

        if not expression: return []

        exp = []
        tmp = &#39;&#39;
        for n in expression:
            if n.isdigit():
                tmp+=n
            else:
                exp.append(tmp)
                tmp = &#39;&#39;
                exp.append(n)
        if tmp:
            exp.append(tmp)
        
        
        res = []
        if len(exp)==1 and (&#39;+&#39; not in exp) and (&#39;-&#39; not in exp) and (&#39;*&#39; not in exp) and (&#39;/&#39; not in exp): return [int(exp[0])]

        for i,op in enumerate(exp):
            if op in &#39;+-*/&#39;:
                left = self.diffWaysToCompute(&#39;&#39;.join(exp[:i]))
                right = self.diffWaysToCompute(&#39;&#39;.join(exp[i+1:]))
            
                for l in left:
                    for r in right:
                        if op==&#39;+&#39;:
                            res.append(l+r)
                        elif op==&#39;-&#39;:
                            res.append(l-r)
                        elif op==&#39;*&#39;:
                            res.append(l*r)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是backtracking但写code出现了问题。。。并不是 a+(b+...)   和 (a+b)+.... 这2种情况， 而是 （left）+ （right）产生不同的组合。&lt;/p&gt;
&lt;h1 id=&#34;242-valid-anagram-easy&#34;&gt;242. Valid Anagram （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isAnagram(self, s: str, t: str) -&amp;gt; bool:
        return collections.Counter(s)==collections.Counter(t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了26个字符的数组存储出现次数，s出现+1，t出现-1. 这样相等时候所有位置都应该是0.&lt;/p&gt;
&lt;h1 id=&#34;243-shortest-word-distance-easy&#34;&gt;243. Shortest Word Distance (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&amp;gt; int:
        visited = dict()
        res=float(&#39;inf&#39;)
        for i,w in enumerate(wordsDict):
            if w==word1 and word2 in visited:
                res=min(res,i-visited[word2])
            if w==word2 and word1 in visited:
                res=min(res,i-visited[word1])
            visited[w]=i
        return res

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&amp;gt; int:

        dic = dict()
        res = len(wordsDict)
        for i,w in enumerate(wordsDict):
            dic[w] = i
            if word1 in dic and word2 in dic:
                res = min(res,abs(dic[word1]-dic[word2]))
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;244-shortest-word-distance-ii-medium&#34;&gt;244. Shortest Word Distance II (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class WordDistance:

    def __init__(self, wordsDict: List[str]):
        self.dic = collections.defaultdict(list)
        for i,w in enumerate(wordsDict):
            self.dic[w].append(i)
        

    def shortest(self, word1: str, word2: str) -&amp;gt; int:
        res=float(&#39;inf&#39;)
        for pos1 in self.dic[word1]:
            for pos2 in self.dic[word2]:
                res=min(res,abs(pos2-pos1))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;245-shortest-word-distance-iii-medium&#34;&gt;245. Shortest Word Distance III (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -&amp;gt; int:
        dic=dict()
        res = float(&#39;inf&#39;)
        for i, w in enumerate(wordsDict):
            if w==word1 and word2 in dic:
                res=min(res,i-dic[word2])
            if w==word2 and word1 in dic:
                res=min(res,i-dic[word1])
            
            dic[w]=i
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;246-strobogrammatic-number-easy&#34;&gt;246. Strobogrammatic Number (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isStrobogrammatic(self, num: str) -&amp;gt; bool:
 
        l=0
        r=len(num)-1
        while l&amp;lt;=r:
            if l==r:
                if num[l] not in {&#39;8&#39;,&#39;1&#39;,&#39;0&#39;}:
                    return False
                return True
            if num[l]==&#39;6&#39;:
                if num[r]!=&#39;9&#39;:
                    return False
            
            elif num[l]==&#39;9&#39;:
                if num[r]!=&#39;6&#39;:
                    return False
            
            elif num[l]==&#39;8&#39;:
                if num[r]!=&#39;8&#39;:
                    return False
            
            elif num[l]==&#39;1&#39;:
                if num[r]!=&#39;1&#39;:
                    return False

            elif num[l]==&#39;0&#39;:
                if num[r]!=&#39;0&#39;:
                    return False
            else:
                return False
            
            l+=1
            r-=1
        
        return True

class Solution:
    def isStrobogrammatic(self, num: str) -&amp;gt; bool:
        # 1 6 9 8 0
        if &#39;2&#39; in num or &#39;3&#39; in num or &#39;4&#39; in num or &#39;5&#39; in num or &#39;7&#39; in num:
            return False
        dic={&#39;6&#39;:&#39;9&#39;,&#39;9&#39;:&#39;6&#39;,&#39;1&#39;:&#39;1&#39;,&#39;8&#39;:&#39;8&#39;,&#39;0&#39;:&#39;0&#39;}
        num2= &#39;&#39;.join([dic[e] for e in num][::-1])
        return num==num2

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue247-strobogrammatic-number-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;247. Strobogrammatic Number II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#answer way of writting
class Solution:
    def findStrobogrammatic(self, n: int) -&amp;gt; List[str]:
        evenMidCandidate = [&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;, &amp;quot;00&amp;quot;]
        oddMidCandidate = [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;8&amp;quot;]
        if n == 1:
            return oddMidCandidate
        if n == 2:
            return evenMidCandidate[:-1]
        if n % 2:
            pre, midCandidate = self.findStrobogrammatic(n-1), oddMidCandidate
        else: 
            pre, midCandidate = self.findStrobogrammatic(n-2), evenMidCandidate
        premid = (n-1)//2
        return [p[:premid] + c + p[premid:] for c in midCandidate for p in pre]

#MY ANSWER
class Solution:
    def findStrobogrammatic(self, n: int) -&amp;gt; List[str]:
        mid = [&#39;1&#39;,&#39;8&#39;,&#39;0&#39;]
        wing =  [&#39;6&#39;,&#39;9&#39;]
        dic  = {&#39;6&#39;:&#39;9&#39;,&#39;9&#39;:&#39;6&#39;,&#39;8&#39;:&#39;8&#39;,&#39;0&#39;:&#39;0&#39;,&#39;1&#39;:&#39;1&#39;}
        if n==1: return mid
        res = []

        def build_head(n):
            res =  []
            
            def helper(n,tmp):
                if n==0:
                    res.append(tmp)
                    return 
                else:
                    for i in &#39;18069&#39;:
                        tmp+=i
                        helper(n-1,tmp)
                        tmp=tmp[:-1]

            
            helper(n,&#39;&#39;)
            return [e for e in res if e[0]!=&#39;0&#39;]


        if n%2==1:
            tmp = build_head((n-1)//2)
            for e in tmp:
                for m in mid:
                    res.append(e+m+&#39;&#39;.join([dic[ee] for ee  in e][::-1])) 

        else:
            tmp = build_head(n//2)
            for e in tmp:
                res.append(e+&#39;&#39;.join([dic[ee] for ee in e][::-1]))
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案思路：&lt;br&gt;
n == 1: [0, 1, 8]&lt;br&gt;
n == 2: [11, 88, 69, 96]&lt;br&gt;
How about n == 3?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 2&lt;br&gt;
n == 4?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 2&lt;br&gt;
n == 5?&lt;br&gt;
=&amp;gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 4&lt;br&gt;
the same, for n == 6, it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 4&lt;/p&gt;
&lt;h1 id=&#34;font-colorred248-strobogrammatic-number-iii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;248. Strobogrammatic Number III （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -&amp;gt; int:
        dic = {&#39;0&#39;: &#39;0&#39;,&#39;1&#39;: &#39;1&#39;,&#39;6&#39;: &#39;9&#39;,&#39;8&#39;: &#39;8&#39;,&#39;9&#39;: &#39;6&#39;}    
        count = 0

        def dfs(low,high, c, left,right):
            nonlocal count
            if left&amp;gt;right:
                s=&#39;&#39;.join(c)
                if (len(s)==len(low) and s&amp;lt;low) or (len(s)==len(high) and s&amp;gt;high):
                    return
                
                count+=1
                return
            
            for k,v in dic.items():
                c[left] = k
                c[right] = v
                if len(c)!=1 and c[0]==&#39;0&#39;:
                    continue
                if left==right and k!=v:
                    continue
                
                dfs(low,high,c,left+1,right-1)
        
        for length in range(len(low),len(high)+1):
            dfs(low,high,[&#39;&#39;]*length,0,length-1)
        
        return count
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;give up, 思路 ， 构建length长度的满足条件的string，从两边向中间构建。  做dfs search。&lt;br&gt;
用247的办法也可以感觉。 然后过滤出low，high之间有多少个。&lt;/p&gt;
&lt;h1 id=&#34;249-group-shifted-strings-medium&#34;&gt;249. Group Shifted Strings （Medium）&lt;/h1&gt;
&lt;p&gt;We can shift a string by shifting each of its letters to its successive letter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, &amp;quot;abc&amp;quot; can be shifted to be &amp;quot;bcd&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can keep shifting the string to form a sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, we can keep shifting &amp;quot;abc&amp;quot; to form the sequence: &amp;quot;abc&amp;quot; -&amp;gt; &amp;quot;bcd&amp;quot; -&amp;gt; ... -&amp;gt; &amp;quot;xyz&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given an array of strings strings, group all strings[i] that belong to the same shifting sequence. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def groupStrings(self, strings: List[str]) -&amp;gt; List[List[str]]:
        dic = collections.defaultdict(list)
        for s in strings:
            if len(s)==1:
                dic[&#39;NULL&#39;].append(s)
            else:
                key=[]
                for i in range(1,len(s)):
                    tmp = str((ord(s[i])-ord(s[i-1]))%26)
                    key.append(tmp)
                key=&#39;-&#39;.join(key)
                dic[key].append(s)
        return dic.values()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;250-count-univalue-subtrees-medium&#34;&gt;250. Count Univalue Subtrees (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the number of uni-value subtrees.&lt;br&gt;
A uni-value subtree means all nodes of the subtree have the same value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        count = [0]
        
        def isUnivalSubtrees(root):
            if not root:
                return False
            if not root.left and not root.right:
                count[0]+=1
                return True
            if not root.left:
                res = isUnivalSubtrees(root.right) and root.val==root.right.val
                if res:
                    count[0]+=1
                return res
            if not root.right:
                res= isUnivalSubtrees(root.left) and root.val==root.left.val
                if res:
                    count[0]+=1
                return res
            
            left = isUnivalSubtrees(root.left)
            right= isUnivalSubtrees(root.right)
            res=left and right and root.val==root.left.val and root.val==root.right.val
            if res:
                count[0]+=1
            return res
        
        isUnivalSubtrees(root)
        return count[0]


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&amp;gt; int:
        # bottom up
        # post order
        res = 0
        def isU(node):
            nonlocal res
            if not node:
                return True
            if not node.left and not node.right:
                res+=1
                return True
            if not node.left:
                r = isU(node.right) and node.val==node.right.val
                if r:
                    res+=1
                return r
            if not root.right:
                r = isU(node.left) and node.val==node.left.val
                if r:
                    res+=1
                return r
            
            left = isU(node.left)
            right = isU(node.right)
            r = left and right and node.val==node.left.val and node.val==node.right.val
            if r:
                res+=1
            return r

        isU(root)
        return res
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-27</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-26/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;231-power-of-two-easy&#34;&gt;231. Power of Two (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        if n&amp;lt;0: return False
        c=0
        while n:
            lastbit= n%2
            if lastbit==1:
                c+=1
            n=n&amp;gt;&amp;gt;1
        return c==1

#answer is great
class Solution:
    def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        if n&amp;lt;=0: return False
        # 1 000 000 000
        #    111 111 111
        return n&amp;amp;(n-1)==0

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;232-implement-queue-using-stacks-easy&#34;&gt;232. Implement Queue using Stacks (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        

    def push(self, x: int) -&amp;gt; None:
        self.s1.append(x)

    def pop(self) -&amp;gt; int:
        # 1 2 3
        # 3 2 1
        while self.s1:
            self.s2.append(self.s1.pop())
        val=self.s2.pop()
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -&amp;gt; int:
        pre=None
        while self.s1:
            cur=self.s1.pop()
            self.s2.append(cur)
            pre=cur
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return pre
        

    def empty(self) -&amp;gt; bool:
        return len(self.s1)==0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        self.front=None

    def push(self, x: int) -&amp;gt; None:
        if self.s1==[]:
            self.front=x
        self.s1.append(x)

    def pop(self) -&amp;gt; int:
        if self.s2==[]:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&amp;gt; int:
        if self.s2:
            return self.s2[-1]
        
        return self.front
          
        
    def empty(self) -&amp;gt; bool:
        return self.s1==[] and self.s2==[]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;follow up的思路挺有意思，push: 数字保存在s1，但是当s1为空时候，保存front。  pop：如果s2有元素，pop s2， 否则 把s1 push到s2    peek: 若s2 有元素，peek s2 否则 就是 front。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred233-number-of-digit-one-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;233. Number of Digit One （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.&lt;br&gt;
Example：&lt;br&gt;
Input: n = 13&lt;br&gt;
Output: 6&lt;br&gt;
1，10， 11，12，13&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countDigitOne(self, n: int) -&amp;gt; int:
        c=0
        i=1
        while i&amp;lt;=n:
            divider = i*10
            c += (n//divider)*i + min(max(n%divider -i+1,0),i)
            i*=10
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完全不是考算法，对于个位来说，存在1的位置有，1，11，21，31，41，51，61，71 ... 基本10个一循环，比如 1到13的个位为1的有1，11，总共2个。 所以是 13//10 + (13%10)!=0。 对于十位来说存在1的有， 10，11，12，。。。19  |   110，111，112，113，。。。119| 210,...，每100个一循环，比如1到113的十位， (113/ 100) * 10 + min(max(113%100-10+1,0),10)   同理千位100,101,...199| 1100,1101....1199|....     千位中1的个数  (n/1000)*100 + min(max(n%1000-100+1,0),100)   具体的循环截断1的个数是在 0到 100之间， 具体多少是n%1000-100+1.&lt;/p&gt;
&lt;h1 id=&#34;234-palindrome-linked-list-easy&#34;&gt;234. Palindrome Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -&amp;gt; bool:
        
        fast=slow=head
        
        while slow and fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        
        if fast:
            mid=slow.next
        else:
            mid=slow
            
        
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        revmid  = rev(mid)
        
        while revmid:
            if revmid.val!=head.val:
                return False
            revmid=revmid.next
            head=head.next
        return True
        #1 2 3 4 5
        #    s m
        #        f
                
        #1 2 3 4
        #    s
        #    m   f  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred235-lowest-common-ancestor-of-a-binary-search-tree-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;235. Lowest Common Ancestor of a Binary Search Tree （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        # 
        #    all left ,  all right,    p mid q
        #
        
        if root.val &amp;gt; p.val and root.val &amp;gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val &amp;lt; p.val and root.val &amp;lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;。。。没仔细看题，忽略了这个是个BST，得用BST性质。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-236-lowest-common-ancestor-of-a-binary-tree-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 236. Lowest Common Ancestor of a Binary Tree （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    dic=dict()
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        
        def find(root,node):
            if not root: return False
            if (root.val,node.val) in self.dic:
                return self.dic[(root.val,node.val)]
          
            if root.val==node.val:
                self.dic[(root.val,node.val)]=True
                return True
            if find(root.left,node):
                self.dic[(root.left.val,node.val)]=True
                return True
            if find(root.right,node):
                if root.right:
                    self.dic[(root.right.val,node.val)]=True
                return True
            return False
        
        if find(root.left,p) and find(root.left,q):
            return self.lowestCommonAncestor(root.left,p,q)
        elif find(root.right,p) and find(root.right,q):
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
#answer way of writting
class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;:
        
        if root in [p,q,None]: return root
        
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        
        
        if left and right: 
            return root
        if left: 
            return left
        if right:
            return right
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次尝试Time limit exceeded...，得找到p，q是在root的同侧还是异侧。 由于是递归调用，find funciton call了太多次，所以用memerization 方法， pass了。答案思路： 如果root 是{p,q,None} 就返回root， left=从root.left找p，q共同祖先， right=从root.right 找p，q共同祖先。&lt;/p&gt;
&lt;h1 id=&#34;237-delete-node-in-a-linked-list-easy&#34;&gt;237. Delete Node in a Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &amp;quot;&amp;quot;&amp;quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
      if node.next:
            node.val=node.next.val
            node.next=node.next.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把下一位数字覆盖到当前node， 然后跳过这个node。&lt;/p&gt;
&lt;h1 id=&#34;238-product-of-array-except-self-medium&#34;&gt;238. Product of Array Except Self （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in O(n) time and without using the division operation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]:
        
        prefix_left = [1]*len(nums)
        prefix_right= [1]*len(nums)
        
        for i in range(1,len(nums)):
            prefix_left[i] = prefix_left[i-1]*nums[i-1]
        for j in range(len(nums)-2,-1,-1):
            prefix_right[j] = prefix_right[j+1]*nums[j+1]
        res = []    
        for (l,r) in zip(prefix_left,prefix_right):
            res.append(l*r)
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred239-sliding-window-maximum-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;239. Sliding Window Maximum (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;
&lt;p&gt;Return the max sliding window.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&amp;gt; List[int]:
        
        #if k==1: return nums
        
        stack_max = []
        queue = []
        res = []
        for n in nums:
            queue.append(n)
            
            
            while stack_max and n&amp;gt;stack_max[-1]:
                stack_max.pop()
            if not stack_max or  n&amp;gt;stack_max[-1]:
                stack_max.append(n)
            
            if len(queue)&amp;gt;k:
                expired = queue.pop(0)
                if expired == stack_max[-1]:
                    stack_max.pop()
            
            if len(queue)==k:
                #print(queue,stack_max)
                if stack_max:
                    res.append(stack_max[-1])
                else:
                    #the expired one is the max and poped out
                    newmax=max(queue)
                    res.append(newmax)
                    stack_max.append(newmax)
            
        return res
#answer way of writting
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        
        
        queue = collections.deque()
        res = []
        for i, n in enumerate(nums):
            while queue and n&amp;gt; nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            #expire
            if queue[0] == i - k:
                queue.popleft()
            #can add to result
            if i &amp;gt;= k - 1:
                res.append(nums[queue[0]])
        return res
    
#         if not nums:
#             return []
#         start=0
#         r=[]
#         while start+k&amp;lt;=len(nums):
#             r.append(max(nums[start:start+k]))
#             start+=1
            
#         return r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试， time limit exceeded。QUEUE 是FIFO结构，适合sliding window，如果当前大，queue 要pop掉末尾元素， 如果过期，踢掉， queue中保存最大值位置。&lt;/p&gt;
&lt;h1 id=&#34;240-search-a-2d-matrix-ii-medium&#34;&gt;240. Search a 2D Matrix II （Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        
        def search(rowl,rowr,coll,colr,target):
            if rowl==rowr and coll==colr:
                return matrix[rowl][coll]==target
            elif rowl==rowr:
                return target in matrix[rowl]
            elif coll==colr:
                return target in [row[coll] for row in matrix]
            
            if  rowr-rowl==1 and colr-coll==1:    
                if matrix[rowl][coll]==target or matrix[rowr][colr]==target or matrix[rowr][coll]==target or matrix[rowl][colr]==target:
                    return True
                return False
            
            
            rowmid = (rowl+rowr)//2
            colmid = (coll+colr)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif target&amp;lt;matrix[rowmid][colmid]:
                return search(rowl,rowmid,coll,colmid,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            else:
                return search(rowmid,rowr,colmid,colr,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            
        
        return search(0,len(matrix)-1,0,len(matrix[0])-1,target)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了分治法，虽然写出来了，但感觉写了陀X。 答案分治法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        # an empty matrix obviously does not contain `target`
        if not matrix:
            return False

        def search_rec(left, up, right, down):
            # this submatrix has no height or no width.
            if left &amp;gt; right or up &amp;gt; down:
                return False
            # `target` is already larger than the largest element or smaller
            # than the smallest element in this submatrix.
            elif target &amp;lt; matrix[up][left] or target &amp;gt; matrix[down][right]:
                return False

            mid = left + (right-left) // 2

            # Locate `row` such that matrix[row-1][mid] &amp;lt; target &amp;lt; matrix[row][mid]
            row = up
            while row &amp;lt;= down and matrix[row][mid] &amp;lt;= target:
                if matrix[row][mid] == target:
                    return True
                row += 1
            
            return search_rec(left, row, mid - 1, down) or \
                   search_rec(mid + 1, up, right, row - 1)

        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class Solution:&lt;br&gt;
def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    m = len(matrix)
    n = len(matrix[0])

    cur = [m-1,0]

    def valid(li):
        r,c = li
        if m&amp;gt;r&amp;gt;=0 and n&amp;gt;c&amp;gt;=0:
            return True
        return False
    
    while valid(cur):
        if matrix[cur[0]][cur[1]]==target: return True

        if target&amp;gt;matrix[cur[0]][cur[1]]:
            cur = [cur[0],cur[1]+1]
        else:
            cur = [cur[0]-1,cur[1]]

    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最佳答案 思路 ： 从左下角开始，如果target大于cur, 列+1， 如果targe 小于cur，行-1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        # an empty matrix obviously does not contain `target` (make this check
        # because we want to cache `width` for efficiency&#39;s sake)
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        # cache these, as they won&#39;t change.
        height = len(matrix)
        width = len(matrix[0])

        # start our &amp;quot;pointer&amp;quot; in the bottom-left
        row = height - 1
        col = 0

        while col &amp;lt; width and row &amp;gt;= 0:
            if matrix[row][col] &amp;gt; target:
                row -= 1
            elif matrix[row][col] &amp;lt; target:
                col += 1
            else: # found it
                return True
        
        return False
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-26</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-25/"" data-c="
          &lt;p&gt;感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-221-maximal-square-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 221. Maximal Square （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing only 1&#39;s and return its area.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&amp;gt; int:
        rows=len(matrix)
        cols=len(matrix[0])
        maxqlen=0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j]==&#39;1&#39;:
                    sqlen=1
                    flag=True
                    while sqlen+i&amp;lt;rows and sqlen+j&amp;lt; cols and flag:
                        for k in range(j,sqlen+j+1):
                            if matrix[i+sqlen][k]==&#39;0&#39;:
                                flag=False
                                break
                        for k in range(i,i+sqlen+1):
                            if matrix[k][j+sqlen]==&#39;0&#39;:
                                flag=False
                                break
                        if flag:
                            sqlen+=1
                    
                    if maxqlen&amp;lt;sqlen:
                        maxqlen=sqlen
                        
                        
        return maxqlen**2

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&amp;gt; int:
        # dp[i][j]  size of box which bottom right in pos[i][j]
        # if matrix[i][j]==1
        #    dp[i][j]=   min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0]*(n+1) for _ in range(m+1)]
        res=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]==&#39;1&#39;:
                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1
                    res=max(res,dp[i][j])
        return res**2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试着用cumsum去解但失败了， 方法1，暴力解。 每次发现是“1”就以它作为正方形左上角起始点， 检查 row: i，i+sqlen col: j, j+sqlen 是否有‘0’.&lt;br&gt;
方法2：dp： dp【i】【j】保存右下角位置在i，j的盒子大小。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-222-count-complete-tree-nodes-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 222. Count Complete Tree Nodes （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if not root.right:
            return 1+ self.countNodes(root.left)
        else:
            return  self.countNodes(root.left)+self.countNodes(root.right)+1


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        def depth(node):
            d=0
            while node.left:
                node=node.left
                d+=1
            return d
        
        def exists(idx,d,node):
            left=0
            right=2**d-1
            for _ in range(d):
                pivot = (left+right)//2
                if idx&amp;lt;=pivot:
                    node=node.left
                    right=pivot
                else:
                    node=node.right
                    left=pivot +1
            return node is not None
        
        if not root: return 0
        d = depth(root)
        if d==0: return 1
        
        l=1
        r=2**d-1
        while l&amp;lt;=r:
            mid = (l+r)//2
            if exists(mid,d,root):
                l=mid+1
            else:
                r=mid-1
        
        return (2**d-1) +l 
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给出了个O（n）解法，但题目要求小于O(n)...&lt;br&gt;
思路： 完全二叉树，第0层2&lt;sup&gt;0个node，第一层，2&lt;/sup&gt;1个node，第n层2^n个node，所以假设这个树深度为d=n， 不包含最后一层2&lt;sup&gt;0+2&lt;/sup&gt;1+..+2&lt;sup&gt;(n-1)=2&lt;/sup&gt;n  -  1 的所有node总和为2^d-1 ,问题转化成求最后一层有多少node。 范围在1~2^n.  因为d=n所以肯定有第一个node。  可以用binary search 求。&lt;/p&gt;
&lt;h1 id=&#34;223-rectangle-area-medium&#34;&gt;223. Rectangle Area （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&amp;gt; int:
        
        # intersect of 1d line
        
        def intersect(a1,a2,b1,b2):
            if a1&amp;gt;b1:
                a1,a2,b1,b2=b1,b2,a1,a2
            
            #print(a1,a2,b1,b2)
            #case 1  --
            #            --
            if a2&amp;lt;b1:
                return 0
            
            #case 2   a1---a2
            #            b1---b2
            if b1&amp;lt;=a2 and a2&amp;lt;=b2:
                return a2-b1
            # case 3  a1------a2
            #            b1-b2
            if b1&amp;lt;a2 and b2&amp;lt;a2:
                return b2-b1
            
            return &#39;ERROR&#39;
        
        width = intersect(ax1,ax2,bx1,bx2)
        height = intersect(by1,by2,ay1,ay2)
        print(width,height)
        return (ay2-ay1)*(ax2-ax1)+ (by2-by1)*(bx2-bx1)    -width*height

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred224-basic-calculator-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;224. Basic Calculator (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#通解
class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        # 转换为 后缀表达式
        # 运算符优先级
        prec = {}
        prec[&amp;quot;*&amp;quot;] = 3
        prec[&amp;quot;/&amp;quot;] = 3
        prec[&amp;quot;+&amp;quot;] = 2
        prec[&amp;quot;-&amp;quot;] = 2
        prec[&amp;quot;(&amp;quot;] = 1

        res = []
        stack = []
        i = 0
        while i &amp;lt; len(s):
            # 数字 直接 接到后缀表达式上
            if s[i] == &amp;quot; &amp;quot;:
                i += 1
                
            elif s[i].isdigit():
                temp = &amp;quot;&amp;quot;
                while i &amp;lt; len(s) and s[i].isdigit():
                    temp += s[i]
                    i += 1
                res.append(temp)

            # 左括号直接入栈
            elif s[i] == &amp;quot;(&amp;quot;:
                stack.append(s[i])
                i += 1

            # 右括号，开始弹栈，直达遇到左括号 左括号出栈 但不输出
            elif s[i] == &amp;quot;)&amp;quot;:
                while stack and stack[-1] != &amp;quot;(&amp;quot;:
                    res.append(stack.pop())
                stack.pop() # 左括号出战， 但是不输出
                i += 1

            # 遇到运算符
            elif s[i] in [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                #  对 &amp;quot;-2 + 2&amp;quot; 或者 &amp;quot;1-(-2)&amp;quot; 进行特殊处理
                if s[i] == &amp;quot;-&amp;quot; and (i == 0 or s[i-1] == &amp;quot;(&amp;quot; ):
                    res.append(&#39;0&#39;)
                # 只要栈顶符号不低于当前符号，就一直输出。最后把当前符号入栈
                while stack and prec[s[i]]&amp;lt;=prec[stack[-1]]:
                    res.append(stack.pop())
                stack.append(s[i])
                i += 1
        
        # 最后把栈里面的元素均 放到后缀表达式后面
        while stack:
            res.append(stack.pop())


        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char.isdigit():
                stack.append(int(char))
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &amp;quot;+&amp;quot;:
                    stack.append(x + y)
                elif char == &amp;quot;-&amp;quot;:
                    stack.append(y-x)
                elif char == &amp;quot;*&amp;quot;:
                    stack.append(y*x)
                elif char == &amp;quot;/&amp;quot;:
                    stack.append(x/y)

        return stack.pop()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot; 2-1 + 2 &amp;quot; 直接用stack解出现-1时候符号和1是合体的，所以换思路把表达式变成前缀/后坠表达。 又遇到后缀表达如何去括号问题。&lt;br&gt;
1 + (( 2 + 3)* 4 ) – 5   方法：  当读到数时，立即输出， 若读到操作符，判断符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就依次把栈中运算符弹出并加到后缀表达式尾端，但又遇到 &amp;quot;1-(-2)&amp;quot; 无法pass。 同理 &amp;quot;- (3 - (- (4 + 5) ) )&amp;quot; 无法pass。 负号不作为减法，作为符号。 需要特殊处理： 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if e == &amp;quot;-&amp;quot; and (i == 0 or s[i-1] == &amp;quot;(&amp;quot; ):
    s_res.append(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案很简单，问题根源在-号不能互相换 比如(A-B)+C != A-(B+C) , 所以把-看作数字的符号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculate(self, s: str) -&amp;gt; int:

        stack = []
        operand = 0
        res = 0 # For the on-going result
        sign = 1 # 1 means positive, -1 means negative  

        for ch in s:
            if ch.isdigit():
                # Forming operand, since it could be more than one digit
                operand = (operand * 10) + int(ch)

            elif ch == &#39;+&#39;:
                # Evaluate the expression to the left,
                # with result, sign, operand
                res += sign * operand

                # Save the recently encountered &#39;+&#39; sign
                sign = 1
                # Reset operand
                operand = 0

            elif ch == &#39;-&#39;:

                res += sign * operand
                sign = -1
                operand = 0

            elif ch == &#39;(&#39;:

                # Push the result and sign on to the stack, for later
                # We push the result first, then sign
                stack.append(res)
                stack.append(sign)

                # Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1
                res = 0

            elif ch == &#39;)&#39;:

                # Evaluate the expression to the left
                # with result, sign and operand
                res += sign * operand

                # &#39;)&#39; marks end of expression within a set of parenthesis
                # Its result is multiplied with sign on top of stack
                # as stack.pop() is the sign before the parenthesis
                res *= stack.pop() # stack pop 1, sign

                # Then add to the next operand on the top.
                # as stack.pop() is the result calculated before this parenthesis
                # (operand on stack) + (sign on stack * (result from parenthesis))
                res += stack.pop() # stack pop 2, operand

                # Reset the operand
                operand = 0

        return res + sign * operand

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue225-implement-stack-using-queues-easy-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;225. Implement Stack using Queues (Easy) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyStack(object):
    def __init__(self):
        self._queue = collections.deque()

    def push(self, x):
        q = self._queue
        q.append(x)
        for _ in range(len(q) - 1):
            q.append(q.popleft())
 
    def pop(self):
        return self._queue.popleft()

    def top(self):
        return self._queue[0]
    
    def empty(self):
        return not len(self._queue)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三种方法&lt;/p&gt;
&lt;h1 id=&#34;226-invert-binary-tree-easy&#34;&gt;226. Invert Binary Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]:
        if not root: return root
        root.left,root.right = root.right,root.left
        root.left = self.invertTree(root.left)
        root.right=self.invertTree(root.right)
        return root

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue227-basic-calculator-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;227. Basic Calculator II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        #convert to 后缀表达
        priority = {&#39;+&#39;:1,&#39;-&#39;:1,&#39;*&#39;:2,&#39;/&#39;:2,&#39;(&#39;:0}
        res = [] #保存后缀表达式
        stack=[] #保存符号
        i=0
        while i&amp;lt;len(s):
            ch=s[i]
            if ch.isdigit():
                tmp=ch
                while i+1&amp;lt;len(s) and s[i+1].isdigit():
                    tmp+=s[i+1]
                    i+=1
                res.append(int(tmp))
            
            elif ch==&#39;(&#39;:
                stack.append(ch)
            elif ch==&#39;)&#39;:
                while stack and stack[-1] != &amp;quot;(&amp;quot;:
                    res.append(stack.pop())
                stack.pop() 
            elif ch in  [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                 if s[i]==&#39;-&#39; and (i==0 or s[i-1]==&#39;(&#39;):
                    res.append(0)
                while stack and priority[ch] &amp;lt;= priority[stack[-1]]:
                    res.append(stack.pop())

                stack.append(ch)
            
            i+=1
                
        while stack:
            res.append(stack.pop())
        
        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char not in  [&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;]:
                #char is number
                stack.append(char)
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &amp;quot;+&amp;quot;:
                    stack.append(x + y)
                elif char == &amp;quot;-&amp;quot;:
                    stack.append(y-x)
                elif char == &amp;quot;*&amp;quot;:
                    stack.append(y*x)
                elif char == &amp;quot;/&amp;quot;:
                    stack.append(y//x)

        return stack.pop()


#ANSWER
class Solution:
    def calculate(self, s: str) -&amp;gt; int:
        
        if not s: return 0
        s = s + &#39;+&#39;
        stack = []
        val = 0
        op = &#39;+&#39;
        for n in s:
            if n==&#39; &#39;:  continue
            
            if n.isdigit():
                val=val*10+int(n)
            else:
                if op==&#39;+&#39;:
                    stack.append(val)
                elif op==&#39;-&#39;:
                    stack.append(-val)
                elif op==&#39;*&#39;:
                    stack.append(stack.pop()*val)
                elif op==&#39;/&#39;:
                    stack.append(int(stack.pop()/val))

                op = n
                val = 0 
            
        print(stack)
        return sum(stack)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接上通杀法。转成后缀表达然后求结果。&lt;br&gt;
为了能延时evaluate，所以先给op一个default值+， 然后当遇到下一个符号时候，再去eval之前的op结果，遇到+-要push到stack，遇到*/要从stack取值做计算， 要注意因为是遇到符号才会触发计算，所以s = s+‘+’ 来做最后一位的触发计算。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-228-summary-ranges-easy-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 228. Summary Ranges （Easy） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def summaryRanges(self, nums: List[int]) -&amp;gt; List[str]:
        # [0]
        # [0,1]
        # [0,2]
        # [0-2,4]
        # [0-2,4,5]
        
        res = []
        stack=[]
        for n in nums:
            if not stack:
                stack.append(n)
            elif len(stack)==1:
                if n==stack[-1]+1:
                    stack.append(n)
                else:
                    res.append(str(stack[-1]))
                    stack=[n]
            else:
                if n==stack[-1]+1:
                    stack[-1]=n
                else:
                    res.append(str(stack[0])+&#39;-&amp;gt;&#39;+str(stack[1]))
                    stack=[n]
 
        if len(stack)==1:
            res.append(str(stack[0]))
        elif len(stack)==2:
            res.append(str(stack[0])+&#39;-&amp;gt;&#39;+str(stack[1]))
        
        return res
#answer way of writting
class Solution:
    def summaryRanges(self, nums: List[int]) -&amp;gt; List[str]:
        res = []
        i=0
        for j in range(len(nums)):
            if j+1&amp;lt;len(nums) and nums[j+1]==nums[j]+1:
                continue
            if i==j:
                res.append(str(nums[i]))
            else:
                res.append(str(nums[i])+&#39;-&amp;gt;&#39;+str(nums[j]))
            i=j+1
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案更简单&lt;/p&gt;
&lt;h1 id=&#34;font-colorred229-majority-element-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;229. Majority Element II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def majorityElement(self, nums: List[int]) -&amp;gt; List[int]:
        
        maj1=nums[0]
        maj2=nums[0]
        c1=0
        c2=0

        for n in nums:
            if n==maj1:
                c1+=1
            elif n==maj2:
                c2+=1
            elif c1==0:
                c1=1
                maj1=n
            elif c2==0:
                c2=1
                maj2=n
            else:
                c1-=1
                c2-=1
        #recalce make sure        
        c1=c2=0
        for n in nums:
            if n==maj1:c1+=1
            if n==maj2:c2+=1
        res=[]
        if c1&amp;gt;len(nums)//3:
            res.append(maj1)
        if c2&amp;gt;len(nums)//3 and maj1!=maj2:
            res.append(maj2)
        return res


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经典算法，在做majorelement 1时候写过，需要记住。&lt;/p&gt;
&lt;h1 id=&#34;230-kth-smallest-element-in-a-bst-medium&#34;&gt;230. Kth Smallest Element in a BST （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -&amp;gt; int:
        ind=0
        stack=[]
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            ind+=1
            if ind==k:
                return node.val
            
            root=node.right
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-25</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-24/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;211-design-add-and-search-words-data-structure-medium&#34;&gt;211. Design Add and Search Words Data Structure （Medium）&lt;/h1&gt;
&lt;p&gt;Design Add and Search Words Data Structure&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class WordDictionary:

    def __init__(self):
        self.next = dict()
        self.isword= False
        

    def addWord(self, word: str) -&amp;gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char]=WordDictionary()
            self.next[char].addWord(rest)
        else:
            self.isword=True
        

    def search(self, word: str) -&amp;gt; bool:
        if not word:
            return self.isword
        char = word[0]
        rest = word[1:]
        if char!=&#39;.&#39;:
            if char not in self.next:
                return False
            else:
                return self.next[char].search(rest)
        else:
            return any([ node.search(rest) for key,node in self.next.items()])
        
        return True

#MY ANSWER
class WordDictionary:

    def __init__(self):
        self.isword = False
        self.data = collections.defaultdict(WordDictionary)
        

    def addWord(self, word: str) -&amp;gt; None:
        if not word: 
            self.isword = True
            return 
        
        head = word[0]
        rest = word[1:]
        if head not in self.data:
            self.data[head] = WordDictionary()
        self.data[head].addWord(rest)
        

    def search(self, word: str) -&amp;gt; bool:
        if not word:
            if self.isword: 
                return True
            else:
                return False
        
        else:
            head = word[0]
            rest = word[1:] 
            

            if head!=&#39;.&#39;:
                return self.data[head].search(rest)
            else:
                return any(self.data[key].search(rest)  for key in self.data )

    
        


# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trie data structure&lt;/p&gt;
&lt;h1 id=&#34;font-colorred212-word-search-ii-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;212. Word Search II （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n board of characters and a list of strings words, return all words on the board.&lt;br&gt;
Input: board = [[&amp;quot;o&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;],[&amp;quot;e&amp;quot;,&amp;quot;t&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;e&amp;quot;],[&amp;quot;i&amp;quot;,&amp;quot;h&amp;quot;,&amp;quot;k&amp;quot;,&amp;quot;r&amp;quot;],[&amp;quot;i&amp;quot;,&amp;quot;f&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;v&amp;quot;]], words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;]&lt;br&gt;
Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   
    
    def findWords(self, board: List[List[str]], words: List[str]) -&amp;gt; List[str]:
        #trie + DFS
        class Trie:
            def __init__(self):
                self.next=dict()
                self.isword=False
            def addwords(self,word):
                if word:
                    char=word[0]
                    rest=word[1:]
                    if char not in self.next:
                        self.next[char]=  Trie()
                    self.next[char].addwords(rest)
                else:
                    self.isword=True           
                
            
        trie =  Trie()
        for word in words:
            trie.addwords(word)
       
        m=len(board)
        n=len(board[0])
        res = []
        def dfs(trie,board,i,j,tmp=&#39;&#39;):
            if i&amp;gt;=0 and i&amp;lt;m and j&amp;gt;=0 and j&amp;lt;n:
                char= board[i][j]
                board[i][j]=&#39;#&#39;
                tmp+=char
                if char in trie.next:
                    if trie.next[char].isword:
                        res.append(tmp)
                        trie.next[char].isword=False
                   
                    trie = trie.next[char]
                    dfs(trie,board,i+1,j,tmp)
                    dfs(trie,board,i-1,j,tmp)
                    dfs(trie,board,i,j+1,tmp)
                    dfs(trie,board,i,j-1,tmp)
                
                tmp = tmp[:-1]
                board[i][j] = char
              
            
        for i in range(m):
            for j in range(n):
                if board[i][j] in [word[0] for word in words]:
                    dfs(trie,board,i,j,&#39;&#39;)
        
        return res

#MY ANSWER
class Trie:
    def __init__(self):
        self.isword = False
        self.data = collections.defaultdict(Trie)
    
    def insert(self,word):
        if not word:
            self.isword = True
            return
        
        head = word[0]
        rest = word[1:]

        if head not in self.data:
            self.data[head] = Trie()
        self.data[head].insert(rest)


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -&amp;gt; List[str]:
        t = Trie()
        for word in words:
            t.insert(word)
        
        res = []
        m = len(board)
        n = len(board[0])

        def dfs(i,j,t,tmp):
            if m&amp;gt;i&amp;gt;=0 and n&amp;gt;j&amp;gt;=0 and board[i][j] in t.data:
                boardij=board[i][j]
                board[i][j] = &#39;#&#39;
                tmp+=boardij
                t = t.data[boardij]
                if t.isword:
                    res.append(tmp)
                    t.isword =False
                dfs(i+1,j,t,tmp)
                dfs(i-1,j,t,tmp)
                dfs(i,j-1,t,tmp)
                dfs(i,j+1,t,tmp)
                board[i][j] = boardij
        

        for i in range(m):
            for j in range(n):
                dfs(i,j,t,&#39;&#39;)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试trie+DFS , time limit exceeded.   什么地方没优化到？？ 原来是 发现isword时候 把isword设为False，这样就不会找到重复的word。&lt;/p&gt;
&lt;h1 id=&#34;213-house-robber-ii-medium&#34;&gt;213. House Robber II （Medium）&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rob(self, nums: List[int]) -&amp;gt; int:
        # dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        # dp[0] = nums[0]
        # dp[1] = max(nums[:2])
        #
        # now circle constraint
        #
        # if select 0, -1 and 1 can not be selected
        #  dp[0] = nums[0]  dp[1] = dp[0] ... dp[-1]=dp[-2]
        # if not select 0, -1 and 1 can be selected
        #  dp[0] = 0 dp[1]=nums[1]  ... dp[-1]=dp[-2]+nums[-1]
        
        if len(nums)&amp;lt;3:
            return max(nums)
       
        #case1) select 0
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=nums[0]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-1]
        res=max(dp)
        #case2)
        dp=[0]*len(nums)
        dp[0]=0
        dp[1]=nums[1]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-2]+nums[-1]
        res=max(res,max(dp))
        return res

#MY ANSWER
class Solution:
    def rob(self, nums: List[int]) -&amp;gt; int:
        # dp[0] = nums[0] rob0 
        # dp[1] = dp[0]
        # dp[i] = max(nums[i]+dp[i-2] ,dp[i-1])
        #
        # dp&#39;[0] = 0 rob1
        # dp&#39;[1] = nums[1]
        # dp [i] = max(nums[i]+dp[i-2] ,dp[i-1])
        
        if len(nums)&amp;lt;=2: return max(nums)
        l = len(nums)
        dp = [[0]*l,[0]*l]
        dp[0][0] = nums[0]
        dp[0][1] = nums[0]
        dp[1][1] = nums[1]
        for i in range(2,l):
            if i!=l-1:
                dp[0][i] =  max(dp[0][i-2]+nums[i],dp[0][i-1])
                dp[1][i] =  max(dp[1][i-2]+nums[i],dp[1][i-1])
            else:
                dp[0][i] = dp[0][i-1]
                dp[1][i] = max(dp[1][i-2]+nums[i],dp[1][i-1])
        return max(dp[0][-1],dp[1][-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为循环数组，所以，分两种case， 抢劫第一户和不抢劫第一户。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred214-shortest-palindrome-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;214. Shortest Palindrome （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given a string s. You can convert s to a palindrome by adding characters in front of it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
#MY ANSWER is a bad one
class Solution:
    def shortestPalindrome(self, s: str) -&amp;gt; str:
        if s == s[::-1]: return s
        #   tfel +   ABC CBA left    
        res = None
        for i in range(1,len(s)//2+1):
            
            if s[:i] == s[i:2*i][::-1]:
                #print(1,s[:i],s[i:2*i], s[2*i:])
                tmp = s[2*i:][::-1]+s
                if res and len(tmp)&amp;lt;len(res):
                    res = tmp
                elif res is None:
                    res = tmp
               
            if s[:i] == s[i+1:2*i+1][::-1]:
                #print(2,s[:i])
                tmp = s[2*i+1:][::-1]+s
                if res and len(tmp)&amp;lt;len(res):
                    res = tmp
                elif res is None:
                    res = tmp
            
           
        return res if res else  s[1:][::-1] + s
            

###
class Solution:
    def shortestPalindrome(self, s: str) -&amp;gt; str:
        # brute force
        l=len(s)
        rev = &#39;&#39;.join(s[::-1])
        
        for i in range(l):
            if s[:l-i]==rev[i:]:
                return rev[:i]+s
        
        return &#39;&#39;
#KMP

class Solution:
    def shortestPalindrome(self, s: str) -&amp;gt; str:
        # KMP
        l=len(s)
        rev = &#39;&#39;.join(s[::-1])
        s_new = s +&#39;#&#39; + rev
        l_new = len(s_new)
        f = [0]*l_new
        for i in range(1,l_new):
            t = f[i-1]
            while t&amp;gt;0 and s_new[i]!=s_new[t]:
                #can&#39;f find prefix=sufix, t=f[t-1]
                t=f[t-1]
            if s_new[i]==s_new[t]:
                t+=1
            f[i]=t
        
        return rev[:l-f[l_new-1]] +s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： finding the largest palindrome substring from the beginning. O（n）方法用了KMP的loolup table。   rev[f[l_new-1]:]是形成回文的序列。和 s[:len(s)-f[l_new-1]] 是对应的，那么未形成回文的就是 rev[: f[l_new-1]] ，s+rev[: f[l_new-1]] 为答案。 s_new = s +&#39;#&#39; + rev 因为不加#会引起 2 strings could mix with each ther, producing wrong answer. For example, take the string &amp;quot;aaaa&amp;quot; . Had we not inserted &amp;quot;#&amp;quot; in the middle, the new string would be &amp;quot;aaaaaaaa&amp;quot;。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-215-kth-largest-element-in-an-array-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 215. Kth Largest Element in an Array （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
        from heapq import heapify, heappush, heappop
        stack=[]
        for i,n in enumerate(nums):
            if len(stack)&amp;lt;k:
                heappush(stack,n)
            else:
                tmp=heappop(stack)
                if n&amp;lt;tmp:
                    heappush(stack,tmp)
                else:
                    heappush(stack,n)
         
        return heappop(stack)
###
class Solution:
    def findKthLargest(self, nums, k):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        def partition(left, right, pivot_index):
            pivot = nums[pivot_index]
            # 1. move pivot to end
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  
            
            # 2. move all smaller elements to the left
            store_index = left
            for i in range(left, right):
                if nums[i] &amp;lt; pivot:
                    nums[store_index], nums[i] = nums[i], nums[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            nums[right], nums[store_index] = nums[store_index], nums[right]  
            
            return store_index
        
        def select(left, right, k_smallest):
            &amp;quot;&amp;quot;&amp;quot;
            Returns the k-th smallest element of list within left..right
            &amp;quot;&amp;quot;&amp;quot;
            if left == right:       # If the list contains only one element,
                return nums[left]   # return that element
            
            # select a random pivot_index between 
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return nums[k_smallest]
            # go left
            elif k_smallest &amp;lt; pivot_index:
                return select(left, pivot_index - 1, k_smallest)
            # go right
            else:
                return select(pivot_index + 1, right, k_smallest)

        # kth largest is (n - k)th smallest 
        return select(0, len(nums) - 1, len(nums) - k)
                
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;min heap&lt;br&gt;
第二种解法quicksort， O（n）&lt;br&gt;
Choose a random pivot.&lt;br&gt;
Use a partition algorithm to place the pivot into its perfect position pos in the sorted array, move smaller elements to the left of pivot, and larger or equal ones - to the right.&lt;br&gt;
Compare pos and N - k to choose the side of array to proceed recursively.&lt;/p&gt;
&lt;h1 id=&#34;216-combination-sum-iii-medium&#34;&gt;216. Combination Sum III （Medium）&lt;/h1&gt;
&lt;p&gt;Find all valid combinations of k numbers that sum up to n such that the following conditions are true:&lt;br&gt;
Only numbers 1 through 9 are used.&lt;br&gt;
Each number is used at most once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(start,tmp,target):
            if target&amp;lt;0: return
            if len(tmp)==k and target==0:
                res.append(tmp[:])
            
            for i in range(start,10):
                tmp.append(i)
                target -= i
                bt(i+1,tmp,target)
                target+=i
                tmp.pop()
        bt(1,[],n)
        return res
#MY  ANSWER
class Solution:
    def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]:

        nums = [i for i in range(1,10)]
        res = []
        def bt(tmp,val,start):
            if val&amp;lt;0 or len(tmp)&amp;gt;k: return
            if len(tmp)==k and val==0:
                res.append(tmp[:])
                return

            for i in range(start,len(nums)):
                tmp.append(nums[i])
                bt(tmp,val-nums[i],i+1)
                tmp.pop() 
            

        
        bt([],n,0)

        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;217-contains-duplicate-easy&#34;&gt;217. Contains Duplicate (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def containsDuplicate(self, nums: List[int]) -&amp;gt; bool:
        s = set()
        for n in nums:
            if n in s:
                return True
            s.add(n)
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred218-the-skyline-problem-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;218. The Skyline Problem (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from heapq import * 
class Solution(object):
    def getSkyline(self, buildings):
        # add start-building events
        # also add end-building events(acts as buildings with 0 height)
        # and sort the events in left -&amp;gt; right order
        events = [(L, -H, R) for L, R, H in buildings]
        events.extend([(R, 0, 0) for _, R, _ in buildings])
        events.sort()

        # res: result, [x, height]
        # live: heap, [-height, ending position]
        res = [[0,0]] 
        live = [(0, float(&amp;quot;inf&amp;quot;))]
        for pos, negH, R in events:
            # 1, pop buildings that are already ended
            # 2, if it&#39;s the start-building event, make the building alive
            # 3, if previous keypoint height != current highest height, edit the result
            while pos&amp;gt;= live[0][1]:
                 heappop(live)
            if negH!=0:
                #start building event
                heappush(live, (negH, R))
            if res[-1][1] != -live[0][0]:
                res.append( [pos, -live[0][0]])
        return res[1:]

 #
class Solution:
    def getSkyline(self, buildings: &#39;List[List[int]]&#39;) -&amp;gt; &#39;List[List[int]]&#39;:
        &amp;quot;&amp;quot;&amp;quot;
        Divide-and-conquer algorithm to solve skyline problem,
        which is similar with the merge sort algorithm.
        &amp;quot;&amp;quot;&amp;quot;
        n = len(buildings)
        # The base cases
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            return [[x_start, y], [x_end, 0]]

        # If there is more than one building,
        # recursively divide the input into two subproblems.
        left_skyline = self.getSkyline(buildings[: n // 2])
        right_skyline = self.getSkyline(buildings[n // 2 :])

        # Merge the results of subproblem together.
        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left, right):
        &amp;quot;&amp;quot;&amp;quot;
        Merge two skylines together.
        &amp;quot;&amp;quot;&amp;quot;
        def update_output(x, y):
            &amp;quot;&amp;quot;&amp;quot;
            Update the final output with the new element.
            &amp;quot;&amp;quot;&amp;quot;
            # if skyline change is not vertical -
            # add the new point
            if not output or output[-1][0] != x:
                output.append([x, y])
            # if skyline change is vertical -
            # update the last point
            else:
                output[-1][1] = y

        def append_skyline(p, lst, n, y, curr_y):
            &amp;quot;&amp;quot;&amp;quot;
            Append the rest of the skyline elements with indice (p, n)
            to the final output.
            &amp;quot;&amp;quot;&amp;quot;
            while p &amp;lt; n:
                x, y = lst[p]
                p += 1
                if curr_y != y:
                    update_output(x, y)
                    curr_y = y

        n_l, n_r = len(left), len(right)
        p_l = p_r = 0
        curr_y  = left_y = right_y = 0
        output = []

        # while we&#39;re in the region where both skylines are present
        while p_l &amp;lt; n_l and p_r &amp;lt; n_r:
            point_l, point_r = left[p_l], right[p_r]
            # pick up the smallest x
            if point_l[0] &amp;lt; point_r[0]:
                x, left_y = point_l
                p_l += 1
            else:
                x, right_y = point_r
                p_r += 1
            # max height (i.e. y) between both skylines
            max_y = max(left_y, right_y)
            # if there is a skyline change
            if curr_y != max_y:
                update_output(x, max_y)
                curr_y = max_y

        # there is only left skyline
        append_skyline(p_l, left, n_l, left_y, curr_y)

        # there is only right skyline
        append_skyline(p_r, right, n_r, right_y, curr_y)

        return output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉用stack做， 还是直接看答案了， 思路：事件驱动， events 包括开始建筑和终止建筑，【（L，-H，R），（R，0，0）.。。。】 这样遍历events，live存放【（-height，end pos）】 1, pop buildings that are already ended in live 2，if it&#39;s the start-building event, make the building alive， 3，if previous keypoint height != current highest height, edit the result， 思路2，分治法 O(Nlog⁡N)&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-219-contains-duplicate-ii-easyfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 219. Contains Duplicate II （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## correct way of doing
class Solution:
    def containsNearbyDuplicate(self, nums: &#39;List[int]&#39;, k: &#39;int&#39;) -&amp;gt; &#39;bool&#39;:
        dic=dict()
        
        for i,n in enumerate(nums):
            if n in dic:
                if abs(i-dic[n])&amp;lt;=k:
                    return True
            dic[n]=i
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer timestap&amp;lt;=k 过期，花的时间太长。。。， 正确方法还是用dict 存 mapping n=&amp;gt; i. 这样当遇到重复的n判断  i-dic【n】距离是否小于k，小于则为True。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-220-contains-duplicate-iii-mediumfont&#34;&gt;&lt;font color=&#39;red&#39; &gt;220. Contains Duplicate III （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&amp;gt; bool:
        if t&amp;lt; 0: return False
        dic = dict()
        for i,n in enumerate(nums):
            #remove outdated 
            if i-k&amp;gt;=0 and nums[i-k] in dic and dic[nums[i-k]]&amp;lt;i-k:
                del dic[nums[i-k]] 
            
            #print(i,n,dic)
            
            #check 
            if any([abs(n-key)&amp;lt;=t and abs(i-val)&amp;lt;=k for key,val in dic.items()]):
                #print(i,n)
                #print(dic)
                return True
            
           
            #add current
            dic[n]=i
        return False

#
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&amp;gt; bool:
        #            0~9 10~19 .. 
        # buketid     0   1
        #   what is 9&#39;s buket id, 9//(9+1) 
        #   so bucket size = 10
        
        buket = dict()
        buket_size = t+1
        for i,n in enumerate(nums):
            buket_id  = n//buket_size
            if buket_id in buket or (buket_id-1 in buket and n-buket[buket_id-1]&amp;lt;=t) or(buket_id+1 in buket and buket[buket_id+1]-n&amp;lt;=t):
                return True
            
            buket[buket_id] = n
            if i&amp;gt;=k:
                del buket[nums[i-k]//buket_size]
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用过期del dict key方法会time limit exceeded。竟然是用bukets。检查当前buket 和上一个或者下一个buket。 这题应该是个hard。&lt;/p&gt;
">Leetcode 2021-11-24</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-23/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred201-bitwise-and-of-numbers-range-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;201. Bitwise AND of Numbers Range （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -&amp;gt; int:
        if left==right: return left
        res = 0
        for pos in range(32):
            res |= 1 &amp;lt;&amp;lt; pos
            for n in range(left,right+1):
                if (n &amp;amp; 1&amp;lt;&amp;lt;pos) &amp;gt;&amp;gt; pos ==0:
                    res ^= 1 &amp;lt;&amp;lt; pos
                    break
        return res

#answer way of writing
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&amp;gt; int:
        shift = 0   
        # find the common 1-bits
        while m &amp;lt; n:
            m = m &amp;gt;&amp;gt; 1
            n = n &amp;gt;&amp;gt; 1
            shift += 1
        return m &amp;lt;&amp;lt; shift
#
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&amp;gt; int:
        while m &amp;lt; n:
            # turn off rightmost 1-bit
            n = n &amp;amp; (n - 1)
        return m &amp;amp; n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次尝试，time limit exceeded， 32位过一次，一旦发现在pos位上为0，就break。 还是速度慢，  after the AND operation on all the numbers, the remaining part of bit strings is the common prefix of all these bit strings.As a result, we then can reformulate the problem as &amp;quot;given two integer numbers, we are asked to find the common prefix of their binary strings.&amp;quot; 思路： shift 直到m n相等，然后再 shift back。 这样就找到了common prefix。另一解法，思路：关闭右侧最后是1的位，然后和左侧求&amp;amp;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When we do AND bit operation between number and number-1, the rightmost bit of one in the original number would be turned off (from one to zero).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;202-happy-number-easy&#34;&gt;202. Happy Number （Easy）&lt;/h1&gt;
&lt;p&gt;Write an algorithm to determine if a number n is happy.&lt;br&gt;
Input: n = 19&lt;br&gt;
Output: true&lt;br&gt;
Explanation:&lt;br&gt;
12 + 92 = 82&lt;br&gt;
82 + 22 = 68&lt;br&gt;
62 + 82 = 100&lt;br&gt;
12 + 02 + 02 = 1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isHappy(self, n: int) -&amp;gt; bool:
        visited =set()
        
        while n!=1:
            if n in visited: return False
            visited.add(n)
            new_n =0
            while n:
                lastdig = n%10
                new_n += lastdig*lastdig
                n //= 10
            n=new_n
        
        return True
#MY ANSWER
class Solution:
    def isHappy(self, n: int) -&amp;gt; bool:
        s =set()
        def helper(n):
            if n==1: return True
            res = 0
            while n:
                lastdig = n%10
                n = n//10
                res+=lastdig**2
            if res in s:return False
            s.add(res)
            return helper(res)
        return helper(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;203-remove-linked-list-elements-easy&#34;&gt;203. Remove Linked List Elements （Easy）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -&amp;gt; Optional[ListNode]:
        if not head: return head
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        cur=dummyhead
        while cur and cur.next:
            while cur.next and cur.next.val==val:
                cur.next=cur.next.next
            cur=cur.next
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred204-count-primes-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;204. Count Primes (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countPrimes(self, n: int) -&amp;gt; int:
 
        if n &amp;lt;=2:
            return 0
        primes = [True] * n
        primes[0] = primes[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if primes[i]:
                primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
        #如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。 
        return sum(primes)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接用判断是否位质数方法会time limit exceeded。 思路：如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;     def isP(num):
            for i in range(2,num//2+1):
                if num%i==0:
                    return False
            return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;205-isomorphic-strings-easy&#34;&gt;205. Isomorphic Strings （Easy）&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;br&gt;
Two strings s and t are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isIsomorphic(self, s: str, t: str) -&amp;gt; bool:
        if len(s)!=len(t): return False
        l=len(s)
        dic1 = dict()
        dic2 = dict()
        for i in range(l):
            a = s[i]
            b = t[i]
            if a in dic1:
                if dic1[a]!=b:
                    return False
            if b in dic2:
                if dic2[b]!=a:
                    return False
            dic1[a] = b
            dic2[b] = a
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;206-reverse-linked-list-easy&#34;&gt;206. Reverse Linked List (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        pre = None
        while head:
            headnext=head.next
            head.next = pre
            pre = head
            head=headnext
        return pre
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;207-course-schedule-medium&#34;&gt;207. Course Schedule (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #DFS 法    
        def dfs(node):
            # return True 无环 False 有环
            node.status=0
            for nei in node.nei:
                if nei.status==-1:
                    if not dfs(nei):
                        return False
                elif nei.status == 0:
                    return False
            
            node.status=1
            return True
        
        for node in nodes:
            if node.status==-1:
                if not dfs(node):
                    return False
        
        return True

# upper DFS lower BFS
class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #bfs 法
        queue=[]
        cnt=0
        for node in nodes:
            if node.ind==0:
                queue.append(node)
        while queue:
            v=queue.pop(0)
            cnt+=1
            for nei in v.nei:
                nei.ind-=1
                if nei.ind==0:
                    queue.append(nei)
        
        return cnt==numCourses

#MY ANSWER 
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool:
        indegree = {i:0 for i in range(numCourses)}
        b2a = collections.defaultdict(set)
        # a&amp;lt;-b
        # c&amp;lt;-d

        #   a&amp;lt;-b
        #   \|  |\
        #    c-&amp;gt;d

        for row in prerequisites:
            a,b = row
            b2a[b].add(a)
            indegree[a]+=1
        
        queue = []
        tobedel = set()
        for key in indegree:
            if indegree[key] == 0:
                queue.append(key)
                tobedel.add(key)
        
        for key in tobedel:
            del indegree[key]
        

        while queue:
            for _ in range(len(queue)):
                b = queue.pop(0)
                #need b-&amp;gt;a map
                for a in b2a[b]:
                    indegree[a]-=1
                    if indegree[a] == 0:
                        queue.append(a)
                        del indegree[a]
        

        return not indegree


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是图的算法，判断是否为DAG。BFS找入度为0的。  DFS时候，如果正在搜索某V，但又回到了V。证明有环路。注意需要3个状态来表示node状态， 【visited，visiting，not visited】&lt;br&gt;
需要补充拓扑排序算法解决变种题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# TopoSort sudo
queue = []
for 图中每个顶点V:
    if indegree(V)==0:
        queue.append(V)
while queue:
    V=queue.pop(0)
    输出V，记录V的输出序号cnt++
    for V的每个邻居 W:
        indegree(W) -= 1
        if indegree(W)==0:
            queue.append(W)

if cnt!=|V|:
    ERROR(图中有回路)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;208-implement-trie-prefix-tree&#34;&gt;208. Implement Trie (Prefix Tree)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Trie:

    def __init__(self):
        self.next= dict()
        self.isword=False
 

    def insert(self, word: str) -&amp;gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char] = Trie()
            self.next[char].insert(rest)
        else:
            self.isword=True
             

    def search(self, word: str) -&amp;gt; bool:
       
        if not word:
            return self.isword
        
        char = word[0]
        rest = word[1:]
        if char in self.next:
            if not self.next[char].search(rest):
                return False
        else:
            return False
        return True
        

    def startsWith(self, prefix: str) -&amp;gt; bool:
        if not prefix:
            return True
        
        char=prefix[0]
        rest=prefix[1:]
        if char in self.next:
            if not self.next[char].startsWith(rest):
                return False
        else:
            return False
        
        return True

#MY ANSWER
class Trie:

    def __init__(self):
        self.data = collections.defaultdict(Trie)
        self.isword = False

    def insert(self, word: str) -&amp;gt; None:
        if not word: 
            self.isword = True
            return
        head=word[0]
        rest = word[1:]
        if head not in self.data:
            self.data[head] = Trie()
        self.data[head].insert(rest)

    def search(self, word: str) -&amp;gt; bool:
        if not word:
            if self.isword: 
                 return True
            else:
                return False
        head = word[0]
        rest = word[1:]
        if head not in self.data: return False
        return self.data[head].search(rest)
        

    def startsWith(self, prefix: str) -&amp;gt; bool:
        if not prefix: return True
        head = prefix[0]
        rest = prefix[1:]
        if head not in self.data: return False
        return self.data[head].startsWith(rest)
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue209-minimum-size-subarray-sum-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;209. Minimum Size Subarray Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# answer way of writting
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&amp;gt; int:
        # two pointer
 
        l=len(nums)
        res=float(&#39;inf&#39;)
        left=0
        sum_=0
        for i,n in enumerate(nums):
            sum_+=n
            while sum_&amp;gt;=target:
                res=min(res,i-left+1)
                sum_-=nums[left]
                left+=1
        
        return res if res!= float(&#39;inf&#39;) else 0
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然是two pointer, 学习answer写法，很清晰。&lt;/p&gt;
&lt;h1 id=&#34;210-course-schedule-ii-medium&#34;&gt;210. Course Schedule II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    class Node:
        def __init__(self,val=None):
            self.val=val
            self.nei = []
            self.indegree = 0
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; List[int]:
        # dag
        
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for a,b in prerequisites:
            nodes[b].nei.append(nodes[a])
            nodes[a].indegree+=1
        
        queue = []
        for node in nodes:
            if node.indegree==0:
                queue.append(node)
                
        res = []
        while queue:
            cur=queue.pop(0)
            res.append(cur.val)
            for w in cur.nei:
                w.indegree-=1
                if w.indegree==0:
                    queue.append(w)
        
        return res if len(res)==numCourses else []

###
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; List[int]:

        indegree = {i:0 for i in range(numCourses)}
        b2a = collections.defaultdict(set)
        queue = deque()

        for row in prerequisites:
            a,b = row
            # a&amp;lt;-b
            indegree[a]+=1
            b2a[b].add(a)
        
        res = []
        
        tobedel= []
        for key in indegree:
            if indegree[key]==0:
                res.append(key)
                tobedel.append(key)
                queue.append(key)
        
        for key in tobedel:
            del indegree[key]


        while queue:

            for _ in range(len(queue)):
                b = queue.popleft()
                for a in b2a[b]:
                    indegree[a]-=1
                    if indegree[a]==0:
                        del indegree[a]
                        queue.append(a)
                        res.append(a)
        
        return res if not indegree else []
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BFS 拓扑排序，找出indegree==0的node output。&lt;/p&gt;
">Leetcode 2021-11-23</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-22/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;191-number-of-1-bits-easy&#34;&gt;191. Number of 1 Bits (Easy)&lt;/h1&gt;
&lt;p&gt;Write a function that takes an unsigned integer and returns the number of &#39;1&#39; bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def hammingWeight(self, n: int) -&amp;gt; int:
        res = 0 
        for _ in range(32):
            lastbit = n &amp;amp; 1
            n = n &amp;gt;&amp;gt;1
            res += 1&amp;amp;lastbit
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;192-word-frequency-medium-bash&#34;&gt;192. Word Frequency (Medium) BASH&lt;/h1&gt;
&lt;p&gt;Write a bash script to calculate the frequency of each word in a text file words.txt.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;for word in $(cat words.txt);   do echo $word;  done | sort | uniq -c | sort -r | awk &#39;{ print $2 &amp;quot; &amp;quot;$1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;193-valid-phone-numbers-easy-bash&#34;&gt;193. Valid Phone Numbers (Easy) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;grep -e &#39;^[0-9]\{3\}-[0-9]\{3\}-[0-9]\{4\}$&#39; -e &#39;^([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}$&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;194-transpose-file-medium-bash&#34;&gt;194. Transpose File (Medium) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt, transpose its content.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;cat file.txt | awk &#39;{for(i=0;++i&amp;lt;=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++&amp;lt;NF;)print a[i]}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;195-tenth-line-easy-bash&#34;&gt;195. Tenth Line (Easy) BASH&lt;/h1&gt;
&lt;p&gt;Given a text file file.txt, print just the 10th line of the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;sed -n &amp;quot;10p&amp;quot; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just ignore ....&lt;/p&gt;
&lt;h1 id=&#34;196-delete-duplicate-emails-easy-sql&#34;&gt;196. Delete Duplicate Emails (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;DELETE p1 FROM Person p1,
    Person p2
WHERE
    p1.Email = p2.Email AND p1.Id &amp;gt; p2.Id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;197-rising-temperature-easy-sql&#34;&gt;197. Rising Temperature (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select w1.id as Id from Weather w1 left join Weather w2 on datediff(w1.RecordDate,w2.RecordDate)=1 where w2.Temperature&amp;lt;w1.Temperature

# answer way of writting
SELECT
    weather.id AS &#39;Id&#39;
FROM
    weather
        JOIN
    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1
        AND weather.Temperature &amp;gt; w.Temperature
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;198-house-robber-medium&#34;&gt;198. House Robber (Medium)&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rob(self, nums: List[int]) -&amp;gt; int:
        # dp[i] = tthe max amount can rob at house i
        # dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        # dp[0] = nums[0]
        # dp[1] = max(nums[0],nums[1])
        if not nums:return 0
        if len(nums)==1: return nums[0]
        if len(nums)==2: return max(nums)
        dp = [float(&#39;-inf&#39;)]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(nums[:2])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        return dp[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;199-binary-tree-right-side-view-medium&#34;&gt;199. Binary Tree Right Side View (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        if not root: return root
        queue = [root]
        res = []
        
        while queue:
            level =[]
            l=len(queue)
            for i in range(l):
                cur = queue.pop(0)
                level.append(cur.val)
                if cur.right:
                    queue.append(cur.right)
                if cur.left:
                    queue.append(cur.left)
            res.append(level[0])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;level order tresversal.&lt;/p&gt;
&lt;h1 id=&#34;200-number-of-islands-medium&#34;&gt;200. Number of Islands (Medium)&lt;/h1&gt;
&lt;p&gt;Given an m x n 2D binary grid grid which represents a map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
        
        
        def dfs(grid,i,j):
            m=len(grid)
            n=len(grid[0])
            if i&amp;lt;0 or j&amp;lt;0 or i&amp;gt;=m or j&amp;gt;=n: return 
            if grid[i][j]==&#39;1&#39;:
                grid[i][j]=&#39;#&#39;
                dfs(grid,i+1,j)
                dfs(grid,i-1,j)
                dfs(grid,i,j+1)
                dfs(grid,i,j-1)
        r=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==&#39;1&#39;:
                    dfs(grid,i,j)
                    r+=1
        
        return r

#UNION FIND
class Solution:
    class UnionFind:
        def __init__(self,grid):
            self.count=0
            self.m=len(grid)
            self.n=len(grid[0])
            self.parent = [None]*(self.m*self.n)
            self.rank = [0]*(self.m*self.n)
            for i in range(self.m):
                for j in range(self.n):
                    if grid[i][j]==&#39;1&#39;:
                        self.parent[i*self.n+j]=i*self.n+j
                        self.count+=1
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&amp;gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&amp;lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
                self.count-=1
        
        def getCount(self):
            return self.count
    
    def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
        nr=len(grid)
        nc=len(grid[0])
        uf = self.UnionFind(grid)
        for r in range(nr):
            for c in range(nc):
                if grid[r][c]==&#39;1&#39;:
                    grid[r][c]=&#39;0&#39;
                    if (r-1&amp;gt;=0 and grid[r-1][c]==&#39;1&#39;):
                        uf.union(r*nc+c,(r-1)*nc+c)
                    if (r + 1 &amp;lt; nr and grid[r+1][c] == &#39;1&#39;):
                        uf.union(r * nc + c, (r+1) * nc + c) 
                    if (c - 1 &amp;gt;= 0 and grid[r][c-1] == &#39;1&#39;):
                        uf.union(r * nc + c, r * nc + c - 1) 
                    if   (c + 1 &amp;lt; nc and grid[r][c+1] == &#39;1&#39;):
                        uf.union(r * nc + c, r * nc + c + 1) 
                    
    
        return uf.getCount() 
        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案玩了个新东西，叫UnionFind， 挺有意思。 就是找爸爸的爸爸，然后谁rank高就作为最终父亲。 这样union时候只是pointer在移动， 刚开始所有1都是自己的爸爸， 然后逐渐union周围的1， 每union一次counter -=1 这样最终counter就是所有独立的岛数目。DFS也很简单， BFS同理。&lt;/p&gt;
">Leetcode 2021-11-22</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-21/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;181-employees-earning-more-than-their-managers-easy-sql&#34;&gt;181. Employees Earning More Than Their Managers (Easy) SQL&lt;/h1&gt;
&lt;p&gt;Write an SQL query to find the employees who earn more than their managers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT
    a.Name AS &#39;Employee&#39;
FROM
    Employee AS a,
    Employee AS b
WHERE
    a.ManagerId = b.Id
        AND a.Salary &amp;gt; b.Salary
;

SELECT
     a.NAME AS Employee
FROM Employee AS a JOIN Employee AS b
     ON a.ManagerId = b.Id
     AND a.Salary &amp;gt; b.Salary
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;182-duplicate-emails-easy-sql&#34;&gt;182. Duplicate Emails (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;
# Write your MySQL query statement below

select Email from
(
  select Email, count(Email) as num
  from Person
  group by Email
) as statistic
where num &amp;gt; 1
;

select Email
from Person
group by Email
having count(Email) &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;183-customers-who-never-order-easy-sql&#34;&gt;183. Customers Who Never Order (Easy) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select name as &amp;quot;Customers&amp;quot; from Customers as c left join Orders o on c.id=o.customerId where o.id is NULL;


select customers.name as &#39;Customers&#39;
from customers
where customers.id not in
(
    select customerid from orders
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;184-department-highest-salary-medium-sql&#34;&gt;184. Department Highest Salary (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
select Department,Employee,Salary from (
    select d.name as &amp;quot;Department&amp;quot;, 
               e.name as &amp;quot;Employee&amp;quot;,  
               e.salary as &amp;quot;Salary&amp;quot;,
              rank()   OVER( partition by e.departmentId order by salary DESC) as &amp;quot;r&amp;quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
     as tmp where r=1


#answer way of writting

SELECT
    Department.name AS &#39;Department&#39;,
    Employee.name AS &#39;Employee&#39;,
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
    )
;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;185-department-top-three-salaries-hard-sql&#34;&gt;185. Department Top Three Salaries (Hard) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select Department,Employee,Salary from (
    select d.name as &amp;quot;Department&amp;quot;, 
               e.name as &amp;quot;Employee&amp;quot;,  
               e.salary as &amp;quot;Salary&amp;quot;,
              dense_rank()   OVER( partition by e.departmentId order by salary DESC) as &amp;quot;r&amp;quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
as tmp where   r&amp;lt;=3

#answer way of writting
SELECT
    d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 &amp;gt; (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary &amp;gt; e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;186-reverse-words-in-a-string-ii-medium&#34;&gt;186. Reverse Words in a String II (Medium)&lt;/h1&gt;
&lt;p&gt;Given a character array s, reverse the order of the words.&lt;br&gt;
A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.&lt;br&gt;
Your code must solve the problem in-place, i.e. without allocating extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseWords(self, s: List[str]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify s in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        def rev(s,i,j):
            while i&amp;gt;=0 and j&amp;lt;len(s) and i&amp;lt;j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
        
        l=0
        r=len(s)-1
        rev(s,l,r)
        start=0
        for i in range(r):
            if s[i]==&#39; &#39;:
                rev(s,start,i-1)
                start=i+1
        rev(s,start,r)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;187-repeated-dna-sequences-medium&#34;&gt;187. Repeated DNA Sequences (Medium)&lt;/h1&gt;
&lt;p&gt;The DNA sequence is composed of a series of nucleotides abbreviated as &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.&lt;br&gt;
For example, &amp;quot;ACGAATTCCG&amp;quot; is a DNA sequence.&lt;br&gt;
When studying DNA, it is useful to identify repeated sequences within the DNA.&lt;br&gt;
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findRepeatedDnaSequences(self, s: str) -&amp;gt; List[str]:
        #sliding window s[i,i+10]  drop i add i+10, if in set, append to res
        if len(s)&amp;lt;=10: 
            return []
        set_ = set()
        res = set()
        for i in range(len(s)-10+1):
            cur=s[i:i+10]
            if cur in set_:
                res.add(cur)
            set_.add(cur)
        return list(res)

#
class Solution:
    def findRepeatedDnaSequences(self, s: str) -&amp;gt; List[str]:
        res = set()
        pos = dict()
        for i in range(len(s)-9):
            key = s[i:i+10]
            if key in pos:
                res.add(key)
            pos[key] = i
        return list(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;188-best-time-to-buy-and-sell-stock-iv-hard&#34;&gt;188. Best Time to Buy and Sell Stock IV （Hard）&lt;/h1&gt;
&lt;p&gt;You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.&lt;br&gt;
Find the maximum profit you can achieve. You may complete at most k transactions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&amp;gt; int:
        #  if k==1
        if not prices: return 0
        if k==0: return 0
        min_ = [float(&#39;inf&#39;)]*k
        p_ = [float(&#39;-inf&#39;)]*k
        
        for i,n in enumerate(prices):
            min_[0] = min(min_[0],n)
            p_[0] = max(p_[0],n-min_[0])
            for j in range(1,k):
                min_[j]=min(min_[j],n-p_[j-1])
                p_[j]=max(p_[j],n-min_[j])
                

        return p_[-1]


class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&amp;gt; int:

        #two  transections
        plow = [prices[0]]*(k+1)
        res = [0]*(k+1)
        for p in prices:
            for j in range(1,k+1):
                plow[j] = min(plow[j],p-res[j-1])
                res[j] = max(res[j], p-plow[j])
        
        return res[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;老老实实写出K=1，K=2的情况，然后改写为数组形式。&lt;/p&gt;
&lt;h1 id=&#34;189-rotate-array-medium&#34;&gt;189. Rotate Array （Medium）&lt;/h1&gt;
&lt;p&gt;Given an array, rotate the array to the right by k steps, where k is non-negative.&lt;br&gt;
Input: nums = [1,2,3,4,5,6,7], k = 3&lt;br&gt;
Output: [5,6,7,1,2,3,4]&lt;br&gt;
7654321&lt;br&gt;
765|4321&lt;br&gt;
657|1234&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rotate(self, nums: List[int], k: int) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        l=len(nums)
        k = k%l
        def rev(nums,i,j):
            while i&amp;lt;j:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j-=1
        
        rev(nums,0,l-1)
        rev(nums,0,k-1)
        rev(nums,k,l-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;190-reverse-bits-easy&#34;&gt;190. Reverse Bits (Easy)&lt;/h1&gt;
&lt;p&gt;Reverse bits of a given 32 bits unsigned integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseBits(self, n: int) -&amp;gt; int:
        res = 0
        for _ in range(32):
            lastbit = n &amp;amp; 1
            n = n&amp;gt;&amp;gt;1
            res = res&amp;lt;&amp;lt;1 | lastbit
        return res  
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-21</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-20/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;171-excel-sheet-column-number-easy&#34;&gt;171. Excel Sheet Column Number (Easy)&lt;/h1&gt;
&lt;p&gt;convert excel sheet column chars to number&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def titleToNumber(self, columnTitle: str) -&amp;gt; int:
        
        s = [e for e in columnTitle]
        res=0
        for char in s:
            n=ord(char)-ord(&#39;A&#39;)+1
            res  = res*26 +n
        return res

class Solution:
    def titleToNumber(self, columnTitle: str) -&amp;gt; int:
        res = 0
        for char in columnTitle:
            res = res*26+ ord(char)-ord(&#39;A&#39;)+1
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;172-factorial-trailing-zeroes-medium&#34;&gt;172. Factorial Trailing Zeroes (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trailingZeroes(self, n: int) -&amp;gt; int:
        # n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.
        #     2*5 =10 4*5=20 5*6=30 5*8=40 
        #    5&#39;s double time give one zero
        res5=0
        for i in range(n,0,-1):
            if i%5==0:  
                res5+=1
                i=i//5
                while i%5==0 and i!=0:
                    res5+=1
                    i=i//5
        
        return  res5
 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题有点意思，要形成末尾的0只能是5和2的结合，阶乘中公共因子2的数肯定大于公共因子为5的数，所以bound by 5的数目。 所以求所有含有5的因子的个数，特殊情况是25，125，625， 。。。 他们包含2个，3个，4个五，因此能产生更多的尾数0.  答案给出了lgn时间的解法。 就是循环求n能否除power of 5. 另一个思路是让n变小n=n//5.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#fives = 0
#power_of_5 = 5
#while n &amp;gt;= power_of_5:
#    fives += n / power_of_5
#    power_of_5 *= 5

tens = fives
def trailingZeroes(self, n: int) -&amp;gt; int:
    zero_count = 0
    current_multiple = 5
    while n &amp;gt;= current_multiple:
        zero_count += n // current_multiple
        current_multiple *= 5
    return zero_count

def trailingZeroes(self, n: int) -&amp;gt; int:
    zero_count = 0
    while n &amp;gt; 0:
        n //= 5
        zero_count += n
    return zero_count

class Solution:
    def trailingZeroes(self, n: int) -&amp;gt; int:
        #2 5   2 is dominant so count 5
        # problem converts to n! has how many 5
        c=0
        while n:
            c+=n//5
            n = n//5
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;173-binary-search-tree-iterator-medium&#34;&gt;173. Binary Search Tree Iterator (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        while root:
            self.stack.append(root)
            root=root.left
        #print([ e.val for e in self.stack])
        #print(&#39;##########################&#39;)
        

    def next(self) -&amp;gt; int:
        node = self.stack.pop()
        if node.right:
            root=node.right
            while root:
                self.stack.append(root)
                root=root.left
                
        #print(&#39;r&#39;,node.val)
        return node.val
    def hasNext(self) -&amp;gt; bool:
        return self.stack!=[]
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred174-dungeon-game-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;174. Dungeon Game (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -&amp;gt; int:
        
        # -2 -3  3
        # -5 -10 1
        # 10  30 -5
        #
        #  7  5   2
        #  16 11  5
        #  1  1   6  
        m = len(dungeon)
        n = len(dungeon[0])
        dp=[[0]*n for _ in range(m)]
        dp[-1][-1] = 1 if dungeon[-1][-1]&amp;gt;0 else -1*(dungeon[-1][-1]-1)
        
        
        for i in range(m-2,-1,-1):
            dp[i][n-1] = dp[i+1][n-1]-dungeon[i][n-1] if dp[i+1][n-1]-dungeon[i][n-1]&amp;gt;0 else 1
        for j in range(n-2,-1,-1):
            dp[m-1][j]= dp[m-1][j+1]-dungeon[m-1][j] if dp[m-1][j+1]-dungeon[m-1][j]&amp;gt;0 else 1
        
        for row in range(m-2,-1,-1):
            for col in range(n-2,-1,-1):
                godown = max(dp[row+1][col]-dungeon[row][col],1)    
                goright = max(dp[row][col+1]-dungeon[row][col],1)  
                dp[row][col]=min(godown,goright)
        
        return dp[0][0]


####
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -&amp;gt; int:
    
        #           -2 -3  3            7   5   2
        #           -5 -10 1            6   11   5
        #            10 30 -5           1    1   6

        #         dp[i,j] = need healthpoints
        #

        m = len(dungeon)
        n = len(dungeon[0])

        if m==1 and n==1: return 1 if dungeon[0][0]&amp;gt;0 else 1-dungeon[0][0]

        dp = [ [0]*n for _ in range(m)]

        dp[-1][-1] = max(1-dungeon[-1][-1],1)

    
        for j in range(n-2,-1,-1):
            dp[m-1][j] =   max(1,dp[m-1][j+1] - dungeon[m-1][j])
    
    
        for i in range(m-2,-1,-1):
            dp[i][n-1] = max(1,dp[i+1][n-1]- dungeon[i][n-1])
        

        print(dp)
        for i in range(m-2,-1,-1):
            for j in range(n-2,-1,-1):
                dp[i][j] = max(1, min(dp[i][j+1],dp[i+1][j])-dungeon[i][j])

        return dp[0][0] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想复杂了，应该从右下角开始回溯。 回溯血量小于0说明格子给的补药多了，所以保持生命1就可以了。 dp存的是需要的生命值。&lt;/p&gt;
&lt;h1 id=&#34;175-combine-two-tables-easysql&#34;&gt;175. Combine Two Tables （Easy）SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
# first name, last name, city, and state of each person in the Person table.  

select Person.firstName, Person.lastName, Address.city, Address.state  from Person left join Address on Person.personId=Address.personId

select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;176-second-highest-salary-mediumsql&#34;&gt;176. Second Highest Salary （Medium）SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below
# select  (
# select salary from Employee where salary&amp;lt; (select max(salary) from Employee ) order by salary desc limit 1
# ) as  SecondHighestSalary

select (select distinct salary from Employee order by salary desc limit 1 offset 1) as SecondHighestSalary
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;177-nth-highest-salary-medium-sql&#34;&gt;177. Nth Highest Salary (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
set N=N-1; 
  RETURN (
      # Write your MySQL query statement below.
      
    select distinct Salary from Employee order by Salary Desc limit 1 offset N
  );
END
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;178-rank-scores-medium-sql&#34;&gt;178. Rank Scores (Medium) SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select  score,  dense_rank() over ( order by score desc) as &#39;rank&#39;    from Scores 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dense_rank和rank不同之处在于是否压缩值。 rank()用法举例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT * FROM (
	SELECT
		product_id,
		product_name,
		category_id,
		list_price,
		DENSE_RANK () OVER ( 
			PARTITION BY category_id
			ORDER BY list_price DESC
		) price_rank 
	FROM
		production.products
) t
WHERE price_rank &amp;lt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred179-largest-number-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;179. Largest Number (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a list of non-negative integers nums, arrange them such that they form the largest number.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class LargerNumKey(str):
    def __lt__(x, y):
        return x+y &amp;gt; y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = &#39;&#39;.join(sorted(map(str, nums), key=LargerNumKey))
        return &#39;0&#39; if largest_num[0] == &#39;0&#39; else largest_num

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接看答案了。答案直接拒绝处理最高位相同情况直接按照string 去compare。。。&lt;/p&gt;
&lt;h1 id=&#34;180-consecutive-numbers-mediumsql&#34;&gt;180. Consecutive Numbers （Medium）SQL&lt;/h1&gt;
&lt;p&gt;Write an SQL query to find all numbers that appear at least three times consecutively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# Write your MySQL query statement below


SELECT DISTINCT
    l1.Num AS ConsecutiveNums
FROM
    Logs l1,
    Logs l2,
    Logs l3
WHERE
    l1.Id = l2.Id - 1
    AND l2.Id = l3.Id - 1
    AND l1.Num = l2.Num
    AND l2.Num = l3.Num
;

&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-20</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-19/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;161-one-edit-distance-medium&#34;&gt;161. One Edit Distance (Medium)&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isOneEditDistance(self, s: str, t: str) -&amp;gt; bool:
        #
        #      &#39;&#39;  a  b
        #   &#39;&#39; 0   1  2
        #    a 1   0  1  
        #    c 2   1  1
        #    b 3   2  1
        #
        #    dp[i][j] is s[:i]  t[:j]&#39;s editdistance
        #    dp[i][j] =   min(dp[i][j-1] ,  dp[i-1][j] ,  dp[i-1][j-1]) +1 if s[i]!=t[j]        
        m = len(s)
        n = len(t)
        
        dp = [[0]*(n+1) for _ in range(m+1)]
      
        for i in range(n+1):
            dp[0][i]=i
        for i in range(m+1):
            dp[i][0]=i
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if s[i-1]!=t[j-1]:
                    dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1
                else:
                    dp[i][j] = dp[i-1][j-1]
        return dp[-1][-1]==1

 #second way of writting
 class Solution:
    def isOneEditDistance(self, s: str, t: str) -&amp;gt; bool:
        
        # s-&amp;gt;t    insert
        
        if len(t)-len(s)==1 and len(set(t))-len(set(s))&amp;lt;=1:
            #s insert
            # ssss sss
            # tttttttt
           
            while s and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while s and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(t)==1:
                return True
            
        elif len(s)-len(t)==1 and len(set(s))-len(set(t))&amp;lt;=1:
            #s del
            # sssssss
            # ttt ttt
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(s)==1:
                return True
            
            
        elif len(s)==len(t)  and len(set(s))-len(set(t))&amp;lt;=1:
            # replace
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            
            if len(t)==1 and len(s)==1 and t!=s:
                return True

        return False

#MY ANSWER WAY OF WRITING
class Solution:
    def isOneEditDistance(self, s: str, t: str) -&amp;gt; bool:
        #insert
        #A B D C
        #A B C
        
        if abs(len(s)-len(t))==1:
            ss = s
            tt = t
            while ss and tt and ss[0]==tt[0]:
                ss = ss[1:]
                tt = tt[1:]
            while ss and tt and ss[-1]==tt[-1]:
                ss = ss[:-1]
                tt = tt[:-1]
            if not ss:
                if tt and len(tt)==1:
                    return  True
            if not tt:
                if ss and len(ss)==1:
                    return  True
                

        #delete
        # is same as insert

        #replace
        if len(s)==len(t):
            ss = s
            tt = t
            while ss and tt and ss[0]==tt[0]:
                ss = ss[1:]
                tt = tt[1:]
            while ss and tt and ss[-1]==tt[-1]:
                ss = ss[:-1]
                tt = tt[:-1]
            if ss  and tt and len(ss)==len(tt) and len(tt)==1 and ss!=tt:
                return True         
        

        return False
        

               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用dp方法，time limit exceeded。dp是n*n的。所以用定义做。 分3种情况， insert ，del， replace。 头尾之间去除相同的，剩下长度为1 就是可以的。&lt;/p&gt;
&lt;h1 id=&#34;162-find-peak-element-medium&#34;&gt;162. Find Peak Element （Medium）&lt;/h1&gt;
&lt;p&gt;A peak element is an element that is strictly greater than its neighbors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findPeakElement(self, nums: List[int]) -&amp;gt; int:
        
#         for i in range(len(nums)-1):
#             if nums[i] &amp;gt; nums[i+1]:
#                 return i
        
#         return len(nums)-1
        
        
        return self.search(nums,0,len(nums)-1)
    
    def search(self, nums,l,r):
        if l==r:
            return l
        
        m = (l+r)//2
        
        if nums[m] &amp;gt; nums[m+1]:
            return self.search(nums,l,m)
        else:
            return self.search(nums,m+1,r)

#
class Solution:
    def findPeakElement(self, nums: List[int]) -&amp;gt; int:

        l = 0
        r = len(nums)-1
        while l&amp;lt; r:
            m = (l+r)//2
            if nums[m]&amp;gt;nums[m+1]:
                r=m
            else:
                l=m+1
        
        return l

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定是考binary search的，但木有思路，答案很精彩。 就是比较 m 和 m+1就搞定了。&lt;br&gt;
做出来了， 但是不是标准的Binary Search， m可以和m+1比较而不越界因为 m=(l+r)//2,m+1也不会很大而越界， 要点在while l小于r， 要退出时候l==r。&lt;/p&gt;
&lt;h1 id=&#34;163-missing-ranges-easy&#34;&gt;163. Missing Ranges （Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&amp;gt; List[str]:
        res=[]
        
        def helper(x,y):
            if y-x==2:
                # y=3 x=1
                res.append(str(x+1))
            elif y-x&amp;gt;2:
                res.append(str(x + 1) + &#39;-&amp;gt;&#39; + str(y - 1))
            
        
        pre = lower-1
        for num in nums:
            helper(pre,num)
            pre=num
        
        helper(pre,upper+1)
            
        return res


class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&amp;gt; List[List[int]]:      
        if not nums: return [[lower, upper]]
        res = []
        pre  = None
        if nums[0]!=lower-1:
            nums  = [lower-1]+nums
        if nums[-1]!=upper+1:
            nums  = nums+[upper+1]

        for n in nums:
            if pre is not None and pre+1!=n:
                res.append([pre+1,n-1])
            pre = n
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if else 判断太繁杂， 答案很简单，这个是个easy题目？？？ 为了统一 x 到 y之间判断， lower =lower-1，这样lower就包括进去了， upper=upper+1，这样upper就包括进去了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred164-maximum-gap-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;164. Maximum Gap （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximumGap(self, nums: List[int]) -&amp;gt; int:
        
        if not nums or len(nums)&amp;lt;2: return 0
        
        maxval = max(nums)
        exp=1 # 1,10,100,...
        radix=10 #base 10 system
        aux = [0]*len(nums)
        while maxval//exp&amp;gt;0:
            count = [0]*radix
            
            for i,n in enumerate(nums):
                count[(n//exp)%10] +=1
            
            for i,n in enumerate(count):
                if i==0: continue
                count[i] += count[i-1]
            
            for i in range(len(nums)-1,-1,-1):
                count[(nums[i]//exp)%10] -= 1
                aux[ count[(nums[i]//exp)%10] ] = nums[i]
                
            nums= aux[:]
            
            exp*=10
        
        print(nums)
        
        maxGap = 0 
        for   i  in range(len(nums)-1): 
            maxGap = max(nums[i + 1] - nums[i], maxGap)

        return maxGap

# answer way of writting
class Solution:
    def maximumGap(self, nums: List[int]) -&amp;gt; int:
        ## RC ##
        ## APPROACH : BUCKET SORT ##
        ## LOGIC ##
        ## 1. lets say we have number from 1 to 10 like, 1,1.1,1.2,2.4,3.5,3.7,4,....10 (not in the same order)
        ## 2. we create n - 1 buckets, why n-1 ? (b1 -&amp;gt; [1-2] b2-&amp;gt; [2-3] b3-&amp;gt;[3-4] ...so on 9 buckets)
        ## 3. we can say size of each bucket will be (10 - 1) // 9 i.e 1 ==&amp;gt; (maximum - mimimum) // (length - 1)
        ## 3. Instead of storing all the elements in the buckets, we store minvalue of that bucket and maximum value of that bucket
        ## 4. Maximum Gap can be Case 1: gap between min and max in the bucket itself (or) Case 2: Gap between bucket1 max and bucket2 and so on..
        
		## TIME COMPLEXITY : O(N) ##
		## SPACE COMPLEXITY : O(N) ##
        
        if len(nums) &amp;lt; 2 or min(nums) == max(nums):
            return 0
        minimum, maximum = min(nums), max(nums)
        size = ( maximum - minimum )//(len(nums)-1) or 1
        buckets = [[None, None] for _ in range(( maximum - minimum )//size+1)]
        for num in nums:
            # getting the bucket number in which it falls into
            bucket = buckets[ ( num - minimum )//size ]
            bucket[0] = num if bucket[0] is None else min(bucket[0], num)
            bucket[1] = num if bucket[1] is None else max(bucket[1], num)
        buckets = [bucket for bucket in buckets if bucket[0] is not None]
        return max(buckets[i][0]-buckets[i-1][1] for i in range(1, len(buckets)))        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要求O（n）for space and time没思路。答案思路1） Radix Sort 听过，但写不出来。。。2）Buckets 这个思路很好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识点 Radix Sort&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
     def count_sort(arr,exp):
           #辅助数组用于返回
           aux = [0]*len(nums)
           #0到9是个数字的计数器
           count=[0]*10
           #计数
           for i,n in enumerate(arr):
               ind= (n//exp)%10
               count[ind]+=1
           #计算位置  count【i】 就是 i 这个位，属于的数字所在的位置
           for i in range(1,10):
               count[i] += count[i-1]
            #从后向前遍历数组
           for i in range(len(arr)-1,-1,-1):
               #找到index
               ind = (arr[i]//exp)%10
               #找到位置 因为位置从0开始所以要-1
               count[ind] -= 1
               #赋值
               aux[count[ind]] = arr[i]
           return aux 


       def Radix_Sort(arr):
           maxval=max(arr)
           exp=1
           while maxval//exp&amp;gt;0:
               #print(&#39;#&#39;,exp)
               arr = count_sort(arr,exp)
               exp*=10
           return arr
       
       nums = Radix_Sort(nums)


&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;165-compare-version-numbers-medium&#34;&gt;165. Compare Version Numbers （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def compareVersion(self, version1: str, version2: str) -&amp;gt; int:
        while version1 or version2:
            v1=0
            v2=0
            while version1 and version1[0]!=&#39;.&#39;:
                v1 = v1*10+int(version1[0])
                version1=version1[1:]
            while version2 and version2[0]!=&#39;.&#39;:
                v2 = v2*10+int(version2[0])
                version2=version2[1:]
            
            if v1&amp;gt;v2: return 1
            if v1&amp;lt;v2: return -1
            
            version1 = version1[1:] if version1 else &#39;&#39;
            version2 = version2[1:] if version2 else &#39;&#39;
    
        return  0
        
class Solution:
    def compareVersion(self, version1: str, version2: str) -&amp;gt; int:

        v1=list(map(int,version1.split(&#39;.&#39;)))
        v2=list(map(int,version2.split(&#39;.&#39;)))

        while v1 or v2:
            c1 = v1.pop(0) if v1 else 0
            c2 = v2.pop(0) if v2 else 0

            if c1&amp;lt;c2: return -1
            if c1&amp;gt;c2: return 1
        
        return 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;166-fraction-to-recurring-decimal-medium&#34;&gt;166. Fraction to Recurring Decimal （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -&amp;gt; str:
        negsign = (numerator&amp;gt;0) ^ (denominator&amp;gt;0)
        numerator= abs(numerator)
        denominator=abs(denominator)
        if numerator==0: negsign=False
        
        integer = numerator//denominator
        if integer*denominator==numerator:
            return str(integer) if not negsign else  &#39;-&#39;+str(integer)
        res_int = str(integer)
        
        numerator -= integer*denominator
        
        def loop(res_dec,denominator_len):
            l=len(res_dec)
            if l&amp;gt;=2:
                for lookback in range(1,l//2+1):     
                    if lookback&amp;gt;=denominator_len and res_dec[l-lookback:l] == res_dec[l-2*lookback :l-lookback] :
                        return True, l-2*lookback, lookback
            return False, 0,0
        res_dec = []
        while True:
            numerator *= 10
            val =numerator//denominator
            res_dec.append(val)
            #print(res_dec)
            flag, start,length =  loop(res_dec,len(str(denominator)))
            if flag:
                l=len(res_dec)
                part1 = res_dec[:start]
                recur = res_dec[start:start+length]
                part1=&#39;&#39;.join([str(e) for e in part1])
                recur = &#39;(&#39;+&#39;&#39;.join([str(e) for e in recur]) +&#39;)&#39; if recur else &#39;&#39;
                decpart=part1+recur
                result= res_int+&#39;.&#39;+decpart if decpart else res_int
                return result if not negsign else &#39;-&#39;+result
            numerator=numerator-val*denominator
            if numerator==0:
                break
        
        decpart=&#39;&#39;.join([str(e) for e in res_dec])
        result=res_int+&#39;.&#39;+decpart if decpart else res_int
        return result if not negsign else &#39;-&#39;+result

#answer way of writting
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        &amp;quot;&amp;quot;&amp;quot;
        :type numerator: int
        :type denominator: int
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
       
        if not numerator: return &amp;quot;0&amp;quot;;
        res=&amp;quot;&amp;quot;
        if  (numerator &amp;lt; 0) ^ (denominator &amp;lt; 0):
            res += &#39;-&#39;
        
        numer = numerator * (-1) if numerator &amp;lt; 0 else numerator
            
        denom =  denominator * (-1) if denominator &amp;lt; 0 else denominator;
        integral = numer // denom;
        res += str(integral);
        rmd = numer % denom;
        if  rmd==0: return res
        res += &#39;.&#39;;
        rmd *= 10
        mp=dict() 
        while rmd:
            quotient = rmd / denom
            if rmd in mp:
                #res.insert(mp[rmd], 1, &#39;(&#39;);
                res=res[:mp[rmd]]+&#39;(&#39;+res[mp[rmd]:]
                res += &#39;)&#39;
                break
            
            mp[rmd] = len(res)
            res += str(quotient);
            rmd = (rmd % denom) * 10
        
        return res;


#MY ANSWER
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -&amp;gt; str:
        sign = (numerator&amp;gt;0 and denominator&amp;gt;0) or (numerator&amp;lt;0 and denominator&amp;lt;0)
        if numerator==0: sign = True
        numerator=abs(numerator)
        denominator = abs(denominator)
        dic = dict()
        res =  str(int(numerator//denominator))
        if numerator % denominator == 0: 
            return res if sign else &#39;-&#39;+res
        else:
            res+=&#39;.&#39;
        
        numerator = (numerator%denominator)*10
        while numerator % denominator:
            val = numerator//denominator
            key = (numerator,denominator)
            if key in dic:
                res =  res[:dic[key]]+&#39;(&#39;+res[dic[key]:]+&#39;)&#39;
                return res if sign else &#39;-&#39;+res
            dic[key] = len(res)
            res+=str(val)
            numerator = (numerator%denominator)*10
          
        res+=str(numerator//denominator)
        return res if sign else &#39;-&#39;+res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断recurring，lookback需要长度大于被除数。不难但细节太多，垃圾题。答案写的很优雅。用了dict去存reminder，如果重复出现reminder说明存在重复。 我的方法是之间判断数组是否循环。答案更优雅。&lt;/p&gt;
&lt;h1 id=&#34;167-two-sum-ii-input-array-is-sorted-easy&#34;&gt;167. Two Sum II - Input Array Is Sorted （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
        length = len(numbers)
        l=0
        r=length-1
        while l&amp;lt;r:
            if numbers[l]+numbers[r]==target:
                return [l+1,r+1]
            elif  numbers[l]+numbers[r]&amp;lt;target:
                l+=1
            else:
                r-=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sorterd 直接上two pointer了。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred168-excel-sheet-column-title-easyfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;168. Excel Sheet Column Title （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def convertToTitle(self, columnNumber: int) -&amp;gt; str:
        # 26 进制数
        
      
        
        
        chars = &#39;ZABCDEFGHIJKLMNOPQRSTUVWXY&#39;
        dic = dict()
        for i in range(26):
            dic[i]=chars[i]
        
        res = []
        while columnNumber:
            
            reminder = columnNumber%26
            #print(columnNumber,reminder)
            res.append(dic[reminder])
            columnNumber = columnNumber //26
            if reminder==0:
                columnNumber-=1
             
        return &#39;&#39;.join(res[::-1])
             
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是个26进制数转换问题，这个也能卡。。。 卡在的点为 if reminder==0:   columnNumber-=1&lt;br&gt;
如果没有余数恰巧除干净了，说明需要上一位减去一。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue169-majority-element-easyfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;169. Majority Element （Easy）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def majorityElement(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        
        maj = nums[0]
        c = 0
        for n in nums:
            if n==maj:
                c+=1
            else:
                c-=1
            
            if c==0:
                maj=n
                c=1
       
        
        return  maj

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是个经典算法 摩尔投票算法，需要记住。 思路：遍历过程中不同元素之间两两抵消，由于一个数组中，出现次数超过n/2最多只有一个，那么遍历结束时，未被抵消掉的即是出现次数超过n/2的元素。在数组中maj元素出现一次，count就自加一次，如果出现了和maj不同的元素，说明maj可被抵消一次，count就自减一次，如果count减为0，也就说明maj元素已经被抵消完了， 更新maj。&lt;br&gt;
如果找超过1/3元素。 最多只有两个元素符合要求。需要设置maj1和count1、maj2和count2来分别记录这两个元素的抵消情况。如果出现了和maj1或maj2相同的元素，那么对应的count1和count2就自加1，如果元素与maj1和maj2都不相同，那么count1和count2就都应当自减1，如果maj1或maj2抵消掉后，就应当更新对应的maj1或maj2。NOTE 注意：  初始值 maj1和maj2、count1和count2相同，所以在判断二者与当前值是否相同时应当使用if else语句，而不是分开的两个if。此外，考虑到可能出现maj1和maj2都同时出现抵消掉的情况，所以也不能同时进行count自减和判断count1或count2是否为0，如果同时判断的话，那么maj1和maj2又会都同时成为当前元素了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;maj1=nums[0]
maj2=nums[0]
c1=0
c2=0

for n in nums:
   if n==maj1:
       c1+=1
   elif n==maj2:
       c2+=1
   elif c1==0:
       c1=1
       maj1=n
   elif c2==0:
       c2=1
       maj2=n
   else:
       c1-=1
       c2-=1
#recalce make sure        
c1=c2=0
for n in nums:
   if n==maj1:c1+=1
   if n==maj2:c2+=1
res=[]
if c1&amp;gt;len(nums)//3:
   res.append(maj1)
if c2&amp;gt;len(nums//3) and maj1!=maj2:
   res.append(maj2)
return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;170-two-sum-iii-data-structure-design-easy&#34;&gt;170. Two Sum III - Data structure design (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TwoSum:

    def __init__(self):
        self.stack = []
        

    def add(self, number: int) -&amp;gt; None:
        self.stack.append(number)
        

    def find(self, value: int) -&amp;gt; bool:
        dic= dict()
        for i,n in enumerate(self.stack):
            if value-n in dic:
                return True
            dic[n]=i
        return False
        


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)

class TwoSum:

    def __init__(self):
        self.dic = collections.defaultdict(list)
        self.c = 0
        

    def add(self, number: int) -&amp;gt; None:
        self.dic[number].append(self.c)
        self.c+=1
        

    def find(self, value: int) -&amp;gt; bool:
        res = False
        for key in self.dic.keys():
            if value-key == key:
                res = res or len(self.dic[key])&amp;gt;1   
            else:
                if value-key in self.dic:
                    res = res or True
        
        return res
        

&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-19</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-18/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;151-reverse-words-in-a-string-medium&#34;&gt;151. Reverse Words in a String （Medium）&lt;/h1&gt;
&lt;p&gt;Given an input string s, reverse the order of the words.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverseWords(self, s: str) -&amp;gt; str:
        if not s: return s
        #trim space
        tmp=&#39;&#39;
        while s:
            if s[0]!=&#39; &#39;:
                tmp+=s[0]
            else:
                if tmp and tmp[-1]!=&#39; &#39; :
                    tmp+=&#39; &#39;
            s=s[1:]
        
        while tmp and tmp[-1]==&#39; &#39;:
            tmp=tmp[:-1]
        
                    
        
        s = [e for e in tmp]
        print(s)
        def rev(s,i,j):
            while i&amp;lt;=j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
            return s
        #rev all
        s = rev(s,0,len(s)-1)
        
        start=0
        for i in range(len(s)):
            if s[i]==&#39; &#39;:
                s = rev(s,start,i-1)
                start=i+1
        s=rev(s,start,len(s)-1)
        
        return &#39;&#39;.join(s)
#quick way using python function
class Solution:
    def reverseWords(self, s: str) -&amp;gt; str:
        def rev(e):
            w=[i for i in e]
            return &#39;&#39;.join(w[::-1])
        s=rev(s)
        res=[]
        for e in  s.strip().split():
            res.append(rev(e))
        return &#39; &#39;.join(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;152-maximum-product-subarray-medium&#34;&gt;152. Maximum Product Subarray (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProduct(self, nums: List[int]) -&amp;gt; int:
        # dp[i][j] is max subarry product till nums[i].. nums[j]
        # dp[i][i] = nums[i]
        #  -2 -3 -4 -5 -6
        #     -3 -4 -5 -6     
        #     max_dp[i][j] = max(min_dp[i][j-1]*nums[j], max_dp[i][j-1]*nums[j], nums[j])
        #     min_dp[i][j] = min(max_dp[i][j-1]*nums[j], min_dp[i][j-1]*nums[j], nums[j])
        #  j&amp;gt;=i
        #  
        l=len(nums)
        if l==1: return nums[0]
        res = float(&#39;-inf&#39;)
        max_dp = [[float(&#39;-inf&#39;)]*l for i in range(l)]
        min_dp = [[float(&#39;inf&#39;)]*l for i in range(l)]
        for i in range(l):
            max_dp[i][i] = nums[i]
            min_dp[i][i] = nums[i]
            res = max(res,max_dp[i][i])
    
        for i in range(l):
            for j in range(l):
                if i&amp;gt;=j:continue
                max_dp[i][j] = max(min_dp[i][j-1]*nums[j], max_dp[i][j-1]*nums[j], nums[j])
                min_dp[i][j] = min(max_dp[i][j-1]*nums[j], min_dp[i][j-1]*nums[j], nums[j])
                res=max(res,max_dp[i][j]) 
        #for row in max_dp:
        #    print(row)
        #for col in min_dp:
        #    print(col)
        
        return res
# 搞定 O（n）解法
class Solution:
    def maxProduct(self, nums: List[int]) -&amp;gt; int:
        
        # max_dp[i] = maxProduct up to nums[0] ... nums[i]
        # min_dp[i] = minProduct up to nums[0] ... nums[i]
        res = float(&#39;-inf&#39;)
        l=len(nums)
        max_dp = [float(&#39;-inf&#39;)]*l
        min_dp = [float(&#39;inf&#39;)]*l
        for i in range(l):
            max_dp[i] = max(nums[i],max_dp[i-1]*nums[i],min_dp[i-1]*nums[i]) if i!=0 else nums[i]
            res = max(res,max_dp[i])
            min_dp[i] = min(nums[i],min_dp[i-1]*nums[i],max_dp[i-1]*nums[i]) if i!=0 else nums[i]
        
        #print(max_dp)
        #print(min_dp)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想了个dp 但是O(n*n)的 time limit exceeded， 所以应该有O（n）的dp解法。&lt;br&gt;
思路： 由于nums的正负符号来回变化，所以需要追踪最大乘积和最小乘积。令max_dp[i] 表示用nums【0】到nums【i】所能得到的最大乘积。 min_dp[i]表示用nums【0】到nums【i】所能得到的最大乘积。 则  max_dp[i] = max(nums[i],max_dp[i-1]*nums[i],min_dp[i-1]*nums[i]) min_dp[i] = min(nums[i],min_dp[i-1]*nums[i],max_dp[i-1]*nums[i])  由于dp【i】只与dp【i-1】有关，所以甚至能简化为O（1）space的解。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred153-find-minimum-in-rotated-sorted-array-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;153. Find Minimum in Rotated Sorted Array (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].&lt;/p&gt;
&lt;p&gt;Given the sorted rotated array nums of unique elements, return the minimum element of this array.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in O(log n) time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:
         if nums[0]&amp;gt;nums[-1]:
            #rotated
            l=0
            r=len(nums)-1
            while l &amp;lt;= r:
                m=(l+r)//2
                if nums[m] &amp;gt; nums[m+1]:
                    return nums[m+1]
                if nums[m-1] &amp;gt; nums[m]:
                    return nums[m]
                
                if nums[m] &amp;gt; nums[l]:
                    l  =m+1
                else:
                    r = m-1
                
         else:
            return nums[0]

#MY ANSWER
class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:

        if nums[0]&amp;lt;nums[-1]: return nums[0]

        l = 0
        r = len(nums)-1
        min_ = nums[0]
        while l&amp;lt;=r:
            m = (l+r)//2

            if nums[l]&amp;lt;=nums[m]:
                #left increase
                min_ = min(min_,nums[l])
                l=m+1
            
            else:
                #right incrase
                min_=min(min_,nums[m])
                r=m-1
        
        return min_


        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不应该做不出来，首先判断是不是rotated 用head，tail大小判断， 其次， 要是再中间遇到下一个或者上一个小于那就能确定最小值了， 最后如果 nums[l] &amp;lt; nums[m] 是左面递增的，所以l=m+1.&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue154-find-minimum-in-rotated-sorted-array-ii-hardfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;154. Find Minimum in Rotated Sorted Array II （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:
        l=0
        r=len(nums)-1
        res = float(&#39;inf&#39;)
        while l&amp;lt;=r:
            m=(l+r)//2

            while l&amp;lt;r and nums[l]==nums[r]:
                res = min(res,nums[l])
                l+=1
                r-=1
            
            if nums[l]&amp;lt;=nums[m]:
                #left incresase
                res = min(res,nums[l])
                l=m+1
            else:
                #right increase
                res = min(res,nums[m])
                r=m-1
        
        res = min(res,nums[l]) if len(nums)&amp;gt;l&amp;gt;=0 else res
        return res

 #MY ANSWER
class Solution:
    def findMin(self, nums: List[int]) -&amp;gt; int:

        min_ = nums[0]

        l=0
        r=len(nums)-1

        while l&amp;lt;=r:

           

            while l&amp;lt;r and nums[l]==nums[r]:
                min_=min(min_,nums[l])
                l+=1
                r-=1
            m  = (l+r)//2
            

            if nums[l]&amp;lt;=nums[m]:
                #left increase
                min_=min(min_,nums[l])
                l=m+1
            else:
                #right incraese
                min_=min(min_,nums[m])
                r=m-1            

    
        return min_
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在之前思路上多加一行判断，while left==rgiht， left+=1 right-=1. 这样在大部分case下是lg（n）最坏情况是O（n）。 有数字duplicated时候要nums[l]&amp;lt;=nums[m] 去重判断要l小于r&lt;/p&gt;
&lt;h1 id=&#34;155-min-stack-easy&#34;&gt;155. Min Stack （Easy）&lt;/h1&gt;
&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []
        

    def push(self, val: int) -&amp;gt; None:
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            self.min_stack.append(min(self.min_stack[-1],val))
        

    def pop(self) -&amp;gt; None:
        self.stack.pop()
        self.min_stack.pop()
        

    def top(self) -&amp;gt; int:
        return self.stack[-1] if self.stack else None
        

    def getMin(self) -&amp;gt; int:
        return self.min_stack[-1] if self.min_stack else None
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-156-binary-tree-upside-down-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 156. Binary Tree Upside Down (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def upsideDownBinaryTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]:
        # 层序遍历
        if not root: return root
        res = []
        queue = [root]
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur)
                if cur.left:
                    queue.append(cur.left)
                    cur.left=None
                if cur.right:
                    queue.append(cur.right)
                    cur.right=None
            res.append(level)
        
        result=res[-1][0]
        
        for j,row in enumerate(res):
            for i,node in enumerate(row):
                if j+1&amp;lt;len(res) and i*2&amp;lt;len(res[j+1]):
                    res[j+1][i*2].right=node  
                    res[j+1][i*2].left = res[j+1][i*2+1]  if   i*2+1 &amp;lt;len(res[j+1]) else None
                
        return result

#ANSWER
	def upsideDownBinaryTree(self, root: TreeNode) -&amp;gt; TreeNode:
        def recurse(node=root, parent=None, right=None):
            if not node:
                return parent
            res = recurse(node.left, node, node.right)
            node.right = parent
            node.left = right
            return res
        return recurse() 
# ANSWER
class Solution:
    def upsideDownBinaryTree(self, root: TreeNode) -&amp;gt; TreeNode:
        if not root or not root.left: return root 
        node = root.left
        ans = self.upsideDownBinaryTree(node)
        node.left = root.right
        node.right = root
        root.left = root.right = None
        return ans 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：层序遍历，然后strip left&amp;amp;right=None光剩下node。 然后重新组建链接关系。&lt;br&gt;
递归去写没写出来。。。一定是postorder。&lt;/p&gt;
&lt;h1 id=&#34;157-read-n-characters-given-read4-easy&#34;&gt;157. Read N Characters Given Read4 （Easy）&lt;/h1&gt;
&lt;p&gt;Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
The read4 API is already defined for you.

    @param buf4, a list of characters
    @return an integer
    def read4(buf4):

# Below is an example of how the read4 API can be called.
file = File(&amp;quot;abcdefghijk&amp;quot;) # File is &amp;quot;abcdefghijk&amp;quot;, initially file pointer (fp) points to &#39;a&#39;
buf4 = [&#39; &#39;] * 4 # Create buffer with enough space to store characters
read4(buf4) # read4 returns 4. Now buf = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], fp points to &#39;e&#39;
read4(buf4) # read4 returns 4. Now buf = [&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], fp points to &#39;i&#39;
read4(buf4) # read4 returns 3. Now buf = [&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,...], fp points to end of file
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def read(self, buf, n):
        &amp;quot;&amp;quot;&amp;quot;
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        &amp;quot;&amp;quot;&amp;quot;
        buf4 =[&#39; &#39; for _ in range(4)]
        c=0
        start=0
        while c&amp;lt;n:
            val=read4(buf4)
            c+=val
            if c&amp;lt;=n:
                buf[start:start+val]=buf4 
            else:
                
                buf[start:n]=buf4[:n-start] 
                return n
               
           
            start=start+val
           
            if val==0:
                break
                
        return c


class Solution:
    def read(self, buf: List[str], n: int) -&amp;gt; int:
        copied_chars = 0
        read_chars = 4
        buf4 = [&#39;&#39;] * 4
        
        while copied_chars &amp;lt; n and read_chars == 4:
            read_chars = read4(buf4)
            
            for i in range(read_chars):
                if copied_chars == n:
                    return copied_chars
                buf[copied_chars] = buf4[i]
                copied_chars += 1
        
        return copied_chars
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;158-read-n-characters-given-read4-ii-call-multiple-times-hard&#34;&gt;158. Read N Characters Given read4 II - Call Multiple Times (Hard)&lt;/h1&gt;
&lt;p&gt;Given a file and assume that you can only read the file using a given method read4, implement a method read to read n characters. Your method read may be called multiple times.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# The read4 API is already defined for you.
# def read4(buf4: List[str]) -&amp;gt; int:

class Solution:
    
   
    buf4_rem = [&#39; &#39;]*4
    n_rem=0
   
    def read(self, buf: List[str], n: int) -&amp;gt; int:
         
        start=0
        buf4=[&#39; &#39;]*4
        c=0
        while c&amp;lt;n:
            if self.n_rem&amp;gt;0:
                #have remain
                if c+self.n_rem&amp;lt;n:
                    buf[start:start+self.n_rem] = self.buf4_rem[:self.n_rem]
                    start+=self.n_rem
                    c+=self.n_rem
                    self.n_rem=0
                  
                else:
                    #c+n_rem&amp;gt;=n
                    # char needed =  n-c
                    buf[start:n] = self.buf4_rem[:n-c]
                    self.n_rem = self.n_rem - (n-c)
                    if self.n_rem&amp;gt;0:
                        self.buf4_rem = self.buf4_rem[n-c:]+[&#39; &#39;]*(4-(n-c))
                    return n
            
            else:
                 
                #n_rem==0
                nread = read4(buf4)
                if nread==0:break
                if c+nread&amp;lt;n:
                    #overwrite nead chars
                    buf[start:start+nread] = buf4[:nread]
                    start+=nread
                    c+=nread
                else:
                    #char needed n-c
                    buf[start:n]=  buf4[:n-c]
                    self.buf4_rem = buf4[n-c:] + [&#39; &#39;]*(4-(n-c))
                    self.n_rem = nread-(n-c)
                    return n
            
        
        return c

#ANSWER
class Solution:
    
    def __init__(self):
        self.deq = deque()
        
    def read(self, buf, n):
        while n &amp;gt; len(self.deq):
            a_buf = [&amp;quot;&amp;quot;] * 4
            read4(a_buf)
            self.deq.extend(a_buf)
            if not self.deq[-1]: break
        k = 0
        while self.deq and self.deq[0] and k &amp;lt; n:
            buf[k] = self.deq.popleft()
            k += 1
        return k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尼玛，这hard题目，完全是考细心不是考算法，垃圾题目。答案很简单。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred159-longest-substring-with-at-most-two-distinct-characters-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;159. Longest Substring with At Most Two Distinct Characters （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, return the length of the longest substring that contains at most two distinct characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&amp;gt; int:
        # e c e b a
        # e c e b a
        
        map_2pos = dict()
        res=1
        start=0
        for i,char in enumerate(s):
            if (char not in map_2pos) and len(map_2pos)==2:
                #do calculation
                small_k=None
                small_v=float(&#39;inf&#39;)
                for k,v in map_2pos.items():
                    if v&amp;lt;small_v:
                        small_v=v
                        small_k=k
                del map_2pos[small_k]
                start=small_v+1
                res=max(res,i-start+1)
            elif char in map_2pos and len(map_2pos)==2:
                res=max(res,i-start+1)
            elif len(map_2pos)&amp;lt;2:
                res=max(res,i-start+1)
                
            map_2pos[char]=i
        
        return res
#ANSWER
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&amp;gt; int:
        if not s: return 0
        dic = dict()
        start = 0
        res =0
        
        for i,n in enumerate(s):
            if (n not in dic and len(dic)==2):
                candi =None
                for key in dic.keys():
                    if dic[key]==min(dic.values()):
                        candi = key
                
                candi_val = dic[candi]
                del dic[candi]
                start = candi_val +1
            
            res=max(res,i-start+1)
            dic[n] = i
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： sliding window， 用dic保存char最近一次出现位置，dic保持2个元素内。 情况1： 当dic已经有2个元素，要加入不同元素，需要pop位置最小那个。然后计算。 情况2：还是在dic中相同char，只做长度更新。 情况3：dic中元素不到2，只做长度更新。&lt;/p&gt;
&lt;h1 id=&#34;160-intersection-of-two-linked-lists-easy&#34;&gt;160. Intersection of Two Linked Lists （Easy）&lt;/h1&gt;
&lt;p&gt;Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; ListNode:
        
        def length(node):
            c=0
            while node:
                c+=1
                node=node.next
            return c
        
        la=length(headA)
        lb=length(headB)
        
        if la&amp;lt;lb:
            la,lb=lb,la
            headA,headB=headB,headA
        
        # A always &amp;gt; B
        
        diff = la-lb 
        
        for i in range(diff):
            headA = headA.next
        
 
        while headA and headB:
            if headA==headB:
                return headA
            headA=headA.next
            headB=headB.next
        return None

#ANSWER
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; ListNode:
        pA = headA
        pB = headB

        while pA != pB:
            pA = headB if pA is None else pA.next
            pB = headA if pB is None else pB.next

        return pA
        
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-18</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-17/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;141-linked-list-cycle-easy&#34;&gt;141. Linked List Cycle (Easy)&lt;/h1&gt;
&lt;p&gt;Given head, the head of a linked list, determine if the linked list has a cycle in it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool:
        if not head: return False
        
        slow=head
        fast=head
        
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            
            if slow==fast:
                return True
        
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;142-linked-list-cycle-ii-medium&#34;&gt;142. Linked List Cycle II (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&amp;gt; ListNode:
        if not head: return head
        fast=slow=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if fast==slow:
                if fast==head: return head
                fast = head
                while fast:
                    fast=fast.next
                    slow=slow.next
                    if fast==slow:
                        return slow
        return None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意  if fast&lt;mark&gt;slow: 时候 if fast&lt;/mark&gt;head: return head 情况。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred143-reorder-list-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;143. Reorder List (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given the head of a singly linked-list. The list can be represented as:0 1 2 3 4 ..n, reorder as 0 n 1 n-1 2 n-2 ...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not head: return None
        if  head and head.next and not head.next.next   : return head
        if head and not head.next: return head
        
        
        cur=head
        
        tail_pre=None
        while cur.next:
            tail_pre=cur
            cur=cur.next
        tail=cur
      
        
        headnext = head.next
        tail_pre.next=None
        head.next=tail
        tail.next=self.reorderList(headnext)
        
        return head
# answer 思路 writing
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
 

        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
 
        slow=fast=head
        pre_slow=None
        while fast and fast.next:
            pre_slow=slow
            slow=slow.next
            fast=fast.next.next
        
        pre_mid = pre_slow
        mid=slow
         
        odd_head = rev(mid)
     
        #merge two
        first, second = head, odd_head
        while second.next:
            tmp=first.next
            first.next=second
            first=tmp
            
            tmp=second.next
            second.next=first
            second=tmp


# using Stack, odd/even is solved by len(stack)//2
 class Solution:
    def reorderList(self, head: Optional[ListNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify head in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not head: return

        stack = []
        cur =head
        while cur:
            stack.append(cur)
            cur =cur.next
        
        cur = head
        for i in range(len(stack)//2):
            next = cur.next
            endnode = stack.pop()
            cur.next =  endnode
            endnode.next = next
            cur = next
        
        cur.next = None
                   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次尝试，time limit exceeded，base case： node为空，2个node，一个node情况。 然后暴力求解即可.T（n）= T（n-2）+1 所以时间复杂度 1+2+3.。。+n = O（n*n）&lt;br&gt;
第二次尝试放弃了， 思路： 找到mid， rev（mid）， merge 2个list。&lt;/p&gt;
&lt;h1 id=&#34;144-binary-tree-preorder-traversal-easy&#34;&gt;144. Binary Tree Preorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def pre(root):
            if not root: return
            res.append(root.val)
            pre(root.left)
            pre(root.right)
        pre(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        stack = []
        while stack or root:
            while root:
                res.append(root.val)
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            root=node.right
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;145-binary-tree-postorder-traversal-easy&#34;&gt;145. Binary Tree Postorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        res=[]
        def post(root):
            if not root:return
            post(root.left)
            post(root.right)
            res.append(root.val)
        post(root)
        return res
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        if not root:
            return []
        
        stack=[]
        result=[]
        
        stack.append(root)

        while stack:
            
            cur=stack.pop()
            result.append(cur.val)
            
            if cur.left:
                stack.append(cur.left)
                
            if cur.right:
                stack.append(cur.right)
                
        return result[::-1]

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:

        res = []
        stack = []
        while root or stack:
            while root:
                stack.append(root)
                res.append(root.val)
                root =root.right
            
            root = stack.pop()
            root =root.left
        
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左右子树颠倒的前序遍历取反向就是正常树的后序遍历。&lt;/p&gt;
&lt;h1 id=&#34;146-lru-cache-medium&#34;&gt;146. LRU Cache （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Node:
    def __init__(self,key,val,next=None,pre=None):
        self.key=key
        self.val=val
        self.next=next
        self.pre=pre
        
class LRUCache:

    def __init__(self, capacity: int):
        self.cap = capacity
        self.n=0
        self.map_key_node=dict()
        self.head = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.tail = Node(key=&#39;NULL&#39;,val=&#39;NULL&#39;)
        self.head.next = self.tail
        self.tail.pre = self.head
    
    def debug(self,disable=True):
        if not disable:
            cur=self.head
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.next
            print(&#39;,&#39;.join(tmp))
            cur=self.tail
            tmp=[]
            while cur:
                tmp.append(&#39;(&#39;+str(cur.key)+&#39;,&#39;+str(cur.val)+&#39;)&#39;)
                cur=cur.pre
            print(&#39;,&#39;.join(tmp[::-1]))

    def get(self, key: int) -&amp;gt; int:
        print(&#39;get&#39;,key)
        if key in self.map_key_node:
            #pop from linked list
            node = self.map_key_node[key]
            node.pre.next=node.next
            node.next.pre = node.pre
            #add from head
            headnext=self.head.next
            node.pre= self.head
            self.head.next=node
            node.next=headnext
            headnext.pre=node
            
            self.debug()
            return self.map_key_node[key].val
        else:
            self.debug()
            return -1
        

    def put(self, key: int, value: int) -&amp;gt; None:
        print(&#39;put&#39;,key,value)
        if key in self.map_key_node:
            #if key in cache, update value &amp;amp; move to top of linked list
            self.map_key_node[key].val=value
            
            self.get(key) 
            
        else:
            #add key-val pair to cache
            self.map_key_node[key]= Node(key=key,val=value)
            self.n = self.n+1
            if self.n &amp;gt; self.cap:
                # evict least recently used key
                # pop from tail
                to_be_del = self.tail.pre
                to_be_del.pre.next= self.tail
                self.tail.pre= to_be_del.pre
                del self.map_key_node[to_be_del.key]
                #add from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                headnext.pre=self.map_key_node[key]
                self.map_key_node[key].next=headnext
                #update n
                self.n = self.n-1
            else:
                #put &amp;lt;=cap append from head
                headnext = self.head.next
                self.head.next=self.map_key_node[key]
                self.map_key_node[key].pre=self.head
                
                headnext.pre = self.map_key_node[key]
                self.map_key_node[key].next=headnext
                
        self.debug()
                
        
        
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

# double directed linkedlist
# dict   key-&amp;gt; Node   (put get update value)
#  put 
#  &amp;lt;= cap just append to linked from head.     head new old1 old2..
# &amp;gt; cap pop from tail   put from head
# get pop() then put to head

class Node:
    def __init__(self,key, val,next=None,pre=None):
        self.val =val
        self.next =next
        self.pre = pre
        self.key = key

class LRUCache:
    def __init__(self, capacity: int):
        self.cap  = capacity
        self.n = 0
        self.map = dict() #based on key find the node
        self.head = Node(&#39;HEAD&#39;,&amp;quot;HEAD&amp;quot;)
        self.tail = Node(&#39;TAIL&#39;,&amp;quot;TAIL&amp;quot;)
        self.head.next = self.tail
        self.tail.pre = self.head
    
    def put2head(self,node):
        headnext = self.head.next
        self.head.next = node
        node.pre = self.head
        headnext.pre =node
        node.next =headnext
        
    def get(self, key: int) -&amp;gt; int:
        if key in self.map:
            node = self.map[key]
            node.pre.next = node.next
            node.next.pre = node.pre
            self.put2head(node)
            return node.val
        else:
            return -1


    def remove_lru(self):
        node = self.tail.pre
        node.pre.next = self.tail
        self.tail.pre = node.pre
        del self.map[node.key]
       

    def put(self, key: int, value: int) -&amp;gt; None:
        if key in self.map:
            self.map[key].val = value
            self.get(key)
        else:
            self.map[key] = Node(key,value)
            self.n+=1    
            if self.n&amp;gt;self.cap:
                self.remove_lru()
                self.n-=1        
            
            self.put2head(self.map[key])
           
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： double linked list + map     get：首先pop from linked list 然后 add 到head下一位。   put： 如果小于等于cap，从head开始append，如果大于cap， pop tail 然后add from head。&lt;/p&gt;
&lt;h1 id=&#34;147-insertion-sort-list-medium&#34;&gt;147. Insertion Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&#39;s head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
       
        
        def insert(node):
            
            pre=None
            cur=head_sorted.next
            FLAG=False
            while cur:
                #    6 1
                if (pre and node.val&amp;lt;=cur.val and node.val&amp;gt;=pre.val) or (pre is None and cur.val&amp;gt;=node.val):
                    #do insert
                    if pre is None:
                        #insert after head_sorted
                        head_sorted_next=head_sorted.next
                        head_sorted.next=node
                        node.next= head_sorted_next
                    else:
                        #normal insertion
                        pre.next=node
                        node.next=cur
                    #after insertion break
                    FLAG=True
                    break
                
                pre=cur
                cur=cur.next
            
            if not FLAG:
                pre.next = node
            
        
        cur=head.next
        head.next=None
        head_sorted = ListNode(val=&#39;NULL&#39;,next=head)
        while cur:
            curnext = cur.next
            cur.next=None
            insert(cur)
            cur=curnext
        
        return head_sorted.next

#ANSWER
class Solution:
    def insertionSortList(self, head: ListNode) -&amp;gt; ListNode:
        dummy = ListNode()
        curr = head

        while curr:
            # At each iteration, we insert an element into the resulting list.
            prev = dummy

            # find the position to insert the current node
            while prev.next and prev.next.val &amp;lt;= curr.val:
                prev = prev.next

            next = curr.next
            # insert the current node to the new list
            curr.next = prev.next
            prev.next = curr

            # moving on to the next iteration
            curr = next

        return dummy.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没啥难的，就是细心。 答案很优美。&lt;/p&gt;
&lt;h1 id=&#34;148-sort-list-medium&#34;&gt;148. Sort List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, return the list after sorting it in ascending order.&lt;br&gt;
Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        # nlogn compare method
        # O(1) space
        # merge sort
        
        def merge(l1,l2):
            #print(&#39;l1&#39;)
            #print(l1)
            #print(&#39;l2&#39;)
            #print(l2)
            dummy_head = ListNode(val=&#39;NULL&#39;)
            cur=dummy_head
            while l1 and l2:
                if l1.val&amp;lt;l2.val:
                    cur.next=l1
                    l1=l1.next if l1 else None
                else:
                    cur.next=l2
                    l2=l2.next if l2 else None
                
                cur=cur.next
                
            if l1:
                cur.next=l1
            if l2:
                cur.next=l2
            #print(&#39;res&#39;)
            #print(dummy_head.next)
            return dummy_head.next
        
        def sort(head):
            if (not head) or (not head.next): return head
            slow=fast=head
            pre=None
            while fast and fast.next:
                pre=slow
                slow=slow.next
                fast=fast.next.next
                
            
            pre.next=None
            mid =slow
         
            l1=sort(mid) 
            l2=sort(head)
          
            return merge(l1,l2)
        
        return sort(head)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;149-max-points-on-a-line-hard&#34;&gt;149. Max Points on a Line (Hard)&lt;/h1&gt;
&lt;p&gt;Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxPoints(self, points: List[List[int]]) -&amp;gt; int:
        # p1 [x, ax+b]
        # p2 [x&#39;,ax&#39;+b]     
        # y1=ax1+b
        # y2=ax2+b
        #   y1-y2=a(x1-x2)
        # a = y1-y2/x1-x2
        # b = y-ax
        dic = collections.defaultdict(set)
        n = len(points)
        if n==1: return 1
        for i in range(n-1):
            for j in range(i+1,n):
                p1=points[i]
                p2=points[j]
                a=(p1[1]-p2[1])/(p1[0]-p2[0]) if p1[0]!=p2[0] else None
                b = p1[1]-a*p1[0] if a is not None else None
                if a is not None:
                    key = str(a)+&#39;-&#39;+str(b)
                else:
                    key = &#39;x=constant&#39;+str(p1[0]) 
                dic[key].add(i)
                dic[key].add(j)
        #print(dic)
        return max(map(len,dic.values()))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;150-evaluate-reverse-polish-notation-medium&#34;&gt;150. Evaluate Reverse Polish Notation (Medium)&lt;/h1&gt;
&lt;p&gt;Input: tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;]&lt;br&gt;
Output: 9&lt;br&gt;
Explanation: ((2 + 1) * 3) = 9&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def evalRPN(self, tokens: List[str]) -&amp;gt; int:
        numstack = []
        for t in tokens:
            if t in &#39;+-*/&#39;:
                #op
            
                num2=numstack.pop()
                num1=numstack.pop()
                print(t,num1,num2,end=&#39;  # &#39;)
                if t==&#39;+&#39;:
                    numstack.append(num1+num2)
                elif t==&#39;-&#39;:
                    numstack.append(num1-num2)
                elif t==&#39;*&#39;:
                    numstack.append(num1*num2)
                elif t==&#39;/&#39;:
                    numstack.append(int(num1/num2) )
                else:
                    print(error)
                #print(numstack[-1])
            else:
                numstack.append(int(t))
         
        #print(numstack)
        return numstack[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 int(num1/num2)，  int(1.8)=1 int(-1.8)=-1  但是  -2/1.1=-1.8181818181818181     -2//1.1=-2  取整后会更偏小，但是对负数希望的是偏大。对正数希望的是抹去小数偏小。 所以只能取int。&lt;/p&gt;
">Leetcode 2021-11-17</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-16/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue131-palindrome-partitioning-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;131. Palindrome Partitioning (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.&lt;br&gt;
A palindrome string is a string that reads the same backward as forward.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def partition(self, s: str) -&amp;gt; List[List[str]]:
        if len(s)==1:
            return [[s]]
        res = []
        for i in range(1,len(s)):
            head = s[:i]
            tail = s[i:]
          
            if [e for e in head]==[e for e in head][::-1]:
                for rest in self.partition(tail):
                    res.append([head]+rest)
        #check total
        if [e for e in s ]==[e for e in s][::-1]:
            res.append([s])
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;132-palindrome-partitioning-ii-hard&#34;&gt;132. Palindrome Partitioning II （Hard）&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;br&gt;
Return the minimum cuts needed for a palindrome partitioning of s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minCut(self, s: str) -&amp;gt; int:
        # find all possible palindrome then return 
        mem = dict()
        def palindrom(s):
            if s in mem: return mem[s]
            if len(s)==1:
                return [[s]]
            res = []
            for i in range(1,len(s)):
                head=s[:i]
                tail=s[i:]
                if [e for e in head]==[e for e in head][::-1]:
                    for rest in palindrom(tail):
                        res.append([head]+rest)
            #final test on whole string
            if [e for e in s]==[e for e in s][::-1]:
                res.append([s])
            mem[s]=res
            return res
        
        res = palindrom(s)
        mincut=float(&#39;inf&#39;)
        for row in res:
            mincut=min(mincut,len(row)-1)
        return mincut
               
#answer way of DP
class Solution:
    def minCut(self, s: str) -&amp;gt; int:
        
        if not s or len(s)==1: return 0
        
        dp=[i for i in range(len(s))]
        
        # 0...ith char cut 
        for mid in range(1,len(s)):
            #case 1 odd len center is at index mid
            start=mid
            end=mid
            while start&amp;gt;=0 and end&amp;lt;len(s) and s[start]==s[end]:
                newcutatend=0 if start==0 else dp[start-1]+1
                dp[end]=min(dp[end],newcutatend)
                start-=1
                end+=1
             
            #case 2  even len center is between mid-1,mid
            start=mid-1
            end=mid
            while start&amp;gt;=0 and end&amp;lt;len(s) and s[start]==s[end]:
                newcutatend=0 if start==0 else dp[start-1]+1
                dp[end]=min(dp[end],newcutatend)
                start-=1
                end+=1
               
            
        return dp[len(s)-1]

class Solution:
    @lru_cache(None)
    def minCut(self, s: str) -&amp;gt; int:

        res = len(s)-1
        for i in range(1,len(s)):
            head = s[:i]
            tail = s[i:]
            if head==head[::-1]:
                res = min(res, 1+self.minCut(tail))
        if s==s[::-1]:res = 0
        return res
                    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接产生出full list 来计算time limit exceeded。即使加了mem都不行。所以得调整思路。BT无法解决，感觉像DP问题。但没思路。&lt;br&gt;
思路：string expansion+DP  , OR RECURSION&lt;br&gt;
string可以从mid的位置做expansion，但odd/even长度expansion初始情况不同， odd时候 start=mid end=mid， enven时候 start=mid-1 end=mid, 定义dp【i】为在0~i包含i位置的string minCut。 则 dp【end】=min（dp【end】，dp【start-1】+1），注意边界情况，如果start==0， dp【end】=dp【end】。&lt;/p&gt;
&lt;h1 id=&#34;133-clone-graph-medium&#34;&gt;133. Clone Graph （Medium）&lt;/h1&gt;
&lt;p&gt;Given a reference of a node in a connected undirected graph.&lt;br&gt;
Return a deep copy (clone) of the graph.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def cloneGraph(self, node: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        if not node: return node
        
        visited=set()
        map_old2new = dict()
        
        #clone node only
        def walk(node):
            visited.add(node)
            #clone node without neighbors
            new_node = Node(node.val)
            map_old2new[node]=new_node
            for nei in node.neighbors:
                if nei not in visited:
                    walk(nei)
        
        walk(node)
        
        #clone neighbors
        visited=set()
        def walk_nei(node):
            visited.add(node)
            #clone new_node neighbors
            map_old2new[node].neighbors = [map_old2new[nei] for nei in node.neighbors]
            for nei in node.neighbors:
                if nei not in visited:
                    walk_nei(nei)
        
        walk_nei(node)
        
        return map_old2new[node]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue134-gas-station-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt;134. Gas Station (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].&lt;br&gt;
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.&lt;br&gt;
Given two integer arrays gas and cost, return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique&lt;br&gt;
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]&lt;br&gt;
Output: 3&lt;br&gt;
Explanation:&lt;br&gt;
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4&lt;br&gt;
Travel to station 4. Your tank = 4 - 1 + 5 = 8&lt;br&gt;
Travel to station 0. Your tank = 8 - 2 + 1 = 7&lt;br&gt;
Travel to station 1. Your tank = 7 - 3 + 2 = 6&lt;br&gt;
Travel to station 2. Your tank = 6 - 4 + 3 = 5&lt;br&gt;
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.&lt;br&gt;
Therefore, return 3 as the starting index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#TLE 用了for break else ...
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int:

    
        for start in range(len(gas)):
            cur = 0
            for i in range(start,start+len(gas)):
                i=i%len(gas)
                cur+=gas[i]
                cur-=cost[i]
                if cur&amp;lt;0:
                    break
            else:
                return start
        
        return -1
            

class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int:
        
        #gas = [1,2,3,4,5], cost = [3,4,5,1,2]
        #Start at station 2 (index 2) and fill up with 3 unit of gas. Your tank = 0 + 3 = 3
        #Travel to station 3. Your tank = 3 - 5 + 4 = 2
        #Travel to station 4. Your tank = 2 - 1 + 5 = 6
        #Travel to station 0. Your tank = 6 - 2 + 1 = 5
        #Travel to station 1. Your tank = 5 - 3 + 2 = 4
        #Travel to station 2. Your tank = 4 - 4 + 3 = 3
        
 
     
        length=len(gas)
       
        for start_pos in range(length):
            my_tank=gas[start_pos]
            cur_pos = start_pos
            i=0
            #print(&#39;start_pos{} mytank {}&#39;.format(start_pos,my_tank))
            while i&amp;lt;=length:
                i+=1
                travel_to = (cur_pos+1)%length
                my_tank=my_tank-cost[cur_pos]
                if my_tank&amp;lt;=0:
                    if my_tank==0 and i&amp;gt;0 and travel_to==start_pos: return start_pos
                    break
                my_tank+=gas[travel_to]
                #print(&#39;travel to {} mytank {}&#39;.format(travel_to,my_tank))
              
                cur_pos=travel_to
                if cur_pos==start_pos:
                    return start_pos
                         
  
        return -1

#answer way of writting
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int:
        
        n=len(gas)
        total_tank=cur_tank=0
        starting_station=0
        for i in range(n):
            total_tank += gas[i]-cost[i]
            cur_tank+=gas[i]-cost[i]
            if cur_tank&amp;lt;0:
                starting_station=i+1
                cur_tank=0
        
        if total_tank&amp;gt;=0:
            return starting_station
        return -1
            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心，做判断时候， my_tank - cost[cur_pos] 如果小于0要break的， 只有确认可以到 travel_to时候才能my_tank += gas[traval_to] 但是显然是O（n*n）时间复杂度。 答案是O（N）。思路： 记录total_tank 和 cur_tank, 如果total_tank 小于0 或者cur_tank 小于0都不能成环路。 如果cur_tank 小于0，说明起始点有问题， start_station=i+1 cur_tank=0.&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-135-candy-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 135. Candy (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.&lt;/p&gt;
&lt;p&gt;You are giving candies to these children subjected to the following requirements:&lt;br&gt;
Each child must have at least one candy.&lt;br&gt;
Children with a higher rating get more candies than their neighbors.&lt;br&gt;
Return the minimum number of candies you need to have to distribute the candies to the children.&lt;br&gt;
Input: ratings = [1,0,2]&lt;br&gt;
Output: 5&lt;br&gt;
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        #[1,0,2]
        # 1 1 1
        # 2 1 2
        
        #[1,2,2]
        # 1 1 1
        # 1 2 1
        
        res = [1]*len(ratings)
        
        hasChanged = True
        while hasChanged:
            hasChanged = False
            for i in range(len(ratings)):
                neigh_left_rating = ratings[i-1] if i-1&amp;gt;=0 else None
                neigh_right_rating = ratings[i+1] if i+1&amp;lt;len(ratings) else None
                if neigh_left_rating is not None and ratings[i]&amp;gt;neigh_left_rating and res[i]&amp;lt;=res[i-1]:
                    hasChanged=True
                    res[i] = res[i-1]+1

                if  neigh_right_rating is not None and ratings[i]&amp;gt;neigh_right_rating and res[i+1] &amp;gt;= res[i]:
                    hasChanged=True
                    res[i] = res[i+1]+1
       
        print(res)
        return sum(res)

#answer way of writting 1）Using two arrays 
class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        
        left2right = [1]*len(ratings)
        right2left = [1]*len(ratings)
        for i in range(1,len(ratings)):
            if ratings[i] &amp;gt; ratings[i - 1]:
                left2right[i] = left2right[i - 1] + 1
            
        for i in range(len(ratings)-2,-1,-1):
            if ratings[i] &amp;gt; ratings[i + 1]:
                right2left[i] = right2left[i + 1] + 1;
        
        res = 0
        for i in range(len(ratings)):
            res+=max( left2right[i], right2left[i]) 
        
        return res

# answer way of writting： Using one array
class Solution:
    def candy(self, ratings: List[int]) -&amp;gt; int:
        
        candies = [1]*len(ratings)
        for i in range(1,len(ratings)):
            if ratings[i] &amp;gt; ratings[i - 1]:  
                candies[i] = candies[i - 1] + 1
          
        sum = candies[-1]
        
        for i in range(len(ratings)-2,-1,-1):
            if  ratings[i] &amp;gt; ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
            
            sum += candies[i];
        
        return sum 
    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hard题目果然有坑，直接做会遇到更新candy数目之后发现之前的res违反了rules 还需要回溯更新。而且即使是brutal force也只写对了一半，没想到用hasChanged Flag，以为过一次就已经得到解了。  O（n）方法  感觉是用stack。但感觉不正确。应该用拆分方法。    答案思路：   1）Using two arrays ：把一个复杂问题分割成2个小问题，单从左向右扫， 做更新使其满足左侧限制，让后从右向左扫。 使其满足右侧条件。最后结果必须满足左右条件，所以取max即可。2）Using one array：  思路和法1相同。&lt;/p&gt;
&lt;h1 id=&#34;136-single-number-easy&#34;&gt;136. Single Number （Easy）&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.&lt;br&gt;
You must implement a solution with a linear runtime complexity and use only constant extra space.&lt;br&gt;
Input: nums = [2,2,1]&lt;br&gt;
Output: 1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        res = 0
        for n in nums:
            res = res^n
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;137-single-number-ii-medium&#34;&gt;137. Single Number II (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.&lt;br&gt;
You must implement a solution with a linear runtime complexity and use only constant extra space.&lt;br&gt;
Input: nums = [2,2,3,2]&lt;br&gt;
Output: 3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        seen_once = seen_twice = 0
        
        for num in nums:
            # first appearance: 
            # add num to seen_once 
            # don&#39;t add to seen_twice because of presence in seen_once
            
            # second appearance: 
            # remove num from seen_once 
            # add num to seen_twice
            
            # third appearance: 
            # don&#39;t add to seen_once because of presence in seen_twice
            # remove num from seen_twice
            seen_once = ~seen_twice &amp;amp; (seen_once ^ num)
            seen_twice = ~seen_once &amp;amp; (seen_twice ^ num)

        return seen_once
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O1 mem On time 木有思路,要是用set 会violate use only constant extra space. 答案是bit manipulation。&lt;/p&gt;
&lt;h1 id=&#34;138-copy-list-with-random-pointer-medium&#34;&gt;138. Copy List with Random Pointer （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        if not head: return head
        map_old2new = dict()
        # just copy node without random 
        cur=head
        while cur:
            map_old2new[cur] = Node(x=cur.val)
            cur=cur.next
        
        # copy random and next pointers
        cur=head
        while cur:
            map_old2new[cur].next = map_old2new.get(cur.next,None)
            map_old2new[cur].random = map_old2new.get(cur.random,None)
            cur=cur.next
        
        return map_old2new[head]

class Solution:
    def copyRandomList(self, head: &#39;Optional[Node]&#39;) -&amp;gt; &#39;Optional[Node]&#39;:

        #copy node

        cur = head
        while cur:
            curnext = cur.next
            cur.next = Node(cur.val)
            cur.next.next=curnext
            cur=curnext
        
    
        #assign random
        cur = head
        while cur:
            curnextnext = cur.next.next
            cur.next.random = cur.random.next if cur.random else None
            cur=curnextnext

        #delink
        cur=head
        res= head.next if head else None
        #1-1&#39;-2-2&#39;-3-3&#39;...
        while cur:
            curnext = cur.next
            cur.next = cur.next.next if cur.next else None
            cur = curnext
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;139-word-break-medium&#34;&gt;139. Word Break (Medium)&lt;/h1&gt;
&lt;p&gt;Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:

    def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool:
       
        mem=dict()
        def helper(s,wordDict):
            if not s: return True
            if s in mem: return mem[s]
            res = False
            for word in wordDict:
                l=len(word)
                if s[:l] == word:
                    res = res or helper(s[l:],wordDict)

            mem[s]=res
            return res
        
        return helper(s,wordDict)
#answer way of writting
class Solution(object):
    def wordBreak(self, s, wordDict):
        &amp;quot;&amp;quot;&amp;quot;
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        
        
        dp[i]= dp[j] and s[j:i] in dic    j&amp;lt;i
        
        &amp;quot;&amp;quot;&amp;quot;
        dp=[False]*(len(s)+1)
        se=set(wordDict)
        
        for i in range(1,len(s)+1):
            dp[i]=(s[:i] in se)
            for j in range(i):
                if dp[j]:
                    dp[i]=dp[i] or (s[j:i] in se)
        #print(dp)
        return dp[-1]


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了recursion+mem ，答案dp，异曲同工。&lt;/p&gt;
&lt;h1 id=&#34;140-word-break-ii-hard&#34;&gt;140. Word Break II （Hard）&lt;/h1&gt;
&lt;p&gt;Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.&lt;br&gt;
Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;,&amp;quot;cats&amp;quot;,&amp;quot;and&amp;quot;,&amp;quot;sand&amp;quot;,&amp;quot;dog&amp;quot;]&lt;br&gt;
Output: [&amp;quot;cats and dog&amp;quot;,&amp;quot;cat sand dog&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]:
        
        
        def helper(s,wordDict):
            res = []
            for word in set(wordDict):
                l=len(word)
                if s[:l] in set(wordDict):
                    head = s[:l]
                    tail = s[l:]
                    if not tail:
                        res.append([head])
                    else:
                        for rest in helper(tail,wordDict):
                            res.append([head]+rest)
            return res
        
        res = set()
        for row in  helper(s,wordDict):
            res.add(&#39; &#39;.join(row))
        return list(res)

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]:
        
        result = []
     
        def helper(s,tmp):
            if not s: result.append(tmp[:])
            

            for word in wordDict:
                temp = tmp[:]
                l=len(word)
                if s[:l]==word:
                    temp.append(s[:l])
                    ss=s[l:]
                    helper(ss,temp)
             
        helper(s,[])
        return [&#39; &#39;.join(li) for li in result]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;just backtracking.&lt;/p&gt;
">Leetcode 2021-11-16</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-15/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;121-best-time-to-buy-and-sell-stock-easy&#34;&gt;121. Best Time to Buy and Sell Stock (Easy)&lt;/h1&gt;
&lt;p&gt;You are given an array prices where prices[i] is the price of a given stock on the ith day.&lt;br&gt;
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.&lt;br&gt;
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        #two pointer
        profit = 0
        min_price = float(&#39;inf&#39;)
        for i,n in enumerate(prices):
            min_price= min(min_price,n)
            profit=max(profit,n-min_price)
        return profit
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;122-best-time-to-buy-and-sell-stock-ii-medium&#34;&gt;122. Best Time to Buy and Sell Stock II (Medium)&lt;/h1&gt;
&lt;p&gt;On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.&lt;br&gt;
Find and return the maximum profit you can achieve.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        # this means I can accumulate every increase trend in fluctuation of price
        if len(prices)&amp;lt;=1: return 0
        profit=0
        for i in range(1,len(prices)):
            profit_i = prices[i]-prices[i-1]
            if profit_i&amp;gt;0:
                profit+=profit_i
        return profit
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;123-best-time-to-buy-and-sell-stock-iii-hard&#34;&gt;123. Best Time to Buy and Sell Stock III (Hard)&lt;/h1&gt;
&lt;p&gt;Find the maximum profit you can achieve. You may complete at most two transactions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int]) -&amp;gt; int:
        
        min_=[float(&#39;inf&#39;)]*3
        r=[0]*3
        
        for i in range(len(prices)):
            for k in range(1,3):
                min_[k]=min(min_[k],prices[i]-r[k-1])
                r[k]=max(r[k],prices[i]-min_[k])
        
        return r[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一感觉是用Dynamic Programming。但是没想出来递推关系。。。Two pointer 的扩展， 求第二次min的时候是price[i]-第一次profit， 因为算第二次profit时候会用price[j] - (price[i]-第一次profit) 所以正好加上了第一次profit。比较巧妙。。&lt;/p&gt;
&lt;h1 id=&#34;124-binary-tree-maximum-path-sum-hard&#34;&gt;124. Binary Tree Maximum Path Sum （Hard）&lt;/h1&gt;
&lt;p&gt;A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.&lt;br&gt;
The path sum of a path is the sum of the node&#39;s values in the path.&lt;br&gt;
Given the root of a binary tree, return the maximum path sum of any non-empty path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        def max_gain(node):
            nonlocal max_sum
            if not node:
                return 0

            # max sum on the left and right sub-trees of node
            left_gain = max(max_gain(node.left), 0)
            right_gain = max(max_gain(node.right), 0)
            
            # the price to start a new path where `node` is a highest node
            price_newpath = node.val + left_gain + right_gain
            
            # update max_sum if it&#39;s better to start a new path
            max_sum = max(max_sum, price_newpath)
        
            # for recursion :
            # return the max gain if continue the same path
            return node.val + max(left_gain, right_gain)
   
        max_sum = float(&#39;-inf&#39;)
        max_gain(root)
        return max_sum

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        res = float(&#39;-inf&#39;)
        def helper(root):
            &#39;&#39;&#39;
            return the path sum up to the root
            &#39;&#39;&#39;
            nonlocal res
            if not root: return 0
            left = helper(root.left)
            right = helper(root.right)
            res = max([res,root.val+left+right,root.val+left,root.val+right,root.val])
            return max(root.val,root.val+max(left,right))
        helper(root)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fail to writing a working recursive solution!....问题出在recursion的return部分。&lt;br&gt;
思路：  local_max_sum = root.val + leftpath+rightpath  但在return时候，由于之前调用自己计算root.left 的leftpath和root.right的rightpath，所以是root.val+max(leftpath,rightpath) 这样return的路径是从root.left/root.right 单点延申出去的。不存在重复计算问题， 要是return  root.val+ leftpath+rightpath， 那么调用自己在root.left计算的是root.left的左右扩展了， 而不是 root.left 的单一延申。  这样返回值会错误。&lt;/p&gt;
&lt;h1 id=&#34;125-valid-palindrome-easy&#34;&gt;125. Valid Palindrome （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPalindrome(self, s: str) -&amp;gt; bool:
        l=0
        r=len(s)-1
        s=s.lower()
        while l&amp;lt;=r:
            while l&amp;lt;=r and s[l] not in &#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;:
                l+=1
            while l&amp;lt;=r and s[r] not in &#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;:
                r-=1
            
            if l&amp;lt;=r and s[l]!=s[r]:
                return False
            
            l+=1
            r-=1
        
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意while l&amp;lt;=r的判断。。。即使在内循环中。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred126-word-ladder-ii-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;126. Word Ladder II （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#answer way of writting
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; List[List[str]]:
        # sortest path, graph bfs 
        # node is word
        # node neighbors are word differ by 1 letter in wordList.
        # find sortest path from beginWordd to endWord
        tree=collections.defaultdict(set)
        words = set(wordList)
        if endWord not in words:
            return []
        starts = {beginWord}
        ends = {endWord}
        rev=False
        FOUND=False
        
        while starts and not FOUND:
            
            words -= starts
            next_words = set()
            for word in starts:
                for i in range(len(word)):
                    left = word[:i]
                    right = word[i+1:]
                    for char in string.ascii_lowercase:
                        next_word = left + char + right
                        if next_word in words:
                            if next_word in ends:
                                FOUND= True
                            else:
                                next_words.add(next_word)
                            
                            tree[word].add(next_word) if not rev else tree[next_word].add(word)
            starts = next_words
            if len(starts) &amp;gt; len(ends):
                starts, ends = ends, starts
                rev=not rev
        
        def bt(x):
            if x==endWord:
                return [[x]]
            else:
                res = []
                for y in tree[x]:
                    for rest in bt(y):
                        res.append([x]+rest)
                return res
      
        return bt(beginWord)
        


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整出来一个写的巨丑但还算正确的time limit exceeded解决方法,思路应该是graph bfs 找最短路径。&lt;br&gt;
答案思路很巧妙， 用了bfs但是是从2端查找，缩小了时间。 然后通过collections.defaultdict(set)记录下一个节点。最后通过backtracking 得到结果。果然是hard 题目。&lt;/p&gt;
&lt;h1 id=&#34;127-word-ladder-hard&#34;&gt;127. Word Ladder （Hard）&lt;/h1&gt;
&lt;p&gt;A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; ... -&amp;gt; sk such that:&lt;br&gt;
Every adjacent pair of words differs by a single letter.&lt;br&gt;
Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList.&lt;br&gt;
sk == endWord&lt;br&gt;
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; int:
        
      
        visited =set()
        
        def neigh(word, wordList):
            nei = []
            for w in wordList:
                if w not in visited:
                    valid = 0
                    for a,b in zip(w,word):
                        if ord(a)^ord(b)==0:
                            continue
                        else:
                            valid+=1
                    if valid==1:
                        nei.append(w)
            return nei
        
        queue = [beginWord]
        res = []
        Found=False
        level=0
        while queue:
            level += 1
            for i in range(len(queue)):
                cur = queue.pop(0)
                if cur==endWord:
                    Found=True
                    return level
                if Found:
                    break
                
                visited.add(cur)
                
                for w in neigh(cur,wordList):
                    queue.append(w)
            if Found:
                break
        return 0

#answer way of writring
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; int:
        
        words = set(wordList)
        if endWord not in words:
            return 0
        starts = {beginWord}
        ends = {endWord}
        level = 1
        # charSet = {w for word in wordList for w in word}
        while starts:
            level += 1
            words -= starts
            next_words = set()
            for word in starts:
                for i in range(len(word)):
                    left = word[:i]
                    right = word[i+1:]
                    for char in string.ascii_lowercase:
                        next_word = left + char + right
                        if next_word in words:
                            if next_word in ends:
                                return level
                            next_words.add(next_word)
            starts = next_words
            if len(starts) &amp;gt; len(ends):
                starts, ends = ends, starts
        return 0 
# bfs 1 direction
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&amp;gt; int:

        begins = {beginWord}
        Found = False
        if endWord not in wordList: return 0
        wl = set(wordList)
        c=1
        while begins and not Found:
            c+=1
            wl-=begins
            next_begins = set()
            for word in begins:
                for i in range(len(word)):
                    for ch in string.ascii_lowercase:
                        nei = word[:i] +ch + word[i+1:]
                        if nei in wl:
                            if nei==endWord:
                                return c
                            next_begins.add(nei)
            begins = next_begins
        
        return 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单复用之前代码还是会得到time limit exceeded，因为bfs不是2头扫的。但2头扫bfs 怎么写？？&lt;/p&gt;
&lt;h1 id=&#34;font-colorred128-longest-consecutive-sequence-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;128. Longest Consecutive Sequence （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&lt;br&gt;
You must write an algorithm that runs in O(n) time.&lt;br&gt;
Input: nums = [100,4,200,1,3,2]&lt;br&gt;
Output: 4&lt;br&gt;
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestConsecutive(self, nums: List[int]) -&amp;gt; int:
        
        res=0
        nums=set(nums)
        
        for num in nums:
            if num-1 not in nums:
                cur=num
                cres=1
                
                while cur+1 in nums:
                    cur+=1
                    cres+=1
                    
                res=max(res,cres)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O（n）没思路。。。 看到答案后。。。大悟。  用了set，这样 num-1 not in nums时候知道当前值为开头。 如果当前值+1还在nums里。 更新当前值和局部最大值。  扫一次，虽然右内部while loop但还是O（n）&lt;/p&gt;
&lt;h1 id=&#34;129-sum-root-to-leaf-numbers-medium&#34;&gt;129. Sum Root to Leaf Numbers (Medium)&lt;/h1&gt;
&lt;p&gt;Input: root = [1,2,3]&lt;br&gt;
Output: 25&lt;br&gt;
Explanation:&lt;br&gt;
The root-to-leaf path 1-&amp;gt;2 represents the number 12.&lt;br&gt;
The root-to-leaf path 1-&amp;gt;3 represents the number 13.&lt;br&gt;
Therefore, sum = 12 + 13 = 25.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -&amp;gt; int:
        
        res = 0
        def calc(root,tmp):
            nonlocal res
            if not root: return
            if not root.left and not root.right:
                #I am leaf do calculatoin and the sum
                res +=  tmp*10+root.val
            
            tmp = tmp*10+root.val
            calc(root.left,tmp)
            calc(root.right,tmp)
            
            
        calc(root,0)
        return res

class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -&amp;gt; int:

        res = 0
        def helper(node, val):
            nonlocal res
            if not node.left and not node.right:
                res+= val
            if node.left:
                helper(node.left,val*10+node.left.val)
            if node.right:
                helper(node.right,val*10+node.right.val)
    
        helper(root,root.val)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：到达leave 才把结果加和给res。 如果不是leave只更新tmp值。 然后前序遍历。&lt;/p&gt;
&lt;h1 id=&#34;130-surrounded-regions-medium&#34;&gt;130. Surrounded Regions （Medium）&lt;/h1&gt;
&lt;p&gt;Given an m x n matrix board containing &#39;X&#39; and &#39;O&#39;, capture all regions that are 4-directionally surrounded by &#39;X&#39;.&lt;br&gt;
A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def solve(self, board: List[List[str]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        m = len(board)
        n = len(board[0])
        
        def dfs(board,i,j):
            
            if m&amp;gt;i&amp;gt;=0 and n&amp;gt;j&amp;gt;=0:
                if board[i][j]==&#39;O&#39;:
                    board[i][j]=&#39;#&#39;
                    
            
                    for newi,newj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                        dfs(board,newi,newj)
      
        
        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1 and board[i][j]==&#39;O&#39;:
                    dfs(board,i,j)
        
        for i in range(m):
            for j in range(n):
                if board[i][j]!=&#39;#&#39;:
                    board[i][j]=&#39;X&#39;
        for i in range(m):
            for j in range(n):
                if board[i][j]==&#39;#&#39;:
                    board[i][j]=&#39;O&#39;

#BFS way of writting
class Solution(object):
    def solve(self, board):
        &amp;quot;&amp;quot;&amp;quot;
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        if not board: return 
        m=len(board)
        n=len(board[0])
        #boarder bfs O-&amp;gt;#          else to  X  restore # to O
        
      
        def nei(i,j):
            r= [ (i+1,j),(i-1,j),(i,j+1),(i,j-1)]
            return [ (xy[0],xy[1]) for xy in r if  (0&amp;lt;=xy[0]&amp;lt;m and 0&amp;lt;=xy[1]&amp;lt;n)]
        
      
        def bfs(i,j):
            visited=set()
            q=[(i,j)]
            visited.add((i,j))
            board[i][j]=&#39;#&#39;
            while q:
                x,y=q.pop(0)
                neis=nei(x,y)
                for xy in neis:
                    if xy not in visited:
                        if board[xy[0]][xy[1]]==&#39;O&#39;:
                            q.append(xy)
                            board[xy[0]][xy[1]]=&#39;#&#39;
                            visited.add(xy)
                            
                         
                        
                    
                    
                
        
        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1:
                    if board[i][j]==&#39;O&#39;:
                        bfs(i,j)
            
        
        for row in board:
            print(row)
        for i in range(m):
            for j in range(n):
                if board[i][j]!=&#39;#&#39;:
                    board[i][j]=&#39;X&#39;
                if board[i][j]==&#39;#&#39;:
                    board[i][j]=&#39;O&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路，在board边界地方为O的点做dfs，更新为#。之后把所有不为#的变为X。之后把#变为O。 得写个bfs dfs模板总结。&lt;/p&gt;
">Leetcode 2021-11-15</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-14/"" data-c="
          &lt;p&gt;BFS DFS 模板总结&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;bfs-template&#34;&gt;BFS - Template&lt;/h1&gt;
&lt;h2 id=&#34;template-i&#34;&gt;template I&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue&amp;lt;Node&amp;gt; queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template-ii&#34;&gt;template II&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue&amp;lt;Node&amp;gt; queue;  // store all nodes which are waiting to be processed
    Set&amp;lt;Node&amp;gt; visited;  // store all the nodes that we&#39;ve visited
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to visited;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to visited;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dfs-template&#34;&gt;DFS - Template&lt;/h1&gt;
&lt;h2 id=&#34;template-i-2&#34;&gt;template I&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set&amp;lt;Node&amp;gt; visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template-ii-2&#34;&gt;template II&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set&amp;lt;Node&amp;gt; visited;
    Stack&amp;lt;Node&amp;gt; stack;
    add root to stack;
    while (stack is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
">BFS DFS 模板总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-13/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;111-minimum-depth-of-binary-tree-easy&#34;&gt;111. Minimum Depth of Binary Tree (Easy)&lt;/h1&gt;
&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    #      2
    #        3
    #          4
    #            5 
    #             6
    
    def minDepth(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        min_ = float(&#39;inf&#39;)
        if root.left:
            min_ = min(min_,self.minDepth(root.left))
        if root.right:
            min_ = min(min_,self.minDepth(root.right))
        
        if not root.left and not root.right:
            min_=0
        return 1+min_

#answer way of writting
class Solution:
    def minDepth(self, root: TreeNode) -&amp;gt; int:
         
        if not root:
            return 0
        if root.left is None:
            return self.minDepth(root.right)+1
        if root.right is None:
            return self.minDepth(root.left)+1
        return min(self.minDepth(root.left),self.minDepth(root.right))+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意special case 全是右斜。    直接写成 if not root: return 0 ， return 1+min(self.minDepth(root.left),self.minDepth(root.right))是不对的。全右斜情况root.left直接是空，所以会返回0+1. 应该多一个判断，左右子树是否存在，存在再更新值。&lt;/p&gt;
&lt;h1 id=&#34;112-path-sum-easy&#34;&gt;112. Path Sum （Easy）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.&lt;br&gt;
A leaf is a node with no children.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; bool:
        if not root: return False 
        
        if (not root.left) and not (root.right) and (targetSum==root.val):
            return True
        
        if  (not root.left) and not (root.right) and (targetSum!=root.val):
            return False
        
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;113-path-sum-ii-medium&#34;&gt;113. Path Sum II (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&amp;gt; List[List[int]]:
        
        res = []
        if not root: return res
        def ps(root,target,tmp):
            if not root.left and not root.right and root.val==target:
                tmp.append(root.val)
                res.append(tmp[:])
                
            if root:
                tmp.append(root.val)
                
                if root.left:
                    ps(root.left,target-root.val,tmp[:])
                
                if root.right:
                    ps(root.right,target-root.val,tmp[:])
        
        ps(root,targetSum,[])
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义帮助函数保存path。&lt;/p&gt;
&lt;h1 id=&#34;114-flatten-binary-tree-to-linked-list-medium&#34;&gt;114. Flatten Binary Tree to Linked List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, flatten the tree into a &amp;quot;linked list&amp;quot;&lt;br&gt;
The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.&lt;br&gt;
The &amp;quot;linked list&amp;quot; should be in the same order as a pre-order traversal of the binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def flatten(self, root: Optional[TreeNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify root in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        previous = None
        def pre(node):
            nonlocal previous
            if not node: return 
            if previous:
                previous.left = None
                previous.right = node
            previous = node
            nodeleft = node.left
            noderight = node.right
            pre(nodeleft)
            pre(noderight)
        
        pre(root)
        return root
        
class Solution:
    def flatten(self, root: Optional[TreeNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify root in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
   
        res = []
        stack = []
        head=None
        cur=None
        while root or stack:
            while root:
                res.append(root)  
                stack.append(root)
                root=root.left
            
            node = stack.pop()
            root=node.right
        
        pre=None
        for node in res:
            if pre:
                pre.left = None
                pre.right = node
            
            pre = node
        
        if pre:
            pre.left=None
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred115-distinct-subsequences-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;115. Distinct Subsequences (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, return the number of distinct subsequences of s which equals t&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numDistinct(self, s: str, t: str) -&amp;gt; int:
        
        if len(t)&amp;gt;len(s): return 0
        
        m=len(t)
        n=len(s)
        
        dp=[[0]*(n+1) for _ in range(m+1)]
        
        # fill row 0:
        for i in range(n+1):
            dp[0][i]=1
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if t[i-1]==s[j-1]:
                    dp[i][j]=dp[i-1][j-1]+dp[i][j-1]
                else:
                    dp[i][j]=dp[i][j-1]
        
        return dp[m][n]
        
#               S
#           #  b a b g b a g
#    T  #   1  1 1 1 1 1 1 1
#       b   0  1 1 2 2 3 3 3 
#       a   0  0 1 1 1 1 4 4
#       g   0  0 0 0 1 1 1 5
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉应该用dp做。找递推关系。。。。&lt;br&gt;
如果s和t末尾字符一样， dp[i][j] = dp[i-1][j-1] + dp[i][j-1]  是t，s都drop末尾+只有s drop末尾，因为是t去匹配s。 如果s和末尾字符不一样 dp[i][j] = dp[i][j-1]。 注意初始条件，空字符串匹配s可能的方式为1.&lt;/p&gt;
&lt;h1 id=&#34;116-populating-next-right-pointers-in-each-node-medium&#34;&gt;116. Populating Next Right Pointers in Each Node （Medium）&lt;/h1&gt;
&lt;p&gt;You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:struct Node {&lt;br&gt;
int val;&lt;br&gt;
Node *left;&lt;br&gt;
Node *right;&lt;br&gt;
Node *next;&lt;br&gt;
}&lt;br&gt;
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;br&gt;
Initially, all next pointers are set to NULL&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&amp;quot;&amp;quot;&amp;quot;

class Solution:
    def connect(self, root: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;:
        
        if not root: return root
        queue = [root]
        
        while queue:
            level=[]
            l=len(queue)
            for _ in range(l):
                cur = queue.pop(0)
                level.append(cur)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            
            pre=None
            for node in level:
                if pre:
                    pre.next=node
                pre = node
        
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs level order transversal ...&lt;/p&gt;
&lt;h1 id=&#34;117-populating-next-right-pointers-in-each-node-ii-medium&#34;&gt;117. Populating Next Right Pointers in Each Node II (Medium)&lt;/h1&gt;
&lt;p&gt;解决方法同上&lt;/p&gt;
&lt;h1 id=&#34;118-pascals-triangle-easy&#34;&gt;118. Pascal&#39;s Triangle （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer numRows, return the first numRows of Pascal&#39;s triangle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generate(self, numRows: int) -&amp;gt; List[List[int]]:
        
        
        if numRows==1:
            return [[1]]
        if numRows==2:
            return [[1],[1,1]]
        res = [[1],[1,1]]
        
        for _ in range(numRows-2):
            level = [1,]
            prev_level = res[-1]
            for i in range(len(prev_level)-1):
                val = prev_level[i]+prev_level[i+1]
                level.append(val)
            
            level.append(1)
            res.append(level)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;杨辉三角&lt;/p&gt;
&lt;h1 id=&#34;119-pascals-triangle-ii-easy&#34;&gt;119. Pascal&#39;s Triangle II （Easy）&lt;/h1&gt;
&lt;p&gt;Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal&#39;s triangle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getRow(self, rowIndex: int) -&amp;gt; List[int]:
       
        res = [1]*(rowIndex+1)
        
        if rowIndex&amp;lt;=1:
            return res
        
        for i in range(rowIndex):
            length = 2+i
            res_copy = res[:]
            for j in range(1,length-1):
                res[j]=res_copy[j]+res_copy[j-1]
                
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是杨辉三角，要细心。&lt;/p&gt;
&lt;h1 id=&#34;120-triangle-medium&#34;&gt;120. Triangle （Medium）&lt;/h1&gt;
&lt;p&gt;Given a triangle array, return the minimum path sum from top to bottom.&lt;br&gt;
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        def mintotal(triangle, i):
            if not triangle:
                return 0
            root = triangle[0][i]
            triangle.pop(0)
            return root+min(mintotal(triangle[:],i),mintotal(triangle[:],i+1))
        return mintotal(triangle,0)

 # second pass solution
 class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        
        mem=dict()
        def mintotal(triangle, i,level):
            if (level,i) in mem: return mem[(level,i)]
            if not triangle:
                return 0
            root = triangle[0][i]
            triangle.pop(0)
            res= root+min(mintotal(triangle[:],i,level+1),mintotal(triangle[:],i+1,level+1))
            mem[(level,i)]=res
            return res
        return mintotal(triangle,0,0)

#answer way of writting
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&amp;gt; int:
        rows=len(triangle)
        minlen=triangle[-1][:]
        for layer in range(rows-2,-1,-1):
            for i in range(layer+1):
                minlen[i]=min(minlen[i],minlen[i+1])+triangle[layer][i]
        return minlen[0]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;first try, time limit exceeded.  add mem, nailed it. 答案用DP方法也很巧妙，因为最后一行就是所有可能性，慢慢回溯去求结果。root是 minlen[0].&lt;/p&gt;
">Leetcode 2021-11-13</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-12/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;101-symmetric-tree-easy&#34;&gt;101. Symmetric Tree (Easy)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        def helper(left,right):
            if not left:
                return not right
            if not right:
                return not left
            return left.val==right.val and helper(left.right,right.left) and helper(left.left,right.right)
        
        return helper(root,root)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;102-binary-tree-level-order-traversal-medium&#34;&gt;102. Binary Tree Level Order Traversal (Medium)&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        res = []
        if not root: return res
        queue = [root]
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            res.append(level)
        return res    

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        res = collections.defaultdict(list)
        def pre(node,level):
            if not node: return
            if node:
                res[level].append(node.val)
            pre(node.left,level+1)
            pre(node.right,level+1)
        pre(root,0)
        return list(res.values())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs用queue，range（length）来确定要pop的元素个数。&lt;/p&gt;
&lt;h1 id=&#34;103-binary-tree-zigzag-level-order-traversal-medium&#34;&gt;103. Binary Tree Zigzag Level Order Traversal （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        if not root: return []
        queue = [root]
        level = 0
        res = []
        while queue:
            li_level = []
            level +=1
            l=len(queue)
            for i in range(l):
                cur=queue.pop(0)
                li_level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            if level%2==0:
                res.append(li_level[::-1])
            else:
                res.append(li_level)
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bfs+level counter 如果偶数，翻转。&lt;/p&gt;
&lt;h1 id=&#34;104-maximum-depth-of-binary-tree-easy&#34;&gt;104. Maximum Depth of Binary Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&amp;gt; int:
        if not root: return 0
        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred105-construct-binary-tree-from-preorder-and-inorder-traversal-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;105. Construct Binary Tree from Preorder and Inorder Traversal (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; Optional[TreeNode]:
    
        if not preorder or not inorder: return None
        
        rootval = preorder[0]
        preorder = preorder[1:]
        root = TreeNode(rootval)
        lileft=[]
        liright=[]
        left=True
        for n in inorder:
            if n!=rootval:
                if left:
                    lileft.append(n)
                else:
                    liright.append(n)
            else:
                left=False
                
        leftnode = self.buildTree([e for e in preorder if e in lileft],lileft)
        rightnode = self.buildTree([e for e in preorder if e in liright],liright)
        root.left=leftnode
        root.right=rightnode
        return root

#answer way of writting
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; TreeNode:
        
        if not preorder or not inorder: return None
        
        rootval=preorder.pop(0)

        root=TreeNode(rootval)
        
        index=inorder.index(rootval)
        
        root.left=self.buildTree(preorder,inorder[:index])
        root.right=self.buildTree(preorder,inorder[index+1:]) #if index+1&amp;lt;len(inorder) else None
        
        return root
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道使用preorder找root 然后split inorder找到左右子数，但time limit exceed。 是因为过滤preordder必须和inorder的元素一样。其实按照子树生长方式不用这层过滤。&lt;br&gt;
这个题的坑在于 #rootval = preorder[0]  #preorder = preorder[1:]      看似和 rootval = preorder.pop(0) 一样，但是pop方式改变了preorder， 在递归调用时候每次递归都会改变preorder的内容，前者不会，导致left right 调用时候preorder都是相同内容导致出错。&lt;/p&gt;
&lt;h1 id=&#34;106-construct-binary-tree-from-inorder-and-postorder-traversal-medium&#34;&gt;106. Construct Binary Tree from Inorder and Postorder Traversal （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; Optional[TreeNode]:
        if not inorder or not postorder: return None
         
        val = postorder.pop()
        ind = inorder.index(val)
        root=TreeNode(val)
       
        right = self.buildTree(inorder[ind+1:],postorder)
        left = self.buildTree(inorder[:ind],postorder)
        
        root.left = left
        root.right = right
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路： 后序遍历最后一个数为root val。 这样可在inorder中分出左右子树数据。但建立数的时候要从右子树开始然后到左子树。&lt;/p&gt;
&lt;h1 id=&#34;107-binary-tree-level-order-traversal-ii-medium&#34;&gt;107. Binary Tree Level Order Traversal II （Medium）&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (i.e., from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -&amp;gt; List[List[int]]:
        if not root: return []
        queue = [root]
        res = []
        while queue:
            l=len(queue)
            level = []
            for i in range(l):
                cur=queue.pop(0)
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            res.append(level)
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;still bfs&lt;/p&gt;
&lt;h1 id=&#34;108-convert-sorted-array-to-binary-search-tree-easy&#34;&gt;108. Convert Sorted Array to Binary Search Tree (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&amp;gt; Optional[TreeNode]:
        if not nums: return None
        l=0
        r=len(nums)
        m = (l+r)//2
        root=TreeNode(nums[m])
        root.left=self.sortedArrayToBST(nums[:m])
        root.right=self.sortedArrayToBST(nums[m+1:])
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;109-convert-sorted-list-to-binary-search-tree-medium&#34;&gt;109. Convert Sorted List to Binary Search Tree (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -&amp;gt; Optional[TreeNode]:
        
        if not head:return None
        if not head.next: return TreeNode(head.val)
        #if not head.next.next: 
        #    return TreeNode(head.next.val,left=TreeNode(head.val))
        p0=head #slow
        p1=head #fast
        pre=None
        while p1 and p1.next:
            p1=p1.next.next
            pre = p0
            p0=p0.next
            
        #print(pre.val,p0.val)    
        pre.next=None
        p0next=p0.next
        p0.next=None
        
        root = TreeNode(p0.val)
        root.left = self.sortedListToBST(head)
        root.right= self.sortedListToBST(p0next)
        
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred110-balanced-binary-tree-easy-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;110. Balanced Binary Tree (Easy) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;br&gt;
For this problem, a height-balanced binary tree is defined as:&lt;br&gt;
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        def depth(root):
            if not root: 
                return 0
            return 1+max(depth(root.left),depth(root.right))
        
        if not root: return True
        
        left=depth(root.left)
        right=depth(root.right)
        isbalanced = abs(left-right)&amp;lt;=1
        return isbalanced and self.isBalanced(root.left) and self.isBalanced(root.right)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题不应该卡， 判断了左右深度差小于等于1后还需要分别判断左右子树是否也是balanced。&lt;/p&gt;
">Leetcode 2021-11-12</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-11/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorred-91-decode-ways-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 91. Decode Ways (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;A message containing letters from A-Z can be encoded into numbers using the following mapping:&lt;/p&gt;
&lt;p&gt;&#39;A&#39; -&amp;gt; &amp;quot;1&amp;quot;&lt;br&gt;
&#39;B&#39; -&amp;gt; &amp;quot;2&amp;quot;&lt;br&gt;
...&lt;br&gt;
&#39;Z&#39; -&amp;gt; &amp;quot;26&amp;quot;&lt;/p&gt;
&lt;p&gt;To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;quot;11106&amp;quot; can be mapped into:&lt;br&gt;
&amp;quot;AAJF&amp;quot; with the grouping (1 1 10 6)&lt;br&gt;
&amp;quot;KJF&amp;quot; with the grouping (11 10 6)&lt;br&gt;
Note that the grouping (1 11 06) is invalid because &amp;quot;06&amp;quot; cannot be mapped into &#39;F&#39; since &amp;quot;6&amp;quot; is different from &amp;quot;06&amp;quot;.&lt;br&gt;
Given a string s containing only digits, return the number of ways to decode it.&lt;br&gt;
The answer is guaranteed to fit in a 32-bit integer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def numDecodings(self, s: str) -&amp;gt; int:

        if  not s: return 0
        n = len(s)
        dp = [0]*(n+1)
        dp[0] = 1 # empty string has 1 way
        dp[1] = 1 if s[0]!=&#39;0&#39; else 0 #single char can not have leading 0

        for i in range(2,n+1):
            #      cur
            # pre  cur
            cur = int(s[i-1])
            precur = int(s[i-2:i])

            if 1&amp;lt;=cur&amp;lt;=9:
                dp[i]+=dp[i-1]
            
            if 26&amp;gt;=precur&amp;gt;=10:
                dp[i]+=dp[i-2]
            
        return dp[-1]
      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试图用递归+mem方法写，越写越繁琐。。。没有解决。 看答案用了DP。&lt;br&gt;
解决方法很巧妙。 空字符dp val=1， dp【1】为首字符结果， 如果首字符为0，则dp【1】=0 else dp【1】=1 从字符第二位到末位。 检查cur 和 （per，cur）形成的数字。 如果valid。就做dp【i】的更新。&lt;/p&gt;
&lt;h1 id=&#34;92-reverse-linked-list-ii-medium&#34;&gt;92. Reverse Linked List II （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]:
        
        def rev(node):
            pre=None
            while node :
                nodenext=node.next
                node.next = pre
                pre=node
                node = nodenext    
            return pre
        
        # get left~right chan, do rev, concat
        
        dummyhead=ListNode(val=&#39;NULL&#39;,next=head)
        
        cur = dummyhead
        pre=None
        for _ in range(left):
            pre=cur
            cur = cur.next
        
        revhead_pre=pre
        revhead=cur
        
        for _ in range(right-left):
            cur=cur.next

        revend = cur
        revend_next = revend.next
        revend.next = None
        
        revhead_pre.next=rev(revhead)
        revhead.next = revend_next
        
        return dummyhead.next
##
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]:
 
        dummyhead = ListNode(val = &#39;NULL&#39;,next=head)
        cur = dummyhead
        
        A = None
        for _ in range(left):
            A = cur
            cur =cur.next
        B = cur
        pre = None
        for _ in range(right-left+1):
            curnext = cur.next
            cur.next = pre
            pre = cur
            cur = curnext

        A.next = pre
        B.next = cur
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用了dummyhead 细心就可以了。。。&lt;/p&gt;
&lt;h1 id=&#34;93-restore-ip-addresses-medium&#34;&gt;93. Restore IP Addresses （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def restoreIpAddresses(self, s: str) -&amp;gt; List[str]:
        # 4 parts, 0 ~ 255 
        ss = s
        
        res = []
        
        def bt(s,tmp):
             
            if len(&#39;.&#39;.join(tmp))==len(ss)+3 and len(tmp)==4:
                res.append(&#39;.&#39;.join(tmp))
                
            for length in [1,2,3]:
                if len(s)&amp;gt;=length and 255&amp;gt;=int(s[:length])&amp;gt;=0:
                    if (length==2 or length==3) and s[0]==&#39;0&#39; : continue
                    tmp.append(s[:length])
                    bt(s[length:],tmp)
                    tmp.pop()
        
        bt(s,[])
        
        return res
###
class Solution:
    def restoreIpAddresses(self, s: str) -&amp;gt; List[str]:
        res = []
        def bt(tmp, s):
            if len(tmp)==4 and not s:
                res.append(&#39;.&#39;.join(tmp))
                return 
            if s and 9&amp;gt;=int(s[0])&amp;gt;=0:
                bt(tmp+[s[0]],s[1:])
            if len(s)&amp;gt;1 and int(s[0])!=0 and 99&amp;gt;=int(s[:2])&amp;gt;=1:
                bt(tmp+[s[:2]],s[2:])
            if len(s)&amp;gt;2 and int(s[0])!=0 and 255&amp;gt;=int(s[:3])&amp;gt;=100:
                bt(tmp+[s[:3]],s[3:])
        
        bt([],s)
        return res             
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 终止条件是被分割成4份而且总长度是string长度加3个点长度。 可能的length只有1，2，3。 length 2，3时候0不能作为开头元素。&lt;/p&gt;
&lt;h1 id=&#34;94-binary-tree-inorder-traversal-easy&#34;&gt;94. Binary Tree Inorder Traversal （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        
        res = []
        def ino(node):
            if not node: 
                return
            ino(node.left)
            res.append(node.val)
            ino(node.right)
        
        ino(root)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归很容易写，how about iterative one？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -&amp;gt; List[int]:
        
        res = []
        s = []
        while s or root:
            while root:
                s.append(root)
                root = root.left
            
            node = s.pop()
            res.append(node.val)
            
            if node.right:
                root =node.right
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经典写法了应该是，当stack有东西或者root不为空，root先入栈，一直探索左子树。当root为空时。从stack中取出node，提取值。如果有右子树。则开始以右子树的node作为root探索。&lt;/p&gt;
&lt;h1 id=&#34;95-unique-binary-search-trees-ii-medium&#34;&gt;95. Unique Binary Search Trees II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -&amp;gt; List[Optional[TreeNode]]:
        
        
        nums = list(range(1,n+1))
        
        def gen(nums):
            if not nums:
                return [None]
            res = []
            for i in range(len(nums)):
                mid = nums[i]
                leftnums=nums[:i] if i!=0 else []
                rightnums = nums[i+1:] if i!=len(nums)-1 else []
                
                for left in gen(leftnums):
                    for right in gen(rightnums):
                        root = TreeNode(mid)
                        root.left = left
                        root.right= right
                        res.append(root)
            
            return res
        
        return gen(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归分治法。&lt;/p&gt;
&lt;h1 id=&#34;96-unique-binary-search-trees-medium&#34;&gt;96. Unique Binary Search Trees （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer n, return the number of structurally unique BST&#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    mem = {0:1,1:1,2:2}
    def numTrees(self, n: int) -&amp;gt; int:
        if n in self.mem: return self.mem[n]
        if n==0:
            return 1
        if n==1:
            return 1
        if n==2:
            return 2
        
        res= 0
        for i in range(n):
            left = i
            right= n-left-1
            res += self.numTrees(left)*self.numTrees(right)
        self.mem[n]=res
        return res
#
class Solution:
    def numTrees(self, n: int) -&amp;gt; int:
        @lru_cache(None)
        def cal(n):
            if n==0: return 1
            if n==1: return 1
            res = 0
            for left in range(n):
                right = n-left-1
                res+=cal(left)*cal(right)
            return res
        
        return cal(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归+记忆  比较容易理解。 答案是什么catalanta number，不感兴趣。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-97-interleaving-string-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 97. Interleaving String （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.&lt;br&gt;
An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:&lt;br&gt;
s = s1 + s2 + ... + sn&lt;br&gt;
t = t1 + t2 + ... + tm&lt;br&gt;
|n - m| &amp;lt;= 1&lt;br&gt;
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&amp;gt; bool:
        
        #dp[i][j]   i is length of string1   
        #           j is length of string2
        #           so interleaving length= i+j
        
        
        
        m=len(s1)
        n=len(s2)
        
        if m+n!=len(s3) or sorted(s1+s2)!=sorted(s3):
            return False
        
        dp=[ [False]*(n+1) for _ in range(m+1)]
        dp[0][0]=True
        
        #fill row 0
        for col in range(1,n+1):
            dp[0][col]=dp[0][col-1] and s2[col-1]==s3[0+col-1]
        #fill col 0
        for row in range(1,m+1):
            dp[row][0]=dp[row-1][0] and s1[row-1]==s3[0+row-1]
            
        #dp
        
        for row in range(1,m+1):
            for col in range(1,n+1):
                dp[row][col]=(dp[row-1][col] and s1[row-1]==s3[row+col-1] ) or (dp[row][col-1] and s2[col-1]==s3[row+col-1])
        
        return dp[m][n]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路。。。&lt;br&gt;
思路： dynamic programming  dp[i][j] 是指长度为i的s1和长度为j的s2是否可interleave。所以dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])&lt;br&gt;
没想到是dynamic programming， 最小子结构是差一位时候，是否interleaving有递推关系。&lt;/p&gt;
&lt;h1 id=&#34;98-validate-binary-search-tree-medium&#34;&gt;98. Validate Binary Search Tree （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -&amp;gt; bool:
        
        s = []
        pre=None
        while s or root:
            while root:
                s.append(root)
                root=root.left
                
            node = s.pop()
            if pre is not None:
                if pre&amp;gt;=node.val:
                    return False
                
            pre = node.val
            
            if node.right:
                root=node.right
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以inorder 然后看是否递增，或者iterative的inorder 直接判断。&lt;/p&gt;
&lt;h1 id=&#34;99-recover-binary-search-tree-font&#34;&gt;99. Recover Binary Search Tree &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify root in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
 
        s=[]
        y=x=pre=None

        while s or root:
            while root:
                s.append(root)
                root=root.left
           
            node=s.pop()
            
            if pre and pre.val&amp;gt; node.val:
                y=node
                if x is None:
                    x=pre
                else:
                    break
           
            pre=node
            if node.right:
                root=node.right
            
        x.val,y.val=y.val,x.val
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很巧妙的解法， 如果x是None， 第一次记录下pre&amp;gt;cur中的pre node, 第二次记录下 pre&amp;gt;cur中的cur node。 【1，2，3，4，5，6】交换2，5 【1，5，3，4，2，6】 第一次出现pre&amp;gt;cur 时候，pre就是5，第二次出现pre&amp;gt;cur时候 cur 是2. 这样就找到了需要交换的nodes。&lt;/p&gt;
&lt;h1 id=&#34;100-same-tree-easy&#34;&gt;100. Same Tree （Easy）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&amp;gt; bool:
        
        if not p:
            return not q
        
        if not q:
            return not p
        
        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) 
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-10/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;font-colorblue-81-search-in-rotated-sorted-array-ii-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 81. Search in Rotated Sorted Array II (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).&lt;/p&gt;
&lt;p&gt;Before being passed to your function, nums is rotated at an unknown pivot index k (0 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].&lt;/p&gt;
&lt;p&gt;Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.&lt;/p&gt;
&lt;p&gt;You must decrease the overall operation steps as much as possible.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; bool:
        #still binary search
        l=0
        r=len(nums)-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==nums[m]:return True
            
            while nums[l]==nums[r] and l&amp;lt;r:
                if nums[l]==target:
                    return True
                l+=1
                r-=1
               
            
            if nums[m] &amp;gt;= nums[l]:
                #left increase
                if nums[m]&amp;gt;=target&amp;gt;=nums[l]:
                    r=m-1
                else:
                    l=m+1
            else:
                #right increase
                if   nums[r]&amp;gt;=target&amp;gt;=nums[m]:
                    l=m+1
                else:
                    r=m-1
        
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意特别处理 nums[l]==nums[r] 情况 而且要确保 l小于r  也就是aba情形。 这样才能l+1 ， r-1。&lt;/p&gt;
&lt;h1 id=&#34;82-remove-duplicates-from-sorted-list-ii-medium&#34;&gt;82. Remove Duplicates from Sorted List II （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        
        pre = dummyhead
        cur = head

        while cur and cur.next:
            
            if cur.val==cur.next.val:
                #find dup, do while loop til end, update pre and cur
                while cur and cur.next and cur.val==cur.next.val:
                    cur = cur.next

                pre.next = cur.next if cur.next else None
                cur = cur.next if cur.next else None
            else:
                #normal update
                pre=cur
                cur=cur.next
        
        return dummyhead.next


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:

        # a  b  c  c  d  d  e
        # P  C
        #    P        C
        #  a  a c  c d 
        # P means previous C means current

             
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        pre=dummyhead
        cur = head
        while cur and cur.next:
            #print(cur.val)
            if cur.next and cur.next.val!=cur.val:
                pre = cur
                cur = cur.next
            elif cur.next and cur.next.val==cur.val:
                while cur.next and cur.next.val==cur.val:
                    cur = cur.next
                cur = cur.next
                if pre:
                    pre.next = cur
                
        return dummyhead.next

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;83-remove-duplicates-from-sorted-list-easy&#34;&gt;83. Remove Duplicates from Sorted List （Easy）&lt;/h1&gt;
&lt;p&gt;Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;,next=head)
        pre=dummyhead
        cur=head
        while cur:
            if pre.val==cur.val:
                #find dup
                while cur and pre.val==cur.val:
                    cur=cur.next
                pre.next=cur
                
            else:
                #normal update
                pre=cur
                cur=cur.next
                
        return dummyhead.next

#answer way of writting
class Solution:
    def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode:
        cur=head
        while cur and cur.next:
            if cur.val==cur.next.val:
                cur.next=cur.next.next
            else:
                cur=cur.next
        
        return head
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案写法更优雅。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-84-largest-rectangle-in-histogram-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 84. Largest Rectangle in Histogram （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;重点记忆，遇到当前小于等于栈顶元素确定了右边界。开始计算，高度是stack.pop（）左边界是stack【-1】，注意起始stack = 【-1】&lt;br&gt;
Given an array of integers heights representing the histogram&#39;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def largestRectangleArea(self, heights: List[int]) -&amp;gt; int:
        stack=[-1]
        res=0
        for i in range(len(heights)):
            while stack[-1]!=-1 and heights[stack[-1]]&amp;gt;=heights[i]:
                res=max(res, heights[stack.pop()]*(i-stack[-1]-1)
            stack.append(i)
        
        while stack[-1]!=-1 and stack:
            res=max(res,heights[stack.pop()]*(len(heights)-stack[-1]-1))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没思路， 似乎是用stack 。。。但如何知道哪块板是需要的？&lt;br&gt;
思路: 如果当前高度小于等于栈顶，说明找到了栈顶的右边界，开始计算。pop栈顶元素的高度为高度，宽度为目前位置到已经pop过的栈顶位置减一。 过完一遍后，如果栈里还有元素， 开始计算， pop栈顶元素的高度为高度， 宽度为目前位置（已经是len（heights）了）到已经pop过的栈顶位置减一。注意初始栈为-1， 方便计算面积公式再edge case 下成立。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-85-maximal-rectangle-hardfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 85. Maximal Rectangle （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a rows x cols binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -&amp;gt; int:
        
        # 似乎能转化成上一题，板子面积最大问题。
        
        def maxarea(nums):
            res = 0
            stack = [-1]
            for i, n in enumerate(nums):
                while stack[-1]!=-1 and nums[stack[-1]] &amp;gt;= n:
                    #calculate
                    res = max(res, nums[stack.pop()]*(i-stack[-1]-1))
                
                stack.append(i)
                
            while stack and stack[-1]!=-1:
                res = max(res, nums[stack.pop()]*(len(nums)-stack[-1]-1))
            return res  
        
        res = 0
        for rowid in range(len(matrix)):
            if rowid==0:
                row = [int(e) for e in matrix[0]]
                #print(row)
                res = max(res,maxarea(row[:]))
            else:
                currow = [int(e) for e in matrix[rowid]]
                row = [ cr+cr*r for (cr,r) in zip(currow,row)]
                #print(row)
                res = max(res,maxarea(row[:]))
        
         
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接用了上一题求解。。。。&lt;/p&gt;
&lt;h1 id=&#34;86-partition-list-medium&#34;&gt;86. Partition List (Medium)&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -&amp;gt; Optional[ListNode]:
        
        smallhead = ListNode(val=&#39;NULL&#39;)
        largehead = ListNode(val=&#39;NULL&#39;)
        small = smallhead
        large = largehead
        while head:
            if head.val&amp;lt;x:
                small.next = head
                small = small.next
            else:
                large.next = head
                large = large.next
                
            head = head.next
        
        #makde ends clean
        if small:
            small.next = None
        if large:
            large.next = None
        
        small.next = largehead.next
        
        return smallhead.next

class Solution:
    def partition(self, head: Optional[ListNode], x: int) -&amp;gt; Optional[ListNode]:
        dummyheadA = ListNode(val=&#39;NULL&#39;)
        dummyheadB = ListNode(val=&#39;NULL&#39;)
        curA = dummyheadA
        curB = dummyheadB
        while head:
            headnext = head.next
            if head.val&amp;lt;x:
                curA.next = head
                curA = curA.next
                curA.next = None
            else:
                curB.next = head
                curB = curB.next
                curB.next = None
                
            head = headnext
        
        #print(dummyheadA.next)
        #print(dummyheadB.next)
        
        curA.next = dummyheadB.next

        return dummyheadA.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-87-scramble-string-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 87. Scramble String (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;We can scramble a string s to get a string t using the following algorithm:&lt;br&gt;
If the length of the string is 1, stop.&lt;br&gt;
If the length of the string is &amp;gt; 1, do the following:&lt;br&gt;
Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.&lt;br&gt;
Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.&lt;br&gt;
Apply step 1 recursively on each of the two substrings x and y.&lt;br&gt;
Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# mem limit exceeded
class Solution:
    def isScramble(self, s1: str, s2: str) -&amp;gt; bool:

        @lru_cache(None)
        def scr(s):
            if len(s)==1: return [s]
            res = set()
            for i in range(1,len(s)):
                x =s[:i]
                y =s[i:]
                for left in scr(x):
                    for right in scr(y):
                        res.add(left+right)
                        res.add(right+left)
            res.add(s)
            return list(res)
        return s2 in scr(s1)

class Solution:
    @lru_cache(None)
    def isScramble(self, s1: str, s2: str) -&amp;gt; bool:
        m =len(s1)
        n=len(s2)
        if m!=n or sorted(s1)!=sorted(s2): return False
        if m&amp;lt;=3 or s1==s2: return True
        f = self.isScramble
        for i in range(1,len(s1)):
            if f(s1[:i],s2[:i]) and f(s1[i:],s2[i:]) or f(s1[:i],s2[-i:]) and f(s1[i:],s2[:-i]):
                return True
        return False


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtraking MLE TLE，重新想办法。。&lt;br&gt;
答案很优雅，用了递归和mem&lt;/p&gt;
&lt;h1 id=&#34;88-merge-sorted-array-easy&#34;&gt;88. Merge Sorted Array （Easy）&lt;/h1&gt;
&lt;p&gt;You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.&lt;br&gt;
Merge nums1 and nums2 into a single array sorted in non-decreasing order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums1 in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        # fill nums1 from end pos to head pos
        cur=len(nums1)-1
        while m&amp;gt;0 and n&amp;gt;0:
            if nums1[m-1]&amp;gt;nums2[n-1]:
                nums1[cur]=nums1[m-1]
                m-=1
            else:
                nums1[cur]=nums2[n-1]
                n-=1
            cur-=1
        
        while m&amp;gt;0:
            nums1[cur]=nums1[m-1]
            m-=1
            cur-=1
        while n&amp;gt;0:
            nums1[cur]=nums2[n-1]
            n-=1
            cur-=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从后向前覆盖，避免overwrite。&lt;/p&gt;
&lt;h1 id=&#34;89-gray-code-medium&#34;&gt;89. Gray Code （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def grayCode(self, n: int) -&amp;gt; List[int]:
        
        #  0      0
        #  1     [0  1]
        #  2     [00 01 11 10]
        
        level = [0,1]
        if n==1: return level
        for i in range(n-1):
            level_res  = []
            mask1 = 1&amp;lt;&amp;lt;(i+1)
            mask0 = 0
            for n in level:
                level_res.append(n|mask0)
            for n in level[::-1]:
                level_res.append(n|mask1)
            
            level=level_res
        
        return level
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每个level下，用0/1 mask遍历前一个level的结果就行了，注意mask1时候reverse遍历顺序。&lt;/p&gt;
&lt;h1 id=&#34;90-subsets-ii-medium&#34;&gt;90. Subsets II （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums that may contain duplicates, return all possible subsets (the power set).&lt;br&gt;
The solution set must not contain duplicate subsets. Return the solution in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(temp,start):
            res.append(temp[:])
            
            for i in range(start,len(nums)):
                if i&amp;gt;start and nums[i]==nums[i-1]: continue
                temp.append(nums[i])
                bt(temp,i+1)
                temp.pop()
        
        nums.sort()
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经在backtrakcing总结篇写过，注意2点，去重，下一次bt起始位置为i+1，不look back。&lt;/p&gt;
">Leetcode 2021-11-10</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-09/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;71-simplify-path-medium&#34;&gt;71. Simplify Path （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string path, which is an absolute path (starting with a slash &#39;/&#39;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def simplifyPath(self, path: str) -&amp;gt; str:
        path = [e.replace(&#39;/&#39;,&#39;&#39;) for e in path.split(&#39;/&#39;) ]
        print(path)
        path = [e for e in path if e!=&#39;.&#39; and len(e)&amp;gt;0]
        print(path)
        res = []
        for p in path:
            if p==&#39;..&#39;:
                if res:
                    res.pop()
            else:
                res.append(p)
        return &#39;/&#39;+&#39;/&#39;.join(res) 
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred72-edit-distance-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;72. Edit Distance (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minDistance(self, word1: str, word2: str) -&amp;gt; int:
        
        # insert 2 del 3 replace
        
        #dp            0  r  o   s  
        #           0  0  1  2   3 
        #           h  1  1  2   3
        #           o  2  2  1   2
        #           r  3  3  2   2
        #           s  4  4  3   2
        #           e  5  5  4   3
        
        rows=len(word1)+1
        cols=len(word2)+1
        
        dp=[[0]*cols for _ in range(rows)]
        
        #fill row0 :
        for j in range(len(word2)+1):
            dp[0][j]=j
            
        #fill col0
        for i in range(len(word1)+1):
            dp[i][0]=i
        
        for i in range(1,rows):
            for j in range(1,cols):
                min_=min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j])
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min_+1
        
        return dp[rows-1][cols-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;似乎是用dynamic programmming， 但没想出来递归怎么写。&lt;br&gt;
看了答案发现很简单。。。dp[i][j] = min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j]) + 1 如果末尾不同，如果末尾相同 dp[i][j] = dp[i-1]dp[j-1]&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue73-set-matrix-zeroes-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt;73. Set Matrix Zeroes (Medium)&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&#39;s, and return the matrix.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify matrix in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        # project 0 to row[0] &amp;amp; col[0] but matrix[0][0] will overlapping should be taken care
        
        row00 = 1
        
        for row in range(len(matrix)):
            for col in range(len(matrix[0])):
                if matrix[row][col]==0:
                    if col==0:
                        row00=0
                    else:
                        matrix[0][col]=0
                    matrix[row][0]=0
        # for row in matrix:
        #     print(row)
        for row in range(len(matrix)-1,-1,-1):
            for col in range(len(matrix[0])-1,-1,-1):
                if col==0:
                    if row00==0:
                        matrix[row][col]=0
                        
                else:
                    if (matrix[0][col]==0 or matrix[row][0]==0):
                        matrix[row][col]=0
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挺有意思一题目，正的扫0位置，把0位置存在top和left边上，但是【0，0】的位置会存2此产生数据覆盖，所以如果第一列有元素是0，则需要把row00这个赋为0.  第二部，反的扫元素位置，防止填0的时候覆盖数据。然后注意第一列是不是为0依靠判断row00元素是否为0即可。&lt;/p&gt;
&lt;h1 id=&#34;74-search-a-2d-matrix-medium&#34;&gt;74. Search a 2D Matrix （Medium）&lt;/h1&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;br&gt;
Integers in each row are sorted from left to right.&lt;br&gt;
The first integer of each row is greater than the last integer of the previous row.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        #     1   2  3
        #     4   5  6   seach 2  mid=5   target&amp;lt;mid  left top or left right
        #     7   8  9         9  mid=5   target&amp;gt;mid  right bot or left bot
        
        
        m = len(matrix)
        n = len(matrix[0])
        
        def helper(matrix, target, rowleft,rowright,colleft,colright):
            print(rowleft,rowright,colleft,colright)
            if rowleft==rowright:
                return target in [matrix[rowleft][col] for col in range(colleft,colright+1)]
            if colleft==colright:
                return target in [matrix[row][colleft] for row in range(rowleft,rowright+1)]
            if rowright-rowleft==1 and colright-colleft==1:
                if matrix[rowleft][colleft]==target:
                    return True
                if matrix[rowleft][colright]==target:
                    return True
                if matrix[rowright][colleft]==target:
                    return True
                if matrix[rowright][colright]==target:
                    return True
                return False
                
            rowmid = (rowleft+rowright)//2
            colmid = (colleft+colright)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif matrix[rowmid][colmid]&amp;lt;target:
                #seach right bot or left bot
                return helper(matrix,target,rowmid,rowright,colmid,colright) or helper(matrix,target,rowmid,rowright, colleft,colmid)
            else:
                #seaerch left top or left right
                return helper(matrix,target,rowleft,rowmid,colleft,colmid) or helper(matrix,target,rowleft,rowmid, colmid,colright)
            
    
        return helper(matrix,target,0,m-1,0,n-1)


# answer way of writting
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        
        if not matrix or not matrix[0]: return False
        
        
        #binary find row first
        rows=len(matrix)
        cols=len(matrix[0])
        
        if rows==cols and rows==1:
            return matrix[0][0]==target
        
        l=0
        r=rows-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==matrix[m][cols-1]:
                return True
            elif target&amp;gt;matrix[m][cols-1]:
                l=m+1
            else:
                r=m-1
        
        findrow=l
        if findrow&amp;lt;0: findrow=0
        if findrow&amp;gt;=rows: findrow=rows-1
        
       
        #binary search find col
        
        l=0
        r=cols-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if target==matrix[findrow][m]:
                return True
            elif target&amp;gt;matrix[findrow][m]:
                l=m+1
            else:
                r=m-1
                
        
        return False
##############
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool:
        m=len(matrix)
        n=len(matrix[0])

        #seach last column
        li = [matrix[i][-1] for i in range(m)]

        def bs(li,t):
            l=0
            r=len(li)-1
            while l&amp;lt;=r:
                m=(l+r)//2
                if li[m]==target:
                    return m
                elif li[m]&amp;gt;target:
                    r=m-1
                else:
                    l=m+1
            return l
        
        row = bs(li,target)
        if row&amp;gt;=m:
            return False
        #print(row)
        col=bs(matrix[row],target)
        if col&amp;gt;=n:
            return False

        return matrix[row][col]==target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;binary search for matrix... 虽然写出来了，但感觉写的不完美而且用时过长，思路：如果最后是4个正方形矩阵，依次寻找target，如果最后是一行，依次寻找。 把目标分解到4个象限中的2个来寻找。&lt;br&gt;
感觉递归base case这步可以优化。另一种写法是先找行再找列。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-75-sort-colors-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 75. Sort Colors （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.&lt;br&gt;
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.&lt;br&gt;
Input: nums = [2,0,2,1,1,0]&lt;br&gt;
Output: [0,0,1,1,2,2]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sortColors(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        # left maintail all 0s rigth maintain all 2s
        l=0
        r=len(nums)-1
        
        for i,n in enumerate(nums):
            if n==0:
                nums[l],nums[i] = nums[i],nums[l]
                l+=1
        l=0
        r=len(nums)-1
        #print(nums)
        for i in range(len(nums)-1,-1,-1):
            if nums[i]==2:
                nums[r],nums[i] = nums[i],nums[r]
                r-=1

#answer way of writting
class Solution:
    def sortColors(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        p0=cur=0
        p2=len(nums)-1
        
        while cur&amp;lt;=p2:
            if nums[cur]==0:
                nums[p0],nums[cur]=nums[cur],nums[p0]
                p0+=1
                cur+=1
            elif nums[cur]==2:
                nums[p2],nums[cur],=nums[cur],nums[p2]
                p2-=1
            else:
                cur+=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的答案是遍历2次， 第一次找0位置做交换， 第二次从末向前遍历找2位置做交换。&lt;br&gt;
答案更简单只遍历一次。。。有点tricky地方在于必须用while cur&amp;lt;=p2, 不能for i，n in enumerate（nums）&lt;/p&gt;
&lt;h1 id=&#34;76-minimum-window-substring-hard&#34;&gt;76. Minimum Window Substring (Hard）&lt;/h1&gt;
&lt;p&gt;Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;quot;&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minWindow(self, s: str, t: str) -&amp;gt; str:
        # sliding window
        # how?
        #
        # l  r
        # move r util contains all t&#39;s chars
        # shrink l,until count[char]==0 del count char, then move r
        #
        def equal(dic_s,dic_t):
            for k,v in dic_t.items():
                if k not in dic_s:
                    return False
                if dic_s[k]&amp;lt;v:
                    return False
            return True
        
        dic_t = dict()
        for char in t:
            dic_t[char]=dic_t.get(char,0)+1
            
        
        l=0
        r=0
        
        dic_s = dict()
        
        while not equal(dic_s,dic_t) and r&amp;lt;len(s):
        
            if s[r] in dic_t:
                dic_s[s[r]]=dic_s.get(s[r],0)+1
            r+=1
        
        r=r-1 if r-1&amp;gt;=0 else 0
        #print(l,r)
        #now l to r contains all chars in t
        res = &#39;&#39;
        minw = float(&#39;inf&#39;)
        #shrink l , move r
        while l&amp;lt;=r and r&amp;lt;len(s):
            #calculate
            if r-l+1 &amp;lt; minw and equal(dic_s,dic_t):
                minw=r-l+1
                res=s[l:r+1]
            #remove char
            char = s[l]
            if char in dic_t:
                dic_s[char] = dic_s.get(char,0)-1
                if dic_s[char]&amp;lt;=0:
                    del dic_s[char]
            
            while not equal(dic_s,dic_t):
                r+=1
                if r&amp;gt;=len(s):
                    break
                if s[r] in dic_t:
                    dic_s[s[r]]=dic_s.get(s[r],0)+1
           
                    
            #
            l=l+1
        
        return res

####
class Solution:
    def minWindow(self, s: str, t: str) -&amp;gt; str:
        dic_t = collections.Counter(t)
        res = None

        # expand include all
        # shrink until less than dic_t expand again
        
        def dic_equal(d,t):
            for k,v in t.items():
                if k not in d:
                    return False
                if d[k]&amp;lt;v:
                    return False
            return True

        p = 0
        dic = dict()
        length = float(&#39;inf&#39;)
        res = &#39;&#39;
        for i,ch in enumerate(s):
            dic[ch] = dic.get(ch,0)+1
            while dic_equal(dic,dic_t):
                candidate=s[p:i+1]
                l=i+1-p
                if l&amp;lt;length:
                    length = l
                    res = candidate
                if s[p] in dic:
                    dic[s[p]]-=1
                    if dic[s[p]]==0:
                        del dic[s[p]]
                p+=1
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过sliding window做出来了， equal 这个helper function很关键。  要equal dic_s里面得有所有 dic_target 的key 而且val必须大于等于target val。  思路：  move r util contains all t&#39;s chars。shrink l,until count[char]==0 del count char, then move r。&lt;/p&gt;
&lt;h1 id=&#34;77-combinations-medium&#34;&gt;77. Combinations （Medium）&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].&lt;br&gt;
You may return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combine(self, n: int, k: int) -&amp;gt; List[List[int]]:
        
        res = []
        nums = [i for i in range(1,n+1)]
        def bt(tmp,start):
            if len(tmp)==k:
                res.append(tmp[:])
            else:
                for i in range(start,n):
                    tmp.append(nums[i])
                    bt(tmp,i+1)
                    tmp.pop()
        
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型backtracking， 新start=i+1 假如是start+1 则可能这个start+1 是小于等于i的，相当于重复选择 。&lt;/p&gt;
&lt;h1 id=&#34;78-subsets-medium&#34;&gt;78. Subsets （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of unique elements, return all possible subsets (the power set).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res = []
        def bt(tmp,start):
            res.append(tmp[:])
            for i in range(start,len(nums)):
                n=nums[i]
                if n not in tmp:
                    tmp.append(n)
                    bt(tmp,i+1)
                    tmp.pop()
        bt([],0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;79-word-search-medium&#34;&gt;79. Word Search (Medium)&lt;/h1&gt;
&lt;p&gt;Given an m x n grid of characters board and a string word, return true if word exists in the grid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def exist(self, board: List[List[str]], word: str) -&amp;gt; bool:
        # bfs???  几乎忘记了 dfs bfs 怎么写?
        # 不能重复用元素，所以访问后设为-1，
        
        def bfs(board,word,i,j):
            if not word:
                return True
            
            if word[0]!= board[i][j]:
                return False
            
            boardij=board[i][j]
            board[i][j]=-1
            
            
            word=word[1:]
            
            res = False
            neig = [(i,j+1),(i,j-1),(i-1,j),(i+1,j)]
            valid_neig = []
            for nei in neig:
                row,col=nei
                if row&amp;gt;=0 and row&amp;lt;len(board) and col&amp;gt;=0 and col&amp;lt;len(board[0]):
                        valid_neig.append((row,col))
            if not valid_neig and not word:
                return True
            
            for nei in valid_neig:
                row,col=nei
                res = res or bfs(board,word,row,col)
            
            board[i][j]=boardij
            return res 
        
     
        
        res = False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j]==word[0]:
                    res = res or bfs(board,word,i,j)
        return res
# answer way of writting
class Solution:
    def exist(self, board: List[List[str]], word: str) -&amp;gt; bool:
        
        if not word: return True
        if not board: return False
        
 
        def dfs(board,i,j,w):
            if not w: 
                return True
            
            if i&amp;lt;0 or j&amp;lt;0 or i&amp;gt;=len(board) or j&amp;gt;=len(board[0]) or board[i][j]!=w[0]:
                return False
            
            #found first fit
            temp=board[i][j]
            board[i][j]=&amp;quot;#&amp;quot; #avoid visit again
            res=dfs(board,i+1,j,w[1:]) or dfs(board,i,j+1,w[1:]) or dfs(board,i-1,j,w[1:]) or dfs(board,i,j-1,w[1:]) 
            board[i][j]=temp
            return res
            
           
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(board, i, j, word):
                    return True
        return False

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码巨大丑无比， 但是pass了 。 答案的dfs写的很优雅。。。Time Complexity: O(N⋅3**L) where N  is the number of cells in the board and L is the length of the word to be matched.&lt;/p&gt;
&lt;h1 id=&#34;80-remove-duplicates-from-sorted-array-ii-medium&#34;&gt;80. Remove Duplicates from Sorted Array II (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeDuplicates(self, nums: List[int]) -&amp;gt; int:
        # 
        pos = 0
        pre=nums[0]
        c =0
        
        for i,n in enumerate(nums):
            
            
            if pre==n:
                c+=1
            else:
                c=1
                
            if c&amp;lt;=2:
                nums[pos] = nums[i]
                pos+=1
            
            pre=n
        
        return pos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 。 pos是下一个正确位置。当pre！=cur时候 重新更新计数器为1，pre=cur&lt;br&gt;
如果 计数器c 小于等于2. 把nums[i]放入nums[pos]。&lt;/p&gt;
">Leetcode 2021-11-09</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-07/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;61-rotate-list-medium&#34;&gt;61. Rotate List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, rotate the list to the right by k places.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]:
        
        if not head: return head
        def length(head):
            c=0
            tail=None
            while head:
                c+=1
                tail=head
                head=head.next
            return c,tail
        
        leng,tail = length(head)
        k = k%leng 
        if k==leng or k==0: return head
        
        
        
        p1=head
        p2=head
        
        for _ in range(k):
            p2=p2.next
        
        
        while p2.next:
            p1=p1.next
            p2=p2.next
        
        new_head=p1.next
        p1.next=None
        tail.next=head
        
        return new_head

#concise writing with dummy head
class Solution:
    def rotateRight(self, head: ListNode, k: int) -&amp;gt; ListNode:
        
        
        if k==0 or (not head): return head
        
        l=0
        cur=head
        while cur:
            l+=1
            cur=cur.next
        
        if k%l==0: return head
        
        k=k%l
        
        dummy=ListNode(-1)
        dummy.next=head
        
        p1=p2=dummy
        
        for _ in range(k):
            p2=p2.next
        
        while p2.next:
            p1=p1.next
            p2=p2.next
            
        
        newhead=p1.next
        p1.next=None
        p2.next=dummy.next
        
        return newhead

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]:
        # k=2
        # 1-&amp;gt;2-&amp;gt;3-&amp;gt;-4-&amp;gt;5
        #              A
        #      B
        if not head : return head
        def length(head):
            c=0
            while head:
                c+=1
                head = head.next
            return c
        
        k= k% length(head)
        if k==0: return head

        head_backup = head
        A=head
        B=head
        for _ in range(k):
            A = A.next
        
        while A.next:
            A =A.next
            B= B.next
        
        res = B.next
        A.next=head_backup
        B.next=None
        return res                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心。。。&lt;/p&gt;
&lt;h1 id=&#34;62-unique-paths-medium&#34;&gt;62. Unique Paths (Medium)&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).&lt;br&gt;
How many possible unique paths are there?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def uniquePaths(self, m: int, n: int) -&amp;gt; int:
        ###  0  1  1  1  1  1  1
        ###  1  2  3  4  5  6  7
        ###  1
        ###  1
        ###  1
        # m rows   n cols
        # dp[i][j] = dp[i][j-1]+dp[i-1][j]
        #
        
        dp = [[0]*n for _  in range(m)]
        for i in range(n):
            if i==0: continue
            dp[0][i]=1
        for i in range(m):
            if m==0: continue
            dp[i][0]=1
        
        for row in range(1,m):
            for col in range(1,n):
                dp[row][col]=dp[row][col-1]+dp[row-1][col]
        return dp[m-1][n-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;63-unique-paths-ii-medium&#34;&gt;63. Unique Paths II (Medium)&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).&lt;br&gt;
Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;br&gt;
An obstacle and space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&amp;gt; int:
        
        ###  0  1  1  1  1  1  1
        ###  1  2  3  4  5  6  7
        ###  1  O
        ###  1  
        ###  1
        # m rows   n cols
        # dp[i][j] = dp[i][j-1]+dp[i-1][j]
        #
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        if obstacleGrid[m-1][n-1]==1 or obstacleGrid[0][0]==1 : return 0
        dp = [[0]*n for _  in range(m)]
        for i in range(n):
            if i==0: continue
            if obstacleGrid[0][i]!=1:
                dp[0][i]=1
            else:
                break
        for i in range(m):
            if m==0: continue
            if obstacleGrid[i][0]!=1:
                dp[i][0]=1
            else:
                break
        
        for row in range(1,m):
            for col in range(1,n):
                rowcol1 = dp[row][col-1] if obstacleGrid[row][col-1]!=1 else 0
                row1col = dp[row-1][col] if obstacleGrid[row-1][col]!=1 else 0
                dp[row][col]=rowcol1+row1col
        return dp[m-1][n-1]
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dp去解， 注意edge case， 在起始和终止位置blok。&lt;/p&gt;
&lt;h1 id=&#34;64-minimum-path-sum-medium&#34;&gt;64. Minimum Path Sum (Medium)&lt;/h1&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def minPathSum(self, grid: List[List[int]]) -&amp;gt; int:
        
        # dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]
        m=len(grid)
        n=len(grid[0])
        dp = [[0]*n for _ in range(m)]
        
        for i in range(n):
            if i==0: 
                dp[0][0]=grid[0][0]
            else:
                dp[0][i] = dp[0][i-1]+grid[0][i]
        
        for i in range(m):
            if i==0:
                dp[0][0]=grid[0][0]
            else:
                dp[i][0]=dp[i-1][0]+grid[i][0]
        
        for row in range(1,m):
            for col in range(1,n):
                dp[row][col]=min(dp[row-1][col],dp[row][col-1])+grid[row][col]
        
        return dp[m-1][n-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred65-valid-number-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;65. Valid Number (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Finite state machine, but hard to write ..... 试了半天。。。。没试出来。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isNumber(self, s: str) -&amp;gt; bool:
        s = s.lower()
        #define DFA(determinstic finite automation) state transition tables
        states = [{},
                 # State (1) - initial state (scan ahead thru blanks)
                 {&#39;blank&#39;: 1, &#39;sign&#39;: 2, &#39;digit&#39;:3, &#39;.&#39;:4},
                 # State (2) - found sign (expect digit/dot)
                 {&#39;digit&#39;:3, &#39;.&#39;:4},
                 # State (3) - digit consumer (loop until non-digit)
                 {&#39;digit&#39;:3, &#39;.&#39;:5, &#39;e&#39;:6, &#39;blank&#39;:9},
                 # State (4) - found dot (only a digit is valid)
                 {&#39;digit&#39;:5},
                 # State (5) - after dot (expect digits, e, or end of valid input)
                 {&#39;digit&#39;:5, &#39;e&#39;:6, &#39;blank&#39;:9},
                 # State (6) - found &#39;e&#39; (only a sign or digit valid)
                 {&#39;sign&#39;:7, &#39;digit&#39;:8},
                 # State (7) - sign after &#39;e&#39; (only digit)
                 {&#39;digit&#39;:8},
                 # State (8) - digit after &#39;e&#39; (expect digits or end of valid input) 
                 {&#39;digit&#39;:8, &#39;blank&#39;:9},
                 # State (9) - Terminal state (fail if non-blank found)
                 {&#39;blank&#39;:9}]
        currentState = 1
        for c in s:
            # If char c is of a known class set it to the class name
            if c in &#39;0123456789&#39;:
                c = &#39;digit&#39;
            elif c in &#39; &#39;:
                c = &#39;blank&#39;
            elif c in &#39;+-&#39;:
                c = &#39;sign&#39;
            # If char/class is not in our state transition table it is invalid input
            if c not in states[currentState]:
                return False
            # State transition
            currentState = states[currentState][c]
        # The only valid terminal states are end on digit, after dot, digit after e, or white space after valid input    
        if currentState not in [3,5,8,9]:
            return False
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;66-plus-one-easy&#34;&gt;66. Plus One (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def plusOne(self, digits: List[int]) -&amp;gt; List[int]:
        
        res = []
        carry=0
        First=True
        for i in digits[::-1]:
            if First:
                val = carry+i+1
                First=False
            else:
                val = carry+i
            carry = val//10 
            val = val%10
            res.append(val)
         
        if carry!=0:
            res.append(carry)
        
        return res[::-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;67-add-binary-easy&#34;&gt;67. Add Binary （Easy）&lt;/h1&gt;
&lt;p&gt;Given two binary strings a and b, return their sum as a binary string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def addBinary(self, a: str, b: str) -&amp;gt; str:
        res = []
        carry=0
        a = [int(e) for e in a][::-1]
        b = [int(e) for e in b][::-1]
        while a or b:
            inta = a[0] if a else 0
            intb = b[0] if b else 0
            val = carry+inta+intb
            carry=val//2
            res.append(val%2)
            a=a[1:] if a else None
            b=b[1:] if b else None
        if carry:
            res.append(1)
        return &#39;&#39;.join([str(e) for e in res[::-1]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorblue-68-text-justification-hard-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 68. Text Justification (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -&amp;gt; List[str]:
        
        # W1+1  W2+1  W3
        level = []
        res = []
        c_level = 0
        while words:
            word = words.pop(0)
            lw = len(word)
            c_level+=(lw+1)
            if c_level-1&amp;gt;maxWidth:
                words = [word]+words
                res.append(level[:])
                level=[]
                c_level=0
            else:
                level.append(word)
        if level:
            res.append(level)
        
        result = []
        for rowid,row in enumerate(res):
            l = len(row)
            ngap =l-1
            if rowid!=len(res)-1:
                if ngap!=0:
                    i=0
                    while sum([len(w) for w in row])&amp;lt;maxWidth:
                        ind = i%ngap
                        row[ind] = row[ind]+&#39; &#39;
                        i+=1
                    row = &#39;&#39;.join(row)
                else:
                    row = row[0]+&#39; &#39;*(maxWidth-len(row[0]))
            else:
                row=&#39; &#39;.join(row)
                row = row+&#39; &#39;*(maxWidth-len(row))
                
            result.append(row)
        
        return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;round robin 分配除了最后一行外的空格。。。&lt;/p&gt;
&lt;h1 id=&#34;69-sqrtx-easy&#34;&gt;69. Sqrt(x) （Easy）&lt;/h1&gt;
&lt;p&gt;Given a non-negative integer x, compute and return the square root of x.&lt;br&gt;
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def mySqrt(self, x: int) -&amp;gt; int:
        
        l=0
        r=x
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if   m**2&amp;lt;=x and (m+1)**2&amp;gt;x:
                return m
            
            elif m**2&amp;gt;x:
                r=m-1
            else:
                l=m+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接二分法了。。&lt;/p&gt;
&lt;h1 id=&#34;70-climbing-stairs-easy&#34;&gt;70. Climbing Stairs （Easy）&lt;/h1&gt;
&lt;p&gt;You are climbing a staircase. It takes n steps to reach the top.&lt;br&gt;
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def climbStairs(self, n: int) -&amp;gt; int:
        # 
        #   0 step to climit to 0    0 
        #   1 step to clime to 1     1
        #   1+1 to clime to 2 
        if n==1: return 1
        if n==2: return 2
        
        dp = [0]*(n+1)
        dp[1]=1
        dp[2]=2
        # dp[n] = dp[n-1]+dp[n-2]
        
        for i in range(3,n+1):
            dp[i]=dp[i-1]+dp[i-2]
    
        return dp[n]

class Solution:
    def climbStairs(self, n: int) -&amp;gt; int:
        #  n = 1    1 
        #  n = 2    2
        # dp[n] = dp[n-1]+dp[n-2]
        if n==1: return 1
        if n==2: return 2
        dpn1 =2
        dpn2 =1
        dpn = 0
        for i in range(3,n+1):
            dpn = dpn1+dpn2
            dpn1_old=dpn1
            dpn1 = dpn
            dpn2 = dpn1_old
        return dpn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单dynamic programming应用。&lt;/p&gt;
">Leetcode 2021-11-08</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/backtracking-zong-jie/"" data-c="
          &lt;p&gt;backtracking 不同题目不完全汇总&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
### Subsets
        def backtrack(list, templist,nums,start):
            list.append(templist[:])
            for i in range(start,len(nums)):
                templist.append(nums[i])
                backtrack(list,templist,nums,i+1)
                templist.pop()      

        list=[]
        nums.sort()
        backtrack(list,[],nums,0)
        return list
### Subsets II
    def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]:
        def backtrack(list, templist,nums,start):
            list.append(templist[:])
            for i in range(start,len(nums)):
                if i &amp;gt; start and nums[i] == nums[i-1]: continue
                templist.append(nums[i])
                backtrack(list,templist,nums,i+1)
                templist.pop()      

        list=[]
        nums.sort()
        backtrack(list,[],nums,0)
        return list
### Permutations
    def permute(self, nums: List[int]) -&amp;gt; List[List[int]]:
        def backtrack(list, templist,nums):
            
            if len(templist)==len(nums): list.append(templist[:])
            else:
                for i in range(0,len(nums)):
                    if nums[i] in templist: continue
                    templist.append(nums[i])
                    backtrack(list,templist,nums)
                    templist.pop()      

        list=[]
        #nums.sort()
        backtrack(list,[],nums)
        return list
### Permutations II
    def permuteUnique(self, nums: List[int]) -&amp;gt; List[List[int]]:
             
        def backtrack(list, templist,nums,used):
            
            if len(templist)==len(nums): list.append(templist[:])
            else:
                for i in range(0,len(nums)):
                    if used[i] or (i &amp;gt; 0 and nums[i] == nums[i-1] and (not used[i - 1])): continue
                    used[i]=True
                    templist.append(nums[i])
                    backtrack(list,templist,nums,used)
                    used[i] = False 
                    templist.pop()      

        list=[]
        used=[False]*len(nums)
        nums.sort()
        backtrack(list,[],nums,used)
        return list
### combination sum
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        
        def backtrack(list, templist,nums,remain,start):
            
            if remain &amp;lt; 0: return
            elif remain == 0: list.append(templist[:])
            else:
                for i in range(start,len(nums)):
                    
                    templist.append(nums[i])
                    backtrack(list,templist,nums,remain - nums[i], i)
                    templist.pop()      
        nums=candidates
        list=[]
        nums.sort()
        backtrack(list,[],nums,target,0)
        return list
### combination sum II
    def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
             
        def backtrack(list, templist,nums,remain,start):
            
            if remain &amp;lt; 0: return
            elif remain == 0: list.append(templist[:])
            else:
                for i in range(start,len(nums)):
                    if (i &amp;gt; start) and (nums[i] == nums[i-1]): continue
                    templist.append(nums[i])
                    backtrack(list,templist,nums,remain - nums[i], i+1)
                    templist.pop()      
        nums=candidates
        list=[]
        nums.sort()
        backtrack(list,[],nums,target,0)
        return list
### Palindrome Partitional 
    def partition(self, s: str) -&amp;gt; List[List[str]]:
        
        def backtrack(list, templist,s,start):
            
            if start==len(s): list.append(templist[:])  
            else:
                for i in range(start,len(s)):
                    if s[start:i+1]==s[start:i+1][::-1]:
                        templist.append(s[start:i+1])
                        backtrack(list,templist,s, i+1)
                        templist.pop()      

        list=[]
        backtrack(list,[],s,0)
        return list
&lt;/code&gt;&lt;/pre&gt;
">backtracking 总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-06/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;51-n-queens-hard&#34;&gt;51. N-Queens (Hard)&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#answer way of writing
class Solution(object):
   def solveNQueens(self, n):
       &amp;quot;&amp;quot;&amp;quot;
       :type n: int
       :rtype: List[List[str]]
       &amp;quot;&amp;quot;&amp;quot;
       
       board = [-1]*n
       
       
       def conflict(board, row, col):
           
           for row_i in range(n):
               #if has Queue in row_i  col != -1 
               if  board[row_i] != -1 and ( col==board[row_i] or row==row_i or row+col==row_i+ board[row_i] or  row-col==row_i- board[row_i]):
                   #same row
                   return True
               
           return False
       
       res = []
       def bt(board,row):
           if row==n:
               res.append(board[:])
           else:
               for col in range(n):
                   if not conflict(board,row,col):
                       board[row]=col
                       bt(board,row+1)
                       board[row]=-1
       bt(board,0)

       result = []
       for solution in res:
           s = []
           for i in solution:
               row = [&#39;.&#39;]*n
               row[i]=&#39;Q&#39;
               s.append(&#39;&#39;.join(row))
           result.append(s)
       return  result

#
class Solution:
   def solveNQueens(self, n: int) -&amp;gt; List[List[str]]:

       def conflict(res,row,col):
          
           if col in res:
               return True
           if res[row]!=-1:
               return True
           if row+col in [ i+n for i,n in enumerate(res) if n!=-1]:
               return True
           if row-col in [ i-n for i,n in enumerate(res) if n!=-1]:
               return True
           
           return False

       result = []
       def solve(tmp,i):
           if i==n:
               result.append(tmp[:])
               return
           for j in range(n):
               if not conflict(tmp,i,j):
                   tmp[i]=j
                   solve(tmp,i+1)
                   tmp[i]=-1 
       
       solve([-1]*n,0)

       res = []
       for r in result:
           tmp = [[&#39;.&#39;]*n for _ in range(n)]
           for row, col in enumerate(r):
               tmp[row][col]=&#39;Q&#39;
           tmp = [&#39;&#39;.join(row) for row in tmp]
           res.append(tmp)

       return res               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ith queens at row i， start已经可以表示ith quene了。。。&lt;/p&gt;
&lt;h1 id=&#34;52-n-queens-ii-hard&#34;&gt;52. N-Queens II （Hard）&lt;/h1&gt;
&lt;p&gt;和之间一样求出所有组合然后求length。。。&lt;/p&gt;
&lt;h1 id=&#34;53-maximum-subarray-medium&#34;&gt;53. Maximum Subarray （Medium）&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum&lt;br&gt;
A subarray is a contiguous part of an array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
        # dp[i] means to sum up to nums[i] is the maxinum
        # dp[i] = max(dp[i-1]+nums[i], nums[i])
        # return max(dp)

        dpi = nums[0]
        res = nums[0]
        for i,n in enumerate(nums):
            if i==0: continue
            dpi = max(dpi+n,n)
            res = max(res,dpi)
        return res

class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
        #O（n）方法， 
        #  dp[i] 表示 在i包含i元素的最大和
        #  dp[i] = max(nums[i],dp[i-1]+nums[i])
        if len(nums)==1: return nums[0]
        res = nums[0]
        dpi1 = nums[0]
        for i in range(1,len(nums)):
            dpi=max(nums[i],dpi1+nums[i])
            if dpi&amp;gt;res:
                res=dpi
            dpi1=dpi
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;54-spiral-matrix-medium&#34;&gt;54. Spiral Matrix （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]:
        res = []
        while matrix:
            res.extend(matrix.pop(0))
            matrix = list(zip(*matrix))[::-1]
        return res

#answer way of writting
class Solution(object):
    def spiralOrder(self, matrix):
        &amp;quot;&amp;quot;&amp;quot;
        :type matrix: List[List[int]]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        if not matrix: return []
        
        visited = [[False for i in range(len(matrix[0]))] for j in range(len(matrix))]
        
        moveX = [1,0,-1,0]
        moveY = [0,1,0,-1]
        res = []
        moveOption = 0
        row = len(matrix)
        col = len(matrix[0])
        r = 0
        c = 0
        for _ in range(row*col):
            res.append(matrix[r][c])
            visited[r][c]=True
            rr = r + moveY[moveOption]
            cc = c + moveX[moveOption]
            if (rr&amp;gt;=0 and rr&amp;lt;row and cc&amp;gt;=0 and cc&amp;lt;col) and not visited[rr][cc]
                r=rr
                c=cc
            else:
                moveOption = (moveOption+1)%4
                r = r+moveY[moveOption]
                c = c+moveX[moveOption]
        return res        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;55-jump-game-medium&#34;&gt;55. Jump Game (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def canJump(self, nums: List[int]) -&amp;gt; bool:

        cur = 0
        right = nums[0]

        for i in range(1,len(nums)):
            if cur&amp;lt;i:
                if right==cur: return False
                cur = right
            
            right = max(right, i+nums[i])

        return cur&amp;gt;=len(nums)-1


class Solution:
    def canJump(self, nums: List[int]) -&amp;gt; bool:
        
        right=nums[0]
        cur = 0
        for i,n in enumerate(nums):
            #form 1th index
            if i==0: continue
            if right&amp;gt;=i:
                #if I can reach Ith pos, update right
                right = max(right,i+n)
        
        return right&amp;gt;=len(nums)-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;56-merge-intervals-medium&#34;&gt;56. Merge Intervals (Medium)&lt;/h1&gt;
&lt;p&gt;Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]:
        #[sort by start
        # scan if &amp;lt; append, else  continue til end
        # case1)
        #    al    ar   
        #    |      |
        #       bl|    |br
        #
        # case2)
        #    al    ar   
        #    |      |
        #              bl|    |br
        # case3)
        #    al               ar   
        #    |                |
        #       bl|    |br
        
        if len(intervals)==1: return intervals
        intervals = sorted(intervals, key=lambda x: x[0])
        res = []
        pre_left = intervals[0][0]
        pre_right = intervals[0][1]
        for i,interval in enumerate(intervals):
            if i==0: continue
            local_left = interval[0]
            local_right = interval[1]
            if local_left &amp;gt; pre_right:
                #case 2)
                res.append([pre_left,pre_right])
                pre_left=local_left
                pre_right=local_right
            else:
                #case 1,3)
                pre_right=max(pre_right,local_right)
                
            if i==len(intervals)-1:
                res.append([pre_left,max(pre_right,local_right)])
                
        return res

#answer way of writting
class Solution:
    def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]:
        
        intervals.sort(key=lambda x:x[0])
        
        if not intervals: return []
        
        cur=intervals.pop(0) 
        res=[cur]
        
        while intervals:
            cur=intervals.pop(0)
            res_1=res[-1]
            # a   b
            #  cd       case 1  drop cur
            #   c  d    csse 2  extend res[-1] to d
            #        cd case 3  add cur to res
            
            if cur[1]&amp;lt;=res_1[1]: 
                continue
            elif    cur[0]&amp;lt;=res_1[1] and cur[1]&amp;gt;res_1[1]:
                res[-1][1]=cur[1]
            else:
                res.append(cur)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sort by 起始元素， 总共有3种情况很容易想到， 答案写的代码比较简单。。。&lt;/p&gt;
&lt;h1 id=&#34;57-insert-interval-medium&#34;&gt;57. Insert Interval （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&amp;gt; List[List[int]]:
        
        intervals.append(newInterval)
        intervals.sort(key=lambda x: x[0])
        if not intervals or len(intervals)==1: return intervals
        
        res = []
        cur = intervals.pop(0)
        res.append(cur)
        
        while intervals:
            cur=intervals.pop(0)
            cur_left = cur[0]
            cur_right= cur[1]
            pre_left = res[-1][0]
            pre_right = res[-1][1]
            
            if cur_right&amp;lt;=pre_right:
                # a  b b  a
                continue
            elif cur_left&amp;lt;=pre_right and cur_right&amp;gt;=pre_right:
                # a  b  a  b
                res[-1][1]=cur_right
            else:
                # a  a  b b
                res.append(cur)
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把区间插入， 排序， 然后重复上题代码。&lt;/p&gt;
&lt;h1 id=&#34;58-length-of-last-word-easy&#34;&gt;58. Length of Last Word （Easy）&lt;/h1&gt;
&lt;p&gt;Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLastWord(self, s: str) -&amp;gt; int:
        while s[-1]==&#39; &#39;:
            s=s[:-1]
        c=0
        while s and s[-1]!=&#39; &#39;:
            c+=1
            s =s[:-1]
        return c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先去尾部空格，然后从尾部开始计数，如果碰到空格就break return。&lt;/p&gt;
&lt;h1 id=&#34;59-spiral-matrix-ii-medium&#34;&gt;59. Spiral Matrix II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generateMatrix(self, n: int) -&amp;gt; List[List[int]]:
        
        matrix = [[&#39;NULL&#39;]*n for _ in range(n)]
        visited= [[False]*n for _ in range(n)]
        move_X = [1,0,-1,0]
        move_Y = [0,1,0, -1]
        
        r=0
        c=0
        moveOption = 0
        for i in range(1,n*n+1):
            matrix[r][c]=i
            visited[r][c]=True
            #calculate next pos
            rr=r+move_Y[moveOption]
            cc=c+move_X[moveOption]
            #print(rr,cc)
            if not (n&amp;gt;rr&amp;gt;=0 and n&amp;gt;cc&amp;gt;=0 and not visited[rr][cc]):
                moveOption = (moveOption+1)%4
                rr=r+move_Y[moveOption]
                cc=c+move_X[moveOption]
            r=rr
            c=cc
        return matrix
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-60-permutation-sequence-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt; 60. Permutation Sequence （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;The set [1, 2, 3, ..., n] contains a total of n! unique permutations.&lt;br&gt;
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&lt;br&gt;
&amp;quot;123&amp;quot;&lt;br&gt;
&amp;quot;132&amp;quot;&lt;br&gt;
&amp;quot;213&amp;quot;&lt;br&gt;
&amp;quot;231&amp;quot;&lt;br&gt;
&amp;quot;312&amp;quot;&lt;br&gt;
&amp;quot;321&amp;quot;&lt;br&gt;
Given n and k, return the kth permutation sequence.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getPermutation(self, n: int, k: int) -&amp;gt; str:
        
        # &amp;quot;123&amp;quot;             0
        # &amp;quot;132&amp;quot;             1
        # &amp;quot;213&amp;quot;             2
        # &amp;quot;231&amp;quot;             3
        # &amp;quot;312&amp;quot;             4
        # &amp;quot;321&amp;quot;             5
        #      3!  2!  1! 0!
        #      a*6  + b2   c1  d1
        #   4= 0      2     0   0
        #             3     1   2
        if n==1: return &amp;quot;1&amp;quot;
        bignumber=[0]*n
        bignumber[0]=1
        bignumber[1]=1
        for i in range(2,n):
            bignumber[i]=i*bignumber[i-1]
        select=[str(i) for i in range(1,n+1)]
        res=[]
        k=k-1
        for i in range(n-1,-1,-1):
            index=k//bignumber[i]
            k=k-index*bignumber[i]
            res.append(select[index])
            select.remove(select[index])
        
        return &amp;quot;&amp;quot;.join(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不会做， 没思路，要是按照求下一个permutation方法肯定time limit exceeded。backtracking too 。&lt;br&gt;
答案思路是： k看作为以阶乘进制计数。eg. 3个数的阶乘进制base为  3!  2!  1! 0!&lt;br&gt;
某个k只是这个阶乘进制计数的值，所以先算bignumber阶乘计数base。&lt;br&gt;
k的最大位阶乘计数对应的值为 index=k//bignumber[i]   i~n-1:0。知道index就能定位出当前位应该放哪个值，由于是无放回抽样。需要删除值。 然后算下一个index。&lt;/p&gt;
">Leetcode 2021-11-06</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-05/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;41-first-missing-positive-hard&#34;&gt;41. First Missing Positive （Hard）&lt;/h1&gt;
&lt;p&gt;Given an unsorted integer array nums, return the smallest missing positive integer.&lt;br&gt;
You must implement an algorithm that runs in O(n) time and uses constant extra space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def firstMissingPositive(self, nums: List[int]) -&amp;gt; int:
        
        # full [1,2,3...len]
        # missing due to -1 , gap ..
        # e.g [3,4,-1,1]
        #     [-3,4,-5,-1]
        #      
        
        length = len(nums)
        
        for i,n in enumerate(nums):
            if n&amp;lt;=0:
                nums[i]=length+1
                #length+1  means mums[i] invalid
                
        for i,n in enumerate(nums):
            real_n = abs(n)
            pos_n = real_n-1
            if pos_n&amp;lt;=length-1:
                nums[pos_n] = -abs(nums[pos_n])
        
        for i,n in enumerate(nums):
            if n&amp;gt;0:
                return i+1
        
        return length+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 -abs（val）符号来判断是否已经扫过，注意0和负数的处理。&lt;/p&gt;
&lt;h1 id=&#34;42-trapping-rain-water-hard&#34;&gt;42. Trapping Rain Water （Hard)&lt;/h1&gt;
&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&lt;br&gt;
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;
Output: 6&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trap(self, height: List[int]) -&amp;gt; int:
        
        # 当入栈时候左边界确定
        # 当入的元素比栈顶大出栈，出栈右边界确定，计算，入栈当前值
        # 边界情况， 第一个元素入栈左边界为空
        # 
        stack = []
        res = 0
        for i,h in enumerate(height):
            while stack and h&amp;gt;height[stack[-1]]:
                #calculate
                cur = stack.pop()
                if stack:
                    left= stack[-1]  
                    right = i
                  
                    width = right-left-1  
                     
                    height_ = min(height[left],height[right])-height[cur]  
                    val = width*height_
                    res+=val
            
            stack.append(i)
        
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然做出来了， 但花了很长时间。。。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-43-multiply-strings-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 43. Multiply Strings (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.&lt;br&gt;
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;        # 1 2 3 j
        # 4 5 6 i
        #-------
        # 7 3 8
     #  6 1 5
    # 4 9 2
    #  5 6 0 8 8
   
## answer
class Solution(object):
    def multiply(self, num1, num2):
        &amp;quot;&amp;quot;&amp;quot;
        :type num1: str
        :type num2: str
        :rtype: str
        &amp;quot;&amp;quot;&amp;quot;
        res = [0]*(len(num1)+len(num2))
        for i in range(len(num1)-1,-1,-1):
            carry = 0
            for j in range(len(num2)-1,-1,-1):
                temp = int(num1[i])*int(num2[j]) + carry
                carry = (res[i+j+1] + temp) //10
                res[i+j+1] = (res[i+j+1] + temp) % 10
            res[i] += carry
        return &#39;&#39;.join(list(map(str,res))).lstrip(&#39;0&#39;) if &#39;&#39;.join(list(map(str,res))).lstrip(&#39;0&#39;) else &amp;quot;0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功做出来，但是得很细心。&lt;br&gt;
答案写的很精简，思路一样&lt;br&gt;
第二次做不会的。。。。醉了&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-44-wildcard-matching-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 44. Wildcard Matching （Hard） &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 遇到 time limit exceeded 问题
class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        
        # ? any single
        # * any sequence
        
        if not p:
            return not s
        if not s:
            if len(set(p))==1 and p[0]==&#39;*&#39;:
                return True
            return False
#       first block  way of writing           
        if p[0] in {s[0],&#39;?&#39;}:
            #match single
            return self.isMatch(s[1:],p[1:])
        elif p[0]==&#39;*&#39;:
            #match sequence     match 0 s,      match 1 s,p not change
            return self.isMatch(s,p[1:]) or self.isMatch(s[1:],p)
        elif p[0]!=s[0]:
            return False
        
#         second block way of writting   using var firstmatch     
#         firstmatch=  p[0] in {&#39;?&#39;,s[0]}              
#         if p[0]==&#39;*&#39;:
#             if len(p)==1:
#                 return True
#             else:
#                 #                 0 s                     1 s
#                 return self.isMatch(s,p[1:]) or  self.isMatch(s[1:],p)
#         else:
#             return firstmatch and self.isMatch(s[1:],p[1:])
    
            
&#39;&#39;&#39; time limit exceeded   1) remove dup*  2) using memorization of (s,p) results   &#39;&#39;&#39;  
class Solution:
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        def removedup(p):
            res=[]
            pre=None
            for e in p:
                if pre==&#39;*&#39; and e==&#39;*&#39;:
                    continue
                res.append(e)
                pre=e
            return &amp;quot;&amp;quot;.join(res)
                
        dic=dict()
        
        def M(s,p):
            if (s,p) in dic: return dic[(s,p)]
            if not p: return not s
            if not s: 
                if p==&#39;*&#39;:
                    dic[(s,p)]=True
                    return True
                else:
                    dic[(s,p)]=False
                    return False
            firstmatch= p[0] in {s[0],&#39;?&#39;}
            
            if p[0]==&#39;*&#39;:
                res=M(s,p[1:]) or M(s[1:],p)
                dic[(s,p)]=res
                return res
            else:
                res=firstmatch and M(s[1:],p[1:])
                dic[(s,p)]=res
                return res
        
        return M(s,removedup(p))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有dynamic programming 解法， 比较不熟悉， 暂时放弃。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-45-jump-game-ii-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 45. Jump Game II （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an array of non-negative integers nums, you are initially positioned at the first index of the array.&lt;br&gt;
Each element in the array represents your maximum jump length at that position.&lt;br&gt;
Your goal is to reach the last index in the minimum number of jumps.&lt;br&gt;
You can assume that you can always reach the last index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def jump(self, nums: List[int]) -&amp;gt; int:
        # i,
        # i+nums[i] is max can just at this step
        # search prev to i+nums[i], which can just further
        if len(nums)==1: return 0
        
        pos = 0 
        step = 0
        while pos&amp;lt;len(nums)-1:
            step+=1
            move_to = None
            max_can_reach = -float(&#39;inf&#39;)
            for i in range(pos,pos+nums[pos]+1):
                if i&amp;gt;=len(nums)-1: return step
                reach = i+nums[i]
                if reach&amp;gt; max_can_reach:
                    max_can_reach = reach
                    move_to = i
            pos = move_to
               
        return step

#anser way of writing
class Solution(object):
    def jump(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        n = len(nums)
        if n &amp;lt; 2:
            return 0 
        
        # max position one could reach 
        # starting from index &amp;lt;= i 
        right = nums[0]
        # max number of steps one could do
        # inside this jump
        cur = nums[0]
        
        jumps = 1
        for i in range(1, n):
            # if to reach this point 
            # one needs one more jump
            if cur &amp;lt; i:
                jumps += 1
                cur = right
            right = max(right, nums[i] + i)
                
        return jumps


class Solution:
    def jump(self, nums: List[int]) -&amp;gt; int:
        if len(nums)==1: return 0

        cur = 0
        maxright = nums[0]
        jump = 0
        for i in range(1,len(nums)):
            if cur&amp;lt;i:
                jump+=1
                cur=maxright
            maxright = max(maxright, nums[i]+i)
            
        
        return jump
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;费了点力气写出来了，思路， 如果pos不到最后一位，需要移动，step+=1， 确定移动到哪里，移动到可以使下次移动更远的index位置。 从【pos，pos+nums【pos】】中选出能达到最远的index，那个index就当前步会移动的地方。 注意再扫能移动到最远的地方时候， 如果【pos，pos+nums【pos】】已经大于等于了最后的位置，再当前步就可提前结束了，return step就行。&lt;br&gt;
答案直接扫从1到LEN（nums）的位置，right能到位置为 right = max(right, nums[i] + i)， 如果在right更新前， cur小于i， 则需要jump，jump后 cur=right。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-46-permutations-mediumfont&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 46. Permutations （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Blue because can not write the switch postion solution.&lt;br&gt;
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def permute(self, nums: List[int]) -&amp;gt; List[List[int]]:
        res =[]
        def bt(tmp):
            if len(tmp)==len(nums):
                res.append(tmp[:])
            for n in nums:
                if n not in tmp:   
                    tmp.append(n)
                    bt(tmp)
                    tmp.pop()
        
        bt([])
        return res

# aswer way of writing 用了swap 比较省检查是否在tmp那步。
class Solution:
    def permute(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &amp;quot;&amp;quot;&amp;quot;
        def backtrack(first = 0):
            # if all integers are used up
            if first == n:  
                output.append(nums[:])
            for i in range(first, n):
                # place i-th integer first 
                # in the current permutation
                nums[first], nums[i] = nums[i], nums[first]
                # use next integers to complete the permutations
                backtrack(first + 1)
                # backtrack
                nums[first], nums[i] = nums[i], nums[first]
        
        n = len(nums)
        output = []
        backtrack()
        return output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking 应用, swap方法很巧妙。&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-47-permutations-ii-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 47. Permutations II （Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def permuteUnique(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &amp;quot;&amp;quot;&amp;quot;
        
        visited = [False]*len(nums)
        
        res = []
        def bt(temp,visited):
            if len(temp)==len(nums):
                res.append(temp[:])
            
            else:
                for i in range(len(nums)):
                    
                    if visited[i] or (i&amp;gt;0 and nums[i]==nums[i-1] and not visited[i-1]) : continue 
         
                    visited[i]=True
                    temp.append(nums[i])
                    bt(temp,visited[:])
                    temp.pop()
                    visited[i]=False
                     
        
        nums.sort()
        bt([],visited)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试着用 Permutations  swap方法+if条件去重，失败， 没想到得开一个visited来记录是否访问过。 如果访问过或者提前访问（i-1 没访问但开始访问i）则continue。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#无奈做法用set去重
class Solution:
    def permuteUnique(self, nums: List[int]) -&amp;gt; List[List[int]]:

        nums.sort()
        n=len(nums)
        res = []
        def bt(tmp,first):
            if first==n:
                res.append(tmp[:])
                return
            
            for j in range(first,n):
                if j-1&amp;gt;=first and nums[j] == nums[j-1]: 
                    continue
                tmp[j],tmp[first] = tmp[first],tmp[j]
                bt(tmp,first+1)
                tmp[j],tmp[first] = tmp[first],tmp[j]
        
        bt(nums,0)
        return list(set( [tuple(e) for e in res]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;48-rotate-image-medium&#34;&gt;48. Rotate Image （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def rotate(self, matrix: List[List[int]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify matrix in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        n = len(matrix)
        
        for level in range(n//2):
            len_level = n-level*2
            
            for i in range(len_level-1):
                lefttop = matrix[level][level+i]
                righttop =matrix[level+i][level+len_level-1]
                rightbot = matrix[n-level-1][level+len_level-i-1]
                leftbot = matrix[level+len_level-i-1][level]
                
                print(lefttop,righttop,rightbot,leftbot)
                
                matrix[level+i][level+len_level-1] = lefttop
                matrix[n-level-1][level+len_level-i-1] = righttop
                matrix[level+len_level-i-1][level] = rightbot
                matrix[level][level+i] = leftbot
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;49-group-anagrams-medium&#34;&gt;49. Group Anagrams (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]:
        
        if len(strs)==1: return [strs]
        res = []
        dic = dict()
        for str in strs:
            key = &#39;&#39;.join(sorted([e for e in str]))
            if key not in dic:
                          dic[key] = []
            dic[key].append(str)
        for k,v in dic.items():
                          res.append(v)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;50-powx-n-medium&#34;&gt;50. Pow(x, n) Medium&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def myPow(self, x: float, n: int) -&amp;gt; float:
        if n==0: return 1.0
        if n&amp;lt;0:
            x=1.0/x
            n=-n
        
        if n%2==1:
            return x*self.myPow(x,n//2)**2
        else:
            return self.myPow(x,n//2)**2
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-05</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-04/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;31-next-permutation-medium&#34;&gt;31. Next Permutation （Medium）&lt;/h1&gt;
&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;br&gt;
If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).&lt;br&gt;
The replacement must be in place and use only constant extra memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextPermutation(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        #   A B
        # 2 4 5 3 1
        # 2 5 4 3 1
        # 2 5 1 3 4

        # 5 4 3 2 1

        def rev(i,j):
            while i&amp;lt;j:
                nums[i],nums[j] = nums[j],nums[i]
                i+=1
                j-=1
        A = None
        for i in reversed(range(len(nums))):
            if i-1&amp;gt;=0 and nums[i-1] &amp;lt;nums[i]:
                A = i-1
                break
        if A is None: 
            rev(0,len(nums)-1)
            return
        B = None
        for j in range(A,len(nums)):
            if nums[A]&amp;lt;nums[j]:
                B = j
        nums[A],nums[B] = nums[B],nums[A]
        rev(A+1,len(nums)-1)


class Solution:
    def nextPermutation(self, nums: List[int]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        #                     peak  &amp;lt;--      
        # 9  6  8   7  1  |2|  5  4  3 1
        #                     find first greater than 2 swap &amp;lt;-
        #                 |3|  5  4  2 1
        #                     rest just rev
        #                  3   1  4  2 5
        
        def rev(nums):
            l=0
            r=len(nums)-1
            while l&amp;lt;r:
                nums[l],nums[r]=nums[r],nums[l]
                l+=1
                r-=1
        
        l = len(nums)
        pos_a = None
        pos_b = None
        for i in range(l-1,-1,-1):
            if i-1&amp;gt;=0 and nums[i-1] &amp;lt; nums[i]:
                a = nums[i-1]
                pos_a = i-1
                break
         
        if  pos_a is None: 
            rev(nums)  
        else:
            for i in range(l-1,pos_a,-1):
                if nums[i]&amp;gt;nums[pos_a]:
                    pos_b = i
                    break
            print(pos_a,pos_b)
            nums[pos_a],nums[pos_b] = nums[pos_b],nums[pos_a]
            nums[pos_a+1:] =  nums[pos_a+1:][::-1 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路， 从最后一位开始，找到第一次drop位置标记为pos_a, 再从后向前找到第一个比num【pos_a】大的位置计为pos_b, swap value of pos_a, pos_b, 对于pos_a之后的，rev。&lt;br&gt;
what if 是 下一个更小的位置？？ drop=&amp;gt;increase,   大=&amp;gt;小&lt;/p&gt;
&lt;h1 id=&#34;font-colorred32-longest-valid-parentheses-hardfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;32. Longest Valid Parentheses （Hard）&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestValidParentheses(self, s: str) -&amp;gt; int:
        
        #&amp;quot;))))())()()(()&amp;quot;
        stack=[-1]
        res=0
        for i,n in enumerate(s):
            if n==&#39;(&#39;:
                stack.append(i)
            else:
                #n==&#39;)&#39;
                if stack:
                    stack.pop()
                
                if stack:
                    res=max(res,i-stack[-1])
                else:
                    stack.append(i)
        
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;题目有坑，如果直接用判断是否是valid parentheses方法计算长度，就掉坑里了。。。&lt;br&gt;
方法依旧是用stack， 但stack里面存的是（括号的位置，如果是（入栈， 否则出栈，出栈时候因为是），所以开始计算长度，“当前位置-stack【-1】” stack【-1】是已经pop后的位置了，所以是起始点，如果栈pop后为空，继续入栈，此为新起始点。（其实为起始点的前一位，算长度避免 j-i+1，直接j-i）&lt;/p&gt;
&lt;h1 id=&#34;font-colorred-33-search-in-rotated-sorted-array-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 33. Search in Rotated Sorted Array (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; int:
        l = 0
        r = len(nums)-1

        while l&amp;lt;=r:
            m = (l+r)//2
            if target ==nums[m]: return m

            if nums[l] &amp;lt;=nums[m]:
                #left increase
                if nums[l] &amp;lt;=target and target &amp;lt;=nums[m]:
                    r=m-1
                else:
                    l=m+1
            else:
                #right increase
                if nums[m]&amp;lt;=target and target&amp;lt;=nums[r]:
                    l=m+1
                else:
                    r=m-1

        return -1

class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; int:
        l = 0
        r = len(nums)-1
        
        while l&amp;lt;=r:
            m = (l+r)//2
            if nums[m] == target: return m
            
            #@stuck here
            if nums[l] &amp;gt; nums[m]:
                #increasing at right
                if nums[m] &amp;lt;= target and target&amp;lt;=nums[r]:
                    l = m+1
                else:
                    r = m-1
            
            else:
                #increasing at left
                if nums[l] &amp;lt;= target and target&amp;lt;=nums[m]:
                    r = m-1
                else:
                    l = m+1
        return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个必须会的题目，binary search 判断单增区间用mid 和 left 比 （mid he right比是错误的）。根据单调区间缩小搜索范围。 若先判断左丹增后判断右丹增，则需要nums[left]&amp;lt;=nums[mid]&lt;/p&gt;
&lt;h1 id=&#34;34-find-first-and-last-position-of-element-in-sorted-array-medium&#34;&gt;34. Find First and Last Position of Element in Sorted Array （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]:
        
        def bsl(nums,target):
            l=0
            r=len(nums)-1
            while l&amp;lt;=r:
                m = (l+r)//2
                
                if nums[m] &amp;gt;= target:
                    r = m-1
                else:
                    l = m+1
            return l
        
        def bsr(nums,target):
            l=0
            r=len(nums)-1
            while l&amp;lt;=r:
                m = (l+r)//2
                
                if nums[m] &amp;lt;= target:
                    l = m+1
                else:
                    r = m-1
            return r
        
        return [bsl(nums,target),bsr(nums,target)] if bsl(nums,target) &amp;lt;= bsr(nums,target) else [-1,-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;35-search-insert-position-easy&#34;&gt;35. Search Insert Position (Easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchInsert(self, nums: List[int], target: int) -&amp;gt; int:
        
        l=0
        r=len(nums)-1
        
        while l&amp;lt;=r:
            m=(l+r)//2
            if nums[m]==target:
                return m
            elif nums[m]&amp;lt;target:
                l=m+1
            else:
                r=m-1
        return l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;target 大于 mid值 说明是插入位置，l位置刚好更新为插入位置， 返回left。&lt;/p&gt;
&lt;h1 id=&#34;36-valid-sudoku-medium&#34;&gt;36. Valid Sudoku （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool:
        for row in board:
            row = [e for e in row if e!=&#39;.&#39;]
            if len(set(row))!=len(row):
                return False
        
        for col in zip(*board):
            print(col)
            col = [e for e in col if e!=&#39;.&#39;]
            if len(set(col))!=len(col):
                return False
        dic={k:[] for k in range(9)}    
        for i in range(9):
            for j in range(9):
                ind = (i//3)*3 + j//3
                dic[ind].append(board[i][j])
        
        for k,v in dic.items():
            row = [e for e in v if e!=&#39;.&#39;]
            if len(set(row))!=len(row):
                return False        
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;box index boxid = (i//3)*3+j//3 or key=(i//3,j//3)&lt;/p&gt;
&lt;h1 id=&#34;37-sudoku-solver-hard&#34;&gt;37. Sudoku Solver (hard)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def solveSudoku(self, board: List[List[str]]) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Do not return anything, modify board in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        
        row  = {i:set() for i in range(9)}
        col = {j:set() for j in range(9)}
        box = {boxid:set() for boxid in range(9)}
        
        def canplace(num,i,j):
            boxid = (i//3)*3+j//3
            if (num in row[i]) or (num in col[j]) or (num in box[boxid]):
                return False
            return True
        
        def place(num,i,j):
            boxid = (i//3)*3+j//3
            board[i][j] = num
            row[i].add(num)
            col[j].add(num)
            box[boxid].add(num)
        
        def remove(num,i,j):
            board[i][j] = &#39;.&#39;
            boxid = (i//3)*3+j//3
            row[i].remove(num)
            col[j].remove(num)
            box[boxid].remove(num)
        
        solved = False
        def placenext(i,j):
            if i==8 and j==8:
                nonlocal solved
                solved=True
            
            elif j==8:
                bt(i+1,0)
            else:
                bt(i,j+1)
        
        #@stuck place step ignored
        for i in range(9):
            for j in range(9):
                if board[i][j]!=&#39;.&#39;:
                    place(board[i][j],i,j)
                    
        
        def bt(i,j):
            
            if board[i][j]==&#39;.&#39;:
                for d in range(1,10):
                    d = str(d)
                    if canplace(d,i,j):
                        place(d,i,j)
                        placenext(i,j)

                        if not solved:
                            remove(d,i,j)
            else:
                placenext(i,j)
                            
        
        bt(0,0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要function， canplace、 remove、 placenext。 backtracking逻辑，如果要填， scan1到9，如果能填入，填入，填入下一个， 如果没有solve，去除填入值。 如果当前空不填，填入下一个。&lt;br&gt;
思路简单，但构建出思路难。&lt;/p&gt;
&lt;h1 id=&#34;38-count-and-say-medium&#34;&gt;38. Count and Say （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def countAndSay(self, n: int) -&amp;gt; str:
        
        if n==1: return &#39;1&#39;
        prev = &#39;1&#39;
        
        for i in range(n-1):
            cur = &#39;&#39;    
            pre_char = None
            c=0
            #print(&#39;in&#39;,prev)
            while prev:
                cur_char = prev[0]
                if pre_char and cur_char!=pre_char:
                    #output
                    cur+= str(c)+pre_char
                    c=1
                else:
                    c+=1
                
                pre_char = cur_char
                prev=prev[1:]
            if c:
                cur+= str(c)+pre_char
            #print(&#39;out&#39;,cur)
            prev=cur
        
        return prev
                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;not hard,but need to pay attention to details.&lt;/p&gt;
&lt;h1 id=&#34;39-combination-sum-medium&#34;&gt;39. Combination Sum (Medium)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        
        res = []
        def bt(tmp,val,start):
            if val&amp;lt;0: return
            if val==0:
                res.append(tmp[:])
                
            for i in range(start,len(candidates)):
                tmp.append(candidates[i])
                bt(tmp,val-candidates[i],i)
                tmp.pop()
                
        bt([],target,0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型的backtracking，可以重复利用元素，所以内循环中 start=i&lt;/p&gt;
&lt;h1 id=&#34;40-combination-sum-ii-medium&#34;&gt;40. Combination Sum II （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        res = []
        candidates.sort()
        def bt(tmp,val,start):
            if val&amp;lt;0:
                return
            if val==0:
                res.append(tmp[:])
            
            for i in range(start,len(candidates)):
                if i&amp;gt;start and candidates[i]==candidates[i-1]:continue
                tmp.append(candidates[i])
                bt(tmp,val-candidates[i],i+1)
                tmp.pop()
        bt([],target,0)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意去重复，也许得写个backtracking模板总结。&lt;/p&gt;
">Leetcode 2021-11-04</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-03/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;21-merge-two-sorted-lists-easy&#34;&gt;21. Merge Two Sorted Lists （Easy）&lt;/h1&gt;
&lt;p&gt;Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        dummy_head = ListNode(val=&#39;NULL&#39;)
        cur = dummy_head
        while l1 and l2:
            if l1.val&amp;lt;l2.val:
                cur.next = l1
                l1=l1.next
            else:
                cur.next = l2
                l2=l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy_head.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-generate-parentheses-medium&#34;&gt;22. Generate Parentheses (Medium)&lt;/h1&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generateParenthesis(self, n: int) -&amp;gt; List[str]:
        # 1(2)3
        # 1(2)3(4)5   1(2(3)4)5
        if n==1: return [&#39;()&#39;]
        level_result =  [&#39;()&#39;]
        for level in range(n-1):
            level_result_tmp = set()
            for result in level_result:
                for ind in range(len(result)+1):
                    if ind==0:
                        new = &#39;()&#39;+result[ind:]
                    elif ind==len(result):
                        new = result+&#39;()&#39;
                    else:
                        new = result[:ind] +&#39;()&#39;+result[ind:]
                    level_result_tmp.add(new)
            level_result = list(level_result_tmp)
        return level_result
#answer way of writing
class Solution:
    def generateParenthesis(self, n: int) -&amp;gt; List[str]:
        if n==0: return [&amp;quot;&amp;quot;]
        res =[]
        for i in range(n):
            left = self.generateParenthesis(i)
            right  = self.generateParenthesis(n-i-1)
            for l in left:
                for r in right:
                    res.append(&amp;quot;({}){}&amp;quot;.format(l,r))
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案用了递归，逻辑简单，把所有复杂表示简化为（{}）{} 。 自己方法是通过观察逐层增加构建答案。&lt;/p&gt;
&lt;h1 id=&#34;23-merge-k-sorted-lists-hard&#34;&gt;23. Merge k Sorted Lists (hard)&lt;/h1&gt;
&lt;p&gt;You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.&lt;br&gt;
Merge all the linked-lists into one sorted linked-list and return it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self,l1,l2):
        dummy_head = ListNode(val=&#39;NULL&#39;)
        cur = dummy_head
        while l1 and l2:
            if l1.val&amp;lt;l2.val:
                cur.next = l1
                l1=l1.next
            else:
                cur.next = l2
                l2=l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy_head.next
    
    def mergeKLists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]:
        
        # 0 1 2 4 5
        if not lists:
            return None
        
        elif len(lists)==1:
            return lists[0]
        
        elif len(lists)==2:
            return  self.mergeTwoLists(lists[0],lists[1])
        
        else:
            l = len(lists)
            left = self.mergeKLists(lists[:l//2])
            right = self.mergeKLists(lists[l//2:])
            return self.mergeTwoLists(left,right)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经知道merge two了， 如何merge K？递归容易写， iterative如何写(假设已经有merge2 function m2)？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; 0  1  2  3  4
 while bitmask &amp;lt; len(list)=5
bitmask = 0001
partner= rank ^ bitmask;   I am sending =  rank &amp;amp; bitmask；
0=&amp;gt;0^1=1                    False
1=&amp;gt;1^1=0                    True
2=&amp;gt;2^1=3                    False
3=&amp;gt;3^1=2                    True
4 =&amp;gt;4^1=5  (no 5)        False
  （01   1   23   3    4）
bitmask = 0010
0=&amp;gt;0^2=2                    False
1=&amp;gt;1^2=3                    False
2=&amp;gt;2^2=0                    True
3=&amp;gt;3^2=1                    True
4=&amp;gt;4^2=6 （no 6）     False
  （0123   13   23   3    4）
bitmask = 0100
0=&amp;gt;0^4 = 4                 False
1=&amp;gt;1^4= 5                  False
2=&amp;gt;2^4=6                   False
3=&amp;gt;3^4=7                   False
4=&amp;gt;4^4=0                   True 
 （01234   13   23   3    4）
或者不用bit方法，开始segmentation 是1，i 收集 i， i+seg信息， 之后segment变为2 ...
k=len(lists)
        seg=1
        while seg&amp;lt;k:
            for i in range(0,k,seg*2):
                if i+seg&amp;lt;k:
                    lists[i]=m2(lists[i],lists[i+seg]) 
            seg*=2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-swap-nodes-in-pairs-medium&#34;&gt;24. Swap Nodes in Pairs (Medium)&lt;/h1&gt;
&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        if not head or (head and not head.next): return head
        
        newhead = head.next
        tmp = newhead.next 
        newhead.next = head
        head.next = self.swapPairs(tmp)
        return newhead
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意边界条件， 至少需要2个才能玩的起来， 如果没有或者只有一个元素，直接return。&lt;/p&gt;
&lt;h1 id=&#34;25-reverse-nodes-in-k-group-hard&#34;&gt;25. Reverse Nodes in k-Group （Hard）&lt;/h1&gt;
&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;
&lt;p&gt;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.&lt;br&gt;
Input: head = [1,2,3,4,5], k = 2&lt;br&gt;
Output: [2,1,4,3,5]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]:
        
        
        cur = head
        counter = 0
        can_reverse = False
        while cur:
            counter+=1
            cur=cur.next
            if counter&amp;gt;=k:
                can_reverse = True
                break
                
        forthnode = cur 
        
        if not can_reverse:
            return head
        
        #can_reverse, let&#39;s reverse k 
        
        cur = head
        pre = None
        c=0
        while cur:
            
            curnext = cur.next
            cur.next = pre
            pre = cur
            cur = curnext
            c+=1
            if c==k:
                break
        
        head.next = self.reverseKGroup(forthnode,k)
        
        return pre 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没想到做出来了， 。。。&lt;/p&gt;
&lt;h1 id=&#34;26-remove-duplicates-from-sorted-array-easy&#34;&gt;26. Remove Duplicates from Sorted Array （Easy）&lt;/h1&gt;
&lt;p&gt;Input: nums = [1,1,2]&lt;br&gt;
Output: 2, nums = [1,2,&lt;em&gt;]&lt;br&gt;
Input: nums = [0,0,1,1,1,2,2,3,3,4]&lt;br&gt;
Output: 5, nums = [0,1,2,3,4,&lt;/em&gt;,&lt;em&gt;,&lt;/em&gt;,&lt;em&gt;,&lt;/em&gt;]&lt;br&gt;
典型的two pointer， array已经sorted，p1 保存将要储存元素位置， p2 扫nums，pre保留之前扫过的数值，如果和pre不同就保存在p1 位置， p1++&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeDuplicates(self, nums: List[int]) -&amp;gt; int:
        pre=None
        i=0
        for j,n in enumerate(nums):
            if n!=pre:
                nums[i]=nums[j]
                i+=1
            pre = n
        return i
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27-remove-element-easy&#34;&gt;27. Remove Element (Easy)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeElement(self, nums: List[int], val: int) -&amp;gt; int:
        i=0
        for j,n in enumerate(nums):
            if n!=val:
                nums[i]=n
                i+=1
        return i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in-place 依旧是考察two pointer&lt;/p&gt;
&lt;h1 id=&#34;28-implement-strstr-easy&#34;&gt;28. Implement strStr() （Easy）&lt;/h1&gt;
&lt;p&gt;Implement strStr().&lt;br&gt;
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def strStr(self, haystack: str, needle: str) -&amp;gt; int:
        if len(needle)&amp;gt;len(haystack): return -1
        res = -1
        #0 1 2 3 4
        #        4
        # 5 -1  range(5)
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred29-divide-two-integers-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;29. Divide Two Integers (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
        INT_MIN=-2**31
        INT_MAX=2**31-1
        
        if  not divisor or (dividend == INT_MIN and divisor == -1):
            return INT_MAX
        
        sign= (dividend&amp;gt;0) ^ ( divisor&amp;gt;0)
        dividend, divisor=abs(dividend), abs(divisor)
        
        c=0
        while dividend &amp;gt;= divisor:
            temp = divisor
            level = 1
            while dividend &amp;gt;= (temp&amp;lt;&amp;lt;1):
                level = level&amp;lt;&amp;lt;1
                temp = temp&amp;lt;&amp;lt;1
            
            dividend-=temp
            c+=level
            
        return -c if sign else c

###my solution

class Solution:
    def divide(self, dividend: int, divisor: int) -&amp;gt; int:
        sign = (dividend&amp;gt;0 and divisor&amp;gt;0) or (dividend&amp;lt;0 and divisor&amp;lt;0)
        divident = abs(dividend)
        divisor = abs(divisor)
        res = 0
        while divident&amp;gt;=divisor:
            mask = 1
            tmp = divisor
            while divident &amp;gt;= (tmp&amp;lt;&amp;lt;1):
                mask = mask &amp;lt;&amp;lt; 1
                tmp = tmp &amp;lt;&amp;lt; 1
            res+= mask
            divident-=tmp
        res = res if sign else -res
        if res&amp;gt;= 2**31-1: return 2**31-1
        if res&amp;lt;=-2**31:return -2**31
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;30-substring-with-concatenation-of-all-words-hard&#34;&gt;30. Substring with Concatenation of All Words (Hard)&lt;/h1&gt;
&lt;p&gt;You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findSubstring(self, s: str, words: List[str]) -&amp;gt; List[int]:
        if not s or not words: return []
        wc=Counter(words)
        nwords = len(words)
        lword = len(words[0])
        head = list(zip(*words))[0]
        res=[]
        for i in range(len(s)-lword*nwords+1):
            if s[i] in head:
                substring = s[i:i+lword*nwords]
                temp =dict()
                for j in range(nwords):
                    key = substring[j*lword:(j+1)*lword]
                    temp[key]=temp.get(key,0)+1
                if temp==wc:
                    res.append(i)
        return res  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Too late today, 知道应该用Counter_dict做比较但没写出来，思路：扫所有字符， 发现在头字符列表中，测试i:i+lword*nwords的字符范围是不是和Counter_dict一样， 一样就append i。&lt;br&gt;
two pointer + counter dict 应用。&lt;/p&gt;
">Leetcode 2021-11-03</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-02/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;11-container-with-most-water-medium&#34;&gt;11. Container With Most Water (Medium)&lt;/h1&gt;
&lt;p&gt;Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxArea(self, height: List[int]) -&amp;gt; int:
        
        res = 0
        l = 0
        r = len(height)-1
        while l&amp;lt;r:
            res = max(res, (r-l)*min([height[r],height[l]]))
            if height[l]&amp;lt;height[r]:
                l+=1
            else:
                r-=1
        return res
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;two pointer 方法， 计算 left到right之间的water，如果left小于right，得寻找更大的left所以left右移动，反之right左移动。  假如 l --- r 移动中错过了最优解，比如在 l 前，比l 还高， 那这个解已经扫过了，因为r只可能在现在的位置或者更右的位置，所有two pointer可以扫出最优解。&lt;/p&gt;
&lt;h1 id=&#34;12-integer-to-roman-medium&#34;&gt;12. Integer to Roman （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def intToRoman(self, num: int) -&amp;gt; str:
        #finding highest possible symbol, extract the val then loop until 0
        
        dic = {1000:&#39;M&#39;,900:&#39;CM&#39;,500:&#39;D&#39;,400:&#39;CD&#39;,
               100:&#39;C&#39;,90:&#39;XC&#39; ,50:&#39;L&#39;,40:&#39;XL&#39;,10:&#39;X&#39;,
              9:&#39;IX&#39;,5:&#39;V&#39;,4:&#39;IV&#39;,1:&#39;I&#39;}
        
        res = &#39;&#39;
        while num:
            for k,v in dic.items():
                if num-k &amp;gt;=0:
                    num = num-k
                    res+=v
                    break
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13-roman-to-integer-easy&#34;&gt;13. Roman to Integer (easy)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def romanToInt(self, s: str) -&amp;gt; int:
        # I before V is 4
        #          X is 9
        # X before L is 40
        #          C is 90
        # C before D is 400
        #          M is 900
        
        dic1 = {
&#39;I&#39;:             1,
&#39;V&#39;:             5,
&#39;X&#39;:             10,
&#39;L&#39;:             50,
&#39;C&#39;:             100,
&#39;D&#39;:             500,
&#39;M&#39;:             1000,}
        
        dic2={
            &#39;IV&#39;:4,
            &#39;IX&#39;:9,
            &#39;XL&#39;:40,
            &#39;XC&#39;:90,
            &#39;CD&#39;:400,
            &#39;CM&#39;:900
        }
        res = 0
        while s:
            if len(s)&amp;gt;1 and s[:2] in dic2:
                res += dic2[s[:2]]
                s=s[2:]
            elif s[0] in dic1:
                res += dic1[s[0]]
                s=s[1:]
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-longest-common-prefix-easy&#34;&gt;14. Longest Common Prefix (Easy)&lt;/h1&gt;
&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string &amp;quot;&amp;quot;.&lt;br&gt;
Example 1:&lt;/p&gt;
&lt;p&gt;Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;br&gt;
Output: &amp;quot;fl&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str:
        
        max_len = min([len(s) for s in strs])
        
        i=0
        res = &#39;&#39;
        common_char = None
        while i&amp;lt;max_len:
            for s in strs:
                char = s[i]
                if common_char is None:
                    common_char = char
                else:
                    if common_char!=char:
                        return res
            res+= common_char
            i+=1
            common_char = None
        
        return res
            
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred-15-3sum-medium-font&#34;&gt;&lt;font color=&#39;red&#39;&gt; 15. 3Sum (Medium) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.&lt;br&gt;
Notice that the solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#backtracking
class Solution:
    def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]:
        #-4 -1 -1 0 1 2
        res = []
        def bt(nums,tmp,start):
            
            
            if len(tmp)==3 and sum(tmp)==0:
                res.append(tmp[:])
            for i in range(start,len(nums)):
                if i &amp;gt; start and nums[i] == nums[i-1]: continue
                n = nums[i]
                tmp.append(n)
                bt(nums,tmp,i+1)
                tmp.pop()
        nums.sort()
        bt(nums,[],0)
        return res

#two pointer
class Solution:
    def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]:
        nums.sort()
        res=[]
        for i in range(len(nums)-2):
            cur = nums[i]
            if i-1&amp;gt;=0 and nums[i]==nums[i-1]: continue
            l = i+1
            r = len(nums)-1
            while l&amp;lt;r:
                if nums[l]+nums[r]+cur&amp;lt;0:
                    l+=1
                elif nums[l]+nums[r]+cur&amp;gt;0:
                    r-=1
                else:
                    res.append([cur,nums[l],nums[r]])
                    while l+1&amp;lt;len(nums) and nums[l]==nums[l+1]:
                        l+=1
                    while r-1&amp;gt;=0 and nums[r]==nums[r-1]:
                        r-=1
                    l+=1
                    r-=1
        return res

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;backtracking在去重复时候卡住了（但正确结果也会TIME LIMIT EXCEED），two pointer？忘记了算法。。。 选定一个target 然后 移动left 和right 注意去重。&lt;/p&gt;
&lt;h1 id=&#34;16-3sum-closest-medium&#34;&gt;16. 3Sum Closest (Medium)&lt;/h1&gt;
&lt;p&gt;Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.&lt;br&gt;
Return the sum of the three integers.&lt;br&gt;
You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&amp;gt; int:
        
        nums.sort()
        abs_diff = float(&#39;inf&#39;)
        res = float(&#39;inf&#39;)
        for i in range(len(nums)-2):
            cur = nums[i]
            left= i+1
            right = len(nums)-1
            
            while left&amp;lt; right:
                val = cur+nums[left]+nums[right] 
                
                if abs(val-target)&amp;lt; abs_diff:
                        abs_diff = abs(val-target)
                        res = val
                        
                if val&amp;gt;target:
                    right -= 1
                elif val&amp;lt;target:
                    left+=1
                else:
                    left+=1
                    right -=1

        return res
            
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-letter-combinations-of-a-phone-number-medium&#34;&gt;17. Letter Combinations of a Phone Number (Medium)&lt;/h1&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&lt;br&gt;
Example :&lt;br&gt;
Input: digits = &amp;quot;23&amp;quot;&lt;br&gt;
Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Solution:
    def letterCombinations(self, digits: str) -&amp;gt; List[str]:
        m = {
            &#39;2&#39;:&#39;abc&#39;,
            &#39;3&#39;:&#39;def&#39;,
            &#39;4&#39;:&#39;ghi&#39;,
            &#39;5&#39;:&#39;jkl&#39;,
            &#39;6&#39;:&#39;mno&#39;,
            &#39;7&#39;:&#39;pqrs&#39;,
            &#39;8&#39;:&#39;tuv&#39;,
            &#39;9&#39;:&#39;wxyz&#39;
        }
        res = []
        def bt(dig,tmp):
            if not dig:
                if tmp:
                    res.append(tmp)
                return

            cur = dig[0]
            for ch in m[cur]:
                bt(dig[1:],tmp+ch)
        bt(digits,&#39;&#39;)
        return res



class Solution:
    def letterCombinations(self, digits: str) -&amp;gt; List[str]:
        
        if not digits:
            return []
        
        dic= {
            2:&#39;abc&#39;,
            3:&#39;def&#39;,
            4:&#39;ghi&#39;,
            5:&#39;jkl&#39;,
            6:&#39;mno&#39;,
            7:&#39;pqrs&#39;,
            8:&#39;tuv&#39;,
            9:&#39;wxyz&#39;
        }
        
        res = []
        l = len(digits)
        
        def bt(digits,tmp,start):
            
            if len(tmp)==l:
                res.append(tmp[:])
            
            for i in range(start,len(digits)):
                key = int(digits[i])
                row = dic[key]
                for char in row:
                    tmp.append(char)
                    bt(digits,tmp,i+1)
                    tmp.pop()
                    
        bt(digits,[],0)
        
        return [&#39;&#39;.join(r) for r in res] if len(res)&amp;gt;0 else []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准的backtracking应用&lt;/p&gt;
&lt;h1 id=&#34;font-colorred18-4sum-mediumfont&#34;&gt;&lt;font color=&#39;red&#39;&gt;18. 4Sum （Medium）&lt;/font&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def fourSum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]:
        
        
        nums.sort()
        res = []
        
        for i in range(len(nums)-3):
            if i-1&amp;gt;=0 and nums[i-1] == nums[i]: continue
            for j in range(i+1,len(nums)-2):
                if j-1&amp;gt;i and nums[j-1]==nums[j]:continue
                    
                l=j+1
                r=len(nums)-1
                
                while l&amp;lt;r:
                    
                    if nums[i]+nums[j]+nums[l]+nums[r]&amp;lt;target:
                        l+=1
                    elif  nums[i]+nums[j]+nums[l]+nums[r]&amp;gt;target:
                        r-=1
                    else:
                        res.append([nums[i],nums[j],nums[l],nums[r]])
                        
                        while l+1&amp;lt;len(nums)  and nums[l+1]==nums[l]:
                            l+=1
                        while r-1&amp;gt;=0 and nums[r-1]==nums[r]:
                            r-=1
                        
                        l+=1
                        r-=1
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意去重判断  if i-1&amp;gt;=0 and nums[i-1] == nums[i]: continue，   if j-1&amp;gt;i and nums[j]==nums[j-1]: continue，   while l+1小于len(nums)  and nums[l+1]==nums[l]:   l+=1， while r-1&amp;gt;=0 and nums[r-1]==nums[r]:   r-=1&lt;/p&gt;
&lt;h1 id=&#34;19-remove-nth-node-from-end-of-list-medium&#34;&gt;19. Remove Nth Node From End of List （Medium）&lt;/h1&gt;
&lt;p&gt;Given the head of a linked list, remove the nth node from the end of the list and return its head.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&amp;gt; Optional[ListNode]:
        
        dummyhead = ListNode(val=&#39;NULL&#39;)
        dummyhead.next = head
        
        heada = dummyhead
        headb = dummyhead
        
        for i in range(n):
            headb = headb.next
        
        while headb and headb.next:
            
            heada = heada.next
            headb = headb.next
            
        
        heada.next = heada.next.next
        
        return dummyhead.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-valid-parentheses-easy&#34;&gt;20. Valid Parentheses (Easy)&lt;/h1&gt;
&lt;p&gt;Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&lt;br&gt;
An input string is valid if:&lt;br&gt;
Open brackets must be closed by the same type of brackets.&lt;br&gt;
Open brackets must be closed in the correct order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValid(self, s: str) -&amp;gt; bool:
        # meet （ push in stack 
        # meet  ）pop outof stack
        
        
        
        dic={&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;}
        stack = []
        
        for char in s:
            if char in {&#39;(&#39;,&#39;[&#39;,&#39;{&#39;}:
                stack.append(char)
            else:
                #pop
                if not stack:
                    return False
                
                top_stack = stack.pop()
                if top_stack!= dic[char]: 
                    return False
        
        return not stack


#simply way of writing code
class Solution:
    def isValid(self, s: str) -&amp;gt; bool:
        
        dic = {&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;}
        stack = []
        for e in s:
            if e in dic:
                #pop
                if not stack or stack[-1]!=dic[e]:
                    return False
                stack.pop()
            else:
                stack.append(e)
        return not stack
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 2021-11-02</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/leetcode-2021-11-01/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;1-two-sum-easy&#34;&gt;1. Two Sum （Easy）&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]:
       dic = dict()
       for i, n in enumerate(nums):
           if target - n in dic:
               return [i, dic[target-n]]
           dic[n] = i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;笨方法，double loop， 找到加和是target。O（N**2）&lt;br&gt;
实际解法，用map存位置，如果target-n 剩余的在之前存过的map里，说明 target-n 和 n 就是要求的结果。&lt;/p&gt;
&lt;h1 id=&#34;2-add-two-numbers-medium&#34;&gt;2. Add Two Numbers （Medium）&lt;/h1&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]:
        
        result = ListNode(&#39;NULL&#39;)
        head = result
        carry = 0 
        while l1 or l2:
        
            l1val = 0 
            l2val = 0
            if l1:
                l1val = l1.val
                l1 = l1.next
            if l2:
                l2val = l2.val
                l2 = l2.next
            
            val = (l1val+l2val+carry)%10
            carry = (l1val+l2val+carry)//10
            head.next = ListNode(val=val)
            head = head.next
        
        if carry:
            head.next = ListNode(val=carry)
        
        
        return result.next

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经是reverse ordered linked list，所以可以直接对l1,l2的val加和， 但是需要注意carry 以及 l1 or l2 可能在loop到下一位时提前空了， 所以预先定义l1val=0 和l2val=0 有value就overwrite，最后检查是否还有carry， 有就新建个ListNode存carry。返回结果。&lt;/p&gt;
&lt;h1 id=&#34;3-longest-substring-without-repeating-characters-medium&#34;&gt;3. Longest Substring Without Repeating Characters （Medium）&lt;/h1&gt;
&lt;p&gt;Given a string s, find the length of the longest substring without repeating characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
   def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
       #when meet the overlapping char, start = overlapping char pos end =current char pos -1
       #when not meet overlapping char, start stil old start end = current char pos
       
       if s == &#39; &#39;: return 1
       if not s: return 0
       result = 0
       dic = dict()
       start = 0
       for i,char in enumerate(s):
           if (char in dic) and (dic[char]&amp;gt;=start):
               #find a overlapping char
               start = dic[char]
               tmp_result = i-start
               result = max(result,tmp_result)
               start = start + 1
           else:
               # no overlapping
               # 0 1 2
               tmp_result = i-start+1
               result = max(result,tmp_result)
               
               
    
           dic[char] = i
       
       return result

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;花了些时间还是写出答案了，但是时间较长，解题思路：&lt;br&gt;
如果存在已经见过的char，更新结果result = max（result， i-dic[char]），老的已经见过char的下一位是新的起始点， 如果没见过char，则同样更新结果 result = max（result， i-start+1）,&lt;br&gt;
但注意 start 这个位置一直应该是单增的， 所以 有这行判断 if (char in dic) and (dic[char]&amp;gt;=start)   例子： abba，如果没这行判断， start 在遇到第二个a时候会重置回0，明显错误。 根据leetcode 这种解法属于sliding window。&lt;br&gt;
精简写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
        
        dic = dict()
        res = 0
        start = 0
        for i,char in enumerate(s):
            if char in dic:
                start = max(start,dic[char]+1) # a b ..... a  # start=b pos
            res = max(res, i-start+1)
            dic[char] = i
            
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-median-of-two-sorted-arrays-hard&#34;&gt;4. Median of Two Sorted Arrays (Hard)&lt;/h1&gt;
&lt;p&gt;Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.&lt;br&gt;
The overall run time complexity should be O(log (m+n)).&lt;br&gt;
粗暴解法直接重新排序求中位数，但不满足 O(log (m+n))， 说明用了二分法。&lt;br&gt;
中位数定义是一半的数， 则假设有个分界线 | 同时分开nums1，nums2.&lt;br&gt;
nums1[0] nums1[1] ... nums1[i-1] | nums1[i] ... nums1[m-1]&lt;br&gt;
nums2[0] nums2[1] ... nums2[j-1] | nums2[j] ... nums2[n-1]&lt;br&gt;
median    nums1[i-1] 小于 nums2[j]&lt;br&gt;
nums2[j-1] 小于 nums1[i]&lt;br&gt;
i+j =  (m+n +1)//2&lt;br&gt;
i: 0~m  j = (m+n+1)//2 - i     m小于n&lt;/p&gt;
&lt;p&gt;在 0~m中 二分查找&lt;br&gt;
确定 i&lt;br&gt;
确定 j&lt;br&gt;
知道 | 边界情况来决定是左移还是右移动搜索边界&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:
        # nums1[0] nums1[1] ... nums1[i-1] | nums1[i] ... nums1[m-1]
        # nums2[0] nums2[1] ... nums2[j-1] | nums2[j] ... nums2[n-1]
        
        # median    nums1[i-1]&amp;lt;nums2[j]
        #           nums2[j-1]&amp;lt;nums1[i]
        #           i+j =  (m+n +1)//2
        #           i: 0~m  j = (m+n+1)//2 - i     m&amp;lt;n
        
        #edge cases
        if nums1 and not nums2:
            if len(nums1)%2==1:
                return nums1[len(nums1)//2]
            else:
                return  (nums1[len(nums1)//2] +  nums1[len(nums1)//2-1])/2.0
        
        if nums2 and not nums1:
            if len(nums2)%2==1:
                return nums2[len(nums2)//2]
            else:
                return  (nums2[len(nums2)//2] +  nums2[len(nums2)//2-1])/2.0
        
        m = len(nums1)
        n = len(nums2)
        
        if m&amp;gt;n:
            m,n= n,m
            nums1,nums2=nums2,nums1
        
        left = 0
        right = m
        while left &amp;lt;= right:
            
            i = (left+right)//2
            j = (m+n+1)//2 - i
            
            if i-1&amp;gt;=0 and nums1[i-1] &amp;gt; nums2[j]:
                # i is too large
                right = i-1
            elif i&amp;lt;m and nums2[j-1] &amp;gt; nums1[i]:
                #i is too small
                left = i+1
            else:
                
                if i==0:
                    larget_left=nums2[j-1]
                elif j==0:
                    larget_left = nums1[i-1]
                else:
                    larget_left = max(nums2[j-1],nums1[i-1])
                
                if (m+n)%2==1: return larget_left
                
                
                if i==m:
                    smaller_right = nums2[j]
                elif j==n:
                    smaller_right = nums1[i]
                else:
                    smaller_right = min(nums1[i],nums2[j])
                    
                
                return (larget_left+smaller_right)/2.0
                    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接copy了答案。。。&lt;/p&gt;
&lt;h1 id=&#34;font-colorblue-5-longest-palindromic-substring-medium-font&#34;&gt;&lt;font color=&#39;blue&#39;&gt; 5. Longest Palindromic Substring （Medium） &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given a string s, return the longest palindromic substring in s.&lt;br&gt;
Input: s = &amp;quot;babad&amp;quot;&lt;br&gt;
Output: &amp;quot;bab&amp;quot;&lt;br&gt;
Note: &amp;quot;aba&amp;quot; is also a valid answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Best Answer
class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; str:
        res = &amp;quot;&amp;quot;
        resLen = 0

        for i in range(len(s)):
            #odd length
            l,r = i,i
            while l&amp;gt;=0 and r&amp;lt;len(s) and s[l]==s[r]:
                if (r-l+1)&amp;gt;resLen:
                    res = s[l:r+1]
                    resLen = r-l+1
                l-=1
                r+=1
            #enven length
            l,r = i,i+1
            while l&amp;gt;=0 and r&amp;lt;len(s) and s[l]==s[r]:
                if (r-l+1)&amp;gt;resLen:
                    res = s[l:r+1]
                    resLen = r-l+1
                
                l-=1
                r+=1
        
        return res


class Solution:
    def longestPalindrome(self, s: str) -&amp;gt; str:
        
        # ith pos, s[i-length]~ s[i] is palindrome 
        #     ith
        #  0 1 2
        #  b a b
        #         or s[i-length-1]~s[i] is palindrome
        
        if not s: return s
        if len(s)==1: return s
        length = 1
        string = s[0]
        
        for i in range(len(s)):
            if (i-length&amp;gt;=0) and (s[i-length:i+1] == s[i-length:i+1][::-1]):
                l = len(s[i-length:i+1])
                if l &amp;gt; length:
                    string = s[i-length:i+1]
                    length = l
                    
            
            if (i-length-1&amp;gt;=0) and s[i-length-1:i+1] == s[i-length-1:i+1][::-1]:
                l = len( s[i-length-1:i+1])
                if  l &amp;gt; length:
                    string = s[i-length-1:i+1]
                    length = l

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-zigzag-conversion-medium&#34;&gt;6. Zigzag Conversion （Medium）&lt;/h1&gt;
&lt;p&gt;The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;p&gt;P   A   H   N&lt;br&gt;
A P L S I I G&lt;br&gt;
Y   I   R&lt;/p&gt;
&lt;p&gt;And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/p&gt;
&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;
&lt;p&gt;string convert(string s, int numRows);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def convert(self, s: str, numRows: int) -&amp;gt; str:
        
        if numRows == 1: return s
        
        #init rows
        res = [[] for _ in range(numRows)]
        #
        direction_down = True
        #y_pos is the next y_pos char sitting at
        y_pos = 0
        #
        for char in s:
            res[y_pos].append(char)
            
            if direction_down:
                y_pos += 1
                if y_pos == numRows:
                    #revert pos
                    direction_down = not direction_down
                    y_pos = numRows-1-1
            else:
                y_pos -= 1
                if y_pos == -1:
                    #revert pos
                    direction_down = not direction_down
                    y_pos = 1
                    
        return &#39;&#39;.join([&#39;&#39;.join(row) for row in res])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意numRows==1 edge case&lt;/p&gt;
&lt;h1 id=&#34;7-reverse-integer-medium&#34;&gt;7. Reverse Integer （Medium）&lt;/h1&gt;
&lt;p&gt;Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2&lt;strong&gt;31, 2&lt;/strong&gt;31 - 1], then return 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reverse(self, x: int) -&amp;gt; int:
        
        sign = 1 if x&amp;gt;=0 else -1
        x = abs(x)
        res = 0
        while x:
            last_dig = x%10
            res = res*10 + last_dig
            x = x//10
            
        return res*sign if (res*sign&amp;gt;=-2**31 and res*sign&amp;lt;=2**31-1) else 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-string-to-integer-atoi-medium&#34;&gt;8. String to Integer (atoi) （Medium）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def myAtoi(self, s: str) -&amp;gt; int:
        sign = 1
        #1)remove leading white space
        while s and s[0] == &#39; &#39;:
            s = s[1:]
        #2) check +/-
        if len(s)&amp;gt;1 and s[0] in {&#39;-&#39;,&#39;+&#39;}:
            s0 = s[0]
            s = s[1:]
            if s0 == &#39;-&#39;:
                sign = -1
        #3) read next until next none-dig/end
        i = 0
        while (i&amp;lt;len(s)) and (s[i] in &#39;0123456789&#39;)   :
            i+=1
        string = s[:i]
        #4) conver to int
        res = int(string) if string else 0
        #5) clamp res
        res = res*sign
        if res&amp;lt;-2**31:
            res = -2**31
        if res&amp;gt; 2**31-1:
            res = 2**31-1
        
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照题目要求写每个判断，很easy。&lt;/p&gt;
&lt;h1 id=&#34;9-palindrome-number-easy&#34;&gt;9. Palindrome Number （easy）&lt;/h1&gt;
&lt;p&gt;Given an integer x, return true if x is palindrome integer.&lt;/p&gt;
&lt;p&gt;An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isPalindrome(self, x: int) -&amp;gt; bool:
        x_backup = x
        if x&amp;lt;0: return False
        res = 0
        while x:
            last_dig = x%10
            res = res*10 + last_dig
            x = x//10
        return res == x_backup
        
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;font-colorred10-regular-expression-matching-hard-font&#34;&gt;&lt;font color=&#39;red&#39;&gt;10. Regular Expression Matching (Hard) &lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;Given an input string s and a pattern p, implement regular expression matching with support for &#39;.&#39; and &#39;*&#39; where:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;.&#39; Matches any single character.​​​​
&#39;*&#39; Matches zero or more of the preceding element.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The matching should cover the entire input string (not partial).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    @lru_cache(None)
    def isMatch(self, s: str, p: str) -&amp;gt; bool:
        #               .match one
        # p[0] is .   isMatch[s[1:],p[1:]]
        #               *match 0/more p[0]
        # p[1] is *   if * match 0 p[0]
        #               isMatch(s, p[2:])
        #              if * match more p[0]
        #                s[0]==p[0] and isMatch(s[1:],p)
        
        if not p:
            return not s
        
        
        firstmatch = p[0] in {s[0],&#39;.&#39;} if s else False
    
        
        if len(p)&amp;gt;1 and p[1]==&#39;*&#39;:
            #start matching
            return (firstmatch and self.isMatch(s[1:],p)) or self.isMatch(s,p[2:])
        else:
            #normal matching
            return firstmatch and self.isMatch(s[1:],p[1:])
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意判断 p[0] in {s[0],&#39;.&#39;} if s else False  这里的if s不为空。差一点写出来。。。&lt;/p&gt;
">Leetcode 2021-11-01</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/er-fen-fa-mo-ban/"" data-c="
          &lt;p&gt;Binary Search 模板总结&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1&#34;&gt;1&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left &amp;lt;= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid + 1
        else:
            right = mid - 1

    # End Condition: left &amp;gt; right
    return -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2&#34;&gt;2&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)
    while left &amp;lt; right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:
        return left
    return -1

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3&#34;&gt;3&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarySearch(nums, target):
    &amp;quot;&amp;quot;&amp;quot;
    :type nums: List[int]
    :type target: int
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left + 1 &amp;lt; right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &amp;lt; target:
            left = mid
        else:
            right = mid

    # Post-processing:
    # End Condition: left + 1 == right
    if nums[left] == target: return left
    if nums[right] == target: return right
    return -1
&lt;/code&gt;&lt;/pre&gt;
">二分法模板</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/da-jia-lai-zhao-chi-wen-zi-ban/"" data-c="
          &lt;p&gt;&lt;a href=&#34;/zhaocha&#34;&gt;点击PLAY大家来找茬&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://headhuanglan.github.io/post-images/1635790537514.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;准备写个大家来找茬的文字版，需要找出所有中文的形状相似字符对，已知GBK下33088-65278为中文编码。找个字库文件比如FZLanTingHei-R-GBK.TTF，把字符黑白矩阵转成一个向量，然后算所有文字对的COS相似度就可以了，算法很简单。 开搞！&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import string
from PIL import Image
from PIL import ImageFont
from PIL import ImageDraw
import numpy as np

fobidden_chars = {&#39;■&#39;,&#39;●&#39;,&#39;︱&#39;, &#39;｜&#39;,&#39;▉&#39; ,&#39;▼&#39;,&#39;▊&#39;,&#39;█&#39;, &#39;▇&#39;,&#39;▇&#39;}.union(set(&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;))

def char_to_pixels(text, path=&#39;font.ttf&#39;, fontsize=80):
    font = ImageFont.truetype(path, fontsize) 
    #getsize lead to w, h change for diffrent chars 
    #w, h = font.getsize(text)  
    w, h = fontsize+5, fontsize+5 
    #print(w,h)
    h *= 2
    image = Image.new(&#39;L&#39;, (w, h), 1)  
    draw = ImageDraw.Draw(image)
    draw.text((0, 0), text, font=font) 
    arr = np.asarray(image)
    arr = np.where(arr, 0, 1)
    #arr = arr[(arr != 0).any(axis=1)]
    return arr
    
def display(arr):
    result = np.where(arr, &#39;1&#39;, &#39;0&#39;)
    print(&#39;\n&#39;.join([&#39;&#39;.join(row) for row in result]))

def get_distance(vecs,me):
    #calculate the cos distance of me with other vecs
    dst = (np.dot(vecs, me) / np.linalg.norm(vecs, axis=1) / np.linalg.norm(me))
    return dst
    
def get_closest_chars (li_arrs, vec,li_gbk_chars, number=6):
    dst = get_distance(li_arrs, vec)
    gbk_char_ids = np.argsort(-dst)
    return [li_gbk_chars[ind] for ind in gbk_char_ids[:number] ]
    
if __name__ == &#39;__main__&#39;:
	li_gbk_chars = []
	li_arrs = []
	#GBK 33088-65278
	for ind in range(33088,65278+1):
		try:
		  gbk_char =  bytes.fromhex(str(hex(ind))[2:]).decode(&amp;quot;GBK&amp;quot;)
		  if gbk_char in fobidden_chars: continue
		  arr = char_to_pixels(gbk_char,&#39;./FZLanTingHei-R-GBK.TTF&#39;)
		  #print(gbk_char)
		  #display(arr)
		  li_gbk_chars.append(gbk_char) 
		  #print(gbk_char, arr)
		  li_arrs.append(arr.reshape(-1)) 	
		  #print(arr.reshape(-1).shape)	  	
		except:
			pass
&lt;/code&gt;&lt;/pre&gt;
">大家来找茬(文字版)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://headhuanglan.github.io/post/about/"" data-c="
          &lt;p&gt;记录下刷题过程以及一些随机想法~~&lt;/p&gt;
&lt;!-- more --&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>
    
      <input hidden id="copy" />
      <script>
        !function () {
          let times = document.querySelectorAll('.publish-time');
          for (let i = 0; i < times.length; i++) {
            let date = times[i].dataset.t;
            let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
            if (time < 60) {
              str = time + '秒之前';
            } else if (time < 3600) {
              str = Math.floor(time / 60) + '分钟之前';
            } else if (time >= 3600 && time < 86400) {
              str = Math.floor(time / 3600) + '小时之前';
            } else if (time >= 86400 && time < 259200) {
              str = Math.floor(time / 86400) + '天之前';
            } else {
              str = times[i].textContent;
            }
            times[i].textContent = str;
          }
        }();
      </script>

      <script>
        let language = '';
        if (language !== '') {
          let map = new Map();
          if (language === 'en') {
            map.set('search', 'Search');
            map.set('category', 'Categories');
            map.set('article', 'Articles');
            map.set('tag', 'Tags');
            map.set('top', 'Top');
            map.set('publish', 'published');
            map.set('minute', ' minutes');
            map.set('read-more', 'Read More');
            map.set('view', 'View');
            map.set('words', ' words');
            map.set('category-in', 'category in');
            map.set('preview', 'Meta');
            map.set('index', 'Toc');
            map.set('no-archives', "You haven't created yet");
            map.set('archives', " articles in total");
            map.set('cloud-tags', " tags in total");
            map.set('copyright', "Copyright: ");
            map.set('author', "Author: ");
            map.set('link', "Link: ");
            map.set('leave-message', "Leave a message");
            map.set('format', "Links Format");
            map.set('site-name', "Name: ");
            map.set('site-link', "Link: ");
            map.set('site-desc', "Desc: ");
            map.set('stat', " related results, taking ");
            map.set('stat-time', " ms");
            map.set('site-img', "Image: ");
          }

          if (map.size > 0) {
            let lanElems = document.querySelectorAll('.language');
            lanElems.forEach(elem => {
              let lan = elem.dataset.lan, text = map.get(lan);
              if (elem.__proto__ === HTMLInputElement.prototype) {
                elem.placeholder = text
              } else {
                if (elem.dataset.count) {
                  text = elem.dataset.count + text;
                }
                elem.textContent = text;
              }
            })
          }
        }

        window.Clipboard = (function (window, document, navigator) {
          var textArea,
            copy;

          // 判断是不是ios端
          function isOS() {
            return navigator.userAgent.match(/ipad|iphone/i);
          }
          //创建文本元素
          function createTextArea(text) {
            textArea = document.createElement('textArea');
            textArea.value = text;
            textArea.style.width = 0;
            textArea.style.height = 0;
            textArea.clientHeight = 0;
            textArea.clientWidth = 0;
            document.body.appendChild(textArea);
          }
          //选择内容
          function selectText() {
            var range,
              selection;

            if (isOS()) {
              range = document.createRange();
              range.selectNodeContents(textArea);
              selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
              textArea.setSelectionRange(0, 999999);
            } else {
              textArea.select();
            }
          }

          //复制到剪贴板
          function copyToClipboard() {
            try {
              document.execCommand("Copy")
            } catch (err) {
              alert("复制错误！请手动复制！")
            }
            document.body.removeChild(textArea);
          }

          copy = function (text) {
            createTextArea(text);
            selectText();
            copyToClipboard();
          };

          return {
            copy: copy
          };
        })(window, document, navigator);

        function copyCode(e) {
          if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
            let code = e.currentTarget.querySelector('code');
            var text = code.innerText;
            if (e.srcElement.textContent === '复制成功') {
              return;
            }
            e.srcElement.textContent = '复制成功';
            (function (elem) {
              setTimeout(() => {
                if (elem.textContent === '复制成功') {
                  elem.textContent = '复制代码'
                }
              }, 1000);
            })(e.srcElement)
            Clipboard.copy(text);
          }
        }

        let pres = document.querySelectorAll('pre');
        pres.forEach(pre => {
          let code = pre.querySelector('code');
          let copyElem = document.createElement('span');
          copyElem.classList.add('copy-code');
          copyElem.textContent = '复制代码';
          pre.appendChild(copyElem);
          pre.onclick = copyCode
        })

      </script>
      <script src="/media/js/motion.js"></script>

      
        <script
          src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
        <script>
          var scroll = new SmoothScroll('a[href*="#"]', {
            speed: 200
          });
        </script>
        
          
            

                
</html>