<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-03-14T04:42:21.070Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-02/">
        </link>
        <updated>2022-03-02T09:50:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-411-minimum-unique-word-abbreviation-hardfont"><font color='red'> 411. Minimum Unique Word Abbreviation （Hard）</font></h1>
<p>A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
Note that &quot;s55n&quot; (&quot;s ubsti tutio n&quot;) is not a valid abbreviation of &quot;substitution&quot; because the replaced substrings are adjacent.<br>
The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation &quot;s10n&quot; has a length of 3 (2 letters + 1 substring) and &quot;su3i1u2on&quot; has a length of 9 (6 letters + 3 substrings).<br>
Given a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.</p>
<pre><code class="language-python">class Solution:
    def minAbbreviation(self, target: str, dictionary: List[str]) -&gt; str:

        def abbr(target, num):
            word, count = '', 0
            for w in target:
                if num &amp; 1 == 1:
                    if count:
                        word += str(count)
                        count = 0
                    word += w
                else:
                    count += 1

                num &gt;&gt;= 1
            if count:
                word += str(count)
            return word

        m = len(target)

        # Figure out the different bits for a same length word in the dictionary
        diffs = []
        for word in dictionary:
            if len(word) != m:
                continue

            # The encoding is opposite
            bits = 0
            for i, char in enumerate(word):
                if char != target[i]:
                    bits += 2 ** i
            diffs.append(bits)

        # No word in dictionary has same length, return the shortest
        if not diffs:
            return str(m)        

        abbrs = []
        for i in range(2 ** m):
            # This abbreviation at least has one word different to every words in the dictionary
            if all(d &amp; i for d in diffs):
                abbrs.append(abbr(target, i))

        return min(abbrs, key=lambda x: len(x))
</code></pre>
<p>思路是bit manipulation。 1）找出在字典里同长度但字符和target不同的bit。 然后所有的encoding是0到2^m， 所以  all（encoding&amp;dif for dif in diffs）  encoding的bit能和所有dif bits有交集则是个可能的候选，把 encoding bit转换为string然后加入到abbrs中，最后找出长度最小的abbrs就可以了。</p>
<h1 id="412-fizz-buzz-easy">412. Fizz Buzz （Easy）</h1>
<p>Given an integer n, return a string array answer (1-indexed) where:<br>
answer[i] == &quot;FizzBuzz&quot; if i is divisible by 3 and 5.<br>
answer[i] == &quot;Fizz&quot; if i is divisible by 3.<br>
answer[i] == &quot;Buzz&quot; if i is divisible by 5.<br>
answer[i] == i (as a string) if none of the above conditions are true.</p>
<pre><code class="language-python">class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        def helper(n):
            if n%3==0 and n%5==0:
                return 'FizzBuzz'
            elif n%3==0:
                return 'Fizz'
            elif n%5==0:
                return 'Buzz'
            else:
                return str(n)
        
        return [helper(i) for i in range(1,n+1)]
</code></pre>
<h1 id="413-arithmetic-slices-medium">413. Arithmetic Slices (Medium)</h1>
<p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.<br>
Given an integer array nums, return the number of arithmetic subarrays of nums.<br>
A subarray is a contiguous subsequence of the array.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        #   [1,3,5,7,9]
        # dp 0 0 1 
        #          2
        #            3  
        # dp is the number of subarays ending in ith
        if len(nums)&lt;3: return 0
        dp=[0]*len(nums)
        if nums[0]-nums[1]==nums[1]-nums[2]:
            dp[2]=1
        
        if len(nums)==3: return dp[2]
        for i in range(3,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp[i]=1+dp[i-1]
        return sum(dp)
#ANSWER
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        dp=0
        res=0
        for i in range(2,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp=1+dp
                res+=dp
            else:
                dp=0
        return res        
</code></pre>
<p>思路和答案一致，DP解决。</p>
<h1 id="414-third-maximum-number-easy">414. Third Maximum Number （Easy）</h1>
<p>Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.</p>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        if len(set(nums))&lt;3: return max(nums)
        if len(set(nums))==3: return sorted(set(nums))[0]
        res=[]
        for n in set(nums):
            heapq.heappush(res,-n)
        heapq.heappop(res)
        heapq.heappop(res)
        return -heapq.heappop(res)

#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        maximums = set()
        for num in nums:
            maximums.add(num)
            if len(maximums) &gt; 3:
                maximums.remove(min(maximums))
        if len(maximums) == 3:
            return min(maximums)
        return max(maximums)
#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        min_heap = []
        for num in nums:
            if num in min_heap:
                continue
            if len(min_heap) &lt; 3:
                heapq.heappush(min_heap, num)
            elif len(min_heap) == 3:
                heapq.heappushpop(min_heap, num)        
        
        if len(min_heap) == 3:
            return heapq.heappop(min_heap)
        else:
            while min_heap:
                result = heapq.heappop(min_heap)
            return result

#3pointer...
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        max=float('-inf')
        max2=float('-inf')
        max3=float('-inf')
        s=set()
        for n in nums:
            if n in s: continue
            if n&gt;max:
                max3=max2
                max2=max
                max=n
            elif n&gt;max2:
                max3=max2
                max2=n
            elif n&gt;max3:
                max3=n
                
            s.add(n)
         
        return max3 if len(s)&gt;=3 else max
</code></pre>
<h1 id="415-add-strings-easy">415. Add Strings (Easy)</h1>
<p>Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.<br>
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.</p>
<pre><code class="language-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        
        n1=[int(e) for e in num1]
        n2=[int(e) for e in num2]
        res=[]
        carry=0
        while n1 or n2:
            a=n1.pop() if n1 else 0
            b=n2.pop() if n2 else 0
            val=(a+b+carry)%10
            carry=(a+b+carry)//10
            res.append(val)
        if carry:
            res.append(carry)
        
        return ''.join(map(str,res[::-1]))

</code></pre>
<h1 id="font-colorred-416-partition-equal-subset-sum-medium-font"><font color='red'> 416. Partition Equal Subset Sum (Medium) </font></h1>
<p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<pre><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        @lru_cache(None)
        def dfs(n,subset_sum):
            if subset_sum==0:
                return True
            if n==0 or subset_sum&lt;0:
                return False
            result = dfs(n-1,subset_sum-nums[n-1]) or dfs(n-1,subset_sum)
            return result
        
        total_sum=sum(nums)
        if total_sum%2==1: return False
        subset_sum=total_sum//2
        n=len(nums)
        return dfs(n,subset_sum)
###DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2
        n = len(nums)

        # construct a dp table of size (n+1) x (subset_sum + 1)
        # dp[n][subsetsum] up to nth num can sum to subsetsum
        dp = [[False] * (subset_sum + 1) for _ in range(n + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            curr = nums[i - 1]
            for j in range(subset_sum + 1):
                if j &lt; curr:
                    # subset_sum&lt; nums[i-1]   so, subsetsum not include nums[i-1]
                    dp[i][j] = dp[i - 1][j]
                else:
                    # could not include or include nums[i-1] 
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - curr]
        return dp[n][subset_sum]

#DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2

        # construct a dp table of size (subset_sum + 1)
        dp = [False] * (subset_sum + 1)
        dp[0] = True
        for curr in nums:
            for j in range(subset_sum,curr-1,-1):
                dp[j] = dp[j] or dp[j - curr]

        return dp[subset_sum]
</code></pre>
<p>没思路。。。 有两种情况，1) num in subset_sum  2) num not in subset_sum 所以dfs</p>
<h1 id="417-pacific-atlantic-water-flow-medium">417. Pacific Atlantic Water Flow （Medium）</h1>
<pre><code class="language-python">class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -&gt; List[List[int]]:
        
        #two bfs from boundy if hight is higher..
        
        visited=set()
        q=[]
        m=len(heights)
        n=len(heights[0])
        for row in range(m):
            visited.add((row,0))
            q.append((row,0))
        for col in range(1,n):
            visited.add((0,col))
            q.append((0,col))
        
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited and heights[row][col]&gt;=heights[r][c]:
                    visited.add((row,col))
                    q.append((row,col))
        
        
        visited2=set()
        q=[]
        for row in range(m):
            visited2.add((row,n-1))
            q.append((row,n-1))
        for col in range(n-1):
            visited2.add((m-1,col))
            q.append((m-1,col))
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited2 and heights[row][col]&gt;=heights[r][c]:
                    visited2.add((row,col))
                    q.append((row,col))
        
        return visited&amp;visited2

</code></pre>
<p>思路，从边界处做两次BFS，相交地方就是结果。</p>
<h1 id="font-colorred-418-sentence-screen-fitting-medium-font"><font color='red'> 418. Sentence Screen Fitting （Medium） </font></h1>
<p>Given a rows x cols screen and a sentence represented as a list of strings, return the number of times the given sentence can be fitted on the screen.<br>
The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.</p>
<pre><code class="language-python">#TIME LIMIT EXCEEDED
class Solution:
    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        sentence=[len(w) for w in sentence]
        r=0
        c_row=0
        res=0
        i=0
        while r&lt;rows:
            
            l=sentence[i]
            #print(r,c_row,l)
            if c_row+l&lt;cols:
                c_row = c_row+l+1
                if c_row==cols:
                    c_row=0
                    r+=1
                    if r&gt;=rows:
                        if i==len(sentence)-1: res+=1
                        break
            elif c_row+l==cols:
                c_row=0
                r+=1
            elif c_row+l&gt;cols:
                c_row=l+1
                r+=1
                if r&gt;=rows:
                    break
                #print('#',c_row,r)
            if i==len(sentence)-1: res+=1
            i=(i+1)%len(sentence)
        return res

#ANSWER
#case 1: sentence_ptr at the end of the screen falls on space in the sentence. Go to the next letter sentence_ptr+1 in the next row of the screen.
#case 2: sentence_ptr at the end of the screen falls on the last letter of a word. We skip the space in the sentence as the last letter coincides with the screen end: sentence_ptr+2
#case 3: sentence_ptr points in the middle of a word at the end of the screen: roll back sentence_ptr till there's a space in the sentence. his corresponds to starting to fill the word in the next row, as it does not fit into the current. sentence_ptr &gt; 0 is needed for the case when a word is longer than cols; sentence_ptr will be &lt; len(s)

#Code with the comments and the variable change:

    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        s = ' '.join(sentence) + ' '
        sentence_ptr = 0
        for i in range(rows):
            sentence_ptr += cols - 1
            # case 1: sentence_ptr at the end of screen falls exactly on the space
            if s[sentence_ptr % len(s)] == ' ':
                sentence_ptr += 1
            # case 2: sentence_ptr at the end of screen coincides with the last letter of a word (next is space)
            elif s[(sentence_ptr + 1) % len(s)] == ' ':
                sentence_ptr += 2
            else:
                # case 3: sentence_ptr at the end of screen falls in the middle of a word; roll back
                while sentence_ptr &gt; 0 and s[(sentence_ptr - 1) % len(s)] != ' ':
                    sentence_ptr -= 1
        return sentence_ptr // len(s)

</code></pre>
<p>初次尝试是TLE。。。 直接暴力解即使考虑全了cornercase也还是过不了。<br>
答案思路，先组成一个句子 s=‘ ‘.join（sentence）+’‘。  定义sentence_ptr 每过一行，sentence_ptr+= cols-1 这时候分3种情况， 1） 如果恰巧sentence_ptr落的位置是空格，senternce_ptr+1 2)如果 sentence_ptr+1位置是空格，sentence_ptr+=2 3)sentence_ptr落在字符上，那么sentence_ptr得往回缩直到遇到空格。</p>
<h1 id="419-battleships-in-a-board-medium">419. Battleships in a Board （Medium）</h1>
<p>Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.<br>
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p>
<pre><code class="language-python">class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
        
        m=len(board)
        n=len(board[0])
        
        visited=set()
        
        
        def dfs(row,col):
            #print(row,col)
            if row&lt;0 or col&lt;0 or row&gt;=m or col&gt;=n or (row,col) in visited: return
            visited.add((row,col))
            if board[row][col]=='X':
                board[row][col]='.'
                dfs(row+1,col)
                dfs(row-1,col)
                dfs(row,col+1)
                dfs(row,col-1)

        res=0
        for i in range(m):
            for j in range(n):
                if board[i][j]=='X':
                    res+=1
                    dfs(i,j)
                    
        
        return res
#ANSWER
class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
 
        total = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X':
                    flag = 1
                    if j &gt; 0 and board[i][j-1] == 'X': flag = 0
                    if i &gt; 0 and board[i-1][j] == 'X': flag = 0
                    total += flag
        return total
</code></pre>
<p>答案没用DFS or BFS 但是很完美的解决了，因为只有横的竖的是叫做Battleships，所以如果不是左上角的X就不是一个qualified battlesships。</p>
<h1 id="font-colorred-420-strong-password-checker-hardfont"><font color='red'> 420. Strong Password Checker （Hard）</font></h1>
<p>A password is considered strong if the below conditions are all met:<br>
It has at least 6 characters and at most 20 characters.<br>
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.<br>
It does not contain three repeating characters in a row (i.e., &quot;...aaa...&quot; is weak, but &quot;...aa...a...&quot; is strong, assuming other conditions are met).<br>
Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.<br>
In one step, you can:<br>
Insert one character to password,<br>
Delete one character from password, or<br>
Replace one character of password with another character.</p>
<pre><code class="language-python">class Solution:
    def strongPasswordChecker(self,s: str) -&gt; int:
        
        missing_type = 3
        if any('a' &lt;= c &lt;= 'z' for c in s): missing_type -= 1
        if any('A' &lt;= c &lt;= 'Z' for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p &lt; len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p &lt; len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) &lt; 6:
            return max(missing_type, 6 - len(s))
        elif len(s) &lt;= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return delete + max(missing_type, change)
</code></pre>
<p>看到这题就头疼~，直接看答案了。<br>
当有20+chars，必须delete=len（s）-20.但是我们能用这些delete中的一部分来处理3char rule violation。<br>
1） aaa ... 这种violation可以del最后一个a。所以， 需要从change里减去这些del。change -= min(delete, one)<br>
2）aaaa ... 这种violation可以del最后2个a。因为已经用了1）中的deletions，所以需要调整,   min(max(delete - one, 0), two * 2) // 2  意思是，如果残留 max(delete - one, 0) 个dels，那么，用这些dels来处理case2的violation。 因为必须del 2 chars  to resolve each violation, 所以只能用 dels // 2<br>
3）aaaaa ...这种 violation可以del最后3个a。   max(delete - one - 2 * two, 0) // 3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-01/">
        </link>
        <updated>2022-03-01T14:53:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>中间搞laser project浪费了不少时间~~~ 争取3月刷300到700. system design 也该看了。</p>
<h1 id="font-colorred-401-binary-watch-easy-font"><font color='red'> 401. Binary Watch (Easy) </font></h1>
<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.<br>
Given an integer turnedOn which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        return ['{}:{}'.format(h, str(m).zfill(2))  for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == turnedOn]

#Backtracking way of answer it
class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        res=set()
        nums1=[8,4,2,1]
        nums2=[32,16,8,4,2,1]
        
        
        def generateDigs(nums,count):
            res=set()
            def helper(c,pos,sum_):
                if c==0:
                    res.add(sum_)
                    return
                for i in range(pos,len(nums)):
                    helper(c-1,i+1,sum_+nums[i])
            helper(count,0,0)
            return res
        
        for i in range(turnedOn+1):
            list1=generateDigs(nums1,i)
            list2=generateDigs(nums2,turnedOn-i)
            for num1 in list1:
                if num1&gt;=12: continue
                for num2 in list2:
                    if num2&gt;=60: continue
                    res.add('{}:{}'.format(num1,str(num2).zfill(2)))
        return res
</code></pre>
<p>是一个backtracking问题， 写起来难度很大，然而是一个easy问题。。。直接暴力解即可。<br>
但用backtracking就是一个比较难的问题了。</p>
<h1 id="font-colorred-402-remove-k-digits-mediumfont"><font color='red'> 402. Remove K Digits （Medium）</font></h1>
<p>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</p>
<pre><code class="language-python">class Solution:
    def removeKdigits(self, num: str, k: int) -&gt; str:
        #
        # 2     1    4
        # left  cur
        # if cur&lt;left, we know left must be removed
        
        stack=[]
        for n in num:
            while k and stack and n&lt;stack[-1]:
                stack.pop()
                k-=1
            stack.append(n)
        
        #truncate remaining k digits at the end
        # if k==0 return entire list
        final_stack=stack[:-k] if k else stack
        
        return ''.join(final_stack).lstrip('0') or '0'
</code></pre>
<p>greedy+stack 这个方法第一次比较难想到，需要考虑corner case。</p>
<h1 id="403-frog-jump-hard">403. Frog Jump （Hard）</h1>
<p>A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.<br>
Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.<br>
If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.</p>
<pre><code class="language-python">class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
       
        dp=[False]*len(stones)
        dic={s:i for i,s in enumerate(stones)}
        
        @lru_cache(None)
        def can(ith,k):
            if k&lt;=0: return
            if ith==0:
                dp[0]=True
                if stones[0]+1 in dic:
                    jth=dic[stones[0]+1] 
                    can(jth,1)
            else:
                for i,step in enumerate([k+1,k,k-1]):
                    if stones[ith]+step in dic:
                        stone_ind=dic[stones[ith]+step]
                        dp[stone_ind]=True
                        can(stone_ind,[k+1,k,k-1][i])
            
        can(0,1)
        return dp[-1]

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        dic=dict()
        for s in stones:
            dic[s]=set()
        dic[0].add(0)
        
        for i in range(len(stones)):
            for k in dic[stones[i]]:
                for step in range(k-1,k+2):
                    if step&gt;0 and stones[i]+step in dic:
                        dic[stones[i]+step].add(step)
                        
        return len(dic[stones[-1]])&gt;0

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        seen = set()
        stoneSet = set(stones)
        end = stones[-1]
        stack = [(0, 0)]
        while len(stack) &gt; 0:
            loc, steps = stack.pop()
            if (loc, steps) in seen:
                continue
            seen.add((loc, steps))
            if loc == end:
                return True
            elif loc &lt; end:
                for i in range(steps-1, steps+2):
                    if i &lt;= 0:
                        continue
                    if loc + i in stoneSet:
                        stack.append((loc+i, i))
        return False
</code></pre>
<p>没想到做出来了。。。。。dp  with mem。。。<br>
答案更好。答案3思路： each node has 3 children. The goal is to check if we can reach to the end along the edges. We can do it with a Depth First Search with a Hashtable(to avoid redundant calculation)</p>
<h1 id="404-sum-of-left-leaves-easy">404. Sum of Left Leaves （Easy）</h1>
<p>Given the root of a binary tree, return the sum of all left leaves.</p>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:
        if not root: return 0
        if root.left and root.left.left is None and root.left.right is None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        return  self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)
</code></pre>
<h1 id="405-convert-a-number-to-hexadecimal-easy">405. Convert a Number to Hexadecimal (Easy)</h1>
<p>Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.<br>
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>
<pre><code class="language-python">class Solution:
    def toHex(self, num: int) -&gt; str:
        if num&lt;0:
            num=4294967295 +num+1
        map=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']
        res=''
        while num:
            ind=num%16
            res+=map[ind]
            num=num//16
        #26=1a  16 11
        return res[::-1]   if res else '0'  
</code></pre>
<h1 id="font-colorred-406-queue-reconstruction-by-height-medium-font"><font color='red'> 406. Queue Reconstruction by Height (Medium) </font></h1>
<p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.<br>
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p>
<pre><code class="language-python">class Solution:
    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        output = []
        for p in people:
            output.insert(p[1], p)
        return output

</code></pre>
<p>思路：最高的sort完了，插入次高的，插入位置？</p>
<h1 id="font-colorred-407-trapping-rain-water-ii-hardfont"><font color='red'> 407. Trapping Rain Water II （Hard）</font></h1>
<p>Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.</p>
<pre><code class="language-python">class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -&gt; int:
        
        class Cell:
            def __init__(self,row,col,h):
                self.row=row
                self.col=col
                self.h=h
            
            def __lt__(self,other):
                return self.h&lt;other.h
            
        
        if not heightMap or len(heightMap)==0 or len(heightMap[0])==0:
            return 0
        
        q=[]
        m=len(heightMap)
        n=len(heightMap[0])
        visited=[[False]*n for _ in range(m)]
        #Initially, add all the Cells which are on borders to the queue.
        for i in range(m):
            visited[i][0]=True
            visited[i][n-1]=True
            heapq.heappush(q, Cell(i,0,heightMap[i][0]))
            heapq.heappush(q, Cell(i,n-1,heightMap[i][n-1]))
        for j in range(n):
            visited[0][j]=True
            visited[m-1][j]=True
            heapq.heappush(q, Cell(0,j,heightMap[0][j]))
            heapq.heappush(q, Cell(m-1,j,heightMap[m-1][j]))
        #from the borders, pick the shortest cell visited and check its neighbors: if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped add all its neighbors to the queue.
        dirs = [[-1,0],[1,0],[0,-1],[0,1]]
        res=0
        while q:
            cur_cell=heapq.heappop(q)
            for dir in dirs:
                row=cur_cell.row+dir[0]
                col=cur_cell.col+dir[1]
                if row&gt;=0 and row&lt;m and col&gt;=0 and col&lt;n and not visited[row][col]:
                    visited[row][col]=True
                    res+=max(0,cur_cell.h-heightMap[row][col])
                    heapq.heappush(q,Cell(row,col,max(cur_cell.h,heightMap[row][col])))
                    
        
        return res
                    
#ANSWER
class Solution(object):
    def trapRainWater(self, heightMap):
        if not heightMap or not heightMap[0]:
            return 0
        
        import heapq    
        m, n = len(heightMap), len(heightMap[0])
        heap = []
        visited = [[0]*n for _ in xrange(m)]

        # Push all the block on the border into heap
        for i in xrange(m):
            for j in xrange(n):
                if i == 0 or j == 0 or i == m-1 or j == n-1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = 1
        
        result = 0
        while heap:
            height, i, j = heapq.heappop(heap)    
            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and not visited[x][y]:
                    result += max(0, height-heightMap[x][y])
                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))
                    visited[x][y] = 1
        return result      
        
</code></pre>
<p>思路：边界最低的板子是开始点，BFS，如果邻居低说明能存水，做计算，然后埋土。</p>
<h1 id="408-valid-word-abbreviation-easy">408. Valid Word Abbreviation （Easy）</h1>
<p>A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.<br>
For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
The following are not valid abbreviations:<br>
&quot;s55n&quot; (&quot;s ubsti tutio n&quot;, the replaced substrings are adjacent)<br>
&quot;s010n&quot; (has leading zeros)<br>
&quot;s0ubstitution&quot; (replaces an empty substring)<br>
Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation.<br>
A substring is a contiguous non-empty sequence of characters within a string.</p>
<pre><code class="language-python">class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -&gt; bool:
        
        dig=0
        while abbr:
            
            if abbr[0].isdigit():
                if dig==0 and abbr[0]=='0': return False
                dig=dig*10+int(abbr[0])
                abbr=abbr[1:]
            else:
                if dig!=0:
                    if len(word)&lt;dig: return False
                    word=word[dig:]
                    dig=0
                else:
                    if not word: return False
                    if abbr[0]!=word[0]: return False
                    abbr=abbr[1:]
                    word=word[1:]
        if dig:
            if len(word)&lt;dig: return False
            if not word: return False
            word=word[dig:]
         
        return not abbr and not word


</code></pre>
<h1 id="font-colorred-409-longest-palindrome-easy-font"><font color='red'> 409. Longest Palindrome (Easy) </font></h1>
<p>Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.<br>
Letters are case sensitive, for example, &quot;Aa&quot; is not considered a palindrome here.</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; int:
        dic=Counter(s)
        res=0
        for k,v in dic.items():
            res+=v//2*2
            if res%2==0 and v%2==1:
                res+=1
        return res
</code></pre>
<p>找到能组成palindrom的最长组合方式，如果是奇数个，可以变成偶数个，比如bbb只用bb。 但当res%2==0时候，遇到奇数情况可以加1.</p>
<h1 id="font-colorred-410-split-array-largest-sum-hard-font"><font color='red'> 410. Split Array Largest Sum （Hard） </font></h1>
<p>Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.<br>
Write an algorithm to minimize the largest sum among these m subarrays.</p>
<pre><code class="language-python">class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        # F[currIndex, subarrayCount] = 
        #  min(max(sum[currIndex, i], F[i + 1, subarrayCount - 1]))
        #        For all i in range [currIndex, n - subarrayCount]
        
        n=len(nums)
        prefix_sum=nums[:]
        for i in range(1,len(prefix_sum)):
            prefix_sum[i]+=prefix_sum[i-1]
        prefix_sum=[0]+prefix_sum
        
        @lru_cache(None)
        def get_min_largest_split_sum(cur_ind, m):
            if m==1:
                return prefix_sum[n]-prefix_sum[cur_ind]
            
            minimum_largest_split_sum=prefix_sum[n]
            for i in range(cur_ind,n-m+1):
                # Store the sum of the first subarray.
                first_split_sum=prefix_sum[i+1]-prefix_sum[cur_ind]
                # find the maxinum subaray sum ffor current frist split
                largest_split_sum=max(first_split_sum,get_min_largest_split_sum(i+1,m-1))
                #find the minum among all possible combinations
                minimum_largest_split_sum=min(minimum_largest_split_sum,largest_split_sum)
                
                if first_split_sum &gt;= minimum_largest_split_sum: break
            
            return minimum_largest_split_sum
        
        return get_min_largest_split_sum(0,m)


#。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        n = len(nums)
        memo = [[0] * (m + 1) for _ in range(n)]
        
        # Create a prefix sum array of nums.
        prefix_sum = [0] + list(itertools.accumulate(nums))
        
        for subarray_count in range(1, m + 1):
            for curr_index in range(n):
                # Base Case: If there is only one subarray left, then all of the remaining numbers
                # must go in the current subarray. So return the sum of the remaining numbers.
                if subarray_count == 1:
                    memo[curr_index][subarray_count] = prefix_sum[n] - prefix_sum[curr_index]
                    continue

                # Otherwise, use the recurrence relation to determine the minimum largest subarray sum
                # between curr_index and the end of the array with subarray_count subarrays remaining.
                minimum_largest_split_sum = prefix_sum[n]
                for i in range(curr_index, n - subarray_count + 1):
                    # Store the sum of the first subarray.
                    first_split_sum = prefix_sum[i + 1] - prefix_sum[curr_index]

                    # Find the maximum subarray sum for the current first split.
                    largest_split_sum = max(first_split_sum, memo[i + 1][subarray_count - 1])

                    # Find the minimum among all possible combinations.
                    minimum_largest_split_sum = min(minimum_largest_split_sum, largest_split_sum)

                    if first_split_sum &gt;= minimum_largest_split_sum:
                        break
            
                memo[curr_index][subarray_count] = minimum_largest_split_sum
        
        return memo[0][m]

#。。。。。。。。。。。。。。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        
        def min_subarrays_required(max_sum_allowed: int) -&gt; int:
            current_sum = 0
            splits_required = 0
            
            for element in nums:
                # Add element only if the sum doesn't exceed max_sum_allowed
                if current_sum + element &lt;= max_sum_allowed:
                    current_sum += element
                else:
                    # If the element addition makes sum more than max_sum_allowed
                    # Increment the splits required and reset sum
                    current_sum = element
                    splits_required += 1

            # Return the number of subarrays, which is the number of splits + 1
            return splits_required + 1
        
        # Define the left and right boundary of binary search
        left = max(nums)
        right = sum(nums)
        while left &lt;= right:
            # Find the mid value
            max_sum_allowed = (left + right) // 2
            
            # Find the minimum splits. If splits_required is less than
            # or equal to m move towards left i.e., smaller values
            if min_subarrays_required(max_sum_allowed) &lt;= m:
                right = max_sum_allowed - 1
                minimum_largest_split_sum = max_sum_allowed
            else:
                # Move towards right if splits_required is more than m
                left = max_sum_allowed + 1
        
        return minimum_largest_split_sum
###Binary Seasrch


class Solution(object):
    def splitArray(self, nums, m):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type m: int
        :rtype: int
        https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1042/discuss/89817/Clear-Explanation:-8ms-Binary-Search-Java?page=1
        &quot;&quot;&quot;
 
        max_ = sum=0
        for  num in nums:
            max_ = max(num, max_);
            sum += num
            
            
        def valid(target, nums, m):
            count = 1
            total = 0
            for num in nums:
                total += num
                if total &gt; target: 
                    total = num
                    count+=1
                    if count &gt; m:
                        return False
                    
            return True
        
        if m == 1: return sum
        #binary search
        l = max_ 
        r = sum
        while l &lt;= r:
            mid = (l + r)// 2;
            if  valid(mid, nums, m): 
                r = mid - 1 
            else: 
                l = mid + 1
            
        return l
</code></pre>
<p>无思路。。。m=2时候很容易，sort然后找到左右平衡点。m=3，4？<br>
DP很好， bianry search是最优解法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-12]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-12/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-12/">
        </link>
        <updated>2021-12-12T14:58:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred391-perfect-rectangle-hardfont"><font color='red'>391. Perfect Rectangle （Hard）</font></h1>
<p>Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).<br>
Return true if all the rectangles together form an exact cover of a rectangular region.</p>
<pre><code class="language-python">class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -&gt; bool:
        x1 = float('inf')
        y1 = float('inf')
        x2 = float('-inf')
        y2 = float('-inf')
        _set = set()
        
        area = 0
        for rect in rectangles:
            x1 = min(x1, rect[0])
            y1 = min(y1, rect[1])
            x2 = max(x2, rect[2])
            y2 = max(y2, rect[3])
            
            area += (rect[2] - rect[0]) * (rect[3] - rect[1])
            
            for x, y in [(rect[0],rect[1]),(rect[0],rect[3]),(rect[2],rect[3]),(rect[2],rect[1])]:
                if (x, y) in _set:
                    _set.remove((x, y))
                else:
                    _set.add((x, y))
        return all((x, y) in _set for x, y in [(x1,y1),(x2,y2),(x1,y2),(x2,y1)]) and len(_set) == 4 and area == (x2 - x1) * (y2 - y1)

</code></pre>
<p>没啥思路。。。答案思路:<br>
要是exact cover of rectangular region 1）大的rectangle面积是所有小rectangle面积和 2） 所有的图中的点应该是偶数个，除了边界的4个点。</p>
<h1 id="392-is-subsequence-easy">392. Is Subsequence (Easy)</h1>
<p>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.<br>
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).</p>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s):
            
            while p2&lt;len(t) and s[p1]!=t[p2]:
                p2+=1
            
            if p2==len(t): return False
            
            if s[p1]==t[p2]:
                p1+=1
                p2+=1
            
            if p1==len(s):return True
 #ANSWER           
class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s) and p2&lt;len(t):
            if s[p1]==t[p2]:
                p1+=1
            p2+=1
        if p1==len(s):
            return True
        return False
                     
</code></pre>
<p>这题竟然卡了，用了two pointer。。 答案写的更好。 只有相等时候s的pointer才跳，t的pointer一直跳，判断s的pointer到头就可以了。</p>
<h1 id="font-colorred393-utf-8-validation-mediumfont"><font color='red'>393. UTF-8 Validation （Medium）</font></h1>
<p>Given an integer array data representing the data, return whether it is a valid UTF-8 encoding.<br>
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:<br>
For a 1-byte character, the first bit is a 0, followed by its Unicode code.<br>
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.</p>
<p>This is how the UTF-8 encoding would work:</p>
<p>Char. number range  |        UTF-8 octet sequence<br>
(hexadecimal)    |              (binary)<br>
--------------------+---------------------------------------------<br>
0000 0000-0000 007F | 0xxxxxxx<br>
0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>
<pre><code class="language-python">class Solution:
    def validUtf8(self, data: List[int]) -&gt; bool:
        
        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # For each integer in the data array.
        for num in data:

            # Get the binary representation. We only need the least significant 8 bits
            # for any given number.
            bin_rep = format(num, '#010b')[-8:]

            # If this is the case then we are to start processing a new UTF-8 character.
            if n_bytes == 0:

                # Get the number of 1s in the beginning of the string.
                for bit in bin_rep:
                    if bit == '0': break
                    n_bytes += 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:
                # Else, we are processing integers which represent bytes which are a part of
                # a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.
                if not (bin_rep[0] == '1' and bin_rep[1] == '0'):
                    return False

            # We reduce the number of bytes to process by 1 after each integer.
            n_bytes -= 1

        # This is for the case where we might not have the complete data for
        # a particular UTF-8 character.
        return n_bytes == 0  



#ANSWER BIT 
class Solution:
    def validUtf8(self, data):
        &quot;&quot;&quot;
        :type data: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # Mask to check if the most significant bit (8th bit from the left) is set or not
        mask1 = 1 &lt;&lt; 7

        # Mask to check if the second most significant bit is set or not
        mask2 = 1 &lt;&lt; 6
        for num in data:

            # Get the number of set most significant bits in the byte if
            # this is the starting byte of an UTF-8 character.
            mask = 1 &lt;&lt; 7
            if n_bytes == 0:
                while mask &amp; num:
                    n_bytes += 1
                    mask = mask &gt;&gt; 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:

                # If this byte is a part of an existing UTF-8 character, then we
                # simply have to look at the two most significant bits and we make
                # use of the masks we defined before.
                if not (num &amp; mask1 and not (num &amp; mask2)):
                    return False
            n_bytes -= 1
        return n_bytes == 0     
</code></pre>
<p>看答案了，down vote比较多不是什么好题</p>
<h1 id="394-decode-string-medium">394. Decode String （Medium）</h1>
<p>Given an encoded string, return its decoded string.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.<br>
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.<br>
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].</p>
<pre><code class="language-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        # 3[a2[c]]
        #
        # stack=[]
        #       [3]
        #       [3 [ a 2 [ c   ] 
        # 
        
        dig=''
        stack=[]
        for char in s:
            if char.isdigit():
                dig+=char
            elif char=='[':
                if dig:
                    stack.append(int(dig))
                stack.append('[')
                dig=''
            elif char==']':
                string=[]
                while stack[-1]!='[':
                    string.append(stack.pop())
                string=''.join(string[::-1])
                stack.pop() #pop掉【
                if type(stack[-1])==int:
                    string=stack.pop()*string
                stack.append(string)
                
                
            else:
                stack.append(char)
        
        return ''.join(stack)



 #3年前的答案估计是看的别人的一样的思路
 class Solution(object):
    def decodeString(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        num='0123456789'
        s=[e for e in s]
        
        stack=[]
        
        while s:
            
            cur=s.pop(0)
            if cur in num:
                stack.append(int(cur))
            elif cur=='[':
                stack.append(cur)
            elif cur==']':
                temp=[]
                while stack and stack[-1]!='[':
                    me=stack.pop()
                    temp.append(me)
                stack.pop()
                temp=''.join(temp[::-1])
                number=0
                time=1
                while stack and type(stack[-1])==int:
                    number+=stack.pop()*time
                    time*=10
                stack.append(temp*number)
            else:
                stack.append(cur)
        return ''.join(stack)           
</code></pre>
<p>感觉是用stack的确写出来了~~</p>
<h1 id="font-colorred-395-longest-substring-with-at-least-k-repeating-characters-mediumfont"><font color='red'> 395. Longest Substring with At Least K Repeating Characters （Medium）</font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.</p>
<pre><code class="language-python">class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        def helper(start,end):
            if end&lt;k:return 0
            countMap=[0]*26
            for i in range(start,end):
                countMap[ord(s[i])-ord('a')]+=1
            for mid in range(start,end):
                if countMap[ord(s[mid])-ord('a')]&gt;=k: continue
                midnext=mid+1
                while midnext&lt;end and countMap[ord(s[midnext])-ord('a')]&lt;k:
                    midnext+=1
                return max(helper(start,mid),helper(midnext,end))
            return end-start
        
        return helper(0,len(s))
            
#Perfect ANSWER
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        for c in set(s):
            if s.count(c) &lt; k:
                return max(self.longestSubstring(t, k) for t in s.split(c))
        return len(s)

#Sliding WIndow
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        maxunique=len(set(s))
        res=0
        for cur_unique in range(1,maxunique+1):
            countmap=[0]*26
            start=end=unique=idx=countAtLeasetK=0
            while end &lt;len(s):
                #expanding sliding window
                if unique&lt;=cur_unique:
                    idx=ord(s[end])-ord('a')
                    if countmap[idx]==0:
                        unique+=1
                    countmap[idx]+=1
                    if countmap[idx]==k:
                        countAtLeasetK+=1
                    end+=1
                else:
                    #shrink sliding window
                    idx=ord(s[start])-ord('a')
                    if countmap[idx]==k:
                        countAtLeasetK-=1
                    countmap[idx]-=1
                    if countmap[idx]==0:
                        unique-=1
                    start+=1
                
                if unique==cur_unique and unique==countAtLeasetK:
                    res=max(res,end-start)
        return res

</code></pre>
<p>答案的分治法很好，<br>
的确是tow pointer啊，但写不出来。。。思路：第一层for loop 用来扫 cur_unique 。 while  end 小于len(s)； 当unique小于cur_unique而且不到s末尾时， expand。记录unique he countAtLeastK大小，否则当unique大于cur_unique就收缩， 更新countAtLeastK和unique。 如果unique等于cur_unique 而且unique等于countAtLeastK，更新结果。<br>
最简单的是方法2解法，如果count（char)小于K就用char作为分界char，recursive call function。</p>
<h1 id="396-rotate-function-medium">396. Rotate Function （Medium）</h1>
<p>You are given an integer array nums of length n.<br>
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:<br>
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].<br>
Return the maximum value of F(0), F(1), ..., F(n-1).</p>
<pre><code class="language-python">class Solution:
    def maxRotateFunction(self, nums: List[int]) -&gt; int:
        #nums = [4,3,2,6]
        #F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
        #F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
        #     = F[0]+sum-4*6
        #F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
        #     = F[1]+sum-4*2
        #F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
        #     = F[2]+sum-4*3
        
        f0=0
        sum_=0
        for i,n in enumerate(nums):
            f0+=i*n
            sum_+=n
        res=f0
        for j in range(len(nums)-1,0,-1):
            f1=f0+sum_-len(nums)*nums[j]
            res=max(res,f1)
            f0=f1
        return res
</code></pre>
<h1 id="397-integer-replacement-medium">397. Integer Replacement (Medium)</h1>
<p>Given a positive integer n, you can apply one of the following operations:<br>
If n is even, replace n with n / 2.<br>
If n is odd, replace n with either n + 1 or n - 1.<br>
Return the minimum number of operations needed for n to become 1.</p>
<pre><code class="language-python">class Solution:
    def integerReplacement(self, n: int) -&gt; int:
        def helper(n):
            if n==1:
                return 0
            step=0
            if n%2==0:
                n=n//2
                step=1+helper(n)
            else:
                step=1+min(helper(n+1),helper(n-1))
            return step
        
        return helper(n)
        
</code></pre>
<p>能加个@lru_cache(None)去优化下。。。不过已经pass autograder了</p>
<h1 id="398-random-pick-index-medium">398. Random Pick Index （Medium）</h1>
<p>Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.<br>
Implement the Solution class:<br>
Solution(int[] nums) Initializes the object with the array nums.<br>
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, nums: List[int]):
        self.dic=collections.defaultdict(list)
        for i,n in enumerate(nums):
            self.dic[n].append(i)
        

    def pick(self, target: int) -&gt; int:
        return random.choice(self.dic[target])
    
</code></pre>
<h1 id="font-colorred-399-evaluate-division-medium-font"><font color='red'> 399. Evaluate Division (Medium) </font></h1>
<p>ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.<br>
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.<br>
Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<pre><code class="language-python">class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        
        # a-val-&gt;b--val-&gt;c
        

        graph = defaultdict(defaultdict)

        def backtrack_evaluate(curr_node, target_node, acc_product, visited):
            visited.add(curr_node)
            ret = -1.0
            neighbors = graph[curr_node]
            if target_node in neighbors:
                ret = acc_product * neighbors[target_node]
            else:
                for neighbor, value in neighbors.items():
                    if neighbor in visited:
                        continue
                    ret = backtrack_evaluate(
                        neighbor, target_node, acc_product * value, visited)
                    if ret != -1.0:
                        break
            visited.remove(curr_node)
            return ret

        # Step 1). build the graph from the equations
        for (dividend, divisor), value in zip(equations, values):
            # add nodes and two edges into the graph
            graph[dividend][divisor] = value
            graph[divisor][dividend] = 1 / value

        # Step 2). Evaluate each query via backtracking (DFS)
        #  by verifying if there exists a path from dividend to divisor
        results = []
        for dividend, divisor in queries:
            if dividend not in graph or divisor not in graph:
                # case 1): either node does not exist
                ret = -1.0
            elif dividend == divisor:
                # case 2): origin and destination are the same node
                ret = 1.0
            else:
                visited = set()
                ret = backtrack_evaluate(dividend, divisor, 1, visited)
            results.append(ret)

        return results


###UNIONFIND 变种
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:

        gid_weight = {}

        def find(node_id):
            if node_id not in gid_weight:
                gid_weight[node_id] = (node_id, 1)
            group_id, node_weight = gid_weight[node_id]
            # The above statements are equivalent to the following one
            #group_id, node_weight = gid_weight.setdefault(node_id, (node_id, 1))

            if group_id != node_id:
                # found inconsistency, trigger chain update
                new_group_id, group_weight = find(group_id)
                gid_weight[node_id] =  (new_group_id, node_weight * group_weight)
            return gid_weight[node_id]

        def union(dividend, divisor, value):
            dividend_gid, dividend_weight = find(dividend)
            divisor_gid, divisor_weight = find(divisor)
            if dividend_gid != divisor_gid:
                # merge the two groups together,
                # by attaching the dividend group to the one of divisor
                gid_weight[dividend_gid] =  (divisor_gid, divisor_weight * value / dividend_weight)

        # Step 1). build the union groups
        for (dividend, divisor), value in zip(equations, values):
            union(dividend, divisor, value)

        results = []
        # Step 2). run the evaluation, with &quot;lazy&quot; updates in find() function
        for (dividend, divisor) in queries:
            if dividend not in gid_weight or divisor not in gid_weight:
                # case 1). at least one variable did not appear before
                results.append(-1.0)
            else:
                dividend_gid, dividend_weight = find(dividend)
                divisor_gid, divisor_weight = find(divisor)
                if dividend_gid != divisor_gid:
                    # case 2). the variables do not belong to the same chain/group
                    results.append(-1.0)
                else:
                    # case 3). there is a chain/path between the variables
                    results.append(dividend_weight / divisor_weight)
        return results
</code></pre>
<p>看提示，是graph问题， 一开始就偏了。。。若是graph问题，则a-val-》b-val-》c，<br>
那么a-》c就是val1*val2，如果是c-》a找不到，就找a-c然后1/结果. 如果node不在里面就return -1，如果是自己-》自己return1<br>
还是第一种方法graph比较标准用DFS。</p>
<h1 id="font-colorred400-nth-digit-mediumfont"><font color='red'>400. Nth Digit （Medium）</font></h1>
<p>Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].</p>
<pre><code class="language-python">class Solution:
    def findNthDigit(self, n: int) -&gt; int:
        #1 ~ 9 include 9 one digit number;
        #10 ~ 99 include 90 two digits number;
        #100 ~ 999 include 900 three digits number;
        #1000 ~ 9999 include 9000 four digits number;
        #...
        #length is how many digits:1 or 2 or 3 ..., range is 9 or 90 or 900 ...
        
        length = 1
        num = 1 
        range_ = 9
        while n &gt; length * range_:
            n -= length * range_
            length+=1
            range_ *= 10
            num *= 10
        num += (n - 1) // length
        return str(num)[ (n-1)%length]
		 

</code></pre>
<p>知道思路，写时候卡。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-11]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-11/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-11/">
        </link>
        <updated>2021-12-10T20:41:58.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-381-insert-delete-getrandom-o1-duplicates-allowed-hardfont"><font color='red'> 381. Insert Delete GetRandom O(1) - Duplicates allowed （Hard）</font></h1>
<p>RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also removing a random element.<br>
Implement the RandomizedCollection class:<br>
RandomizedCollection() Initializes the empty RandomizedCollection object.<br>
bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.<br>
bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.<br>
int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of same values the multiset contains.<br>
You must implement the functions of the class such that each function works on average O(1) time complexity.</p>
<pre><code class="language-python">class RandomizedCollection:

    def __init__(self):
        self.lst = []
        self.idx = defaultdict(set)
        

    def insert(self, val: int) -&gt; bool:
        self.idx[val].add(len(self.lst))
        self.lst.append(val)
        return len(self.idx[val]) == 1

    def remove(self, val: int) -&gt; bool:
        if not self.idx[val]: return False
        remove, last = self.idx[val].pop(), self.lst[-1]
        self.lst[remove] = last
        self.idx[last].add(remove)
        self.idx[last].remove(len(self.lst) - 1)

        self.lst.pop()
        return True

    def getRandom(self) -&gt; int:
        return choice(self.lst)


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

</code></pre>
<p>思路是对的，但写不出来， 崩溃，看答案。。。用list和defaultdict（set），insert很简单，难的是remove。 先找出remove val的index并从dict中pop，和array last 元素交换， array last元素的dict添加index，array last 元素dict.remove(len(self.lst) - 1）, len(self.lst) - 1是last元素的idx。</p>
<h1 id="font-colorblue-382-linked-list-random-node-mediumfont"><font color='blue'> 382. Linked List Random Node （Medium）</font></h1>
<p>Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.<br>
Implement the Solution class:<br>
Solution(ListNode head) Initializes the object with the head of the singly-linked list head.<br>
int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.dic=dict()
        ind=0
        while head:
            self.dic[ind]=head.val
            ind+=1
            head=head.next
        self.ind=ind
        

    def getRandom(self) -&gt; int:
        return self.dic[random.randint(0,self.ind-1)]  

#ANSER of Reservor sampling      
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.head = head
        

    def getRandom(self) -&gt; int:
        scope = 1
        chosen_value = 0
        curr = self.head

        while curr:
            # decide whether to include the element in reservoir
            if random.random() &lt; 1 / scope:
                chosen_value = curr.val
            # move on to the next node
            curr = curr.next
            scope += 1
        return chosen_value
        

</code></pre>
<p>follow up说如果linkedlist很大而且不知道长度。。。如何random 取样。。。<br>
忘记了有一个随机取样法 Reservoir sampling，需要复习, 当rand小于1/scope时候，说明当前值可以以1/scope的概率保留下来：</p>
<pre><code class="language-python"># S has items to sample, R will contain the result
def ReservoirSample(S[1..n], R[1..k])
  # fill the reservoir array
  for i := 1 to k
      R[i] := S[i]

  # replace elements with gradually decreasing probability
  for i := k+1 to n
    # randomInteger(a, b) generates a uniform integer
    #   from the inclusive range {a, ..., b} *)
    j := randomInteger(1, i)
    if j &lt;= k
        R[j] := S[i]
</code></pre>
<h1 id="383-ransom-note-easy">383. Ransom Note （Easy）</h1>
<p>Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.<br>
Each letter in magazine can only be used once in ransomNote.</p>
<pre><code class="language-python">class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        a = Counter(ransomNote)
        b = Counter(magazine)
        for k,v in a.items():
            if k not in b or b[k]&lt;v:
                return False
        return  True
</code></pre>
<h1 id="font-colorred384-shuffle-an-array-medium-font"><font color='red'>384. Shuffle an Array (Medium) </font></h1>
<p>Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.<br>
Implement the Solution class:<br>
Solution(int[] nums) Initializes the object with the integer array nums.<br>
int[] reset() Resets the array to its original configuration and returns it.<br>
int[] shuffle() Returns a random shuffling of the array.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&gt; List[int]:
        aux = self.array[:]

        for idx in range(len(self.array)):
            remove_idx = random.randint(0,len(aux)-1)
            self.array[idx] = aux.pop(remove_idx)

        return self.array

#BEST ANSWER  Fisher-Yates Algorithm
class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&gt; List[int]:
        for idx in range(len(self.array)):
            swap_idx=random.randint(idx,len(self.array)-1)
            self.array[idx],self.array[swap_idx]=self.array[swap_idx],self.array[idx]
        return self.array

</code></pre>
<p>感觉思路是找到以n！为base的数，然后还原出suffled array但是写不出来。。。想的过于复杂了。这个就是个随机算法。 元素e在第k轮被抽中概率是  k在前k-1轮不中但在k轮中。 (n-1/n ) (n-2/n-1)...(n-k)/(n-k+1))* 1/n-k = 1/n   所以按照  剩下的有效数字中选1个的概率去组成array就可以保证每个数字是等概率选取。这样总体就是random shuffle了。</p>
<h1 id="font-colorred385-mini-parser-mediumfont"><font color='red'>385. Mini Parser （Medium）</font></h1>
<p>Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.<br>
Each element is either an integer or a list whose elements may also be integers or other lists.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &quot;&quot;&quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &quot;&quot;&quot;
#
#    def isInteger(self):
#        &quot;&quot;&quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def add(self, elem):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def setInteger(self, value):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def getInteger(self):
#        &quot;&quot;&quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &quot;&quot;&quot;
#
#    def getList(self):
#        &quot;&quot;&quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &quot;&quot;&quot;

class Solution:
    def deserialize(self, s: str) -&gt; NestedInteger:
        # '-1' is not digit
        if s and s[-1].isdigit():
            return  NestedInteger(int(s))

        nested_integer = None
        digits = ''
        stack = []
        for c in s:
            if c.isdigit() or c == '-':
                digits += c
            elif c == '[':
                if nested_integer:
                    stack.append(nested_integer)
                nested_integer = NestedInteger()
            elif c == ']':
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = ''
                if stack:
                    previous_nested_integer = stack.pop()
                    previous_nested_integer.add(nested_integer)
                    nested_integer = previous_nested_integer
            elif c == ',':
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = ''

        return nested_integer

#作弊写法用eval
def deserialize(self, s):
    def nestedInteger(x):
        if isinstance(x, int):
            return NestedInteger(x)
        lst = NestedInteger()
        for y in x:
            lst.add(nestedInteger(y))
        return lst
    return nestedInteger(eval(s))
</code></pre>
<p>想写正确并不容易。。。</p>
<h1 id="font-colorblue386-lexicographical-numbers-median-font"><font color='blue'>386. Lexicographical Numbers （median） </font></h1>
<p>Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.<br>
You must write an algorithm that runs in O(n) time and uses O(1) extra space.</p>
<pre><code class="language-python">class Solution:
    def lexicalOrder(self, n: int) -&gt; List[int]:
        
        class trie:
            def __init__(self):
                self.childer=dict()
                self.isnumber=False
            
            def insert(self,n):
                if len( n )==1:
                    first= n 
                    if first not in self.childer:
                        self.childer[first]=trie()
                    self.childer[first].isnumber=True
                else:
                    first= n[0] 
                    rest =  n[1:] 
                    if first not in self.childer:
                        self.childer[first]=trie()
                    self.childer[first].insert(rest)
               
        tr=trie()
        for i in range(1,n+1):
            tr.insert(str(i))
        
        res=[]
        
        def preorder(tr,tmp):
            for key in tr.childer:
                temp=tmp+key
                if tr.childer[key].isnumber:
                    res.append(temp)
                preorder(tr.childer[key],temp)
            
        preorder(tr,'')
        return map(int,res)

#ANSWER DFS
class Solution:
    def lexicalOrder(self, n: int) -&gt; List[int]:
        self.res = []
        for i in range(1, 10):
            self.helper(i, n)
        return self.res
    
    def helper(self, start, end):
        if start &gt; end:
            return
        self.res.append(start)
        for i in range(0, 10):
            if 10 * start + i &gt; end:
                return
            self.helper(10 * start + i, end)

</code></pre>
<p>用的trie做出来的，写的磕磕绊绊。。。<br>
答案用的DFS， 很好的思路。。。<br>
The idea is pretty simple. If we look at the order we can find out we just keep adding digit from 0 to 9 to every digit and make it a tree.<br>
Then we visit every node in pre-order.<br>
1        2        3    ...<br>
/\        /\       /<br>
10 ...19  20...29  30...39   ....</p>
<h1 id="387-first-unique-character-in-a-string-easy">387. First Unique Character in a String （Easy）</h1>
<p>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.</p>
<pre><code class="language-python">class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        c=Counter(s)
        for i,char in enumerate(s):
            if c[char]==1:
                return i
        return -1
</code></pre>
<h1 id="font-colorred388-longest-absolute-file-path-medium-font"><font color='red'>388. Longest Absolute File Path (Medium) </font></h1>
<p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:<br>
Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.</p>
<p>In text form, it looks like this (with ⟶ representing the tab character):</p>
<p>dir<br>
⟶ subdir1<br>
⟶ ⟶ file1.ext<br>
⟶ ⟶ subsubdir1<br>
⟶ subdir2<br>
⟶ ⟶ subsubdir2<br>
⟶ ⟶ ⟶ file2.ext</p>
<p>If we were to write this representation in code, it will look like this: &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;. Note that the '\n' and '\t' are the new-line and tab characters.<br>
Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is &quot;dir/subdir2/subsubdir2/file2.ext&quot;. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.<br>
Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.</p>
<pre><code class="language-python">class Solution:
    def lengthLongestPath(self, input: str) -&gt; int:
        maxlen = 0
        pathlen = {0: 0}
        for line in input.split('\n'):
            depth = line.count('\t')
            name = line.lstrip('\t')
            if '.' in name:
                maxlen = max(maxlen, pathlen[depth] + len(name))
            else:
                pathlen[depth + 1] = pathlen[depth] + len(name) + 1
        return maxlen


</code></pre>
<p>coner case 太多，自己写的太复杂，还不能完全pass。。。看答案了。。。</p>
<h1 id="389-find-the-difference-easy">389. Find the Difference （Easy）</h1>
<p>You are given two strings s and t.<br>
String t is generated by random shuffling string s and then add one more letter at a random position.<br>
Return the letter that was added to t.</p>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        s=Counter(s)
        t=Counter(t)
        for key in s:
            t[key]-=s[key]
            if t[key]==0:
                del t[key]
        
        return  list(t.keys())[0]

#ANSER NLOGN
class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:

        # Sort both the strings
        sorted_s = sorted(s)
        sorted_t = sorted(t)

        # Character by character comparison
        i = 0
        while i &lt; len(s):
            if sorted_s[i] != sorted_t[i]:
                return sorted_t[i]
            i += 1

        return sorted_t[i]

#DICT O(n)
from collections import Counter

class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        # Prepare a counter for string s.
        # This holds the characters as keys and respective frequency as value.
        counter_s = Counter(s)

        # Iterate through string t and find the character which is not in s.
        for ch in t:
            if ch not in counter_s or counter_s[ch] == 0:
                return ch
            else:
                # Once a match is found we reduce frequency left.
                # This eliminates the possibility of a false match later.
                counter_s[ch] -= 1

#XOR O（n）
class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:

        # Initialize ch with 0, because 0 ^ X = X
        # 0 when XORed with any bit would not change the bits value.
        ch = 0

        # XOR all the characters of both s and t.
        for char_ in s:
            ch ^= ord(char_)

        for char_ in t:
            ch ^= ord(char_)

        # What is left after XORing everything is the difference.
        return chr(ch)
</code></pre>
<h1 id="font-colorred-390-elimination-game-medium-font"><font color='red'> 390. Elimination Game （Medium) </font></h1>
<p>You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:<br>
Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.<br>
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.<br>
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.<br>
Given the integer n, return the last number that remains in arr.</p>
<pre><code class="language-python">
#Navie not work memery exceeded
class Solution:
    def lastRemaining(self, n: int) -&gt; int:
        li = [i for i in range(1,n+1)]
        
        def helper(li,forward=True):
            if len(li)==1: return li[0]
            if forward:
                #print(li[1::2],not forward)
                return helper(li[1::2],not forward)
            else:
                li=li[::-1]
                li=li[1::2]
                #print(li[::-1],not forward)
                return helper(li[::-1],not forward)
                
        return helper(li,True)


#Perfect ANSWER
class Solution:
    def lastRemaining(self, n: int) -&gt; int:
 
        head, left, step, remaining = 1, True, 1, n
        while remaining &gt; 1:
            if left or remaining % 2: 
                #when to update head
                #go from left or remaining is odd
                head += step
            left = not left
            step *= 2
            remaining //= 2
        return head
</code></pre>
<p>按照题目意思直接搞时间复杂度和空间复杂度都太大。。，<br>
看答案：<br>
update and record head in each turn. when the total number becomes 1, head is the only number left.</p>
<p>When will head be updated?</p>
<pre><code>if we move from left
if we move from right and the total remaining number % 2 == 1
like 2 4 6 8 10, we move from 10, we will take out 10, 6 and 2, head is deleted and move to 4
like 2 4 6 8 10 12, we move from 12, we will take out 12, 8, 4, head is still remaining 2
</code></pre>
<p>then we find a rule to update our head.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-10]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-10/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-10/">
        </link>
        <updated>2021-12-09T17:33:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-371-sum-of-two-integers-medium-font"><font color='red'> 371. Sum of Two Integers （Medium） </font></h1>
<p>Given two integers a and b, return the sum of the two integers without using the operators + and -.</p>
<pre><code class="language-python">class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        x, y = abs(a), abs(b)
        # ensure that abs(a) &gt;= abs(b)
        if x &lt; y:
            return self.getSum(b, a)
        
        # abs(a) &gt;= abs(b) --&gt; 
        # a determines the sign
        sign = 1 if a &gt; 0 else -1
        
        if a * b &gt;= 0:
            # sum of two positive integers x + y
            # where x &gt; y
            while y:
                answer = x ^ y
                carry = (x &amp; y) &lt;&lt; 1
                x, y = answer, carry
        else:
            # difference of two integers x - y
            # where x &gt; y
            while y:
                answer = x ^ y
                borrow = ((~x) &amp; y) &lt;&lt; 1
                x, y = answer, borrow
        
        return x * sign
#ANSWER
class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        mask = 0xFFFFFFFF
        
        while b != 0:
            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask
        
        max_int = 0x7FFFFFFF
        return a if a &lt; max_int else ~(a ^ mask)
</code></pre>
<p>bit manipulation 初见感觉是。 但不知道怎么处理。思路，borrow 是 x&amp;y《《1， 没borrow的sum是x^y.</p>
<h1 id="font-colorred-372-super-pow-medium-font"><font color='red'> 372. Super Pow (Medium) </font></h1>
<p>Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<pre><code class="language-python">class Solution:
    def superPow(self, a: int, b: List[int]) -&gt; int:
        base=1337
        def f(a,b):
            res=1
            for i in range(b):
                res*=(a%base)
                res%=base
            return res
        if not b: return 1
        last_digit=b.pop()
        return f(self.superPow(a, b), 10) * f(a, last_digit) % base;
</code></pre>
<p>mod 有结合律交换律吗？。。不太清楚。。。 答案用了1） ab % k = (a%k)(b%k)%k<br>
2）a<sup>b%k=(a%k)</sup>b%k<br>
推到递推关系：<br>
a^1234567 % k = (a^1234560 a^7)%k= ((a^1234560)%k )  ((a^7)%k ) %k<br>
= ((a<sup>123456)</sup>10)%k )  ((a^7)%k ) %k<br>
= ((((a<sup>123456)%k)</sup>10 )% k)  ((a^7)%k ) %k<br>
设 a^b%k=f(a,b)<br>
f(a,1234567)=  f(f(a,123456),10) f(a,7)%k</p>
<h1 id="font-colorred-373-find-k-pairs-with-smallest-sums-medium-font"><font color='red'> 373. Find K Pairs with Smallest Sums （Medium） </font></h1>
<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.<br>
Define a pair (u, v) which consists of one element from the first array and one element from the second array.<br>
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.</p>
<pre><code class="language-python">class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:
        res = []
        if not nums1 or not nums2 or not k:
            return res
        
        heap = []
        visited = set()
        
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        
        visited.add((0, 0))
        
        while len(res) &lt; k and heap:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            
            if i+1 &lt; len(nums1) and (i+1, j) not in visited:
                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))
                visited.add((i+1, j))
            
            if j+1 &lt; len(nums2) and (i, j+1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
                visited.add((i, j+1))
        return res
        
           

</code></pre>
<p>暴力解肯定TLE。。。也想到了是k-way merge sort 但怎么写出来？直接抄答案了，用到了heapq.heappush, heapq.heappop, visited.  先从（0，0）开始push，然后是（1，0）（0，1）， i.e.   (i,j) then (i+1,j),(i,j+1)... 通过visited 去重。</p>
<h1 id="374-guess-number-higher-or-lower-easy">374. Guess Number Higher or Lower （Easy）</h1>
<p>We are playing the Guess Game. The game is as follows:<br>
I pick a number from 1 to n. You have to guess which number I picked.<br>
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.<br>
You call a pre-defined API int guess(int num), which returns three possible results:<br>
-1: Your guess is higher than the number I picked (i.e. num &gt; pick).<br>
1: Your guess is lower than the number I picked (i.e. num &lt; pick).<br>
0: your guess is equal to the number I picked (i.e. num == pick).</p>
<pre><code class="language-python"># The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if guess(m)==0:
                return m
            elif guess(m)==1:
                l=m+1
            else:
                r=m-1
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m1=l+(r-l)//3
            m2=r-(r-l)//3
            res1=guess(m1)
            res2=guess(m2)
            if res1==0:
                return m1
            if res2==0:
                return m2
            elif res1&lt;0:
                r=m1-1
            elif res2&gt;0:
                l=m2+1
            else:
                l=m1+1
                r=m2-1
</code></pre>
<p>二分法，三分法。。。</p>
<h1 id="font-colorred375-guess-number-higher-or-lower-ii-mediumfont"><font color='red'>375. Guess Number Higher or Lower II （Medium）</font></h1>
<p>We are playing the Guessing Game. The game will work as follows:<br>
I pick a number between 1 and n.<br>
You guess a number.<br>
If you guess the right number, you win the game.<br>
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.<br>
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.</p>
<pre><code class="language-python">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        #dp[i][j] will save the min cost guessing from i to j
        dp=[[0]*(n+1) for _ in range(n+1)]
         
        def helper(start,end):
            if start&gt;=end: return 0
            if dp[start][end]!=0: return dp[start][end]
            res=float('inf')
            for x in range(start,end+1):
                #try select x,the cost will be
                tmp=x+max(helper(start,x-1),helper(x+1,end))
                res=min(res,tmp)
            dp[start][end]=res
            return res
            
        return helper( 1, n)
    
</code></pre>
<p>没思路。。。看答案，用了DP 关键是DP【i】【j】定义为从i猜到j，花费的最小cost。 那么如果X在i，j之间，选定了X，则cost为 X+max（dp【start】【x-1】，dp【x+1】【end】）因为dp这时候还没值，所以用helper（start，x-1），helper（x+1，end）代替，用max是因为不确定是左面还是右面，只能按照最坏情况准备钱。扫描所有X，然后最小的作为dp【i】【j】cost结果。</p>
<h1 id="font-colorblue376-wiggle-subsequence-mediumfont"><font color='blue'>376. Wiggle Subsequence （Medium）</font></h1>
<p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.<br>
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.<br>
Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<pre><code class="language-python">class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        #dp[i]   the max length of wiggle including nums[i]
        # 1 17 5 10 13 15 10 5 16 8
        # 0 +  - +  +   +  - - +  -
        # 1 2  3 4  4   4  5 5 6  7   
        
        # 1 7 4 9 2 5
        # 0 + - + - +
        #sign[i] the sign of max length of nums[i-1] to nums[i] if increasing 1 decresasing -1
        if len(nums)&lt;2: return len(nums)
        if len(nums)==2 and nums[0]!=nums[1]:return 2
        if len(nums)==2 and nums[0]==nums[1]:return 1
        
        
        count_plus=0
        count_minus=0
        presign=None
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]: continue
            sign= nums[i]-nums[i-1]&gt;0
            if sign:
                #positive
                if presign is None:
                    count_minus=1
                
                if presign!=sign:
                    
                    count_plus=count_minus+1
            else:
                #negtive
                if presign is None:
                    count_plus=1
                if presign!=sign:
                    count_minus=count_plus+1 
            
            presign=sign
        
        return max([1,count_plus,count_minus])

#ANSWER DP O（n*n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[1]*len(nums)
        down=[1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]&gt;nums[j]:
                    up[i]=max(up[i],down[j]+1)
                elif nums[i]&lt;nums[j]:
                    down[i]=max(down[i],up[j]+1)
        return max(up[-1],down[-1])

#ANSWER DP O（n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[0]*len(nums)
        down=[0]*len(nums)
        up[0]=1
        down[0]=1
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up[i]=down[i-1]+1
                down[i]=down[i-1]
            elif nums[i]&lt;nums[i-1]:
                down[i]=up[i-1]+1
                up[i]=up[i-1]
            else:
                down[i]=down[i-1]
                up[i]=up[i-1]
        return max(up[-1],down[-1])

#ANSWER DP O（n） space O（1）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=1
        down=1
       
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up =down +1
           
            elif nums[i]&lt;nums[i-1]:
                down =up +1
              
        return max(up ,down )

#Greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        maxLen=1
        sign=0
        for i in range(1,len(nums)):
            if nums[i]&lt;nums[i-1] and sign!=-1:
                # find a peak nums[i-1] is peak, now it is a decreasing sequence sign=-1
                sign=-1
                maxLen+=1
           
            elif nums[i]&gt;nums[i-1] and sign!=1:
                #valley
                sign=1
                maxLen+=1
              
        return maxLen
         
</code></pre>
<p>本来想用DP做，但发现只用保持 count+ 和 count- 两个计数器就够了。  如果发现增加2元序列，count-加1. 如果发现减小2元序列，count+加1，最后返回count+,count-中最大的就可以了，注意corner case。答案用了多种方法，贴上来开阔思路。第三个方法和我的一样但是写的更简单</p>
<h1 id="font-colorred-377-combination-sum-iv-mediumfont"><font color='red'> 377. Combination Sum IV （Medium）</font></h1>
<p>Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.<br>
The test cases are generated so that the answer can fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        @lru_cache(None)
        def dp(remain):
            if remain==0:
                return 1
            res=0
            for n in nums:
                if remain-n&gt;=0:
                    res+=dp(remain-n)
            return res
        return dp(target)
    
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):

            for num in nums:
                if comb_sum - num &gt;= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
</code></pre>
<p>知道是DP，而且知道DP【i】是能sum到i的组合个数，那么dp【i】=dp【i-n】+dp【n】为啥不对？？ n是添加的最后一个数。而且扫的是所有n in nums。 如果再拆分n，那么会有重复。<br>
思路卡了， 应该是dp【i】+=dp【i-n】   要往组合里加n能到i，那么多出来的组合数就是dp【i-n】。应该求的是和。。。</p>
<h1 id="379-design-phone-directory-medium">379. Design Phone Directory （Medium）</h1>
<p>Design a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.<br>
Implement the PhoneDirectory class:<br>
PhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.<br>
int get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.<br>
bool check(int number) Returns true if the slot number is available and false otherwise.<br>
void release(int number) Recycles or releases the slot number.</p>
<pre><code class="language-python">class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n=maxNumbers
        self.avaliable=set([i for i in range(self.n)])
        self.used=set()
        self.current=-1
        

    def get(self) -&gt; int:
        if not self.avaliable: return -1
        while not self.check(self.current):
            self.current= (self.current+1)%self.n
        
        #current in self.avaliable
        # remove from self.avaliable
        self.avaliable.remove(self.current)
        self.used.add(self.current)
        
        res = self.current
        self.current= (self.current+1)%self.n
        return res

    def check(self, number: int) -&gt; bool:
        return  number in self.avaliable 

    def release(self, number: int) -&gt; None:
        self.avaliable.add(number)
        if number in self.used:
            self.used.remove(number)
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)

   def __init__(self, maxNumbers):
        self.available = set(range(maxNumbers))

    def get(self):
        return self.available.pop() if self.available else -1

    def check(self, number):
        return number in self.available

    def release(self, number):
        self.available.add(number)

#ANSWER PERFECT
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.pos=0
        self.next=[0]*maxNumbers
        for i in range(maxNumbers):
            self.next[i]=(i+1)%maxNumbers
        

    def get(self) -&gt; int:
        if self.next[self.pos]==-1: return -1
        res=self.pos
        self.pos=self.next[self.pos]
        self.next[res]=-1
        return res
        

    def check(self, number: int) -&gt; bool:
        return self.next[number]!=-1

    def release(self, number: int) -&gt; None:
        if self.next[number]!=-1: return
        self.next[number]=self.pos
        self.pos=number
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number) int[] next;
   
  


</code></pre>
<p>答案很完美的写法：Use a linked list to track available numbers, and a pointer to head. If head is still available, get() would return it and move to the next available number. Release would re-add a node to the beginning of the linked list and update head</p>
<h1 id="font-colorred-380-insert-delete-getrandom-o1-mediumfont"><font color='red'> 380. Insert Delete GetRandom O(1) （Medium）</font></h1>
<p>Implement the RandomizedSet class:</p>
<pre><code>RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
</code></pre>
<p>You must implement the functions of the class such that each function works in average O(1) time complexity.</p>
<pre><code class="language-python">from random import choice
class RandomizedSet():
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -&gt; int:
        &quot;&quot;&quot;
        Get a random element from the set.
        &quot;&quot;&quot;
        return choice(self.list)

</code></pre>
<p>这个思路好，用dic保存插入元素位置方便找出index， 删除时候找出index，然后和list中最后一个元素交换位置，然后pop list del dict【val】</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-09]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-09/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-09/">
        </link>
        <updated>2021-12-09T05:25:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="361-bomb-enemy-medium">361. Bomb Enemy （Medium）</h1>
<p>Given an m x n matrix grid where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.</p>
<p>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.</p>
<pre><code class="language-python">class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        m=len(grid)
        n=len(grid[0])
        dp=[[0]*n for _ in range(m) ]
        #look from left for each row
        for i in range(m):
            c=0
            for j in range(n):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from right for each row
        for i in range(m):
            c=0
            for j in range(n-1,-1,-1):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from up for each col
        for i in range(n):
            c=0
            for j in range(m):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
        #look from bottom for each col
        for i in range(n):
            c=0
            for j in range(m-1,-1,-1):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
         
        res=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]=='0':
                    res=max(res,dp[i][j])
        return res
                
 #ANSWER
 class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        if len(grid) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        max_count = 0
        row_hits = 0
        col_hits = [0] * cols

        for row in range(0, rows):
            for col in range(0, cols):
                # reset the hits on the row, if necessary.
                if col == 0 or grid[row][col - 1] == 'W':
                    row_hits = 0
                    for k in range(col, cols):
                        if grid[row][k] == 'W':
                            # stop the scan when we hit the wall.
                            break
                        elif grid[row][k] == 'E':
                            row_hits += 1

                # reset the hits on the col, if necessary.
                if row == 0 or grid[row - 1][col] == 'W':
                    col_hits[col] = 0
                    for k in range(row, rows):
                        if grid[k][col] == 'W':
                            break
                        elif grid[k][col] == 'E':
                            col_hits[col] += 1

                # count the hits for each empty cell.
                if grid[row][col] == '0':
                    total_hits = row_hits + col_hits[col]
                    max_count = max(max_count, total_hits)

        return max_count       
</code></pre>
<p>和答案思路是一致的，写的更简洁些。</p>
<h1 id="362-design-hit-counter-medium">362. Design Hit Counter （Medium）</h1>
<p>Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).<br>
Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). Several hits may arrive roughly at the same time.<br>
Implement the HitCounter class:<br>
HitCounter() Initializes the object of the hit counter system.<br>
void hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.<br>
int getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).</p>
<pre><code class="language-python">#NOT WORKING DUE TO timestamp range up to 2*10^9
class HitCounter:
    class BIT:
        def __init__(self,size):
            self.size=size
            self.tree=[0]*size
            
        def update(self,ind):
            #index in BIT is 1 more than original index
            while ind&lt;self.size:
                self.tree[ind]+=1
                ind+= ind&amp;-ind
        def query(self,ind):
            #index in BIT is 1 more than original index
            res=0
            while ind&gt;0:
                res+=self.tree[ind]
                ind-= ind&amp;-ind
            return res


    def __init__(self):
        self.tree=self.BIT(2000)
    def hit(self, timestamp: int) -&gt; None:
        self.tree.update(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return self.tree.query(timestamp)-self.tree.query(timestamp-300 if timestamp-300&gt;0 else 0)
        
#ANOTHER WAY...
class HitCounter:

    def __init__(self):
        self.data=[]
        
        

    def hit(self, timestamp: int) -&gt; None:
        self.data.append(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return bisect.bisect_right(self.data,timestamp)-bisect.bisect_left(self.data,timestamp-299)


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)

class HitCounter(object):

def __init__(self):
    &quot;&quot;&quot;
    Initialize your data structure here.
    &quot;&quot;&quot;
    self.deque = collections.deque()

def hit(self, timestamp):
    &quot;&quot;&quot;
    Record a hit.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: None
    &quot;&quot;&quot;
    self.deque.append(timestamp)
    

def getHits(self, timestamp):
    &quot;&quot;&quot;
    Return the number of hits in the past 5 minutes.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: int
    &quot;&quot;&quot;

    while self.deque and timestamp - self.deque[0] &gt;= 300:
        self.deque.popleft()
    return len(self.deque)

</code></pre>
<p>感觉用Seg Tree 或者Binary Indexed Tree 但忘记怎么写。。。遇到memory out of bond 问题，因为timestamp 范围太大。。。换思路。。。直接用binary search。。。或者用queue</p>
<h1 id="font-colorred-363-max-sum-of-rectangle-no-larger-than-k-hardfont"><font color='red'> 363. Max Sum of Rectangle No Larger Than K （Hard）</font></h1>
<p>Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        m=len(matrix)
        n=len(matrix[0])
        res=[]
        for i in range(m):
            for j in range(n):
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
                if i==0 and j==0:continue
                if j&gt;0 and i==0 :
                    matrix[i][j]+=matrix[i][j-1]
                elif i&gt;0 and j==0:
                    matrix[i][j]+=matrix[i-1][j]
                else:
                    matrix[i][j]+=matrix[i][j-1]+matrix[i-1][j]-matrix[i-1][j-1]
                
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
        
        #for row in matrix:
        #    print(row)
        #print(res)
   
        for row in range(m):
            for col in range(n):
                for row_p in range(row):
                    area=matrix[row][col]-matrix[row_p][col]
                    if area&lt;=k:
                            heapq.heappush(res,-area)
                    for col_p in range(col):
                        area=matrix[row][col]-matrix[row][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)
                        area=matrix[row][col]-matrix[row_p][col]-matrix[row][col_p]+matrix[row_p][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)

        return -heapq.heappop(res)

#ANSWER
import sortedcontainers
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        def updateresult(nums,k):
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result

#ANSWER 
import sortedcontainers
class Solution:
    
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        
        def getmaxkadane(nums):
            maxkadane=float('-inf')
            currentmaxsum=0
            for num in nums:
                currentmaxsum=max(currentmaxsum+num,num)
                maxkadane=max(maxkadane,currentmaxsum)
            return maxkadane
        def updateresult(nums,k):
            kadanesum=getmaxkadane(nums)
            if kadanesum&lt;=k:
                self.result=max(self.result,kadanesum)
                return
            
            
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result
                      
</code></pre>
<p>初次尝试heapq+cumsum time limit exceeded，因为还是属于暴力解法。。。看答案。答案用python去解也是TLE， 答案思路，先考虑1D问题，要寻找加和小于等于K的，相当于找当前的runningsum-X小于等于K，所以要寻找X大于等于runningsum-K，这样用orderedset和binary seasrch可以从runningsum中找到这个X，runningsum-X就是要求的小于等于K的累加和。 再还原成2d问题，对于每一个起始点为ith row的数据，初始化一个rowsum。然后每添加一个row就update一下答案。 Time complexity: O(m2nlog⁡n)<br>
另一种方法增加改进用Kadane's algorithm gets the max possible sum of a sub-array in O(n) time，</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        # Initialize our variables using the first element.
        current_subarray = max_subarray = nums[0]
        # Start with the 2nd element since we already used the first one.
        for num in nums[1:]:
            # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
            current_subarray = max(num, current_subarray + num)
            max_subarray = max(max_subarray, current_subarray)
        return max_subarray
</code></pre>
<p>一种DP的方法求maxsubarray。。。因为一个row如果maxsumarry已经小于等于K了就没必要用nlogn方法的updateresult再去求了，算一步时间复杂度上的小优化。这样写出来能pass。</p>
<h1 id="364-nested-list-weight-sum-ii-medium">364. Nested List Weight Sum II （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth. Let maxDepth be the maximum depth of any integer.<br>
The weight of an integer is maxDepth - (the depth of the integer) + 1.<br>
Return the sum of each integer in nestedList multiplied by its weight.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &quot;&quot;&quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &quot;&quot;&quot;
#
#    def isInteger(self):
#        &quot;&quot;&quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def add(self, elem):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def setInteger(self, value):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def getInteger(self):
#        &quot;&quot;&quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &quot;&quot;&quot;
#
#    def getList(self):
#        &quot;&quot;&quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &quot;&quot;&quot;

class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -&gt; int:
        #[[1,1],2,[1,1]]
        
        def depth(nestedList):
            d=1
            for li in nestedList:
                if not li.isInteger():
                    d=max(d,1+depth(li.getList()))
            return d
                    
                    
                
        maxd=depth(nestedList)    
        #print(maxd)
    
        
        def helper(nestedList,depth):
            res=0
            for li in nestedList:
                if li.isInteger():
                    #print(li.getInteger(),(maxd-depth+1))
                    res+=li.getInteger()*(maxd-depth+1)
                else:
                    
                    res+=helper(li.getList(),depth+1)
                   
            return res
        
        return helper(nestedList,1)

            
        
</code></pre>
<p>算maxdepth时候卡壳了。。。。写出的算法同答案1，double DFS。 算法2，3用了math+BFS。</p>
<h1 id="font-colorred365-water-and-jug-problem-mediumfont"><font color='red'>365. Water and Jug Problem （Medium）</font></h1>
<p>ou are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.</p>
<p>If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<pre><code>Fill any of the jugs with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.
</code></pre>
<pre><code class="language-python">class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
     
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
        if x + y &lt; z: return False
        if  x == z or y == z or x + y == z : return True
        
        def GCD(a,b):
            while b:
                a,b=b,a%b
            return a
        return z%GCD(x, y) == 0 

#ANSWER BFS
class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
     
        if x&gt;y:
            #make sure x&lt;y
            x,y=y,x
            
        if z &gt; x + y: return False
        
        # set the initial state will empty jars;
        queue = [(0, 0)]
        visited = set((0, 0))
        while queue:
            a, b = queue.pop(0);
            if a + b == z:
                return True;
            
            states = set()
            
            states.add((x, b)) # fill jar x;
            states.add((a, y)) # fill jar y;
            states.add((0, b)) # empty jar x;
            states.add((a, 0)) # empty jar y;
            states.add((min(x, b + a), 0 if b &lt; x - a else b - (x - a))) # pour jar y to x;
            states.add((0 if a + b &lt; y else a - (y - b), min(b + a, y))) # pour jar x to y;

            for state in states:
                if state in visited:
                    continue;
                queue.append(state)
                visited.add(state);
                
        return False

</code></pre>
<p>一眼看上去好像是个dp问题。但提示是DFS，BFS, MATH。 答案用了 Bézout's identity and check if z is a multiple of GCD(x, y)<br>
Bézout's identity (also called Bézout's lemma) is a theorem in the elementary theory of numbers:<br>
let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x and y such that ax+by=d，In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by every integer of the form ax + by is a multiple of the greatest common divisor d.<br>
BFS解法也很经典</p>
<h1 id="366-find-leaves-of-binary-tree-medium">366. Find Leaves of Binary Tree （Medium）</h1>
<p>Given the root of a binary tree, collect a tree's nodes as if you were doing this:<br>
Collect all the leaf nodes.<br>
Remove all the leaf nodes.<br>
Repeat until the tree is empty.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        self.maxd=0
        def depth(root):
            if not root: return
            if not root.left and not root.right:
                root.d=0
                return
        
            depth(root.left)
            depth(root.right)
            
            if root.left and root.right:
                root.d=max(root.left.d,root.right.d)+1
            elif root.left:
                root.d=root.left.d+1
            else:
                root.d=root.right.d+1
            
            self.maxd=max(self.maxd,root.d)
                
                    
        depth(root)
        res=[[] for _ in range(self.maxd+1)]
        
        def pre(root):
            if not root: return 
            res[root.d].append(root.val)
            pre(root.left)
            pre(root.right)
        
        pre(root)
        return res 


#ANSWER
def findLeaves(self, root: TreeNode) -&gt; List[List[int]]:
    output = collections.defaultdict(list)
    
    def dfs(node, layer):
        if not node: 
            return layer 
        left = dfs(node.left, layer)
        right = dfs(node.right, layer)
        layer = max(left, right)
        output[layer].append(node.val)
        return layer + 1
    
    dfs(root, 0)
    return output.values() 
</code></pre>
<p>先后序遍历给node标号，同时知道最大深度，然后初始化res，再前序遍历把val放到应该放的res位置。答案把所有的都放在后序遍历里了。</p>
<h1 id="367-valid-perfect-square-easy">367. Valid Perfect Square （Easy）</h1>
<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<pre><code class="language-python">class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        l=1
        r=num//2+1
        while l&lt;=r:
            m= (l+r)//2
            if m*m==num:
                return True
            elif m*m&gt;num:
                r=m-1
            else:
                l=m+1
        return False
#ANSWER
class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        if num &lt; 2:
            return True
        
        x = num // 2
        while x * x &gt; num:
            x = (x + num // x) // 2
        return x * x == num
</code></pre>
<p>答案用了牛顿法，更快收敛比二分法。找出f（x）= x^2-num=0的根。 设一个猜测值Xk  ，f（Xk）是y值，f‘（Xk）是对比底，所以底= f（Xk）/f'(Xk)  新的猜测Xk+1= Xk- f（Xk）/f'(Xk) 所以 xk+1​=0.5*(xk​+num/xk​​)<br>
牛顿法也是O(log⁡N)</p>
<h1 id="font-colorred368-largest-divisible-subset-mediumfont"><font color='red'>368. Largest Divisible Subset （Medium）</font></h1>
<p>Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:<br>
answer[i] % answer[j] == 0, or<br>
answer[j] % answer[i] == 0<br>
If there are multiple solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:
        #dp[i]= maxsubset include nums[i] from 0 to i
        # dp[i]=      nums[0] to nums[i] are divisible by nums[i] find max(dp)+1
        nums.sort()
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i]%nums[j]==0 or nums[j]%nums[i]==0:
                    dp[i]=max(dp[i],dp[j]+1)
               
        ind=dp.index(max(dp))
        while ind+1&lt;len(dp) and dp[ind+1]==max(dp):
            ind+=1
        #print(nums)
        #print(dp)
        #reconstruct res
        res=[]
        cursize=max(dp)
        curtail=nums[ind]
        for i in range(ind,-1,-1):
            if cursize==dp[i] and curtail%nums[i]==0:
                res.append(nums[i])
                cursize-=1
                curtail=nums[i]
        return res[::-1]

 #ANSWER WAY OF WRITING        
class Solution(object):
    def largestDivisibleSubset(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # The container that holds all intermediate solutions.
        # key: the largest element in a valid subset.
        subsets = {-1: set()}
        
        for num in sorted(nums):
            subsets[num] = max([subsets[k] for k in subsets if num % k == 0], key=len) | {num}
        
        return list(max(subsets.values(), key=len))
</code></pre>
<p>用dp可以算出长度，但没法正确给出一个result。问题出在了reconstruct这一步。 看了答案写出来了。<br>
答案写出算法用了2个定理。假设【E，F，G】已经是从小到大排序好的而且是divisible subset，那么1）对于h大于G， h%G等于0则【E，F，G，h】满足divisible subset  2）对于 d小于E，若 E%d==0则【d，E，F，G】满足divisible subset。</p>
<h1 id="369-plus-one-linked-list-medium">369. Plus One Linked List （Medium）</h1>
<p>Given a non-negative integer represented as a linked list of digits, plus one to the integer.<br>
The digits are stored such that the most significant digit is at the head of the list.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
        revlist_head = rev(head)
        cur=revlist_head
        first=True
        carry=0
        pre=None
        while cur:
            if first:
                val=cur.val+carry+1
                cur.val=val%10
                carry=val//10
                first=False
            else:
                val=cur.val+carry
                cur.val=val%10
                carry=val//10
            pre=cur
            cur=cur.next
        
        if carry:
            pre.next=ListNode(val=carry)
        
        return rev(revlist_head)

#ANSWER WAY OF WRITING
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        # sentinel head
        sentinel = ListNode(0)
        sentinel.next = head
        not_nine = sentinel

        # find the rightmost not-nine digit
        while head:
            if head.val != 9:
                not_nine = head
            head = head.next

        # increase this rightmost not-nine digit by 1
        not_nine.val += 1
        not_nine = not_nine.next

        # set all the following nines to zeros
        while not_nine:
            not_nine.val = 0
            not_nine = not_nine.next

        return sentinel if sentinel.val else sentinel.next

</code></pre>
<p>先rev了加1，然后再rev回去。<br>
答案做法用哨兵0node，找到最右面不是9的node+1，后面是9的一律变0.</p>
<h1 id="font-colorblue-370-range-addition-mediumfont"><font color='blue'> 370. Range Addition （Medium）</font></h1>
<p>You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].</p>
<p>You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.</p>
<p>Return arr after applying all the updates.</p>
<pre><code class="language-python">class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:
        #brute force
        res=[0]*length
        for update in updates:
            i,j,inc=update
            res[i]+=inc
            if j+1&lt;length:
                res[j+1]+=-inc 
            
        for i in range(1,length):
            res[i]+=res[i-1]
        return res
        

</code></pre>
<p>暴力解TLE。。 看了hint写出来了。。。第一个hint就是没必要用复杂数据结构，别想太多。<br>
BIT,SEGMENTTREE</p>
<pre><code class="language-python">tree=[0]*(2*size)   
#####SEGMENT TREE
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7
       
def update(ind):
    tree[ind]+=1
    
    while ind&gt;0:
        left=ind
        right=ind
        if ind%2==0:
            right+=1
        else:
            left-=1
        if ind//2&gt;0:
            tree[ind//2]=tree[left]+tree[right]
        ind//=2
#####
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7      
def query(left,right):
    res=0
    while left&lt;=right:
        if right%2==0:
            res+=tree[right]
            right-=1
        if left%2==1:
            res+=tree[left]
            left+=1

        left//=2
        right//=2

    return res

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-08]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-08/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-08/">
        </link>
        <updated>2021-12-08T03:32:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred351-android-unlock-patterns-medium-font"><font color='red'>351. Android Unlock Patterns (Medium) </font></h1>
<p>Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an &quot;unlock pattern&quot; by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true:<br>
All the dots in the sequence are distinct.<br>
If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.<br>
For example, connecting dots 2 and 9 without dots 5 or 6 appearing beforehand is valid because the line from dot 2 to dot 9 does not pass through the center of either dot 5 or 6.<br>
However, connecting dots 1 and 3 without dot 2 appearing beforehand is invalid because the line from dot 1 to dot 3 passes through the center of dot 2.<br>
Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys.</p>
<p>Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.</p>
<pre><code class="language-python">class Solution:
    def numberOfPatterns(self, m: int, n: int) -&gt; int:
        skip = [[0]*10 for _ in range(10)]
        skip[1][3] = skip[3][1] = 2 
        skip[1][7] = skip[7][1] = 4 
        skip[3][9] = skip[9][3] = 6 
        skip[7][9] = skip[9][7] = 8 
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5 
        visited = [False]*10
        res=0
        def DFS(cur,remain):
            if remain&lt;0: return 0
            if remain==0: return 1
            visited[cur]=True
            res=0
            for i in range(1,10):
                if not visited[i] and (skip[cur][i]==0 or visited[skip[cur][i]]):
                    res+=DFS(i,remain-1)
            visited[cur]=False
            return res
        
        for i in range(m,n+1):
            res+=DFS(1,i-1)*4 # 1,3,7, 9 sym 
            res+=DFS(2,i-1)*4 # 2 4 6 8  sym
            res+=DFS(5,i-1) 
            
        return res
        
</code></pre>
<p>问题是奇怪的问题，解决方法大概是DP，但递归关系不好找。思路错误， 答案用DFS+BT  简化思路是 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.</p>
<h1 id="font-colorred352-data-stream-as-disjoint-intervals-hardfont"><font color='red'>352. Data Stream as Disjoint Intervals （Hard）</font></h1>
<p>Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.<br>
Implement the SummaryRanges class:<br>
SummaryRanges() Initializes the object with an empty stream.<br>
void addNum(int val) Adds the integer val to the stream.<br>
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].</p>
<pre><code class="language-python">class SummaryRanges:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.interval = [] # record the interval
        self.s = set() # record the number we have added before
        return 

    def addNum(self, val: int) -&gt; None:
        if val in self.s:
            return 
        self.s.add(val)
        index = bisect_left(self.interval,[val,val])

        # check whether we could extend the interval on its left and right 
        if index &lt; len(self.interval) and self.interval[index][0]-1 == val:
            self.interval[index][0] = self.interval[index][0] - 1
        elif index &gt; 0 and self.interval[index-1][1]+1 == val:
            self.interval[index-1][1] = self.interval[index-1][1] + 1
        else:
            self.interval.insert(index, [val,val])

    def getIntervals(self) -&gt; List[List[int]]:
        # update the intervals in getIntervals function 
        connect = []
        for x in self.interval:
            if connect and connect[-1][1] == x[0]-1:
                connect[-1][1] = x[1]
            else:
                connect.append(x)
        self.interval = connect
        return self.interval 

</code></pre>
<p>思路： binary search for interval， interval update when getIntervals。</p>
<h1 id="353-design-snake-game-medium">353. Design Snake Game （Medium）</h1>
<pre><code class="language-python">class SnakeGame:

    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.food=food
        self.w=width
        self.h=height
        self.score=0
        self.body = [[0,0]]
        self.pos=[0,0]

    def move(self, direction: str) -&gt; int:
        #outofbound check
        if direction=='R':
            self.pos[1]+=1
        elif direction=='L':
            self.pos[1]-=1
        elif direction=='U':
            self.pos[0]-=1
        elif direction=='D':
            self.pos[0]+=1
        
        if not (self.h&gt;self.pos[0]&gt;=0): return -1
        if not (self.w&gt;self.pos[1]&gt;=0): return -1
        
        #hadle food
       
        if not (self.food and self.pos==self.food[0]):
            #no food
            self.body.pop(0)
            if self.pos in self.body: return -1
            self.body.append(self.pos[:])
        else:
            #food
            self.food.pop(0)
            self.body.append(self.pos[:])
            self.score+=1
        return self.score
            
# Your SnakeGame object will be instantiated and called as such:
# obj = SnakeGame(width, height, food)
# param_1 = obj.move(direction)

</code></pre>
<h1 id="font-colorred354-russian-doll-envelopes-hard-font"><font color='red'>354. Russian Doll Envelopes (Hard) </font></h1>
<p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.</p>
<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.</p>
<p>Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).</p>
<pre><code class="language-python">from bisect import bisect_left
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:
        arr = envelopes
        arr.sort(key=lambda x: (x[0], -x[1]))

        def lis(nums):
            dp = []
            for i in range(len(nums)):
                idx = bisect_left(dp, nums[i])
                if idx == len(dp):
                    dp.append(nums[i])
                else:
                    dp[idx] = nums[i]
            return len(dp)
        # extract the second dimension and run the LIS
        return lis([i[1] for i in arr])

</code></pre>
<p>尝试用greedy解决但失败了，感觉是个DP问题。。。思路看答案了。  2D longest increasing subsequence problem (LIS).  KEY： ''we also sort decreasing on the second dimension, so two envelopes that are equal in the first dimension can never be in the same increasing subsequence'' 关键是NlogN的 LIS 没用过。。。，需要记住写法。dp[i] 存储的是长度是i+1的LIS末尾元素。</p>
<h1 id="355-design-twitter-medium">355. Design Twitter （Medium）</h1>
<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.<br>
Implement the Twitter class:<br>
Twitter() Initializes your twitter object.<br>
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.<br>
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.<br>
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.<br>
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.</p>
<pre><code class="language-python">
class Twitter:

    def __init__(self):
        self.follows=collections.defaultdict(set)
        self.tweets=collections.defaultdict(list)
        self.time=0
   

    def postTweet(self, userId: int, tweetId: int) -&gt; None:
        self.tweets[userId].append([tweetId,self.time])
        self.time+=1
        

    def getNewsFeed(self, userId: int) -&gt; List[int]:
        res=[]
        followers=self.follows[userId]
        for f in list(followers)+[userId]:
            res.extend(self.tweets[f])
        
        return [ e[0] for e in sorted(res,key=lambda x:-x[1])][:10] 

    def follow(self, followerId: int, followeeId: int) -&gt; None:
        self.follows[followerId].add(followeeId)
    

    def unfollow(self, followerId: int, followeeId: int) -&gt; None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
        


</code></pre>
<h1 id="font-colorred356-line-reflection-medium-font"><font color='red'>356. Line Reflection (Medium) </font></h1>
<p>Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.</p>
<p>In other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.</p>
<pre><code class="language-python">class Solution:
    def isReflected(self, points: List[List[int]]) -&gt; bool:
        s=set()
        min_=float('inf')
        max_=float('-inf')
        for p in points:
            min_=min(p[0],min_)
            max_=max(p[0],max_)
            s.add(tuple(p))
        sum_=min_+max_
        for p in points:
            if s and (sum_-p[0],p[1]) not in s:
                return False
        return True
        

</code></pre>
<p>思路竟然和two sum类似， 用一个set先保存点，然后找reflect点是否在set里。 中心位置一定是min+max的中点。</p>
<h1 id="font-colorblue357-count-numbers-with-unique-digits-medium-font"><font color='blue'>357. Count Numbers with Unique Digits (Medium) </font></h1>
<p>Given an integer n, return the count of all numbers with unique digits, x, where 0 &lt;= x &lt; 10n.</p>
<pre><code class="language-python">class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        #Let f(k) = count of numbers with unique digits with length equals k.
        # f(1)=10
        # f(2)=9*9   choose 1~9, choose 0~9 except first choose
        # f(3)=9*9*8
        # f(k)=9*9*8*...(9-k+2)
        if n==0: return 1
        if n==1: return 10 
        if n==2: return 91
        f=[0]*(n+1)
        f[1]=10
        f[2]=81
        for i in range(3,n+1):
            f[i]=f[i-1]*(9-i+2)
        
         
        res=0
        for j in range(1,n+1):
            #print(j,f[j])
            res+=f[j]
        return res
</code></pre>
<p>看了提示才做出来。。。 定义f（x） ，意思是长度为x的string，有多少种不同组合方式。答案就是f1+f2+。。。+fn</p>
<h1 id="font-colorred-358-rearrange-string-k-distance-apart-hard-font"><font color='red'> 358. Rearrange String k Distance Apart (Hard) </font></h1>
<p>Given a string s and an integer k, rearrange s such that the same characters are at least distance k from each other. If it is not possible to rearrange the string, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">class Solution:
    def rearrangeString(self, s: str, k: int) -&gt; str:
     
        if k == 0:
            return s
        n = len(s)
        count = collections.Counter(s)
        max_val = max(count.values())
        max_count = sum(1 for val in count.values() if val == max_val)
        if (max_val-1)*k+max_count &gt; n:
            return &quot;&quot;
        
        buckets = [[] for _ in range(max_val)]
        cnt = 0
        for key in sorted(count, key = lambda x: -count[x]):
            divisor = max_val if count[key] == max_val else max_val-1
            for _ in range(count[key]):
                buckets[cnt% divisor].append(key)
                cnt += 1
        return &quot;&quot;.join([&quot;&quot;.join(bucket) for bucket in buckets])
</code></pre>
<p>刚开始想用bt做，看了答案用的是比较巧妙的bucket。 而且要从数目多的char到数目少的char来排。 排的位置如果是频率最大的，则能排到所有buket，否则只能排到n-1 buket。<br>
aaabbcccd  k=2<br>
count={a：3，c：3，b：2，d：1}<br>
max_val=3 所以有3个buket<br>
【】 【】 【】<br>
先排a，divisor=3<br>
【a】 【a】 【a】<br>
再排c，divisor=3<br>
【ac】【ac】【ac】<br>
再排b，divisor=2 最后一个位置排满了<br>
【acb】【acb】【ac】<br>
再排d，divisor=2<br>
【acbd】【acb】【ac】</p>
<p>这个思路比较难想出来。。。buket+变divisor。。。</p>
<h1 id="359-logger-rate-limiter-easy">359. Logger Rate Limiter （Easy）</h1>
<p>Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).<br>
All messages will come in chronological order. Several messages may arrive at the same timestamp.<br>
Implement the Logger class:<br>
Logger() Initializes the logger object.<br>
bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.</p>
<pre><code class="language-python">class Logger:

    def __init__(self):
        self.dic=dict()
        

    def shouldPrintMessage(self, timestamp: int, message: str) -&gt; bool:
        res=True
        if message in self.dic and timestamp-self.dic[message]&lt;10:
            res=False
        if res:
            self.dic[message]=timestamp
        return res
# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)


#ANSWER WAY OF WRITTING
class Logger(object):

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._msg_dict = {}
    
    def shouldPrintMessage(self, timestamp, message):
        &quot;&quot;&quot;
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        &quot;&quot;&quot;
        if message not in self._msg_dict:
            # case 1). add the message to print
            self._msg_dict[message] = timestamp
            return True

        if timestamp - self._msg_dict[message] &gt;= 10:
            # case 2). update the timestamp of the message
            self._msg_dict[message] = timestamp
            return True
        else:
            return False

</code></pre>
<h1 id="360-sort-transformed-array-medium">360. Sort Transformed Array (Medium)</h1>
<p>Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.</p>
<pre><code class="language-python">class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
        #f(x)=ax**2+bx+c
        #f(x)= a(x+b/2a)**2 -b**2/4a+c
        #Therefore, sym axis=  -b/2a  
        
        
        
        f=lambda x: a*x**2+b*x+c
        if a==0: return [f(i) for i in nums] if b&gt;0 else  [f(i) for i in nums[::-1]]
        
        axis=-b/(2*a)
        res=[]
        ind=bisect.bisect_left(nums,axis)
        l=ind-1
        r=ind
        while l&gt;=0 and r&lt;len(nums):
            
            if a&gt;0: #fill left to right find smaller
                if f(nums[l])&lt;=f(nums[r]):
                    res.append(f(nums[l]))
                    l-=1
                else:
                    res.append(f(nums[r]))
                    r+=1
            
            else:# fill right to left find larger
                if f(nums[l])&gt;=f(nums[r]):
                    res=[f(nums[l])]+res
                    l-=1
                else:
                    res= [f(nums[r])]+res
                    r+=1
        
        #print(res)
        while l&gt;=0:
            if a&gt;0:
                res.append(f(nums[l]))
            else:
                res=[f(nums[l])]+res
            l-=1
                
        while r&lt;len(nums):
            if a&gt;0:
                res.append(f(nums[r]))
            else:
                res=[f(nums[r])]+res
            r+=1
        
        return res
        
#ANSWER WAY
class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
 
        
        f=lambda x: a*x**2+b*x+c
        n=len(nums)
        res=['NULL']*n
        l=0
        r=n-1
        index= n-1 if a&gt;=0 else 0
        while l&lt;=r:
            if a&gt;=0:
                res[index]=f(nums[l]) if f(nums[l])&gt;=f(nums[r]) else f(nums[r])
                index-=1
                if f(nums[l])&gt;=f(nums[r]):
                    l+=1
                else:
                    r-=1
             
            else:
                res[index]=f(nums[r]) if f(nums[l])&gt;=f(nums[r]) else f(nums[l])
                index+=1
                if f(nums[l])&gt;=f(nums[r]):
                    r-=1
                else:
                    l+=1
        return res
      

</code></pre>
<p>考二次函数，答案更精巧 用two pointer，关键点在于如果a大于0, 最大值肯定在head tail之间的一个，如果a小于0，最小值肯定在head tail中的一个。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-07]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-07/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-07/">
        </link>
        <updated>2021-12-06T22:31:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred341-flatten-nested-list-iterator-mediumfont"><font color='red'>341. Flatten Nested List Iterator （Medium）</font></h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>
<pre><code class="language-python">
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.integers=[]
        self.position = -1
        def flaten_list(nestedList):
            for nl in nestedList:
                if nl.isInteger():
                    self.integers.append(nl.getInteger())
                else:
                    flaten_list(nl.getList())
        flaten_list(nestedList)
    
    def next(self) -&gt; int:
        self.position+=1
        return self.integers[self.position]
    
    def hasNext(self) -&gt; bool:
        return self.position+1&lt;len(self.integers)


class NestedIterator(object):

    def __init__(self, nestedList):
        &quot;&quot;&quot;
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        &quot;&quot;&quot;
        self.stack = nestedList[::-1]
        
    def next(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.stack.pop().getInteger()
        
    def hasNext(self):
        &quot;&quot;&quot;
        :rtype: bool
        &quot;&quot;&quot;
        while self.stack:
            top = self.stack[-1]
            if top.isInteger():
                return True
            self.stack = self.stack[:-1] + top.getList()[::-1]
        return False

class NestedIterator:

    def __init__(self, nestedList: [NestedInteger]):
        # Get a generator object from the generator function, passing in
        # nestedList as the parameter.
        self._generator = self._int_generator(nestedList)
        # All values are placed here before being returned.
        self._peeked = None

    # This is the generator function. It can be used to create generator
    # objects.
    def _int_generator(self, nested_list) -&gt; &quot;Generator[int]&quot;:
        # This code is the same as Approach 1. It's a recursive DFS.
        for nested in nested_list:
            if nested.isInteger():
                yield nested.getInteger()
            else:
                # We always use &quot;yield from&quot; on recursive generator calls.
                yield from self._int_generator(nested.getList())
        # Will automatically raise a StopIteration.
    
    def next(self) -&gt; int:
        # Check there are integers left, and if so, then this will
        # also put one into self._peeked.
        if not self.hasNext(): return None
        # Return the value of self._peeked, also clearing it.
        next_integer, self._peeked = self._peeked, None
        return next_integer
        
    def hasNext(self) -&gt; bool:
        if self._peeked is not None: return True
        try: # Get another integer out of the generator.
            self._peeked = next(self._generator)
            return True
        except: # The generator is finished so raised StopIteration.
            return False

</code></pre>
<p>generator 解法没见过， 普通解法，要么初始化时候分解，要么用stack倒序，保证栈顶是integer。</p>
<h1 id="342-power-of-four-easy">342. Power of Four （Easy）</h1>
<p>Given an integer n, return true if it is a power of four. Otherwise, return false.<br>
An integer n is a power of four, if there exists an integer x such that n == 4^x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfFour(self, n: int) -&gt; bool:
        if n==0: return False 
        while n:
            if n==1: return True
            if n%4!=0:
                return False
            n//=4
        return True

class Solution(object):
    def isPowerOfFour(self, n):
        if n == 0:
            return False
        while n % 4 == 0:
            n /= 4
        return n == 1
</code></pre>
<h1 id="font-colorred343-integer-break-medium-font"><font color='red'>343. Integer Break (Medium) </font></h1>
<p>Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers.<br>
Return the maximum product you can get.</p>
<pre><code class="language-python">class Solution:
    def integerBreak(self, n: int) -&gt; int:
        dp = [0]*(n+1)
        dp[1]=1
        for i in range(2,n+1):
            for j in range(1,i):
                dp[i]=max(dp[i],max(dp[j],j)*max(i-j,dp[i-j]))
        return dp[n]
  
class Solution:
    def integerBreak(self, n: int) -&gt; int:
        if n==2: return 1
        if n==3: return 2
        product = 1
        while n&gt;4:
            product*=3;
            n-=3
        product*=n;
        return product

#
class Solution:
    def integerBreak(self, n: int) -&gt; int:
        if n == 2: 
            return 1 
        elif n == 3:
            return 2
        elif n%3 == 0:
            return 3**(n//3)
        elif n%3 == 1:
            return 4* 3**((n - 4) // 3)
        else: 
            #n%3==2
            return 2 * (3** (n//3))
</code></pre>
<p>没思路,答案一，dp，dp【i】保存i可以被分解的最大乘集，假设i被分解成 a和b的和， 那么a或者b可以选中集训分解dp【a/b】或者不分解保留原始值a/b. 思路2： 用3 as many as possible. 比如 6, 3 乘 3大于2 乘 2 乘 2. 因此答案不会有超过3个的2. 尽力用3.   答案3： 有了思路2 ，和容易写出答案3.但dp这种方法应该想出来。。。</p>
<h1 id="344-reverse-string-easy">344. Reverse String (Easy)</h1>
<p>Write a function that reverses a string. The input string is given as an array of characters s.<br>
You must do this by modifying the input array in-place with O(1) extra memory.</p>
<pre><code class="language-python">class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        l=0
        r=len(s)-1
        while l&lt;r:
            s[l],s[r]=s[r],s[l]
            l+=1
            r-=1
</code></pre>
<h1 id="345-reverse-vowels-of-a-string-easy">345. Reverse Vowels of a String (Easy)</h1>
<p>Given a string s, reverse only all the vowels in the string and return it.<br>
The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.</p>
<pre><code class="language-python">class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        s=[e for e in s]
        l=0
        r=len(s)-1
        vowels={'a','e','i','o','u'}
        while l&lt;r:
            while l&lt;r and s[l].lower() not in vowels:
                l+=1
            while l&lt;r and s[r].lower() not in vowels:
                r-=1
            
            s[l],s[r]=s[r],s[l]
            r-=1
            l+=1
        
        return ''.join(s)
</code></pre>
<h1 id="346-moving-average-from-data-stream-easy">346. Moving Average from Data Stream (Easy)</h1>
<p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.<br>
Implement the MovingAverage class:<br>
MovingAverage(int size) Initializes the object with the size of the window size.<br>
double next(int val) Returns the moving average of the last size values of the stream.</p>
<pre><code class="language-python">class MovingAverage:

    def __init__(self, size: int):
        self.size=size
        self.q=[]
    def next(self, val: int) -&gt; float:
        if len(self.q)&lt;self.size:
            self.q.append(val)
            return sum(self.q)/len(self.q)
        else:
            self.q.pop(0)
            self.q.append(val)
            return sum(self.q)/len(self.q)
        
from collections import deque
class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = deque()
        # number of elements seen so far
        self.window_sum = 0
        self.count = 0

    def next(self, val: int) -&gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        self.queue.append(val)
        tail = self.queue.popleft() if self.count &gt; self.size else 0

        self.window_sum = self.window_sum - tail + val

        return self.window_sum / min(self.size, self.count)

class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = [0] * self.size
        self.head = self.window_sum = 0
        # number of elements seen so far
        self.count = 0

    def next(self, val: int) -&gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        tail = (self.head + 1) % self.size
        self.window_sum = self.window_sum - self.queue[tail] + val
        # move on to the next head
        self.head = (self.head + 1) % self.size
        self.queue[self.head] = val
        return self.window_sum / min(self.size, self.count)

</code></pre>
<p>用queue 和 Circular Queue 都是好想法。</p>
<h1 id="font-colorblue347-top-k-frequent-elements-mediumfont"><font color='blue'>347. Top K Frequent Elements （Medium）</font></h1>
<p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.<br>
Your algorithm's time complexity must be better than O(n log n), where n is the array's size</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        dic_c = collections.Counter(nums)
        return sorted(dic_c.keys(),key=lambda x: dic_c[x],reverse=True)[:k]

#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        count = Counter(nums)
        unique = list(count.keys())
        
        def partition(left, right, pivot_index) -&gt; int:
            pivot_frequency = count[unique[pivot_index]]
            # 1. move pivot to end
            unique[pivot_index], unique[right] = unique[right], unique[pivot_index]  
            
            # 2. move all less frequent elements to the left
            store_index = left
            for i in range(left, right):
                if count[unique[i]] &lt; pivot_frequency:
                    unique[store_index], unique[i] = unique[i], unique[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            unique[right], unique[store_index] = unique[store_index], unique[right]  
            
            return store_index
        
        def quickselect(left, right, k_smallest) -&gt; None:
            &quot;&quot;&quot;
            Sort a list within left..right till kth less frequent element
            takes its place. 
            &quot;&quot;&quot;
            # base case: the list contains only one element
            if left == right: 
                return
            
            # select a random pivot_index
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # if the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return 
            # go left
            elif k_smallest &lt; pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            # go right
            else:
                quickselect(pivot_index + 1, right, k_smallest)
         
        n = len(unique) 
        # kth top frequent element is (n - k)th less frequent.
        # Do a partial sort: from less frequent to the most frequent, till
        # (n - k)th less frequent element takes its place (n - k) in a sorted array. 
        # All element on the left are less frequent.
        # All the elements on the right are more frequent.  
        quickselect(0, n - 1, n - k)
        # Return top k frequent elements
        return unique[n - k:]

#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        
        bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: 
            bucket[freq].append(num) 
        flat_list = [item for sublist in bucket for item in sublist]
        return flat_list[::-1][:k]
</code></pre>
<p>答案给出了quick selelct的解法O（n）。但bucket 方法更好。 也是O（n）。</p>
<h1 id="348-design-tic-tac-toe-medium">348. Design Tic-Tac-Toe （Medium）</h1>
<p>Assume the following rules are for the tic-tac-toe game on an n x n board between two players:<br>
A move is guaranteed to be valid and is placed on an empty block.<br>
Once a winning condition is reached, no more moves are allowed.<br>
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.<br>
Implement the TicTacToe class:<br>
TicTacToe(int n) Initializes the object the size of the board n.<br>
int move(int row, int col, int player) Indicates that the player with id player plays at the cell (row, col) of the board. The move is guaranteed to be a valid move.</p>
<pre><code class="language-python">class TicTacToe:

    def __init__(self, n: int):
        self.n=n
        self.rows_p1 = [0]*n
        self.rows_p2 = [0]*n
        self.cols_p1 = [0]*n
        self.cols_p2 = [0]*n
        self.i_plus_j_n_1_p1=0
        self.i_plus_j_n_1_p2=0
        self.i_equal_j_p1=0
        self.i_equal_j_p2=0
                
    def move(self, row: int, col: int, player: int) -&gt; int:
        if player==1:
            self.rows_p1[row]+=1
            if self.rows_p1[row]==self.n: return player
            self.cols_p1[col]+=1
            if self.cols_p1[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p1+=1
                if self.i_plus_j_n_1_p1==self.n: return player
            if row==col:
                self.i_equal_j_p1+=1
                if self.i_equal_j_p1==self.n: return player
        else:
            self.rows_p2[row]+=1
            if self.rows_p2[row]==self.n: return player
            self.cols_p2[col]+=1
            if self.cols_p2[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p2+=1
                if self.i_plus_j_n_1_p2==self.n: return player
            if row==col:
                self.i_equal_j_p2+=1
                if self.i_equal_j_p2==self.n: return player
        
        return 0


</code></pre>
<h1 id="349-intersection-of-two-arrays-easy">349. Intersection of Two Arrays (Easy)</h1>
<p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p>
<pre><code class="language-python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        return list(set(nums1)&amp;set(nums2))
</code></pre>
<p>folowup, solve in O(n) time O(1) space given nums1,nums2 are sorted.</p>
<pre><code class="language-python">def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
    # if the lists are already sorted and you're told to solve in O(n) time and O(1) space:
    nums1.sort() # assume sorted
    nums2.sort() # assume sorted

    # iterate both nums backwards till at least 1 is empty
    # if num2[j] &gt; num1[i], pop num2
    # if num2[j] &lt; num1[i], pop num1
    # if equal and num not last appended to result, append to result and pop both nums
    
    result = []
            
    while nums1 and nums2:
        if nums2[-1] &gt; nums1[-1]:
            nums2.pop()
        elif nums2[-1] &lt; nums1[-1]:
            nums1.pop()
        else:
            # to avoid duplicates
            if not result or (result and nums1[-1] != result[-1]):
                result.append(nums1[-1])
            nums1.pop()
            nums2.pop()

    return result
</code></pre>
<h1 id="350-intersection-of-two-arrays-ii-easy">350. Intersection of Two Arrays II （Easy）</h1>
<p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</p>
<pre><code class="language-python">class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        c1=collections.Counter(nums1)
        c2=collections.Counter(nums2)
        res=[]
        for k in c1:
            if k in c2:
                res.extend([k]*min(c1[k],c2[k]))
        return res

#Bad but save space answer
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1.sort()
        nums2.sort()
        result = []
    
        while nums1 and nums2:
            if nums2[-1] &gt; nums1[-1]:
                nums2.pop()
            elif nums2[-1] &lt; nums1[-1]:
                nums1.pop()
            else:
                result.append(nums1[-1])
                nums1.pop()
                nums2.pop()

        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-06/">
        </link>
        <updated>2021-12-06T05:36:37.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue331-verify-preorder-serialization-of-a-binary-tree-font"><font color='blue'>331. Verify Preorder Serialization of a Binary Tree </font></h1>
<p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.</p>
<pre><code class="language-python">class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        
        stack = []
        for char in preorder.split(','):
            while char=='#' and stack and stack[-1]=='#':
                if len(stack)&lt;2: return False
                stack.pop()
                stack.pop()
            
            stack.append(char)
        
        return stack==['#']
                
 #ANSWER           
 class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        # number of available slots
        slots = 1

        for node in preorder.split(','):
            # one node takes one slot
            slots -= 1
            
            # no more slots available
            if slots &lt; 0:
                return False
            
            # non-empty node creates two children slots
            if node != '#':
                slots += 2
        
        # all slots should be used up
        return slots == 0
</code></pre>
<p>没思路初看， 但是用stack解决了， 如果遇到‘X,#,#’ X一定是个leave，出栈，但X本身可能是其他人的child，所以补一个#。  最后如果valid，应该stack为【#】。答案思路没用stack用了计算slot的方法。</p>
<h1 id="font-colorred332-reconstruct-itinerary-hardfont"><font color='red'>332. Reconstruct Itinerary （Hard）</font></h1>
<p>You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.<br>
All of the tickets belong to a man who departs from &quot;JFK&quot;, thus, the itinerary must begin with &quot;JFK&quot;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>
<pre><code class="language-python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
        
        self.visitBitmap=dict()
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
            self.visitBitmap[origin]=[False]*len(itinerary)
        
        self.flights=len(tickets)
        self.result=[]
        route=['JFK']
        self.backtracking('JFK',route)
        return self.result
    
    def backtracking(self,origin,route):
        if len(route)==self.flights+1:
            self.result=route
            return True
        
        for i, nextDest in enumerate(self.flightMap[origin]):
            if not self.visitBitmap[origin][i]:
                self.visitBitmap[origin][i]=True
                ret=self.backtracking(nextDest,route+[nextDest])
                self.visitBitmap[origin][i]=False
                if ret:
                    return True
        return False

#
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
 
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
         
        self.result=[]
        self.DFS('JFK')
       
        return self.result[::-1]
    
    def DFS(self,origin):
        destList=self.flightMap[origin]
        while destList:
            nextDest=destList.pop(0)
            self.DFS(nextDest)
        self.result.append(origin)
</code></pre>
<p>这个明显是个一笔画问题，不知道答案。。。有两个问题，判断能否是一笔画，怎么能画出一笔画。一笔画算法：<br>
It starts with a random node and then follows an arbitrary unvisited edge to a neighbor. This step is repeated until one returns to the starting node. This yields a first circle in the graph.</p>
<pre><code>If this circle covers all nodes it is an Eulerian cycle and the algorithm is finished. Otherwise, one chooses another node among the cycles' nodes with unvisited edges and constructs another circle, called subtour.
By connecting all the circles in the above process, we build the Eulerian cycle at the end
</code></pre>
<p>答案1：backtracking+greedy  答案2： 在倒序添加一个机场前，必须已经visited 所有这个机场的outgoing edge。否则就是还有路径没有浏览过。 所以算法是postorder DFS</p>
<h1 id="font-colorblue333-largest-bst-subtree-medium-font"><font color='blue'>333. Largest BST Subtree （Medium） </font></h1>
<p>Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -&gt; int:
         
        self.res=0
        
        def isBST(root):
            if not root: 
                return True
            res=[]
            def inorder(root):
                if not root: return 
                inorder(root.left)
                res.append(root.val)
                inorder(root.right)
            inorder(root)
            for i in range(1,len(res)):
                if res[i-1] &gt;= res[i]:
                    return False
            root.size=len(res)
            return True
            
        
        def helper(root):
            if not root: return
            helper(root.left)
            helper(root.right)
            if isBST(root):
                self.res=max(self.res,root.size)  
     
        helper(root)
        return self.res          

</code></pre>
<p>因为要判断isBST，call很多次，自己写的时间复杂度感觉比较大。。。 isBST同时设置了 BST大小，所以call完isBST后直接更新self.res.  看答案思路：答案是preorder 和postorder 。。。 postorder优于preorder，因为没有重复判断isvalidBST. 但需要通知parent node maxleft minright是多少，感觉更繁琐，不如自己的答案。</p>
<h1 id="font-colorred334-increasing-triplet-subsequence-mediumfont"><font color='red'>334. Increasing Triplet Subsequence （Medium）</font></h1>
<p>Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.</p>
<pre><code class="language-python">class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        if len(nums)&lt;3: return False
        
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                 if nums[i]&gt;nums[j]:
                    dp[i]= max(dp[j]+1,dp[i])  
                    if dp[i]&gt;=3: return True
        
        return False


class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        first_num = float(&quot;inf&quot;)
        second_num = float(&quot;inf&quot;)
        for n in nums:
            if n &lt;= first_num:
                first_num = n
            elif n &lt;= second_num:
                second_num = n
            else:
                return True
        return False
</code></pre>
<p>初次尝试用increasing subsequence DP方法， time limit exceeded。。。直接看答案了。。。直接比较难相到这个方法，思路：scan num list。 边scan边保存看到的最小的和次小的数字，如果遇到比这两个数字都大的，那么找到了答案，如果都没有return False。</p>
<h1 id="font-colorred335-self-crossing-hard-font"><font color='red'>335. Self Crossing （Hard） </font></h1>
<p>You are given an array of integers distance.<br>
You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.<br>
Return true if your path crosses itself, and false if it does not.</p>
<pre><code class="language-python">class Solution:
    def isSelfCrossing(self, distance: List[int]) -&gt; bool:
        
        x=distance
        for i in range(3,len(x)):
            
            if i &gt;= 3 and x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]:
                return True
            
            if i &gt;= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] &gt;= x[i - 2]:
                return True
            
            if i &gt;= 5 and x[i - 2] &gt;= x[i - 4] and x[i - 5] + x[i - 1] &gt;= x[i - 3] and x[i - 1] &lt;= x[i - 3] and x[i - 4] + x[i] &gt;= x[i - 2]:
                return True
        
        return False

#GREAT ANSWER
def isSelfCrossing(self, x):
    b = c = d = e = 0
    for a in x:
        if d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c-e &gt;= 0 and f &gt;= d-b):
            return True
        b, c, d, e, f = a, b, c, d, e
    return False
</code></pre>
<p>直接看答案， 只有3种情况会crossing， 第一种包含4条线段 最后一条穿过第一条， 第二种包括5条线段，最后一条嵌入第一条。 第三种包含6条线段，最后一条与第一条十字交叉穿过。</p>
<p>第二种解法：</p>
<pre>
            b                              b
   +----------------+             +----------------+
   |                |             |                |
   |                |             |                | a
 c |                |           c |                |
   |                | a           |                |    f
   +----------->    |             |                | <----+
            d       |             |                |      | e
                    |             |                       |
                                  +-----------------------+
                                               d
</pre>
<h1 id="font-colorred336-palindrome-pairs-hard-font"><font color='red'>336. Palindrome Pairs (Hard) </font></h1>
<p>Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.</p>
<pre><code class="language-python">class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
        res= []
        def isp(w):
            res = [e for e in w]
            return res==res[::-1]
        for i in range(len(words)):
            for j in range(i+1,len(words)):
                if not words[i] or not words[j] or words[i][0]==words[j][-1]:
                    if isp(words[i]+words[j]):
                        res.append([i,j])
                if not words[i] or not words[j] or words[j][0]==words[i][-1]:
                    if isp(words[j]+words[i]):
                        res.append([j,i])
        return res
#answer                  
class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
      
        def all_valid_prefixes(word):
            valid_prefixes = []
            for i in range(len(word)):
                if word[i:] == word[i:][::-1]:
                    valid_prefixes.append(word[:i])
            return valid_prefixes

        def all_valid_suffixes(word):
            valid_suffixes = []
            for i in range(len(word)):
                if word[:i+1] == word[:i+1][::-1]:
                    valid_suffixes.append(word[i + 1:])
            return valid_suffixes

        word_lookup = {word: i for i, word in enumerate(words)}
        solutions = []

        for word_index, word in enumerate(words):
            reversed_word = word[::-1]

            # Build solutions of case #1. This word will be word 1.
            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:
                solutions.append([word_index, word_lookup[reversed_word]])

            # Build solutions of case #2. This word will be word 2.
            for suffix in all_valid_suffixes(word):
                reversed_suffix = suffix[::-1]
                if reversed_suffix in word_lookup:
                    solutions.append([word_lookup[reversed_suffix], word_index])

            # Build solutions of case #3. This word will be word 1.
            for prefix in all_valid_prefixes(word):
                reversed_prefix = prefix[::-1]
                if reversed_prefix in word_lookup:
                    solutions.append([word_index, word_lookup[reversed_prefix]])

        return solutions
#ANSWER TRIE

class TrieNode:
    def __init__(self):
        self.next = collections.defaultdict(TrieNode)
        self.ending_word = -1
        self.palindrome_suffixes = []

class Solution:
    def palindromePairs(self, words):

        # Create the Trie and add the reverses of all the words.
        trie = TrieNode()
        for i, word in enumerate(words):
            word = word[::-1] # We want to insert the reverse.
            current_level = trie
            for j, c in enumerate(word):
                # Check if remainder of word is a palindrome.
                if word[j:] == word[j:][::-1]:# Is the word the same as its reverse?
                    current_level.palindrome_suffixes.append(i)
                # Move down the trie.
                current_level = current_level.next[c]
            current_level.ending_word = i

        # Look up each word in the Trie and find palindrome pairs.
        solutions = []
        for i, word in enumerate(words):
            current_level = trie
            for j, c in enumerate(word):
                # Check for case 3.
                if current_level.ending_word != -1:
                    if word[j:] == word[j:][::-1]: # Is the word the same as its reverse?
                        solutions.append([i, current_level.ending_word])
                if c not in current_level.next:
                    break
                current_level = current_level.next[c]
            else: # Case 1 and 2 only come up if whole word was iterated.
                # Check for case 1.
                if current_level.ending_word != -1 and current_level.ending_word != i:
                    solutions.append([i, current_level.ending_word])
                # Check for case 2.
                for j in current_level.palindrome_suffixes:
                    solutions.append([i, j])
        return solutions
</code></pre>
<p>初次尝试，time limit exceeded。 基本暴力解，无优化。如何优化？  感觉是用Trie。。。看答案了。思路1： 三种情况，1）word本身是palindrome，2）AB_PALINDROME     BA  找到第一个词所有满足第一个pattern的prefix，然后找prefix[::-1]  3)    BA    PALINDROM_AB,找第二个词所有满足第二个patern的suffix，然后找suffix[::-1]<br>
思路2： Trie， case1） CAT TAC     case2）  CAT   PALINDROME_TAC case3） CAT_PALINDROME  TAC.     只有在扫过所有word1字符情况都不break情况下才会再检查case1和2. 逆序在tire保存word和保存满足palindrome suffix的word ids是简化算法的关键。</p>
<h1 id="337-house-robber-iii-medium">337. House Robber III （Medium）</h1>
<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.<br>
Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.<br>
Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -&gt; int:
        # root.val =  root.left_rob+root.right.rob                         1)rob2child
        # root.val =  root.left_norob + root.right.norob + root.val        2)rob root no rob child
        # root.val = root.left/right.rob   root.right/left.norob      3) rob one of child norob root
        
    
        #postorder transversal  add two value, rob  norob
        
        def helper(root):
            if not root: return 
            helper(root.left)
            helper(root.right)
            
            #processing leaves
            if not root.left and not root.right:
                root.rob=root.val
                root.norob=0
            
            #if decide rob root:
            root_left_max = root.left.norob if root.left else 0
            root_right_max= root.right.norob if root.right else 0
            root.rob = root.val + root_left_max + root_right_max
            #if decide norob root:
            root_left_max =max([root.left.norob,root.left.rob]) if root.left else 0
            root_right_max= max([root.right.norob,root.right.rob]) if root.right else 0
            root.norob = root_left_max + root_right_max
        
        helper(root)
        return max([root.rob,root.norob])


#ANSWER
class Solution:
    def rob(self, root: TreeNode) -&gt; int:
        def helper(node):
            # return [rob this node, not rob this node]
            if not node:
                return (0, 0)
            left = helper(node.left)
            right = helper(node.right)
            # if we rob this node, we cannot rob its children
            rob = node.val + left[1] + right[1]
            # else we could choose to either rob its children or not
            not_rob = max(left) + max(right)
            return [rob, not_rob]

        return max(helper(root))
</code></pre>
<h1 id="338-counting-bits-easy">338. Counting Bits (Easy)</h1>
<p>Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1's in the binary representation of i.</p>
<pre><code class="language-python">class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        if n==0: return [0]
        if n==1: return [0,1]
        cur=[0,1]
        while len(cur)&lt;=n:
            cur = cur+[1+e for e in cur]
        return cur[:n+1]
        
#ANSWER
class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        ans = [0] * (n + 1)
        for x in range(1, n + 1):
            ans[x] = ans[x &amp; (x - 1)] + 1
        return ans 

</code></pre>
<p>答案更优雅，x&amp;x-1 得到去掉最后一个significant bit的数字  X&gt; X&amp;(X-1) 然后从1遍历到n用dp。</p>
<h1 id="339-nested-list-weight-sum-medium">339. Nested List Weight Sum （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.<br>
Return the sum of each integer in nestedList multiplied by its depth.</p>
<pre><code class="language-python">
class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -&gt; int:
        def helper(nestli,level):
            res=0
            for nl in nestli:
                if nl.isInteger():
                    res+=nl.getInteger() * level
                else:
                    res+=helper(nl.getList(),level+1)
            
            return res
        return helper(nestedList,1)
</code></pre>
<h1 id="font-colorblue340-longest-substring-with-at-most-k-distinct-characters-medium-font"><font color='blue'>340. Longest Substring with At Most K Distinct Characters (Medium) </font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        #  e c e b a  a a a a a a c d a a 
        # two pointer
        #   
        dic=dict()
        start=0
        res=0
        for j,char in enumerate(s):
            #process over k case
            if dic and char not in dic and len(dic)==k:
                while len(dic)==k:
                    dic[s[start]]-=1
                    if dic[s[start]]==0:
                        del dic[s[start]]
                    start+=1
            
            elif char in dic and len(dic)&lt;=k:
                res=max(res,j-start+1)
            
            
            elif len(dic)&lt;k:
                res+=1
        
            
            dic[char]=dic.get(char,0)+1
        
        return res



#ANSWER
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        n = len(s)
        if n * k == 0:
            return 0

        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -&gt; its rightmost position
        # in the sliding window
        hashmap = defaultdict()

        max_len = 1

        while right &lt; n:
            # add new character and move right pointer
            hashmap[s[right]] = right
            right += 1

            if len(hashmap) == k + 1:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len
</code></pre>
<p>典型的two pointer 写的磕磕绊绊 但写出来了。。。dic存放window中遇到字符的个数，  case1）如果目前dic有内容而且当前char不在dic而且window已经达到容量，start得向前移动，每前进一位，dic中s【start】数目减少一个，如果减少到0需要删除key。 退出while循环现在len（dic）小于k，后续这个不在dic中的char会加入dic。 case2）char in dic and len（dic）小于等于k，直接算结果 case3） len（dic）小于k，res+1.  答案方法思路也差不多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-05/">
        </link>
        <updated>2021-12-05T10:46:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred321-create-maximum-number-hard-font"><font color='red'>321. Create Maximum Number (Hard) </font></h1>
<p>You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.<br>
Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.<br>
Return an array of the k digits representing the answer.<br>
Example<br>
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5<br>
Output: [9,8,6,5,3]</p>
<pre><code class="language-python">class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[int]:
        # 思路。。。
        # 最大需要每个位置数字最大，
        # 但选择最大的数字有顺序约束
        # 而且当可选最大数字相同时，需要程序tracking 2种不同结果。
        

        def prep(nums, k):
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] &lt; num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            return [max(a, b).pop(0) for _ in a+b]

        return max(merge(prep(nums1, i), prep(nums2, k-i))  for i in range(k+1)   if i &lt;= len(nums1) and k-i &lt;= len(nums2))

</code></pre>
<p>没思路。。。看到答案用了greedy方法。。。  prep function只是在一个数组中按照顺序找出K个最大的数。先算一下需要drop多少个数， 如果当前值大于栈顶元素，说明需要更新栈顶。  merge function这一步是按照a，b的lexcial顺序找到最大的元素，a+b总共有K个元素，所以pop k次。 最后return所有K+1个分割可能产生的结果取最大的。基本不可能现想出来解法。</p>
<h1 id="322-coin-change-medium">322. Coin Change （Medium）</h1>
<p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.<br>
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.<br>
You may assume that you have an infinite number of each kind of coin.</p>
<pre><code class="language-python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        if amount==0: return 0 if coins else -1
        dp = dict()
        for c in coins:
            dp[c]=1
        for a in range(1,amount+1):
            for c in coins:
                if a+c&lt;=amount and a in dp:
                    if a+c in dp:
                        dp[a+c]=min(dp[a+c],dp[a]+1) 
                    else:
                        dp[a+c]=dp[a]+1
        return dp[amount] if   amount in dp else -1

#ANSWER
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
</code></pre>
<p>感觉是个DP问题，递归关系？  dp【i】是需要达到amount i需要的次数。 初始coins值的dp【coins_val】=1.   对于每一个有dp值的位置，都用coints_val 更新， dp【i+val】=min（dp【i+val】，dp【i】+1）直到amount。 由于不能开过大内存，所以dp变成dict。<br>
答案写法更标准， dp【x】=min（dp【x】，dp【x-coin】+1） x大于等于coin小于等于amount。</p>
<h1 id="323-number-of-connected-components-in-an-undirected-graph-medium">323. Number of Connected Components in an Undirected Graph （Medium）</h1>
<p>You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.<br>
Return the number of connected components in the graph.</p>
<pre><code class="language-python">class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        #  BFS
        neis = collections.defaultdict(list)
        for edge in edges:
            neis[edge[0]].append(edge[1])
            neis[edge[1]].append(edge[0])
        
        
        res=0
        visited=set()
        while len(visited)!=n:
            res+=1
            for i in range(n):
                if i not in visited:
                    visited.add(i)
                    q=[i]
                    break     
            while q:
                l=len(q)
                for _ in range(l):
                    cur=q.pop(0)
                    for nei in neis[cur]:
                        if nei not in visited:
                            visited.add(nei)
                            q.append(nei)
        return res
#UNIONFIND
class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1
                    
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        uf=self.UnionFind(n)
        for edge in edges:
            uf.union(*edge)
        return uf.n

</code></pre>
<p>注意unionfind中   if x!=self.parent[x]   爸爸=找爸爸（爸爸）  self.parent[x]=self.find(self.parent[x])， union只有rank相同时候才需要+rank。</p>
<h1 id="font-colorred324-wiggle-sort-ii-mediumfont"><font color='red'>324. Wiggle Sort II （Medium）</font></h1>
<p>Given an integer array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....<br>
You may assume the input array always has a valid answer.</p>
<pre><code class="language-python">     def wiggleSort(self, nums):
        count = [0]*5001
        
        for n in nums:
            count[n]+=1
        
        odd = 1
        even = 0
        for n in range(5000,-1,-1):
            if odd &gt;= len(nums) and even &gt;= len(nums):
                break
                
            if count[n] == 0:
                continue
            
            while count[n] and (odd &lt; len(nums) or even &lt; len(nums)):
                count[n]-=1
                if odd &lt; len(nums):
                    nums[odd] = n
                    odd+=2
                else:
                    nums[even] = n
                    even+=2
        
 class Solution(object):
    def wiggleSort(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
      
        arr = sorted(nums)
        for i in range(1, len(nums), 2): nums[i] = arr.pop() 
        for i in range(0, len(nums), 2): nums[i] = arr.pop() 

class Solution:
    def wiggleSort(self, A: List[int]) -&gt; None:        
        N = len(A)                    
        count = [0] * 5001        
        self.curr_val = A[0]
        
        for v in A:
            count[v] += 1
            self.curr_val = max(self.curr_val, v)
        
        def next_val():
            while count[self.curr_val] == 0: self.curr_val -= 1            
            count[self.curr_val] -= 1
            return self.curr_val
                            
        for i in range(1, N, 2): A[i] = next_val()     
        for i in range(0, N, 2): A[i] = next_val() 
</code></pre>
<p>思路：从sorted 最大到最小，奇数位置放置，然后偶数位置放置数字。时间要降低到O（n）只能用count sort了。</p>
<h1 id="font-colorred325-maximum-size-subarray-sum-equals-k-mediumfont"><font color='red'>325. Maximum Size Subarray Sum Equals k （Medium）</font></h1>
<p>Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.</p>
<pre><code class="language-python">class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:
        
        prefix_sum = 0 
        res = 0
        indices = dict()
        
        for i,n in enumerate(nums):
            prefix_sum+=n
            
            if prefix_sum==k:
                res=i+1
            
            if prefix_sum-k in indices:
                res=max(res,i-indices[prefix_sum-k])
            
            if prefix_sum not in indices:
                indices[prefix_sum]=i
        
        return res

</code></pre>
<p>没思路，直接看答案了。看错题目了，题目是subarray。。。是连续的字符串，并不是sublist。。。。<br>
思路：用到了prefix sum和 two sum的解法。 因为是subarray，prefix【j】-prefix【i】==k 就是一个答案。  具体扫predix过程借鉴two sum，在predix-k在 dict中，更新res。 不在dict中，更新dict。 不能无条件更新dict，因为prefix在dict中与之间prefix重复，应该保留更早的index使长度更长。</p>
<h1 id="326-power-of-three-easy">326. Power of Three （Easy）</h1>
<p>Given an integer n, return true if it is a power of three. Otherwise, return false.<br>
An integer n is a power of three, if there exists an integer x such that n == 3x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n==0: return False
        while n:
            if n==1: return True
            if n%3!=0:
                return False
            n//=3
        return True

class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n&lt;1: return False
        while n%3==0:
            n//=3
            
        return n==1
</code></pre>
<h1 id="font-colorred327-count-of-range-sum-hard-font"><font color='red'>327. Count of Range Sum (Hard) </font></h1>
<p>Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.<br>
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i &lt;= j.</p>
<pre><code class="language-python">class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        presum = [0]*(len(nums)+1)
        for i,n in enumerate(nums):
            presum[i+1]=presum[i]+n
        
        res=0
        for i in range(1,len(nums)+1):
            for j in range(i):
                if upper&gt;=presum[i]-presum[j]&gt;=lower:
                    res+=1
        return res
#ANSWER 1 PrefixSum+MergeSort
class Solution:
    def countRangeSum(self, nums, lower, upper):
        cumsum = [0]*(len(nums)+1)
        for i,num in enumerate(nums):
            cumsum[i+1]=cumsum[i]+num
        def sort(lo, hi):
            mid = (lo + hi) // 2
            if mid == lo:
                return 0
            count = sort(lo, mid) + sort(mid, hi)
            i = j = mid
            for left in cumsum[lo:mid]:
                while i &lt; hi and cumsum[i] - left &lt;  lower: i += 1
                while j &lt; hi and cumsum[j] - left &lt;= upper: j += 1
                count += j - i
            cumsum[lo:hi] = sorted(cumsum[lo:hi])
            return count
        return sort(0, len(cumsum))


#ANSER Binary Indexed Tree + Binary Search
class BinaryIndexedTree:
    
    def __init__(self, n):
        self.n = n
        self.tree = [0 for _ in range(n+1)]
    
    def update(self, idx, val):
        while idx &lt;= self.n:
            self.tree[idx] += val
            idx += idx &amp; -idx
    
    def query(self, idx):
        total = 0
        while idx &gt; 0:
            total += self.tree[idx]
            idx -= idx &amp; -idx
        return total

    
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        n, prefixes = len(nums), list(itertools.accumulate(nums))
        
        sortedPrefixes = sorted(set(prefixes))
        ranks = { prefix: idx + 1 for idx, prefix in enumerate(sortedPrefixes) }
        
        ds = BinaryIndexedTree(len(sortedPrefixes))
        for prefix in prefixes:
            ds.update(ranks[prefix], 1)
        
        res = 0
        processed = 0
        for prefix in prefixes:
            l = bisect.bisect_left(sortedPrefixes, lower + processed)
            r = bisect.bisect_right(sortedPrefixes, upper + processed)  
            res += ds.query(r) - ds.query(l)
            ds.update(ranks[prefix], -1)
            processed = prefix
        
        return res
</code></pre>
<p>首次尝试O（n^2）time limit exccded。  看来得低于O（n^2）才可以。。。改进方法是增加mergesort。 思路：先算cumsum。 目标找出cumsum【right】-cumsum【left】在upper lower 之间的这样的pair个数。 定义helper function merge sort。 返回值是满足条件的个数，先递归找出只在lo<sub>mid和mid</sub>hi之间的个数。若left~right横跨mid， 对于每一个left in sumsum【lo：mid】 找出满足upper lower bond的 right。其中满足lower bound的index 是i， 满足upper bound 的index 是j 所以 count+=j-i。<br>
又忘记了有segment tree 和binary indexed tree这两种数据结构。。。。</p>
<h1 id="328-odd-even-linked-list-medium">328. Odd Even Linked List (Medium)</h1>
<p>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.<br>
The first node is considered odd, and the second node is even, and so on.<br>
Note that the relative order inside both the even and odd groups should remain as it was in the input.<br>
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if not head: return head
        odd_head=head
        even_head=head.next
        
        cur=head
        odd_tail=None
        c=0
        while cur:
            curnext=cur.next
            c+=1
            if c%2==1:
                #cur is odd node
                cur.next=cur.next.next if cur.next else None
                odd_tail=cur
            else:
                #cur is even node
                cur.next=cur.next.next if cur.next else None
            
            cur=curnext
        
        if odd_tail:
            odd_tail.next=even_head
        
        return odd_head


#ANSWER 
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        
        if not head: return head
        
        odd  = head
        even = head.next
        evenhead = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        return head
</code></pre>
<h1 id="font-colorred329-longest-increasing-path-in-a-matrix-hard-font"><font color='red'>329. Longest Increasing Path in a Matrix (Hard) </font></h1>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.<br>
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<pre><code class="language-python">class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int:
        dirs = [[0,1],[1,0],[0,-1],[-1,0]]
        m=len(matrix)
        n=len(matrix[0])
        if not matrix: return 0
        cache= [[0]*n for _ in range(m)]
        res=0
        
        def dfs(i,j):
            if cache[i][j]!=0: return cache[i][j]
            for d in dirs:
                x=i+d[0]
                y=j+d[1]
                if m&gt;x&gt;=0 and n&gt;y&gt;=0 and matrix[x][y]&gt;matrix[i][j]:
                    cache[i][j]=max(cache[i][j],dfs(x,y))
            
            cache[i][j]+=1
            return cache[i][j] 
        
        
        for i in range(m):
            for j in range(n):
                res=max(res,dfs(i,j))
                
        return res
</code></pre>
<p>DFS+mem  太晚了直接看答案了。。。因为是strictly increasing path 所以是DAG，所以dfs（i，j） path length 是可以用mem记住的。 但通常的DFS是不能用mem的。</p>
<h1 id="font-colorred330-patching-array-hardfont"><font color='red'>330. Patching Array （Hard）</font></h1>
<p>Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.<br>
Return the minimum number of patches required.</p>
<pre><code class="language-python">class Solution:
    def minPatches(self, nums: List[int], n: int) -&gt; int:
        
        '''Initialize the range [1, miss) = [1, 1) = empty
        While n is not covered yet
            if the current element nums[i] is less than or equal to miss
                extends the range to [1, miss + nums[i])
                increase i by 1
            otherwise
                patch the array with miss, extends the range to [1, miss + miss)
                increase the number of patches
        Return the number of patches
        '''
        
        patches=0
        i=0
        miss=1
        while miss&lt;=n:
            if i&lt;len(nums) and nums[i]&lt;=miss:
                #miss is covered
                miss+=nums[i]
                i+=1
            else:
                #patch miss to aray
                miss+=miss
                patches+=1
        return patches

</code></pre>
<p>太晚没思路直接看答案， 答案思路：假设miss 是最小的missing number， 但我们知道【1，miss） 已经covered。 要cover miss，需要添加小于等于miss的数字。<br>
假设我们添加的数字是x，那么区间【1，miss） 【x，x+miss）都covered。由于x小于等于miss。 所以两个区间可以合并为【1，x+miss）我们想选一个range cover最大的x，显然当x=miss时候区间最大。所以算法是：<br>
初始化区间【1，miss）=【1，1）<br>
当n还没covered，如果 nums【i】小于等于miss，增加区间为【1，miss+nums【i】），i++ 否则， 数组里添加miss， 增加区间为【1，miss+miss), res+=1</p>
]]></content>
    </entry>
</feed>