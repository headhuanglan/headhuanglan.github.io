<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-01-06T15:03:27.501Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-03/">
        </link>
        <updated>2021-12-02T20:07:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred301-remove-invalid-parentheses-hard-font"><font color='red'>301. Remove Invalid Parentheses (Hard) </font></h1>
<p>Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.<br>
Return all the possible results. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution(object):
    def removeInvalidParentheses(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: List[str]
        &quot;&quot;&quot;
        
        res=[] 
        if not s: return [s]
        visited=set()
        q=[]
        
        q.append(s)
        visited.add(s)
        
      
        
        def isValid(s):
            c=0
            for e in s:
                if e=='(':c+=1
                if e==')':c-=1
                
                if c&lt;0: return False
            return c==0

        found=False
        
        while q:
            s=q.pop(0)
            
            if isValid(s):
                res.append(s)
                found=True
            
            if found: continue
            
            for i in range(len(s)):
                if s[i]!='(' and s[i]!=')': continue
                t=s[:i]+s[i+1:]
                
                if not t in visited:
                    q.append(t)
                    visited.add(t)
        
        return res
    
#         def valid(s):
#             stack=[]
#             ss=[ i for i in s if (i in '()') ]
#             for e in ss:
#                 if e==')':
#                     if (not stack) or (not stack.pop()=='('):
#                         return False
#                 else:
#                     stack.append(e)
#             return not stack

#ANSWER
class Solution:
    
  
    
    def removeInvalidParentheses(self, s: str) -&gt; List[str]:
        #based on hint 
        #1) figure out how many misplaced left and right parenthesis
        left=0
        right=0
        for i,p in enumerate(s):
            if p=='(':
                left+=1
            elif p==')':
                if left&gt;0:
                    left-=1
                else:
                    right+=1
        
        #2)recursion process 
        res =set()
        def bt(left_rem,right_rem,left,right,tmp,index):
            #left_rem is the left error position ( remained
            #right_rem is the right error position ) remained
            #left is # of ( in current expression tmp
            #right is # of ) in current expression tmp
            #tmp is current expression
            #index is the index of char in original string s
            
            #BASE CASE
            if index==len(s):     
                #print(left_rem,right_rem,left,right,tmp)
                if left_rem==0 and right_rem==0:
                    res.add(&quot;&quot;.join(tmp))
                return
            
            #discard current
            if (s[index]=='(' and left_rem&gt;0) or (s[index]==')' and right_rem&gt;0):
                bt(left_rem-(s[index]=='('),right_rem-(s[index]==')'),left,right,tmp,index+1)

            #add current
            tmp.append(s[index])

            #if current is not in {()}
            if s[index] not in [&quot;(&quot;,&quot;)&quot;]:
                bt(left_rem,right_rem,left,right,tmp,index+1)
            elif s[index]=='(':
                #consider an opening bracket
                bt(left_rem,right_rem,left+1,right,tmp,index+1)
            elif s[index]==')' and left&gt;right:
                # consider a closing bracket
                bt(left_rem,right_rem,left,right+1,tmp,index+1)

            tmp.pop()                 

         
        bt(left,right,0,0,[],0)
        return list(res)

</code></pre>
<p>思路1 最快最吊炸天） 类似bfs，用queue 做，验证每一个可能的结果。但为了找到最少的变动就能valid的string，所以一旦找到remove后可以valid的string就不在queue中添加后续元素了。 2）backtracking，先计算错位的left right 括号个数。需要track的， left_remain,right_remain,left_counter,right_counter, tmp=[], index.  比较复杂。</p>
<h1 id="302-smallest-rectangle-enclosing-black-pixels-hard">302. Smallest Rectangle Enclosing Black Pixels （Hard）</h1>
<p>You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel.<br>
The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.<br>
Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.<br>
You must write an algorithm with less than O(mn) runtime complexity</p>
<pre><code class="language-python">class Solution:
    minx=float('inf')
    miny=float('inf')
    maxx=float('-inf')
    maxy=float('-inf')
    def minArea(self, image: List[List[str]], x: int, y: int) -&gt; int:
        
        m=len(image)
        n=len(image[0])
        def dfs(x,y):
            self.minx=min(self.minx,x)
            self.miny=min(self.miny,y)
            self.maxx=max(self.maxx,x)
            self.maxy=max(self.maxy,y)
            image[x][y]='#'
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n and image[xx][yy]=='1':
                    dfs(xx,yy)
        dfs(x,y)
        return (self.maxx-self.minx+1)*(self.maxy-self.miny+1)
</code></pre>
<p>除了bfs ，dfs外 答案给出了一种project 图片到1D，然后用binary search 找上下界，来算面积。</p>
<h1 id="303-range-sum-query-immutable-easy">303. Range Sum Query - Immutable （Easy）</h1>
<pre><code class="language-python">class NumArray:

    def __init__(self, nums: List[int]):
        
        for i,n in enumerate(nums):
            if i==0: continue
            nums[i]+=nums[i-1]
        self.cumsum=nums

    def sumRange(self, left: int, right: int) -&gt; int:
        # 1 2 3
        # 1 3 6
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)

#OR ANSWER WAY OF WRITTEN
class NumArray(object):

    def __init__(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        &quot;&quot;&quot;
        
        nums = [0] + nums
        
        for i in range(1,len(nums)):
            nums[i] +=nums[i-1]
        
        self.nums=nums
     

    def sumRange(self, i, j):
        &quot;&quot;&quot;
        :type i: int
        :type j: int
        :rtype: int
        &quot;&quot;&quot;
        return self.nums[j+1]-self.nums[i]
</code></pre>
<h1 id="304-range-sum-query-2d-immutable-medium">304. Range Sum Query 2D - Immutable (Medium)</h1>
<p>Given a 2D matrix matrix, handle multiple queries of the following type:<br>
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        # original matrix
        # 1 2 3
        # 4 5 6
        # 7 8 9
        #
        #cumsum matrix
        #             c1
        #        0 0  0    0
        #        0 1  3    6
        # row1   0 5  #12  21
        # row2   0 12 27  #45 
        #                 c2
        # do cumsum on row
        # do cumsum on col
        #
        #  row2,col2 -(row1-1)col2 - row2(col1-1) + (row1-1)(col1-1)
        self.matrix = [[0]*(len(matrix[0])+1)]
        for row in matrix:
            self.matrix.append([0]+row)
        
    
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row][col-1]
        
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row-1][col]
        
        
        
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        return self.matrix[row2+1][col2+1]-self.matrix[row1][col2+1]-self.matrix[row2+1][col1]+self.matrix[row1][col1]
        


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<h1 id="font-colorred305-number-of-islands-ii-hard-font"><font color='red'>305. Number of Islands II (Hard) </font></h1>
<p>You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0's represent water and 1's represent land. Initially, all the cells of grid are water cells (i.e., all the cells are 0's).<br>
We may perform an add land operation which turns the water at position into a land. You are given an array positions where positions[i] = [ri, ci] is the position (ri, ci) at which we should operate the ith operation.<br>
Return an array of integers answer where answer[i] is the number of islands after turning the cell (ri, ci) into a land.</p>
<pre><code class="language-python">class Solution:
    
    class unionfind:
        
        def __init__(self,m,n):
            self.m=m
            self.n=n
            self.parent=[-1]*(m*n) 
            self.rank = [0]*(m*n)
            self.counter=0
           
        def isvalid(self,row,col):
            ind=row*self.n+col
            return self.parent[ind]&gt;=0
        
        def setparent(self,row,col):
            ind=row*self.n+col
            if self.parent[ind]==-1:
                self.parent[ind]=ind
                self.counter+=1
            
        def find(self,row,col):
            ind= row*self.n+col
            if self.parent[ind]!=ind:
                new_col = self.parent[ind]%self.n
                new_row = (self.parent[ind]-new_col)//self.n
                self.parent[ind]=self.find(new_row,new_col)
            return self.parent[ind]
            
            
        def union(self,p1,p2):
            x1,y1=p1
            x2,y2=p2
            root1=self.find(x1,y1)
            root2=self.find(x2,y2)
            if root1!=root2:
                self.counter-=1
                if self.rank[root1]&gt;self.rank[root2]:
                    self.parent[root2]=root1
                elif self.rank[root1]&lt;self.rank[root2]:
                    self.parent[root1]=root2
                else:
                    self.parent[root1]=root2
                    self.rank[root2]+=1
                    
        def getcount(self):
            return self.counter
         
                    
                
            
    
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -&gt; List[int]:
        
       
        res=[]
        
        uf=self.unionfind(m,n)
    
        def get_nei(pos,uf):
            nei = []
            x,y=pos
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n:
                    if uf.isvalid(xx,yy):
                        nei.append((xx,yy))
            return nei
    
        for pos in positions:
            uf.setparent(*pos)
            for nei in get_nei(pos,uf):
                uf.union(nei,pos)
            res.append(uf.getcount())
            
        return res
            
            
   

</code></pre>
<p>试过用neighbor_list做，但是无法分辨新加入的点是否会引起2个或3个不同island合并。 思路不正确， 感觉是用UNIONFIND做。还是不能顺畅写出UNIONFIND calss。这次的unionfind class是个变种。 注意增加相同点的时候，setparent做check，必须self.parent[i]==-1 才能做self.conter+=1 。 思路： 每次增加一个点，做setparent，counter++，找这个点所有valid neighbors，然后做union。没发现以个union则counter--。</p>
<h1 id="font-colorblue-306-additive-number-mediumfont"><font color='blue'> 306. Additive Number （Medium）</font></h1>
<p>An additive number is a string whose digits can form an additive sequence.<br>
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.<br>
Given a string containing only digits, return true if it is an additive number or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def isAdditiveNumber(self, num: str) -&gt; bool:
        if not num or len(num)&lt;3: 
            return False
        
        mem=dict()
        def helper(num):
            if not num: return True
            if num in mem: return mem[num]
            Found=False
            for len_a in range(1,len(num)):
                if len_a&gt;1 and num[0]=='0': continue
                for len_b in range(1,len(num)):
                    if len_b&gt;1 and num[len_a]=='0': continue
                    temp_flag=False
                    if len_a+len_b&gt;=len(num):continue
                    a = num[:len_a]
                    b = num[len_a:len_a+len_b]
                    c = str(int(a)+int(b))
                    #print(a,b,c)
                    len_c= len(c)
                    if len_a+len_b+len_c&gt;len(num):continue
                    if len_a+len_b+len_c==len(num) and num[len_a+len_b:len_a+len_b+len_c]==c:
                        return True
                    elif num[len_a+len_b:len_a+len_b+len_c]==c:
                        temp_flag = True and helper(num[len_a:])
                    Found=Found or temp_flag
            mem[num]=Found
            print(num,Found)
            return Found
        
        return helper(num)
        
#ANSWER WAY
def isAdditiveNumber(self, num):
    n = len(num)
    for i, j in itertools.combinations(range(1, n), 2):
        a, b = num[:i], num[i:j]
        if a != str(int(a)) or b != str(int(b)):
            continue
        while j &lt; n:
            c = str(int(a) + int(b))
            if not num.startswith(c, j):
                break
            j += len(c)
            a, b = b, c
        if j == n:
            return True
    return False                

</code></pre>
<p>自己通过recursion with mem解决的，头部为0问题用2个continue 判断去解决。<br>
答案大神用了itertools.combinatons i 是a的长度，j是 a+b的长度，确定了a，b可以算出来c，如果不满足条件跳出while，如果满足条件，则j+len（c），前进一位做下一次判断。 推出时候如果j==n说明找到了。</p>
<h1 id="font-colorred-307-range-sum-query-mutable-medium-font"><font color='red'> 307. Range Sum Query - Mutable (Medium) </font></h1>
<p>Given an integer array nums, handle multiple queries of the following types:<br>
Update the value of an element in nums.<br>
Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.cumsum=nums[:]
        for i in range(1,len(nums)):
            self.cumsum[i]+=self.cumsum[i-1]
 
    def update(self, index: int, val: int) -&gt; None:
        diff=val-self.nums[index]
        self.nums[index]=val
        for i in range(index,len(self.cumsum)):
            self.cumsum[i]+=diff
    def sumRange(self, left: int, right: int) -&gt; int:
        
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]
#METHOD 1  SQRT DECOMPOSTION
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.len =  len(nums)//int(math.sqrt(len(nums)))+1 
        self.b=[0]*self.len
        for i,n in enumerate(nums):
            self.b[i//self.len]+=n
         

    def update(self, index: int, val: int) -&gt; None:
        block_index = index//self.len
        self.b[block_index] = self.b[block_index] - self.nums[index]+val
        self.nums[index]=val

    def sumRange(self, left: int, right: int) -&gt; int:
        res=0
        startblock=left//self.len
        endblock=right//self.len
        if startblock==endblock:
            for ind in range(left,right+1):
                res+=self.nums[ind]
        else:
            for ind in range(left,(startblock+1)*self.len):
                res+=self.nums[ind]
            for block_ind in range(startblock+1,endblock):
                res+=self.b[block_ind]
            for ind in range(endblock*self.len,right+1):
                res+=self.nums[ind]
        return res
        
# METHOD 2 ＳＥＧＭＥＮＴ　ＴＲＥＥ
class NumArray:

    def __init__(self, nums: List[int]):
        self.n=len(nums)
        self.tree=['#']*(2*self.n)
        self.buildtree(nums)
        print(self.tree)
    
    def buildtree(self,nums):
        #populate leaves
        j=0
        for i in range(self.n,2*self.n):
            self.tree[i]=nums[j]
            j+=1
        #populate parent nodes
        for i in range(self.n-1,0,-1):
            self.tree[i]=self.tree[i*2]+self.tree[i*2+1]
        

    def update(self, index: int, val: int) -&gt; None:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        #     22 9 13 4  5  6   7
        pos = index+self.n
        self.tree[pos]=val
        while pos&gt;0:
            left=pos
            right=pos
            #这里比较巧妙，tree变成数组后可以理解。
            if pos%2==0:
                right=pos+1
            else:
                left=pos-1
            
            if left&gt;0:
                self.tree[pos//2] = self.tree[left]+self.tree[right]
            pos //=2
        

    def sumRange(self, left: int, right: int) -&gt; int:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        # #  22 9  13 4  5  6   7
        l = left+self.n
        r = right+self.n
        res=0
        while l&lt;=r:
            if l%2==1:
                res+=self.tree[l]
                l+=1
            if r%2==0:
                res+=self.tree[r]
                r-=1
            l//=2
            r//=2
        return res
        
　

</code></pre>
<p>第一版本用cumsum，time limit exceeded。原因在于update时候，要更新所有后续影响的cumsum值。 看答案了。思路1） Sqrt Decomposition，把nums分成 sqrt（len）个block求和。 思路2） Segment Tree。 这个没见过，是最优解。  构造方法很巧妙。可能需要记住．</p>
<h1 id="font-colorred308-range-sum-query-2d-mutable-hard-font"><font color='red'>308. Range Sum Query 2D - Mutable (Hard) <font></h1>
<p>1D to 2D of rang sum Query</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.trees=[self.buildtree(nums) for nums in matrix]
        
        #for tree in self.trees:
        #    print(tree)
    
    def buildtree(self,nums):
        #   1
        #  2  3
        # 4 5 6 7
        # 1 2 3 4 5 6 7
        tree=['#']*self.n*2
        for i,n in enumerate(nums):
            ind=i+self.n
            tree[ind]=n
        
        for ind in range(self.n-1,0,-1):
            tree[ind]=tree[2*ind]+tree[2*ind+1]
        return tree
    
    def update(self, row: int, col: int, val: int) -&gt; None:
        tree=self.trees[row]
        #   1
        #  2  3
        # 4 5 6 7
        # 1   2  3  4 5 6 7
        # 22  9  13 4 5 6 7
        ind = self.n+col
        self.matrix[row][col]=val
        tree[ind]=val
        while ind&gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&gt;0:
                tree[ind//2]=tree[left]+tree[right]
            ind=ind//2
        self.trees[row]=tree
      

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        res = 0
        for row in range(row1,row2+1):
            tree=self.trees[row]
            #   1
            #  2  3
            # 4 5 6 7
            # 1   2  3  4 5 6 7
            # 22  9  13 4 5 6 7
            l=col1+self.n
            r=col2+self.n
            while l&lt;=r:
                if l%2==1:
                    res+=tree[l]
                    l+=1
                if r%2==0:
                    res+=tree[r]
                    r-=1
                l//=2
                r//=2
        return res
            
# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)

#ANSWER
class NumMatrix:
    
    def lsb(self,n):
        return n&amp;-n
    
    def updateBIT(self,r,c,val):
        i=r
        while i&lt;=self.m:
            j=c
            while j&lt;=self.n:
                self.bit[i][j]+=val
                j+=self.lsb(j)
            i+=self.lsb(i)
    
    def queryBIT(self,r,c):
        res=0
        i=r
        while i&gt;0:
            j=c
            while j&gt;0:
                res+=self.bit[i][j]
                j-=self.lsb(j)
            i-=self.lsb(i)
        return res
    def buildBIT(self,matrix):
        for i in range(1,self.m+1):
            for j in range(1,self.n+1):
                val=matrix[i-1][j-1]
                self.updateBIT(i,j,val)
    
    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.bit= [[0]*(self.n+1) for _ in range(self.m+1)]
        self.buildBIT(matrix)
        
    def update(self, row: int, col: int, val: int) -&gt; None:
        old_val=self.sumRegion(row,col,row,col)
        #handling 1-based indexing
        row+=1
        col+=1
        diff=val-old_val
        self.updateBIT(row,col,diff)
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        #handling 1-based indexing
        row1+=1;col1+=1;row2+=1;col2+=1
        a=self.queryBIT(row2,col2)
        b=self.queryBIT(row1-1,col1-1)
        c=self.queryBIT(row2,col1-1)
        d=self.queryBIT(row1-1,col2)
        return a-c-d+b
    


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<p>自己套用之前的1d segment tree用在2d问题，可以pass。 但不是最优解。 答案用了 Fenwick Tree (Binary Index Tree)  https://www.youtube.com/watch?v=uSFzHCZ4E-8  没见过。而且最终还是用的2D版本的 Binary Index Tree。bit操作下，X，Y不影响，bit位置是bit，保存的值是partial sum。</p>
<h1 id="font-colorred309-best-time-to-buy-and-sell-stock-with-cooldown-mediumfont"><font color='red'>309. Best Time to Buy and Sell Stock with Cooldown （Medium）</font></h1>
<p>You are given an array prices where prices[i] is the price of a given stock on the ith day.<br>
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:<br>
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int: 
        
    
        &quot;&quot;&quot;
        state machine  
                  O held    -sell-&gt;  sold 
                    /\                |
                    |_ buy_ O reset &lt;-rest
       
       O is self loop
       
       DP:
         sold[i]=held[i-1]+price[i]
         held[i]=max(held[i-1],reset[i-1]-price[i])
         reset[i]=max(rest[i-1],sold[i-1])
         
         return max(reset[n],sold[n]
         &quot;&quot;&quot;
        sold, held, reset = float('-inf'), float('-inf'), 0
        for price in prices:
            pre_sold = sold
            sold = held + price               #sell operation
            held = max(held, reset - price)   #buy operation
            reset = max(reset, pre_sold)      # do nothing operation
            
        return max(sold, reset)
 
        #309 直接看答案了
        # profit on ith day kth transanction 0 means 0 stock at our hand after the end of ith day， 1 means 1 stock at our hand after the end of ith day
        #T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) #sell
        #T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])  # buy 
        #Base cases:
        # T[-1][k][0] = 0, T[-1][k][1] = -Infinity
        # T[i][0][0] = 0, T[i][0][1] = -Infinity
        #constain to cooldown
        
        T_ik0=0
        T_ik0_pre=0
        T_ik1=-float('inf')
        
        for p in prices:
            T_ik0_old=T_ik0
            T_ik0 = max(T_ik0, T_ik1+p)
            T_ik1 = max(T_ik1, T_ik0_pre-p)
            T_ik0_pre=T_ik0_old
        
        return T_ik0


</code></pre>
<p>这是一类问题，很多变种。。。。https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75924/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 答案的state machine 思维方法很有意思。</p>
<h1 id="310-minimum-height-trees-medium">310. Minimum Height Trees （Medium）</h1>
<p>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.</p>
<p>Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).</p>
<p>Return a list of all MHTs' root labels. You can return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]:
        #remove those leafves what left is root 
        
        
        dic={i:[] for i in range(n)}
        q = []
        for edge in edges:
            n1,n2=edge
            dic[n1].append(n2)
            dic[n2].append(n1)
        
        for i in range(n):
            if len(dic[i])==1:
                q.append(i)
                
        res=q
        while q:
            l=len(q)
            res=q[:]
            for _ in range(l):
                cur=q.pop(0)
                for nei in dic[cur]:
                    dic[nei].remove(cur)
                if len(dic[nei])==1:
                    q.append(nei)
        return res if res else [0]
    
</code></pre>
<p>看一下hint才做出来，思路topological sort，leaves 直接砍掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-02/">
        </link>
        <updated>2021-12-02T06:05:58.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="291-word-pattern-ii-medium">291. Word Pattern II （Medium）</h1>
<p>Given a pattern and a string s, return true if s matches the pattern.<br>
A string s matches a pattern if there is some bijective mapping of single characters to strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.</p>
<pre><code class="language-python">class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -&gt; bool:
        
        
        
        def helper(pattern,s,dic1,dic2):
            if not s: return not pattern
            if not pattern: return not s
            key = pattern[0]
            res=False
            for i in range(1,len(s)+1):
                dic1_copy=dic1.copy() 
                dic2_copy=dic2.copy()
                s_val = s[:i]
                
                #print(key,s_val)
                if key in dic1_copy and dic1_copy[key]!=s_val: 
                    res=res or False
                    continue
                else:
                    dic1_copy[key]=s_val
                
                if s_val in dic2_copy and dic2_copy[s_val]!=key: 
                    res=res or False
                    continue
                else:
                    dic2_copy[s_val]=key
                    
                s_rest = s[i:]
                res = res or helper(pattern[1:],s_rest,dic1_copy,dic2_copy)
            #if res:
            #    print(pattern,s)
            return res
        
        return helper(pattern,s,dict(),dict())
</code></pre>
<p>知道使用backtracking，但是得小心 dic1 dic2 copy问题，以及res = res or False， 既然当前s[:i] 已经是False了就skip，所以用cotinue。</p>
<h1 id="292-nim-game-easy">292. Nim Game （Easy）</h1>
<p>You are playing the following Nim Game with your friend:<br>
Initially, there is a heap of stones on the table.<br>
You and your friend will alternate taking turns, and you go first.<br>
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br>
The one who removes the last stone is the winner.</p>
<pre><code class="language-python">class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # dp [0]   [1]     [2]   [3]    [4]     [5]
        #    True   True   True  True   False  
        
        dp = [False] * (n+1)
        if n&lt;=3: return True
        dp[0]=True
        dp[1]=True
        dp[2]=True
        dp[3]=True
        for nn in range(2,n+1):
            for i_select in [1,2,3]:
                dp[nn] = dp[nn] or  (not dp[nn-i_select])
        
        #print(dp)
        return dp[n]
    
class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # 只要对方等于4个 对方必然输。
        # 我先开始，如何让对方等于4个
        # n=4 我输
        # n=5 我选1
        # n=6 我选2
        # n=7 我选3
        # n=8 我选1 不行 我选2 不行 我选3 还是不行
        # n=9 选1
        # n=10 选2
        # n=11 选3
        # n=12 都不行
        
        return  not n%4==0

</code></pre>
<p>用dp写了一个答案，但time limit exceeded。 逐渐发现规律。。。就是是否被4整除。</p>
<h1 id="293-flip-game-easy">293. Flip Game （Easy）</h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].</p>
<pre><code class="language-python">class Solution:
    def generatePossibleNextMoves(self, currentState: str) -&gt; List[str]:
        res= []
        for i in range(len(currentState)-1):
            if currentState[i]=='+' and currentState[i+1]=='+':
                res.append(currentState[:i]+'--'+currentState[i+2:])
        return res
</code></pre>
<h1 id="font-colorred294-flip-game-ii-medium-font"><font color='red'>294. Flip Game II (Medium) </font></h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return true if the starting player can guarantee a win, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    def canWin(self, currentState: str) -&gt; bool:
            return any(currentState[i:i+2] == '++' and not self.canWin(currentState[:i] + '--' + currentState[i+2:])  for i in range(len(currentState)))
#ANSWER
class Solution(object):
    _memo = {}
    def canWin(self, s):
        memo = self._memo
        if s not in memo:
            memo[s] = any(s[i:i+2] == '++' and not self.canWin(s[:i] + '--' + s[i+2:])
                          for i in range(len(s)))
        return memo[s]

#ANSWER
class Solution(object):
    def canWin(self, s):
        memo = {}
        def can(s):
            if s not in memo:
                memo[s] = any(s[i:i+2] == '++' and not can(s[:i] + '--' + s[i+2:])
                              for i in range(len(s)))
            return memo[s]
        return can(s)

</code></pre>
<p>没思路。。 。。。backtracking with mem。。。。</p>
<h1 id="font-colorred295-find-median-from-data-stream-hardfont"><font color='red'>295. Find Median from Data Stream （Hard）</font></h1>
<pre><code class="language-python">from heapq import *


class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))
        else:
            heappush(self.small, -heappushpop(self.large, num))

    def findMedian(self):
        if len(self.small) == len(self.large):
            return float(self.large[0] - self.small[0]) / 2.0
        else:
            return float(self.large[0])

</code></pre>
<p>最简单方法的是sort， 复杂点的比如答案，用了min heap。 思路： small 保存较小的，large保存较大的， 由于需要small的最大元素，minheap头是最小元素，所以push到small要反向。  large能最多比small多存一个元素。 heappushpop同时 push一个元素取出一个元素。TimeCoplex O(logn).</p>
<h1 id="296-best-meeting-point-hard">296. Best Meeting Point （Hard）</h1>
<p>Given an m x n binary grid grid where each 1 marks the home of one friend, return the minimal total travel distance.<br>
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.<br>
The distance is calculated using Manhattan Distance</p>
<pre><code class="language-python">class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -&gt; int:
        
        m=len(grid)
        n=len(grid[0])
        rows=[]
        cols=[]
        for row in range(m):
            for col in range(n):
                if grid[row][col]==1:
                    rows.append(row)
                    cols.append(col)
        
        rows = sorted(rows)
        cols = sorted(cols)
        row=rows[len(rows)//2]
        col=cols[len(cols)//2]
        
        def mindis1d(points,origin):
            distance=0
            for point in points:
                distance += abs(point-origin)
            return distance
        
        return mindis1d(rows,row)+mindis1d(cols,col)
                    

</code></pre>
<p>第一想法多次BFS。。。一次cost mn   最差情况有mn个1， 所以最差有O（mmnn）。 不可行。 答案思路：1）分解成2个1d的问题，最小值点出现在median位置。  O(mnlog⁡mn)    2）只要不sort，时间复杂度还能降低到O(mn) 。 拉出来行和列分别遍历即可。</p>
<h1 id="font-colorred-297-serialize-and-deserialize-binary-tree-hard-font"><font color='red'> 297. Serialize and Deserialize Binary Tree （Hard） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;
        res = []
        def pre(root):
            if not root:
                res.append('#')
                return  
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
         
        return '@'.join(res)
        

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        
        data = [ e.strip() for e in data.split('@')  ]
        
        def deser(data):
            if not data: return None
            if data[0]=='#':
                data.pop(0)
                return None
            
            root=TreeNode(int(data.pop(0))) 
            root.left=deser(data)
            root.right=deser(data)
            return root
        
        return deser(data)
        
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

</code></pre>
<p>有个什么儿子兄弟表示法，但忘记了。。。这个题目只用了preorder。 但要注意递归时候，传入data必须是list，这样随着递归list本身会变化，要是str会出错。</p>
<h1 id="font-colorred298-binary-tree-longest-consecutive-sequence-mediumfont"><font color='red'>298. Binary Tree Longest Consecutive Sequence （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -&gt; int:
        res=[0]
        def pre(root,parent, length):
            if not root:
                return 
            if parent and root.val==parent.val+1:
                length+=1
            else:
                length=1
            res[0]=max(res[0],length)
            pre(root.left,root,length)
            pre(root.right,root,length)
        pre(root,None,0)
        
        return res[0]
         
</code></pre>
<p>太晚了，应该能做出来，直接看答案改写。 pre order， 如果 parent+1=current ， length+=1 else length=1</p>
<h1 id="299-bulls-and-cows-medium">299. Bulls and Cows （Medium）</h1>
<pre><code class="language-python">class Solution:
    def getHint(self, secret: str, guess: str) -&gt; str:
        aaa=0
        dic1=dict()
        dic2=dict()
        for a,b in zip(secret,guess):
            if a==b:
                aaa+=1
            dic1[a]=dic1.get(a,0)+1
            dic2[b]=dic2.get(b,0)+1
        bbb=0
        for k in dic1:
            if k in dic2:
                bbb+=min(dic1[k],dic2[k])
        
        bbb=bbb-aaa
        
        return str(aaa)+'A'+str(bbb)+'B'
</code></pre>
<h1 id="font-colorblue300-longest-increasing-subsequence-medium-font"><font color='blue'>300. Longest Increasing Subsequence (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        # dp[i] means the LIS till ith number including i
        # dp[i] =  max(dp[i],dp[j]+1)   j&lt;i and nums[j]&lt;nums[i]
        if not nums: return 0
        if len(nums)==1: return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j]&lt;nums[i]:
                    dp[i]=max(dp[i],dp[j]+1)
        
        return max(dp)
</code></pre>
<p>classical DP problem O(n^2)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-01/">
        </link>
        <updated>2021-11-30T05:36:09.000Z</updated>
        <summary type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
]]></summary>
        <content type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
<!-- more -->
<h1 id="281-zigzag-iterator-medium">281. Zigzag Iterator （Medium）</h1>
<p>Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.</p>
<pre><code class="language-python">class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        li=[v1,v2]
        self.li = [[v,len(v)] for v in li if v]
        self.select = 0
    
    def next(self) -&gt; int:
        if self.li[self.select][1]&gt;0:
            self.li[self.select][1]-=1
            val= self.li[self.select][0].pop(0)
            if self.li[self.select][1]==0:
                self.li.pop(self.select)
            self.select=(self.select+1)%len(self.li) if self.li else 0
            return val
         
    def hasNext(self) -&gt; bool:
        return sum([e[1] for e in self.li])&gt;0
        
        

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
</code></pre>
<h1 id="282-expression-add-operators-hard">282. Expression Add Operators (Hard)</h1>
<p>Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.Note that operands in the returned expressions should not contain leading zeros.</p>
<pre><code class="language-python">class Solution:
    def addOperators(self, num: 'str', target: 'int') -&gt; 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append(&quot;&quot;.join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand &gt; 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
</code></pre>
<p>第一眼感觉是用backtracking，写出了第一版，但是没考虑1） number 可以是1位可以是2位，3位 etc， 2）乘法的优先级高于加减，所以需要tracking operator是什么。 3）不可以backtracking到最后eval结果，太费时间。 直接看答案了。。。答案： 关键在于除了加减乘以外，增加一个不操作operator， 12--&gt;123  是 12乘以10+3     extending 当前值12 by one digit， 12乘以10。  看了答案还是懵逼。细节太多但都符合逻辑。</p>
<h1 id="283-move-zeroes-easy">283. Move Zeroes （Easy）</h1>
<p>Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.</p>
<pre><code class="language-python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos]=n
                pos+=1
        while pos&lt;len(nums):
            nums[pos]=0
            pos+=1

#SWAP is a better solution
class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos],nums[i] = nums[i],nums[pos]
                pos+=1
     
</code></pre>
<h1 id="284-peeking-iterator-medium">284. Peeking Iterator (Medium)</h1>
<pre><code class="language-python"># Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         &quot;&quot;&quot;
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         &quot;&quot;&quot;
#
#     def hasNext(self):
#         &quot;&quot;&quot;
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         &quot;&quot;&quot;
#
#     def next(self):
#         &quot;&quot;&quot;
#         Returns the next element in the iteration.
#         :rtype: int
#         &quot;&quot;&quot;

class PeekingIterator:
    def __init__(self, iterator):
        &quot;&quot;&quot;
        Initialize your data structure here.
        :type iterator: Iterator
        &quot;&quot;&quot;
        self.iterator=iterator
        self.peekval=None

    def peek(self):
        &quot;&quot;&quot;
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval:
            return self.peekval
        else:
            self.peekval=self.iterator.next()
            return self.peekval
        

    def next(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval is not None:
            peekval=self.peekval
            self.peekval=None
            return peekval
        else:
            return self.iterator.next()
        

    def hasNext(self):
        &quot;&quot;&quot;
        :rtype: bool
        &quot;&quot;&quot;
        return self.iterator.hasNext() or self.peekval is not None
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].

</code></pre>
<h1 id="285-inorder-successor-in-bst-medium">285. Inorder Successor in BST (Medium)</h1>
<p>Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'Optional[TreeNode]':
        stack = []
        while root and root.val!=p.val:
            stack.append(root)
            if p.val&lt;root.val:
                root=root.left
            else:
                root=root.right
        
        if p.right:
            node=p.right
            while node.left:
                node=node.left
            return node
                
        else:
            while stack:
                node=stack.pop()
                if node.val&gt;p.val:
                    return node
            return None


#ANSWER
class Solution:
    
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'TreeNode':
        
        successor = None
        
        while root:
            
            if p.val &gt;= root.val:
                root = root.right
            else:
                successor = root
                root = root.left
                
        return successor

</code></pre>
<p>答案更巧妙。</p>
<h1 id="286-walls-and-gates-medium">286. Walls and Gates （Medium）</h1>
<p>You are given an m x n grid rooms initialized with these three possible values.</p>
<pre><code>-1 A wall or an obstacle.
0 A gate.
INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
</code></pre>
<p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.</p>
<pre><code class="language-python">class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        visited = set()
        while q:
            level+=1
            for _ in range(len(q)):
                i,j = q.popleft()
                visited.add((i,j))
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and (ii,jj) not in visited:
                        if rooms[ii][jj]!=0 and rooms[ii][jj]!=-1:
                            rooms[ii][jj] = level
                            q.append((ii,jj))
                            visited.add((ii,jj))

#ANSWER
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        while q:
            for _ in range(len(q)):
                i,j = q.popleft()
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and  rooms[ii][jj]==INF :
                        rooms[ii][jj] = rooms[i][j]+1
                        q.append((ii,jj))
                           
</code></pre>
<p>第一眼感觉用bfs做，从gates 处扫不是墙和gate的rooms距离。 差点忘了bfs 要for _ in range(len(queue))  .....   答案不用visited level 解决， 因为BFS所以只要INF 变成距离就是最短距离， 从什么地方变得距离？就是rooms[ii][jj] = rooms[i][j]+1</p>
<h1 id="font-colorred-287-find-the-duplicate-number-mediumfont"><font color='red'> 287. Find the Duplicate Number （Medium）</font></h1>
<p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.<br>
There is only one repeated number in nums, return this repeated number.<br>
You must solve the problem without modifying the array nums and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        for num in nums:
            cur = abs(num)
            if nums[cur] &lt; 0:
                duplicate = cur
                break
            nums[cur] = -nums[cur]

        # Restore numbers
        for i in range(len(nums)):
            nums[i] = abs(nums[i])

        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        duplicate = 0
        n = len(nums)
        bits = n.bit_length()
        for bit in range(bits):
            mask = 1 &lt;&lt; bit
            base_count = 0
            nums_count = 0
            for i in range(n):
                # If bit is set in number (i) then add 1 to base_count
                if i &amp; mask:
                    base_count += 1
                    
                # If bit is set in nums[i] then add 1 to nums_count
                if nums[i] &amp; mask:
                    nums_count += 1
                    
            # If the current bit is more frequently set in nums than it is in 
            # the range [1, 2, ..., n] then it must also be set in the duplicate number.
            if nums_count - base_count &gt; 0:
                duplicate |= mask
                
        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: 'List[int]') -&gt; 'int':
        
        low = 1
        high = len(nums)-1
        
        while low &lt; high:
            mid = low+(high-low)//2
            count = 0
            for i in nums:
                if i &lt;= mid:
                    count+=1
            if count &lt;= mid:
                low = mid+1
            else:
                high = mid
        return low

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        
        #who can think it as cycled two pointer problem?
        
        slow = nums[0]
        fast = nums[0]
        
        while True:
            slow =  nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        
        fast = nums[0]
        while slow!=fast:
            slow=nums[slow]
            fast=nums[fast]
        return slow
</code></pre>
<p>一堆double数中找single容易，用xor就可以， 但一堆single中找double。。。 答案思路： 思路1）标负。符号所在位置表示数出现过没。 nums[cur]小于0表示 cur这个数出现过。 2）bitmask 3）binary search 4）Cycle Detection，这个方法最妙。</p>
<h1 id="288-unique-word-abbreviation-medium">288. Unique Word Abbreviation （Medium）</h1>
<p>The abbreviation of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an abbreviation of itself.</p>
<pre><code class="language-python">class ValidWordAbbr:
    
    
    def __init__(self, dictionary: List[str]):
        import collections 
        self.dic= collections.defaultdict(set)
        for w in dictionary:
            key=self.sort(w)
            self.dic[key].add(w)
        #print(self.dic)
        
    def sort(self,w):
        if len(w)&lt;=2:
            key=w
        else:
            key=w[0]+str(len(w[1:-1])) +w[-1]
        return key
    
    def isUnique(self, word: str) -&gt; bool:
        key=self.sort(word)
        if key not in self.dic or (len(self.dic[key])==1 and list(self.dic[key])[0]==word):
            return True
        return False


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)

#Better solution
class ValidWordAbbr(object):
    
    def getkey(self,word):
        if len(word)&lt;=2: 
            return word
        else:
            return word[0]+str(len(word[1:-1]))+word[-1]
        
    
    def __init__(self, dictionary):
        &quot;&quot;&quot;
        :type dictionary: List[str]
        &quot;&quot;&quot;
         
        self.dic=dict()
        for word in dictionary:
            key=self.getkey(word)
            if key in self.dic and word!=self.dic[key]:
                self.dic[key]='#'
            else:
                self.dic[key]=word
        

    def isUnique(self, word):
        &quot;&quot;&quot;
        :type word: str
        :rtype: bool
        &quot;&quot;&quot;

        key=self.getkey(word)
        
        if key in self.dic and self.dic[key]==word:
            return True
        elif key not in self.dic:
            return True
        return False
</code></pre>
<h1 id="289-game-of-life-medium">289. Game of Life (Medium)</h1>
<pre><code class="language-python">class Solution:
    def gameOfLife(self, board: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        m=len(board)
        n=len(board[0])
        #solve it in-place
        #rule
        #  live cell =1
        #            #nei &lt;2      die
        #            #nei 2 or 3  live
        #            #nei &gt;3      die
        #  dead cell = 0
        #            #nei 3       live
        #
        #  save live die in next round with (X//10)%2   if live save as 10+old
        #                                               if die  save as 20+old
        #  when get old value   old = old%10
        
        for i in range(m):
            for j in range(n):
                live=0
                old=board[i][j]%10
                if old==1:
                    livecell=True
                else:
                    livecell=False
                    
                for nei in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    ii,jj=nei
                    if ii&lt;m and ii&gt;=0 and jj&lt;n and jj&gt;=0:
                        live+=board[ii][jj]%10
                
                if livecell:
                    if live==2 or live==3:
                        board[i][j]= 10+old
                    else:
                        board[i][j]= 20+old
                else:
                    if live==3:
                        board[i][j] = 10+old
                        
        for i in range(m):
            for j in range(n):
                board[i][j] = (board[i][j]//10)%2
        
#INF CASE
def gameOfLifeInfinite(self, live):
    ctr = collections.Counter((I, J)
                              for i, j in live
                              for I in range(i-1, i+2)
                              for J in range(j-1, j+2)
                              if I != i or J != j)
    return {ij
            for ij in ctr
            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}

def gameOfLife(self, board):
    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}
    live = self.gameOfLifeInfinite(live)
    for i, row in enumerate(board):
        for j in range(len(row)):
            row[j] = int((i, j) in live)
</code></pre>
<h1 id="290-word-pattern-easy">290. Word Pattern （Easy）</h1>
<pre><code class="language-python">class Solution:
    def wordPattern(self, pattern: str, s: str) -&gt; bool:
        
        dic1=dict()
        dic2=dict()
        if len(pattern)!=len(s.split()): return False
        for k,v in zip(s.split(),pattern):
            if k not in dic1:
                dic1[k]=v
            else:
                if dic1[k]!=v:
                    return False
            
            if v not in dic2:
                dic2[v]=k
            else:
                if dic2[v]!=k:
                    return False
        return True
</code></pre>
<p>注意是一一映射，所以需要2个dict检查， 注意corner case。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-30]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-30/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-30/">
        </link>
        <updated>2021-11-30T03:53:48.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="271-encode-and-decode-strings-medium">271. Encode and Decode Strings (Medium)</h1>
<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<pre><code class="language-python">class Codec:
    def encode(self, strs: [str]) -&gt; str:
        &quot;&quot;&quot;Encodes a list of strings to a single string.
        &quot;&quot;&quot;
        candidate='a'
        set_ = set()
        for str in strs:
            for s in str:
                set_.add(s)
        while candidate in set_:
            candidate = chr(ord(candidate)+1)
        return candidate + candidate.join(strs)
        

    def decode(self, s: str) -&gt; [str]:
        &quot;&quot;&quot;Decodes a single string to a list of strings.
        &quot;&quot;&quot;
        candidate = s[0]
        s = s[1:]
        return s.split(candidate)
        


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))
</code></pre>
<h1 id="font-colorblue272-closest-binary-search-tree-value-ii-hard-font"><font color='blue'>272. Closest Binary Search Tree Value II (Hard) </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -&gt; List[int]:
        stack  = []
        s  =[]
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            root=stack.pop()
            diff = abs(root.val-target)
            if len(s)&lt;k:
                s.append((diff,root.val))
            else:
                s.sort(key=lambda x:x[0])
                if s and s[-1][0]&gt;diff:
                    s.pop()
                    s.append((diff,root.val))
                    s.sort(key=lambda x:x[0])
            
            root=root.right
        
        return [e[1] for e in s]

#ANSWER 1 Recursive Inorder + Sort, O(N log N) time
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        nums = inorder(root)
        nums.sort(key = lambda x: abs(x - target))
        return nums[:k]

#ANSWER 2 
from heapq import heappush, heappop
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            if not r:
                return
            
            inorder(r.left)
            heappush(heap, (- abs(r.val - target), r.val))
            if len(heap) &gt; k:
                heappop(heap)
            inorder(r.right) 
    
        heap = []
        inorder(root)
        return [x for _, x in heap]

#ANSWER 3 QuickSelect, O(N) time.
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        def partition(pivot_idx, left, right):
            pivot_dist = dist(pivot_idx)
            
            # 1. move pivot to end
            nums[right], nums[pivot_idx] = nums[pivot_idx], nums[right]
            store_idx = left
            
            # 2. move more close elements to the left
            for i in range(left, right):
                if dist(i) &lt; pivot_dist:
                    nums[i], nums[store_idx] = nums[store_idx], nums[i]
                    store_idx += 1
                    
            # 3. move pivot to its final place
            nums[right], nums[store_idx] = nums[store_idx], nums[right]
            
            return store_idx
            
        def quickselect(left, right):
            &quot;&quot;&quot;
            Sort a list within left..right till kth less close element
            takes its place.
            &quot;&quot;&quot;
            # base case: the list contains only one element
            if left == right:
                return 
            
            # select a random pivot_index
            pivot_idx = randint(left, right)
            
            # find the pivot position in a sorted list
            true_idx = partition(pivot_idx, left, right)
            
            # if the pivot is in its final sorted position
            if true_idx == k:
                return
            
            if true_idx &lt; k:
                # go left
                quickselect(true_idx, right)
            else:
                # go right
                quickselect(left, true_idx)
        
        nums = inorder(root)
        dist = lambda idx : abs(nums[idx] - target)
        quickselect(0, len(nums) - 1)
        return nums[:k]
</code></pre>
<p>虽然做出来了，但是感觉用minheap会更好。我的方法得一直sort，时间复杂度太高。  需要记住 from heapq import heappush，heappop 用法 heappush（heap，val） heappop（heap） 每次pop出来的是最小的元素。  O（n）方法用到了快排。</p>
<h1 id="273-integer-to-english-words-hard">273. Integer to English Words （Hard）</h1>
<p>Convert a non-negative integer num to its English words representation.</p>
<pre><code class="language-python">class Solution:
    def numberToWords(self, num: int) -&gt; str:
      
        nums = []
      
        if num==0: nums.append(0)
        while num:
            nums.append(num%1000)
            num//=1000
        
    
        res = []
        l=len(nums)
        dic = {0:'',1:'Thousand',2:'Million',3:'Billion',4:'Trillion'}
        def helper(n):
            if type(n)==str: return ''
            s  = ''
            dic = {0:'Zero',1:'One',2:'Two',3:'Three',4:'Four',5:'Five',6:'Six',7:'Seven',8:'Eight',9:'Nine',10:'Ten',11:'Eleven',12:'Twelve',13:'Thirteen',14:'Fourteen',15:'Fifteen',16:'Sixteen',17:'Seventeen',18:'Eighteen',19:'Nineteen',20:'Twenty',30:'Thirty',40:'Forty',50:'Fifty',60:'Sixty',70:'Seventy',80:'Eighty',90:'Ninety'}
            
            if n&lt;10: return dic[n]
            if n&gt;99:
                s+= dic[n//100]+' Hundred'
            n = n%100
            if n==0: return s
            if n in dic:
                s+= ' '+dic[n]
                return s
            else:
                s+=' '+dic[10*(n//10)]
                n=n%10
                if n==0:
                    return s
                else:
                    s+= ' '+ dic[n]
                    return s
       
        tmp=[]
        while nums:
            if nums[0]==0:
                nums.pop(0)
                tmp.append('#')
            else:
                tmp.append(nums.pop(0))

        nums=tmp
        if nums==['#']:
            nums=[0]
        for i,number in enumerate(nums):
            if number!='#':
                res.append(helper(number)+ ' ' + dic[i])
        return ' '.join([ e.strip() for e in res[::-1] if e.strip()])
#ANSWER
class Solution:
    def numberToWords(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: str
        &quot;&quot;&quot;
        def one(num):
            switcher = {
                1: 'One',
                2: 'Two',
                3: 'Three',
                4: 'Four',
                5: 'Five',
                6: 'Six',
                7: 'Seven',
                8: 'Eight',
                9: 'Nine'
            }
            return switcher.get(num)

        def two_less_20(num):
            switcher = {
                10: 'Ten',
                11: 'Eleven',
                12: 'Twelve',
                13: 'Thirteen',
                14: 'Fourteen',
                15: 'Fifteen',
                16: 'Sixteen',
                17: 'Seventeen',
                18: 'Eighteen',
                19: 'Nineteen'
            }
            return switcher.get(num)
        
        def ten(num):
            switcher = {
                2: 'Twenty',
                3: 'Thirty',
                4: 'Forty',
                5: 'Fifty',
                6: 'Sixty',
                7: 'Seventy',
                8: 'Eighty',
                9: 'Ninety'
            }
            return switcher.get(num)
        

        def two(num):
            if not num:
                return ''
            elif num &lt; 10:
                return one(num)
            elif num &lt; 20:
                return two_less_20(num)
            else:
                tenner = num // 10
                rest = num - tenner * 10
                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)
        
        def three(num):
            hundred = num // 100
            rest = num - hundred * 100
            if hundred and rest:
                return one(hundred) + ' Hundred ' + two(rest) 
            elif not hundred and rest: 
                return two(rest)
            elif hundred and not rest:
                return one(hundred) + ' Hundred'
        
        billion = num // 1000000000
        million = (num - billion * 1000000000) // 1000000
        thousand = (num - billion * 1000000000 - million * 1000000) // 1000
        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000
        
        if not num:
            return 'Zero'
        
        result = ''
        if billion:        
            result = three(billion) + ' Billion'
        if million:
            result += ' ' if result else ''    
            result += three(million) + ' Million'
        if thousand:
            result += ' ' if result else ''
            result += three(thousand) + ' Thousand'
        if rest:
            result += ' ' if result else ''
            result += three(rest)
        return result

</code></pre>
<p>corner case 有点太多了。。。写出来是写出来了。</p>
<h1 id="274-h-index-medium">274. H-Index （Medium）</h1>
<p>Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        # [1,3,1]
        # 
        #  0 1 2 3
        # []
        
        dp = [0]*(len(citations)+1)
        for c in citations:
            if c&gt;len(citations):
                c=len(citations)
            dp[c]+=1
        
        for i in range(len(dp)-2,-1,-1):
            dp[i]=dp[i]+dp[i+1]
        
        hindex=[]
        print(dp)
        for ind, n in enumerate(dp):
            if n&gt;=ind:
                hindex.append(ind)
        
        return max(hindex)

#ANSWER reverse SORT
class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
    
        citations.sort(reverse=True)
        print(citations)
        hindex=0
        for ind, cit in enumerate(citations):
            hindex_candidate = ind+1
            if cit&gt;=hindex_candidate:
                hindex = hindex_candidate
                
        return hindex

</code></pre>
<h1 id="font-colorblue275-h-index-ii-medium-font"><font color='blue'>275. H-Index II (Medium) </font></h1>
<p>sorted citations O(lgn) time to solve</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        # already sorterd so binary search
        
        #hindex=0
        #for idx in range(len(citations)-1,-1,-1):
        #    cit = citations[idx]
        #    hidx =  len(citations)-idx 
        #    if cit&gt;=hidx:
        #        hindex=hidx
        # 
        #return hindex
        
        l=0
        r=len(citations)-1
        res = [0]
        while l&lt;=r:
            m=(l+r)//2
            
            cit=citations[m]
            hidx=len(citations)-m
            if cit&gt;=hidx:
                res.append(hidx)
                r=m-1
            else:
                l=m+1
        
        return max(res)

#ANSWER
class Solution:
    def hIndex(self, citations):
        &quot;&quot;&quot;
        :type citations: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(citations)
        for idx, c in enumerate(citations):
            if c &gt;= n - idx:
                return n - idx
        return 0
#binary serach
class Solution:
    def hIndex(self, citations):
        &quot;&quot;&quot;
        :type citations: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(citations)
        left, right = 0, n - 1

        # We need to find the rightmost 'index' such that: (citations[index] &lt;= n - index)
        while left &lt;= right:
            mid = left + (right - left) // 2

            # There's (n - mid) papers with an equal or higher citation count than citations[mid]
            # If (citations[mid] == n - mid) it's the optimal result and can be returned right away
            if citations[mid] == n - mid:
                return n - mid

            # If citations[mid] is less than (n - mid), narrow down on the right half to look for a paper
            # at a future index that meets the h-index criteria. Otherwise, narrow down on the left half
            if citations[mid] &lt; n - mid:
                left = mid + 1
            else:
                right = mid - 1

        # We didn't find an exact match, so there's exactly (n - left) papers that have citations
        # greater than or equal to citations[left] and that is our answer
        return n - left
</code></pre>
<p>虽然做出来了，但是还是不熟。</p>
<h1 id="font-colorred276-paint-fence-medium-font"><font color='red'>276. Paint Fence (Medium) </font></h1>
<p>You are painting a fence of n posts with k different colors. You must paint the posts following these rules:<br>
Every post must be painted exactly one color.<br>
There cannot be three or more consecutive posts with the same color.<br>
Given the two integers n and k, return the number of ways you can paint the fence.</p>
<pre><code class="language-python">class Solution:
    def numWays(self, n: int, k: int) -&gt; int:
        # dp    
        # n = 0    0  
        # n = 1    k
        # n = 2    k*k    
        # n = 3    diff color  (k-1)*dp[i-1]   same color 1*  (k-1)*dp[i-2]  
        # so, dp[i] = (k-1)dp[i-1]+(k-1)*dp[i-2]
        
        if n==1:
            return k
        if n==2:
            return k*k
        dp=[0]*(n+1)
        dp[1]=k
        dp[2]=k*k
        for i in range(3,n+1):
            dp[i] = (k-1)*(dp[i-1]+dp[i-2])
        
        return dp[n]
</code></pre>
<p>感觉是DP，递推关系是？ 已经想到了，但是没仔细去想。 当前颜色和前一个相同， 当前颜色和前一个不同。</p>
<h1 id="font-colorred-277-find-the-celebrity-mediumfont"><font color='red'> 277. Find the Celebrity （Medium）</font></h1>
<pre><code class="language-python">
class Solution:
    def findCelebrity(self, n: int) -&gt; int:
        self.n = n
        celebrity_candidate = 0
        for i in range(1, n):
            if knows(celebrity_candidate, i):
                celebrity_candidate = i
        if self.is_celebrity(celebrity_candidate):
            return celebrity_candidate
        return -1

    def is_celebrity(self, i):
        for j in range(self.n):
            if i == j: continue
            if knows(i, j) or not knows(j, i):
                return False
        return True
</code></pre>
<p>答案找possible candidate O（n）时间的方法第一次没想出来。。。</p>
<h1 id="278-first-bad-version-easy">278. First Bad Version （Easy）</h1>
<p>Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<pre><code class="language-python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if isBadVersion(m):
                r=m-1
            else:
                l=m+1
        return l

</code></pre>
<h1 id="font-colorred279-perfect-squares-medium-font"><font color='red'>279. Perfect Squares (Medium) </font></h1>
<p>Given an integer n, return the least number of perfect square numbers that sum to n.</p>
<pre><code class="language-python">class Solution:
    def numSquares(self, n: int) -&gt; int:
        #dp   1 2  3  4  5  6  7  8
        #     1 2  3  1  2  3  4  2
        if n&lt;=3: return n
        def is_sqrt(num):
            for i in range(1,num//2+1):
                if i*i==num:
                    return True
            return False
        dp = [float('inf')]*(n+1)
        dp[0]=0
        dp[1]=1
        dp[2]=2
        dp[3]=3
        for i in range(4,n+1):
            if is_sqrt(i):
                dp[i]=1
            else:
                for ii in range(1,i//2+1):
                    dp[i]=min(dp[i],dp[ii]+dp[i-ii])
        
        print(dp)
        return dp[n]

#ANSWER O（n*sqrt（n））
class Solution(object):
    def numSquares(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        # bottom case
        dp[0] = 0
        
        for i in range(1, n+1):
            for square in square_nums:
                if i &lt; square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
</code></pre>
<p>第一次整了个time limit exceeded。 思路类似,答案pre calculate square_nums  省了很多时间也不用判断是否为完全平方数。</p>
<h1 id="font-colorred280-wiggle-sort-mediumfont"><font color='red'>280. Wiggle Sort （Medium）</font></h1>
<p>Given an integer array nums, reorder it such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]....<br>
You may assume the input array always has a valid answer.</p>
<pre><code class="language-python">class Solution:
    def wiggleSort(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        nums.sort()
        for i in range(1,len(nums)-1,2):
            nums[i],nums[i+1]=nums[i+1],nums[i]

#ANSWER
class Solution:
    def wiggleSort(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        less=True
        for i in range(len(nums)-1):
            if less:
                if nums[i]&gt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            else:
                if nums[i]&lt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            
            less=not less
</code></pre>
<p>too late today。  思路1  sort first， 从第二个元素开始swap。 思路2，如果顺序不正确就纠正。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-29]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-29/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-29/">
        </link>
        <updated>2021-11-29T11:15:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue261-graph-valid-tree-mediumfont"><font color='blue'>261. Graph Valid Tree （Medium）</font></h1>
<p>You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.<br>
Return true if the edges of the given graph make up a valid tree, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent = [None]*n
            self.rank = [0]*n
            for i in range(n):
                self.parent[i]=i
                
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
    
        
    def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
        #UNIONFIND
        uf =self.UnionFind(n)
        for (a,b) in edges:
            uf.union(a,b)
        
        if len(set( [uf.find(i) for i in range(n)]))!=1:
            return False
    
        return len(edges)==n-1

#answer DFS
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            stack.append(neighbour)
    
    return len(seen) == n
#answer 
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = set()

    def dfs(node):
        if node in seen: return
        seen.add(node)
        for neighbour in adj_list[node]:
            dfs(neighbour)

    dfs(0)
    return len(seen) == n

#answer
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    queue = collections.deque([0])
    
    while queue:
        node = queue.popleft()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            queue.append(neighbour)
    
    return len(seen) == n
</code></pre>
<p>猜到了使用UnionFind做，但是还是copy了UnionFind Class 代码，还没熟练到自己写出来。 思路很简单，union后同一个parent，#edges+1=#node      答案思路：DFS或者BFS  判断是树1）n-1 edges， 2）graph fully connected。</p>
<h1 id="262-trips-and-users-hard">262. Trips and Users （Hard）</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
select   request_at as 'Day', round(sum(counter)/sum(total),2) as 'Cancellation Rate' from (
select CASE WHEN Trips.status='completed' THEN 0 else 1 END as counter, 1 as total, Trips.request_at  from
Trips left join Users c on Trips.client_id=c.users_id left join Users d on Trips.driver_id=d.users_id where c.banned!='Yes' and d.banned!='Yes'
) tmp  where Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot; group by request_at

#ANSWER 
SELECT Request_at as Day,
ROUND(SUM(CASE WHEN Status!=&quot;completed&quot; THEN 1 ELSE 0 END)/COUNT(*),2) as &quot;Cancellation Rate&quot; 
FROM Trips
WHERE Client_Id NOT IN
(
    SELECT Users_Id FROM Users
    WHERE Banned=&quot;Yes&quot;
)
AND Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot;
GROUP BY Request_at;
</code></pre>
<h1 id="263-ugly-number-easy">263. Ugly Number (Easy)</h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return true if n is an ugly number.</p>
<pre><code class="language-python">class Solution:
    def isUgly(self, n: int) -&gt; bool:
        if n==0: return False
        if n==1: return True
        
        while n%2==0:
            n//=2
        if n==1: return True
        while n%3==0:
            n//=3
        if n==1: return True
        while n%5==0:
            n//=5
        if n==1: return True
        
        return False

</code></pre>
<h1 id="font-colorred264-ugly-number-ii-medium-font"><font color='red'>264. Ugly Number II (Medium) </font></h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return the nth ugly number.</p>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [0] * n
        t2 = t3 = t5 = 0
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
            if(dp[i] == dp[t2]*2): t2 += 1
            if(dp[i] == dp[t3]*3): t3 += 1
            if(dp[i] == dp[t5]*5): t5 += 1
        return dp[-1]

</code></pre>
<p>没思路 。。。或者知道思路但写不出代码。  要是添加2倍，3倍，4倍，5倍还是会有空隙当n很大时候。 答案，用了dynamic programming。 思路是多个pointer。 t2，t3，t5记录已经遍历的数字里2，3，5都有多少个。 关键点是找到下一个最小的ugly number当乘以2，3，5时候。 又因为已经存在的数字只能被2，3，5乘1次，所以可以用pointer保持下次2，3，5要乘以的位置。</p>
<h1 id="265-paint-house-ii-hard">265. Paint House II （Hard）</h1>
<p>There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br>
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.</p>
<pre><code class="language-python">class Solution:
    def minCostII(self, costs: List[List[int]]) -&gt; int:
        #  cost last =     [a1,a2,a3,a4]
        #  cost last-1 =   [a1'+min(a2,a3,a4),a2'+min(a1,a3,a4),...]
        #  ...
        #  cost  0     =    [a1''',a2'''....]
        # ans= min(cost0)
        for i in range(len(costs)-2,-1,-1):
            for ii in range(len(costs[0])):
                costs[i][ii] = costs[i][ii]+min([costs[i+1][jj] for jj in range(len(costs[0])) if jj!=ii])
        
        return min(costs[0])
</code></pre>
<h1 id="266-palindrome-permutation-easy">266. Palindrome Permutation (Easy)</h1>
<p>Given a string s, return true if a permutation of the string could form a palindrome.</p>
<pre><code class="language-python">class Solution:
    def canPermutePalindrome(self, s: str) -&gt; bool:
        #odd occurance can not &gt;1
        dic = collections.Counter(s)
        c=0
        for k,v in dic.items():
            if v%2==1:
                c+=1
            if c&gt;1:
                return False
        return True
</code></pre>
<h1 id="267-palindrome-permutation-ii-medium">267. Palindrome Permutation II (Medium)</h1>
<pre><code class="language-python">class Solution:
    def generatePalindromes(self, s: str) -&gt; List[str]:
        dic = collections.Counter(s)
        c = 0
        odd_char = ''
        odd_c = 0
        for k,v in dic.items():
            if v%2==1:
                c+=1
                odd_char = k
                odd_c = v
        if c&gt;1: return []
        if len(dic)==1:
            return [list(dic.keys())[0]*dic[list(dic.keys())[0]]]
        if odd_char:
            tmp=odd_char
            dic[odd_char]-=1
            if dic[odd_char]&lt;=0:
                del dic[odd_char]
                 
        res = []
        def bt(dic,tmp):
            if len(tmp)==len(s):
                res.append(tmp)
                return
            
            for k,v in dic.items():
                dic_copy = dic.copy()
                tmp = k+tmp+k
                dic_copy[k]-=2
                if dic_copy[k]==0:
                    del dic_copy[k]
                #print(tmp,dic_copy)
                bt(dic_copy,tmp)
                tmp=tmp[1:-1]

            
        bt(dic,odd_char)
        return  res
</code></pre>
<p>backtracking 分为odd 元素存在时候，中间位置只能是odd元素，然后从中间向两边扩展。</p>
<h1 id="268-missing-number-easy">268. Missing Number （Easy）</h1>
<p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n=len(nums)
        return (0+n)*(n+1)//2 - sum(nums)
</code></pre>
<h1 id="font-colorred269-alien-dictionary-hard-font"><font color='red'>269. Alien Dictionary (Hard) </font></h1>
<p>There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.<br>
You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.<br>
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return &quot;&quot;. If there are multiple solutions, return any of them.<br>
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length &lt; t.length.<br>
Input: words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]<br>
Output: &quot;wertf&quot;</p>
<pre><code class="language-python">class Solution:
     
    
    from collections import defaultdict, Counter, deque

    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: create data structures + the in_degree of each unique letter to 0.
        adj_list = defaultdict(set)
        in_degree = Counter({c : 0 for word in words for c in word})

        # Step 1: We need to populate adj_list and in_degree.
        # For each pair of adjacent words...
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d:
                    if d not in adj_list[c]:
                        adj_list[c].add(d)
                        in_degree[d] += 1
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): return &quot;&quot;

        # Step 2: We need to repeatedly pick off nodes with an indegree of 0.
        output = []
        queue = deque([c for c in in_degree if in_degree[c] == 0])
        while queue:
            c = queue.popleft()
            output.append(c)
            for d in adj_list[c]:
                in_degree[d] -= 1
                if in_degree[d] == 0:
                    queue.append(d)

        # If not all letters are in output, that means there was a cycle and so
        # no valid ordering. Return &quot;&quot; as per the problem description.
        if len(output) &lt; len(in_degree):
            return &quot;&quot;
        # Otherwise, convert the ordering we found into a string and return it.
        return &quot;&quot;.join(output)

#DFS topo sorter reverse adj list and using grey black for node color

class Solution:
    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: Put all unique letters into the adj list.
        reverse_adj_list = {c : [] for word in words for c in word}

        # Step 1: Find all edges and put them in reverse_adj_list.
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d: 
                    reverse_adj_list[d].append(c)
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): 
                    return &quot;&quot;

        # Step 2: Depth-first search.
        seen = {} # False = grey, True = black.
        output = []
        def visit(node):  # Return True iff there are no cycles.
            if node in seen:
                return seen[node] # If this node was grey (False), a cycle was detected.
            seen[node] = False # Mark node as grey.
            for next_node in reverse_adj_list[node]:
                result = visit(next_node)
                if not result: 
                    return False # Cycle was detected lower down.
            seen[node] = True # Mark node as black.
            output.append(node)
            return True

        if not all(visit(node) for node in reverse_adj_list):
            return &quot;&quot;

        return &quot;&quot;.join(output)


</code></pre>
<p>很明显图论相关的题，没复习到还，看答案。思路：1）找到dependence rules， 2）topological sort。用queue来存indegree=0的node，然后遍历neighbors。或者DFS，revse adj list 然后为了防止有环，需要标注node color white grey black。</p>
<pre><code class="language-python">for item in container:
    if search_something(item):
        # Found it!
        process(item)
        break
else:
    # Didn't find anything..
    not_found_in_container()

</code></pre>
<p>这个语法从来没见过，for后面可以带一个else表明for loop中没有break的条件，else 来执行后续操作。</p>
<h1 id="270-closest-binary-search-tree-value-easy">270. Closest Binary Search Tree Value （Easy）</h1>
<p>Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -&gt; int:
        if not root.left and not root.right: return root.val
        if not root.right:
            if target&lt;root.val:
                res=self.closestValue(root.left,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        if not root.left:
            if target&gt;root.val:
                res = self.closestValue(root.right,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        
        if target==root.val:
            return root.val
        elif target&lt;root.val:
            res = self.closestValue(root.left,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val
        else:
            res= self.closestValue(root.right,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val

#ANSWER
class Solution:
    def closestValue(self, root: TreeNode, target: float) -&gt; int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            root = root.left if target &lt; root.val else root.right
        return closest
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-28]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-28/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-28/">
        </link>
        <updated>2021-11-27T20:14:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="251-flatten-2d-vector-medium">251. Flatten 2D Vector (Medium)</h1>
<p>Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.<br>
Implement the Vector2D class:<br>
Vector2D(int[][] vec) initializes the object with the 2D vector vec.<br>
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.<br>
hasNext() returns true if there are still some elements in the vector, and false otherwise.</p>
<pre><code class="language-python">class Vector2D:

    def __init__(self, vec: List[List[int]]):
        self.stack=[]
        self.vec=vec

    def next(self) -&gt; int:
        if self.hasNext():
            val=self.stack.pop(0)
        return val

    def hasNext(self) -&gt; bool:
        if not self.stack:
            if not self.vec:
                return False
            row=self.vec.pop(0)
            if not row: 
                if self.hasNext():
                    return True
                else:
                    return False
            for e in row:
                self.stack.append(e)
        return True


# Your Vector2D object will be instantiated and called as such:
# obj = Vector2D(vec)
# param_1 = obj.next()
# param_2 = obj.hasNext()
#answer way of writing
class Vector2D:

    def __init__(self, v: List[List[int]]):
        # We need to iterate over the 2D vector, getting all the integers
        # out of it and putting them into the nums list.
         
        self.nums = []
        for inner_list in v:
            for num in inner_list:
                self.nums.append(num)
        # We'll keep position 1 behind the next number to return.
        self.position = -1

    def next(self) -&gt; int:
        # Move up to the current element and return it.
        self.position += 1
        return self.nums[self.position]

    def hasNext(self) -&gt; bool:
        # If the next position is a valid index of nums, return True.
        return self.position + 1 &lt; len(self.nums)

</code></pre>
<p>自己写的这个递归调用比较tricky。。。答案很简答。</p>
<h1 id="252-meeting-rooms-easy">252. Meeting Rooms （Easy）</h1>
<p>Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.</p>
<pre><code class="language-python">class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool:
        intervals=sorted(intervals,key=lambda x:x[0])
        pre_end = None
        for interval in intervals:
            if pre_end is not None and interval[0]&lt;pre_end:
                return False
            pre_end = interval[1]
        return True
</code></pre>
<h1 id="font-colorblue253-meeting-rooms-ii-medium-font"><font color='blue'>253. Meeting Rooms II (Medium) </font></h1>
<p>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</p>
<pre><code class="language-python">class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:
        #find max overlapping interval num
        res=1
        c=0
        #at start +=1 at end -=1
        dic=dict()
        for interval in intervals:
            start,end=interval[0],interval[1]
            if start in dic:
                dic[start]+=1
            else:
                dic[start]=1
            
            if end in dic:
                dic[end]-=1
            else:
                dic[end]=-1
        
        for k in sorted(dic.keys()):
            c+=dic[k]
            res=max(res,c)
        return res
</code></pre>
<p>虽然做出来了，感觉下次再做可能会忘记怎么做的， 思路： 把所有时节节点从小到大排序，如果是start， counter+=1 如果是end， counter-=1， 找出counter变化过程中最大值。 答案做的感觉没自己的思路简单。</p>
<h1 id="font-colorred-254-factor-combinations-mediumfont"><font color='red'> 254. Factor Combinations （Medium）</font></h1>
<p>Numbers can be regarded as the product of their factors.</p>
<pre><code>For example, 8 = 2 x 2 x 2 = 2 x 4.
</code></pre>
<p>Given an integer n, return all possible combinations of its factors. You may return the answer in any order.</p>
<p>Note that the factors should be in the range [2, n - 1].</p>
<pre><code class="language-python">#Iterative:

def getFactors(self, n):
    todo, combis = [(n, 2, [])], []
    while todo:
        n, i, combi = todo.pop()
        while i * i &lt;= n:
            if n % i == 0:
                combis += combi + [i, n/i],
                todo += (n/i, i, combi+[i]),
            i += 1
    return combis

#Recursive:

class Solution:
    def getFactors(self, n: int) -&gt; List[List[int]]:
        
        res=[]
        def factor(n, i, tmp):
            while i * i &lt;= n:
                if n % i == 0:
                    res.append(tmp + [i, n//i])
                    factor(n//i, i, tmp+[i])
                i += 1
        factor(n, 2, [])
        return res

</code></pre>
<p>思路类似，但是还是没写粗来，这个不应该， res 先append  tmp+[i,n//i],然后再factor（n//i， i，tmp+【i】，res）</p>
<h1 id="font-colorred255-verify-preorder-sequence-in-binary-search-tree-mediumfont"><font color='red'>255. Verify Preorder Sequence in Binary Search Tree （Medium）</font></h1>
<pre><code class="language-python">def verifyPreorder(self, preorder):
    stack = []
    low = float('-inf')
    for p in preorder:
        if p &lt; low:
            return False
        while stack and p &gt; stack[-1]:
            low = stack.pop()
        stack.append(p)
    return True
</code></pre>
<p>没思路，答案思路： 模拟traversal，stack是左子树的栈。 如果下一个数小于栈顶，说明还在左子树，所以append。  如果当前preorder值大于栈顶，所有小于当前值元素出栈。说明当前元素跳到了右子树。low=stack.pop() 很巧妙， lower bound是满足小于当前值的最后一个pop出去的元素。</p>
<h1 id="font-colorred256-paint-house-mediumfont"><font color='red'>256. Paint House （Medium）</font></h1>
<p>Input: costs = [[17,2,17],[16,16,5],[14,3,19]]<br>
Output: 10<br>
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>
Minimum cost: 2 + 5 + 3 = 10.</p>
<pre><code class="language-python">class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        mem=dict()
        def paint(n,color):
            if (n,color) in mem:
                return mem[(n,color)]
            res = costs[n][color]
            
            if n!=len(costs)-1:
                if color==0:
                    res+=min(paint(n+1,1),paint(n+1,2))
                elif color==1:
                    res+=min(paint(n+1,0),paint(n+1,2))
                else:
                    res+=min(paint(n+1,0),paint(n+1,1))
            mem[(n,color)]=res
            return res
       
        return min([paint(0,0),paint(0,1),paint(0,2)])

#
class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        if not costs:return 0
        for n in range(len(costs)-2,-1,-1):
            costs[n][0]+=min(costs[n+1][1],costs[n+1][2])
            costs[n][1]+=min(costs[n+1][0],costs[n+1][2])
            costs[n][2]+=min(costs[n+1][0],costs[n+1][1])
        return min(costs[0])
</code></pre>
<p>这个应该是递归mem的经典题和dp的经典题。用dynamic programming，但是写出来一版是错的。。。应该定义dp=【#costs】【#color】。从最后一个房子开始， 倒数第二个 cost红=最后一个min（绿，蓝），。。。</p>
<h1 id="257-binary-tree-paths-easy">257. Binary Tree Paths （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:
        res=[]
        def bt(tmp,node):
            if not node: return
            if not node.left and not node.right:
                tmp.append(str(node.val))
                res.append('-&gt;'.join(tmp))
                return
            tmp.append(str(node.val))
            bt(tmp[:],node.left)
            bt(tmp[:],node.right)
        bt([],root)
        return res
</code></pre>
<h1 id="258-add-digits-easy">258. Add Digits (Easy)</h1>
<pre><code class="language-python">class Solution:
    def addDigits(self, num: int) -&gt; int:
        res = 0
        while num:
            #
            tmp=0
            while num:
                lastdig = num%10
                num=num//10
                tmp+=lastdig
            num=tmp
            if num&gt;=0 and num&lt;=9:
                return num
        
        return res 
# answer way of writing
class Solution:
    def addDigits(self, num: int) -&gt; int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9
</code></pre>
<p>答案用了一个数能被九整除，那么他们所有位数和能被9整除。</p>
<h1 id="font-colorblue259-3sum-smaller-mediumfont"><font color='blue'>259. 3Sum Smaller （Medium）</font></h1>
<p>Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<pre><code class="language-python">class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            for left in range(start+1,len(nums)-1):
                right=left+1
                if nums[start]+nums[left]+nums[right]&gt;target:continue
                
                while  right&lt;len(nums) and nums[start]+nums[left]+nums[right]&lt;target:
                    res+=1
                    right+=1
                
               
        return res

#answer
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            tar = target-nums[start]
            #become two sum question
            left=start+1
            right=len(nums)-1
            while left&lt;right:
                #print('@',left,right,tar)
                if nums[left]+nums[right]&lt;tar:
                    #print(left,right)
                    res+=right-left
                    left+=1
                else:
                    right-=1
            
        return res
</code></pre>
<p>写出来个暴力解。。。 几乎是O(n^3)....  O（n^2）思路, 选出一个数字，把3sum转成2sum，然后定义left=start+1，right=len（nums）-1， 若left +right 值小于target 说明 left 到right所有都满足条件，这样left+1求解下一步， 若left +right 值大于target说明right太大得减1.</p>
<h1 id="font-colorred260-single-number-iii-mediumfont"><font color='red'>260. Single Number III （Medium）</font></h1>
<p>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.</p>
<p>You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xor=0
        for n in nums:
            xor = xor^n
        
        # rightmost 1-bit diff between a and b
        diff = xor &amp; -xor
        
        a=0
        for n in nums:
            if n&amp;diff:
                # diff means a's last bit is diff then b's last bit
                # by using this filter we could get a 
                a= a^n
        return [a,xor^a]

</code></pre>
<p>没思路， one pass 只能找出xor=a^b  但不能确定出a，b具体值。<br>
答案思路：用了一个不知道的trick， x &amp; (-x) 保留x中最右边bit，设置其他bit为0.   这样就能用a，b 的diff bit把所有数字过滤一次，只有a可以被过滤出来，因为a的diff bit是1 其余diff bit是1的都出现了2次抵消了。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[书单]]></title>
        <id>https://headhuanglan.github.io/post/shu-dan/</id>
        <link href="https://headhuanglan.github.io/post/shu-dan/">
        </link>
        <updated>2021-11-27T06:31:55.000Z</updated>
        <summary type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
]]></summary>
        <content type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
<!-- more -->
<p><a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史5</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画世界史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf">半小时漫画世界史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画科学史1 2 3全 MOBI</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画预防常见病</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-27]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-27/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-27/">
        </link>
        <updated>2021-11-27T01:05:28.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-241-different-ways-to-add-parentheses-mediumfont"><font color='red'> 241. Different Ways to Add Parentheses （Medium）</font></h1>
<p>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def diffWaysToCompute(self, expression: str) -&gt; List[int]:
        if not expression: return []
         
        exp = []
        start=0
        i=0
        while i&lt;len(expression):
            if expression[i].isdigit():
                i+=1
            else:
                exp.append(expression[start:i])
                exp.append(expression[i])
                start=i+1
                i+=1
        exp.append(expression[start:])
        
        
        #basecase
        res = []
        if len(exp)==1 and ('+' not in exp) and ('-' not in exp) and ('*' not in exp):
            res=[int(exp[0])]
        
        
        for i, op in enumerate(exp):
            if not op.isdigit():
                left = self.diffWaysToCompute(''.join(exp[:i]))
                right= self.diffWaysToCompute(''.join(exp[i+1:]))
                if op=='+':
                    for l in left:
                        for r in right:
                            res.append(l+r)
                elif op=='-':
                     for l in left:
                        for r in right:
                            res.append(l-r)
                else:
                     for l in left:
                        for r in right:
                            res.append(l*r)
                      
 
        return res

</code></pre>
<p>感觉是backtracking但写code出现了问题。。。并不是 a+(b+...)   和 (a+b)+.... 这2种情况， 而是 （left）+ （right）产生不同的组合。  思路错误导致没写出来。。写了个bug。</p>
<h1 id="242-valid-anagram-easy">242. Valid Anagram （Easy）</h1>
<pre><code class="language-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        return collections.Counter(s)==collections.Counter(t)
</code></pre>
<p>答案用了26个字符的数组存储出现次数，s出现+1，t出现-1. 这样相等时候所有位置都应该是0.</p>
<h1 id="243-shortest-word-distance-easy">243. Shortest Word Distance (Easy)</h1>
<pre><code class="language-python">class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        visited = dict()
        res=float('inf')
        for i,w in enumerate(wordsDict):
            if w==word1 and word2 in visited:
                res=min(res,i-visited[word2])
            if w==word2 and word1 in visited:
                res=min(res,i-visited[word1])
            visited[w]=i
        return res

</code></pre>
<h1 id="244-shortest-word-distance-ii-medium">244. Shortest Word Distance II (Medium)</h1>
<pre><code class="language-python">class WordDistance:

    def __init__(self, wordsDict: List[str]):
        self.dic = collections.defaultdict(list)
        for i,w in enumerate(wordsDict):
            self.dic[w].append(i)
        

    def shortest(self, word1: str, word2: str) -&gt; int:
        res=float('inf')
        for pos1 in self.dic[word1]:
            for pos2 in self.dic[word2]:
                res=min(res,abs(pos2-pos1))
        return res
</code></pre>
<h1 id="245-shortest-word-distance-iii-medium">245. Shortest Word Distance III (Medium)</h1>
<pre><code class="language-python">class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        dic=dict()
        res = float('inf')
        for i, w in enumerate(wordsDict):
            if w==word1 and word2 in dic:
                res=min(res,i-dic[word2])
            if w==word2 and word1 in dic:
                res=min(res,i-dic[word1])
            
            dic[w]=i
        return res

</code></pre>
<h1 id="246-strobogrammatic-number-easy">246. Strobogrammatic Number (Easy)</h1>
<pre><code class="language-python">class Solution:
    def isStrobogrammatic(self, num: str) -&gt; bool:
        # 1 6 9 8 0
        if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
            return False
        dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
        num2= ''.join([dic[e] for e in num][::-1])
        return num==num2

</code></pre>
<h1 id="font-colorred247-strobogrammatic-number-ii-medium-font"><font color='red'>247. Strobogrammatic Number II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        if n==1: return [&quot;0&quot;,&quot;1&quot;,&quot;8&quot;]
        nums=['0','1','6','8','9']
        
        def isStrobogrammatic(num: str) -&gt; bool:
            if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
                return False
            dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
            num2= ''.join([dic[e] for e in num][::-1])
            return num==num2
        
        res = []
        def bt(tmp):
            if len(tmp)==n:
                sb = ''.join(tmp[:])
                if isStrobogrammatic(sb) and sb[0]!='0':
                    res.append(sb)
                return 
            for cur in nums:
                tmp.append(cur)
                bt(tmp)
                tmp.pop()
        
        bt([])
        return res
#answer way of writting
class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        evenMidCandidate = [&quot;11&quot;,&quot;69&quot;,&quot;88&quot;,&quot;96&quot;, &quot;00&quot;]
        oddMidCandidate = [&quot;0&quot;, &quot;1&quot;, &quot;8&quot;]
        if n == 1:
            return oddMidCandidate
        if n == 2:
            return evenMidCandidate[:-1]
        if n % 2:
            pre, midCandidate = self.findStrobogrammatic(n-1), oddMidCandidate
        else: 
            pre, midCandidate = self.findStrobogrammatic(n-2), evenMidCandidate
        premid = (n-1)//2
        return [p[:premid] + c + p[premid:] for c in midCandidate for p in pre]
</code></pre>
<p>初次尝试， time limit exceeded。。。 backtracking属于暴力求解。 答案思路：<br>
n == 1: [0, 1, 8]<br>
n == 2: [11, 88, 69, 96]<br>
How about n == 3?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 2<br>
n == 4?<br>
=&gt; it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 2<br>
n == 5?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 4<br>
the same, for n == 6, it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 4</p>
<h1 id="font-colorred248-strobogrammatic-number-iii-hard-font"><font color='red'>248. Strobogrammatic Number III （Hard） </font></h1>
<pre><code class="language-python">class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -&gt; int:
        
        
        dic = {'0': '0','1': '1','6': '9','8': '8','9': '6'}    
        count=[0] # count as list can be modifed without return 
        
        
        
        def dfs(low,high,c,left,right,count):
            if left&gt;right:
                s=''.join(c)
                if (len(s)==len(low) and s&lt;low) or (len(s)==len(high) and s&gt;high):
                    return 
                count[0]+=1
                return
            for k,v in dic.items():
                c[left]=k
                c[right]=v
                if len(c)!=1 and c[0]=='0':
                    continue
                if left==right and k!=v:
                    continue
                
                dfs(low,high,c,left+1,right-1,count)
        
        
        for length in range(len(low),len(high)+1):
   
            dfs(low, high, ['']*length, 0, length-1, count);
        
        return count[0]
    

</code></pre>
<p>give up, 思路 ， 构建length长度的满足条件的string，从两边向中间构建。  做dfs search。<br>
用247的办法也可以感觉。 然后过滤出low，high之间有多少个。</p>
<h1 id="249-group-shifted-strings-medium">249. Group Shifted Strings （Medium）</h1>
<p>We can shift a string by shifting each of its letters to its successive letter.</p>
<pre><code>For example, &quot;abc&quot; can be shifted to be &quot;bcd&quot;.
</code></pre>
<p>We can keep shifting the string to form a sequence.</p>
<pre><code>For example, we can keep shifting &quot;abc&quot; to form the sequence: &quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;.
</code></pre>
<p>Given an array of strings strings, group all strings[i] that belong to the same shifting sequence. You may return the answer in any order.</p>
<pre><code class="language-python">
class Solution:
    def groupStrings(self, strings: List[str]) -&gt; List[List[str]]:
        dic = collections.defaultdict(list)
        for s in strings:
            if len(s)==1:
                dic['NULL'].append(s)
            else:
                key=[]
                for i in range(1,len(s)):
                    tmp = str((ord(s[i])-ord(s[i-1]))%26)
                    key.append(tmp)
                key='-'.join(key)
                dic[key].append(s)
        return dic.values()
</code></pre>
<h1 id="250-count-univalue-subtrees-medium">250. Count Univalue Subtrees (Medium)</h1>
<p>Given the root of a binary tree, return the number of uni-value subtrees.<br>
A uni-value subtree means all nodes of the subtree have the same value.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&gt; int:
        
        count = [0]
        
        def isUnivalSubtrees(root):
            if not root:
                return False
            if not root.left and not root.right:
                count[0]+=1
                return True
            if not root.left:
                res = isUnivalSubtrees(root.right) and root.val==root.right.val
                if res:
                    count[0]+=1
                return res
            if not root.right:
                res= isUnivalSubtrees(root.left) and root.val==root.left.val
                if res:
                    count[0]+=1
                return res
            
            left = isUnivalSubtrees(root.left)
            right= isUnivalSubtrees(root.right)
            res=left and right and root.val==root.left.val and root.val==root.right.val
            if res:
                count[0]+=1
            return res
        
        isUnivalSubtrees(root)
        return count[0]

</code></pre>
<p>从上个题目获得的trick这个题目马上用到， count作为list，边run边更新不影响helper function的bool返回值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-26]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-26/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-26/">
        </link>
        <updated>2021-11-26T01:39:32.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="231-power-of-two-easy">231. Power of Two (Easy)</h1>
<p>Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;0: return False
        c=0
        while n:
            lastbit= n%2
            if lastbit==1:
                c+=1
            n=n&gt;&gt;1
        return c==1

#answer is great
class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;=0: return False
        # 1 000 000 000
        #    111 111 111
        return n&amp;(n-1)==0

</code></pre>
<h1 id="232-implement-queue-using-stacks-easy">232. Implement Queue using Stacks (Easy)</h1>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        

    def push(self, x: int) -&gt; None:
        self.s1.append(x)

    def pop(self) -&gt; int:
        # 1 2 3
        # 3 2 1
        while self.s1:
            self.s2.append(self.s1.pop())
        val=self.s2.pop()
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -&gt; int:
        pre=None
        while self.s1:
            cur=self.s1.pop()
            self.s2.append(cur)
            pre=cur
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return pre
        

    def empty(self) -&gt; bool:
        return len(self.s1)==0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</code></pre>
<p>Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?</p>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        self.front=None

    def push(self, x: int) -&gt; None:
        if self.s1==[]:
            self.front=x
        self.s1.append(x)

    def pop(self) -&gt; int:
        if self.s2==[]:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&gt; int:
        if self.s2:
            return self.s2[-1]
        
        return self.front
          
        
    def empty(self) -&gt; bool:
        return self.s1==[] and self.s2==[]

</code></pre>
<p>follow up的思路挺有意思，push: 数字保存在s1，但是当s1为空时候，保存front。  pop：如果s2有元素，pop s2， 否则 把s1 push到s2    peek: 若s2 有元素，peek s2 否则 就是 front。</p>
<h1 id="font-colorred233-number-of-digit-one-hard-font"><font color='red'>233. Number of Digit One （Hard） </font></h1>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.<br>
Example：<br>
Input: n = 13<br>
Output: 6<br>
1，10， 11，12，13</p>
<pre><code class="language-python">class Solution:
    def countDigitOne(self, n: int) -&gt; int:
        c=0
        i=1
        while i&lt;=n:
            divider = i*10
            c += (n//divider)*i + min(max(n%divider -i+1,0),i)
            i*=10
        return c
</code></pre>
<p>完全不是考算法，对于个位来说，存在1的位置有，1，11，21，31，41，51，61，71 ... 基本10个一循环，比如 1到13的个位为1的有1，11，总共2个。 所以是 13//10 + (13%10)!=0。 对于十位来说存在1的有， 10，11，12，。。。19  |   110，111，112，113，。。。119| 210,...，每100个一循环，比如1到113的十位， (113/ 100) * 10 + min(max(113%100-10+1,0),10)   同理千位100,101,...199| 1100,1101....1199|....     千位中1的个数  (n/1000)*100 + min(max(n%1000-100+1,0),100)   具体的循环截断1的个数是在 0到 100之间， 具体多少是n%1000-100+1.</p>
<h1 id="234-palindrome-linked-list-easy">234. Palindrome Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:
        
        fast=slow=head
        
        while slow and fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        
        if fast:
            mid=slow.next
        else:
            mid=slow
            
        
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        revmid  = rev(mid)
        
        while revmid:
            if revmid.val!=head.val:
                return False
            revmid=revmid.next
            head=head.next
        return True
        #1 2 3 4 5
        #    s m
        #        f
                
        #1 2 3 4
        #    s
        #    m   f  
</code></pre>
<h1 id="font-colorred235-lowest-common-ancestor-of-a-binary-search-tree-easyfont">&lt;/font color='red'&gt;235. Lowest Common Ancestor of a Binary Search Tree （Easy）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        # 
        #    all left ,  all right,    p mid q
        #
        
        if root.val &gt; p.val and root.val &gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val &lt; p.val and root.val &lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

</code></pre>
<p>卡在了一道easy题上确实不应该。。。没仔细看题，忽略了这个是个BST，得用BST性质。</p>
<h1 id="font-colorblue-236-lowest-common-ancestor-of-a-binary-tree-medium-font"><font color='blue'> 236. Lowest Common Ancestor of a Binary Tree （Medium） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    dic=dict()
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        def find(root,node):
            if not root: return False
            if (root.val,node.val) in self.dic:
                return self.dic[(root.val,node.val)]
          
            if root.val==node.val:
                self.dic[(root.val,node.val)]=True
                return True
            if find(root.left,node):
                self.dic[(root.left.val,node.val)]=True
                return True
            if find(root.right,node):
                if root.right:
                    self.dic[(root.right.val,node.val)]=True
                return True
            return False
        
        if find(root.left,p) and find(root.left,q):
            return self.lowestCommonAncestor(root.left,p,q)
        elif find(root.right,p) and find(root.right,q):
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
#answer way of writting
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        if root in [p,q,None]: return root
        
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        
        
        if left and right: 
            return root
        if left: 
            return left
        if right:
            return right
</code></pre>
<p>第一次尝试Time limit exceeded...，得找到p，q是在root的同侧还是异侧。 由于是递归调用，find funciton call了太多次，所以用memerization 方法， pass了。答案思路： 如果root 是{p,q,None} 就返回root， left=从root.left找p，q共同祖先， right=从root.right 找p，q共同祖先。</p>
<h1 id="237-delete-node-in-a-linked-list-easy">237. Delete Node in a Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        
      if node.next:
            node.val=node.next.val
            node.next=node.next.next
</code></pre>
<p>把下一位数字覆盖到当前node， 然后跳过这个node。</p>
<h1 id="238-product-of-array-except-self-medium">238. Product of Array Except Self （Medium）</h1>
<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>
<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>
<pre><code class="language-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        
        prefix_left = [1]*len(nums)
        prefix_right= [1]*len(nums)
        
        for i in range(1,len(nums)):
            prefix_left[i] = prefix_left[i-1]*nums[i-1]
        for j in range(len(nums)-2,-1,-1):
            prefix_right[j] = prefix_right[j+1]*nums[j+1]
        res = []    
        for (l,r) in zip(prefix_left,prefix_right):
            res.append(l*r)
        return res

</code></pre>
<h1 id="font-colorred239-sliding-window-maximum-hard-font"><font color='red'>239. Sliding Window Maximum (Hard) </font></h1>
<p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<pre><code class="language-python">
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        
        #if k==1: return nums
        
        stack_max = []
        queue = []
        res = []
        for n in nums:
            queue.append(n)
            
            
            while stack_max and n&gt;stack_max[-1]:
                stack_max.pop()
            if not stack_max or  n&gt;stack_max[-1]:
                stack_max.append(n)
            
            if len(queue)&gt;k:
                expired = queue.pop(0)
                if expired == stack_max[-1]:
                    stack_max.pop()
            
            if len(queue)==k:
                #print(queue,stack_max)
                if stack_max:
                    res.append(stack_max[-1])
                else:
                    #the expired one is the max and poped out
                    newmax=max(queue)
                    res.append(newmax)
                    stack_max.append(newmax)
            
        return res
#answer way of writting
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &quot;&quot;&quot;
        
        
        queue = collections.deque()
        res = []
        for i, n in enumerate(nums):
            while queue and n&gt; nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            #expire
            if queue[0] == i - k:
                queue.popleft()
            #can add to result
            if i &gt;= k - 1:
                res.append(nums[queue[0]])
        return res
    
#         if not nums:
#             return []
#         start=0
#         r=[]
#         while start+k&lt;=len(nums):
#             r.append(max(nums[start:start+k]))
#             start+=1
            
#         return r
</code></pre>
<p>初次尝试， time limit exceeded。  思路是一致的， 如果过期，踢掉， queue中保存最大值位置。</p>
<h1 id="font-colorblue240-search-a-2d-matrix-ii-mediumfont"><font color='blue'>240. Search a 2D Matrix II （Medium）</font></h1>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        
        
        def search(rowl,rowr,coll,colr,target):
            if rowl==rowr and coll==colr:
                return matrix[rowl][coll]==target
            elif rowl==rowr:
                return target in matrix[rowl]
            elif coll==colr:
                return target in [row[coll] for row in matrix]
            
            if  rowr-rowl==1 and colr-coll==1:    
                if matrix[rowl][coll]==target or matrix[rowr][colr]==target or matrix[rowr][coll]==target or matrix[rowl][colr]==target:
                    return True
                return False
            
            
            rowmid = (rowl+rowr)//2
            colmid = (coll+colr)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif target&lt;matrix[rowmid][colmid]:
                return search(rowl,rowmid,coll,colmid,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            else:
                return search(rowmid,rowr,colmid,colr,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            
        
        return search(0,len(matrix)-1,0,len(matrix[0])-1,target)
</code></pre>
<p>用了分治法，虽然写出来了，但感觉写了陀X。 答案分治法</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target`
        if not matrix:
            return False

        def search_rec(left, up, right, down):
            # this submatrix has no height or no width.
            if left &gt; right or up &gt; down:
                return False
            # `target` is already larger than the largest element or smaller
            # than the smallest element in this submatrix.
            elif target &lt; matrix[up][left] or target &gt; matrix[down][right]:
                return False

            mid = left + (right-left) // 2

            # Locate `row` such that matrix[row-1][mid] &lt; target &lt; matrix[row][mid]
            row = up
            while row &lt;= down and matrix[row][mid] &lt;= target:
                if matrix[row][mid] == target:
                    return True
                row += 1
            
            return search_rec(left, row, mid - 1, down) or \
                   search_rec(mid + 1, up, right, row - 1)

        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)
</code></pre>
<p>最佳答案 思路 ： 从左下角开始，如果target大于cur, 列+1， 如果targe 小于cur，行-1.</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target` (make this check
        # because we want to cache `width` for efficiency's sake)
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        # cache these, as they won't change.
        height = len(matrix)
        width = len(matrix[0])

        # start our &quot;pointer&quot; in the bottom-left
        row = height - 1
        col = 0

        while col &lt; width and row &gt;= 0:
            if matrix[row][col] &gt; target:
                row -= 1
            elif matrix[row][col] &lt; target:
                col += 1
            else: # found it
                return True
        
        return False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-25]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-25/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-25/">
        </link>
        <updated>2021-11-25T08:23:51.000Z</updated>
        <summary type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
<!-- more -->
<h1 id="font-colorred-221-maximal-square-mediumfont"><font color='red'> 221. Maximal Square （Medium）</font></h1>
<p>Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>
<pre><code class="language-python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        rows=len(matrix)
        cols=len(matrix[0])
        maxqlen=0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j]=='1':
                    sqlen=1
                    flag=True
                    while sqlen+i&lt;rows and sqlen+j&lt; cols and flag:
                        for k in range(j,sqlen+j+1):
                            if matrix[i+sqlen][k]=='0':
                                flag=False
                                break
                        for k in range(i,i+sqlen+1):
                            if matrix[k][j+sqlen]=='0':
                                flag=False
                                break
                        if flag:
                            sqlen+=1
                    
                    if maxqlen&lt;sqlen:
                        maxqlen=sqlen
                        
                        
        return maxqlen**2

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        # dp[i][j]  size of box which bottom right in pos[i][j]
        # if matrix[i][j]==1
        #    dp[i][j]=   min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0]*(n+1) for _ in range(m+1)]
        res=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]=='1':
                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1
                    res=max(res,dp[i][j])
        return res**2
</code></pre>
<p>试着用cumsum去解但失败了， 方法1，暴力解。 每次发现是“1”就以它作为正方形左上角起始点， 检查 row: i，i+sqlen col: j, j+sqlen 是否有‘0’.<br>
方法2：dp： dp【i】【j】保存右下角位置在i，j的盒子大小。</p>
<h1 id="font-colorred-222-count-complete-tree-nodes-mediumfont"><font color='red'> 222. Count Complete Tree Nodes （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if not root.right:
            return 1+ self.countNodes(root.left)
        else:
            return  self.countNodes(root.left)+self.countNodes(root.right)+1


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        
        def depth(node):
            d=0
            while node.left:
                node=node.left
                d+=1
            return d
        
        def exists(idx,d,node):
            left=0
            right=2**d-1
            for _ in range(d):
                pivot = (left+right)//2
                if idx&lt;=pivot:
                    node=node.left
                    right=pivot
                else:
                    node=node.right
                    left=pivot +1
            return node is not None
        
        if not root: return 0
        d = depth(root)
        if d==0: return 1
        
        l=1
        r=2**d-1
        while l&lt;=r:
            mid = (l+r)//2
            if exists(mid,d,root):
                l=mid+1
            else:
                r=mid-1
        
        return (2**d-1) +l 
        
</code></pre>
<p>给出了个O（n）解法，但题目要求小于O(n)...<br>
思路： 完全二叉树，第0层2<sup>0个node，第一层，2</sup>1个node，第n层2^n个node，所以假设这个树深度为d=n， 不包含最后一层2<sup>0+2</sup>1+..+2<sup>(n-1)=2</sup>n  -  1 的所有node总和为2^d-1 ,问题转化成求最后一层有多少node。 范围在1~2^n.  因为d=n所以肯定有第一个node。  可以用binary search 求。</p>
<h1 id="223-rectangle-area-medium">223. Rectangle Area （Medium）</h1>
<pre><code class="language-python">class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&gt; int:
        
        # intersect of 1d line
        
        def intersect(a1,a2,b1,b2):
            if a1&gt;b1:
                a1,a2,b1,b2=b1,b2,a1,a2
            
            #print(a1,a2,b1,b2)
            #case 1  --
            #            --
            if a2&lt;b1:
                return 0
            
            #case 2   a1---a2
            #            b1---b2
            if b1&lt;=a2 and a2&lt;=b2:
                return a2-b1
            # case 3  a1------a2
            #            b1-b2
            if b1&lt;a2 and b2&lt;a2:
                return b2-b1
            
            return 'ERROR'
        
        width = intersect(ax1,ax2,bx1,bx2)
        height = intersect(by1,by2,ay1,ay2)
        print(width,height)
        return (ay2-ay1)*(ax2-ax1)+ (by2-by1)*(bx2-bx1)    -width*height

</code></pre>
<h1 id="font-colorred224-basic-calculator-hard-font"><font color='red'>224. Basic Calculator (Hard) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #1+1
        #1 1 +  
        #2-1+3
        #2 1 - 3 + 
        #(1+(4+5+2)-3)+(6-8)
        
        s='('+s+')'
        s_res=[]
        s_char=[]
        i=0
        while i&lt;len(s):
            e=s[i]
            if e==' ':
                i+=1
                continue
            elif e==')':
                while s_char[-1]!='(':
                    op=s_char.pop()
                    s_res.append(op)
                if s_char and s_char[-1]=='(':
                    s_char.pop()
            elif e in '(':
                s_char.append(e)
                    
            elif e in '+-':
                if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    s_res.append(0)
                    
                while s_char[-1] in '+-':
                    s_res.append(s_char.pop())
                s_char.append(e)
            else:
                #e is num
                tmp=int(e)
                while i+1&lt;len(s) and s[i+1] in '0123456789':
                    tmp = tmp*10+ int(s[i+1])
                    i+=1
                s_res.append(tmp)
            
                
            i+=1
        
                
        
        print(s_res)
        if '+' not in s_res and '-' not in s_res:
            return int(''.join(map(str,s_res)))
        
        res = []
        for e in s_res:
            if e=='+' or e=='-':
                b = res.pop() if res else None
                a = res.pop() if res else None
                
                
                if a is None:
                    if e=='+':
                        res.append(b)
                    else:
                        res.append(-b)
                
                else:    
                    if e=='+':
                        res.append(a+b) 
                    else:
                        res.append(a-b)
            else:
                res.append(e)
        #print(res)
        return res[0]

#通解
class Solution:
    def calculate(self, s: str) -&gt; int:
        
        # 转换为 后缀表达式
        # 运算符优先级
        prec = {}
        prec[&quot;*&quot;] = 3
        prec[&quot;/&quot;] = 3
        prec[&quot;+&quot;] = 2
        prec[&quot;-&quot;] = 2
        prec[&quot;(&quot;] = 1

        res = []
        stack = []
        i = 0
        while i &lt; len(s):
            # 数字 直接 接到后缀表达式上
            if s[i] == &quot; &quot;:
                i += 1
                
            elif s[i].isdigit():
                temp = &quot;&quot;
                while i &lt; len(s) and s[i].isdigit():
                    temp += s[i]
                    i += 1
                res.append(temp)

            # 左括号直接入栈
            elif s[i] == &quot;(&quot;:
                stack.append(s[i])
                i += 1

            # 右括号，开始弹栈，直达遇到左括号 左括号出栈 但不输出
            elif s[i] == &quot;)&quot;:
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() # 左括号出战， 但是不输出
                i += 1

            # 遇到运算符
            elif s[i] in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #  对 &quot;-2 + 2&quot; 或者 &quot;1-(-2)&quot; 进行特殊处理
                if s[i] == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    res.append('0')
                # 只要栈顶符号不低于当前符号，就一直输出。最后把当前符号入栈
                while stack and prec[s[i]]&lt;=prec[stack[-1]]:
                    res.append(stack.pop())
                stack.append(s[i])
                i += 1
        
        # 最后把栈里面的元素均 放到后缀表达式后面
        while stack:
            res.append(stack.pop())


        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char.isdigit():
                stack.append(int(char))
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(x/y)

        return stack.pop()
</code></pre>
<p>&quot; 2-1 + 2 &quot; 直接用stack解出现-1时候符号和1是合体的，所以换思路把表达式变成前缀/后坠表达。 又遇到后缀表达如何去括号问题。<br>
1 + (( 2 + 3)* 4 ) – 5   方法：  当读到数时，立即输出， 若读到操作符，判断符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就依次把栈中运算符弹出并加到后缀表达式尾端，但又遇到 &quot;1-(-2)&quot; 无法pass。 同理 &quot;- (3 - (- (4 + 5) ) )&quot; 无法pass。 负号不作为减法，作为符号。 需要特殊处理： 方法：</p>
<pre><code class="language-python">if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
    s_res.append(0)
</code></pre>
<p>答案很简单，问题根源在-号不能互相换 比如(A-B)+C != A-(B+C) , 所以把-看作数字的符号。</p>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:

        stack = []
        operand = 0
        res = 0 # For the on-going result
        sign = 1 # 1 means positive, -1 means negative  

        for ch in s:
            if ch.isdigit():
                # Forming operand, since it could be more than one digit
                operand = (operand * 10) + int(ch)

            elif ch == '+':
                # Evaluate the expression to the left,
                # with result, sign, operand
                res += sign * operand

                # Save the recently encountered '+' sign
                sign = 1
                # Reset operand
                operand = 0

            elif ch == '-':

                res += sign * operand
                sign = -1
                operand = 0

            elif ch == '(':

                # Push the result and sign on to the stack, for later
                # We push the result first, then sign
                stack.append(res)
                stack.append(sign)

                # Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1
                res = 0

            elif ch == ')':

                # Evaluate the expression to the left
                # with result, sign and operand
                res += sign * operand

                # ')' marks end of expression within a set of parenthesis
                # Its result is multiplied with sign on top of stack
                # as stack.pop() is the sign before the parenthesis
                res *= stack.pop() # stack pop 1, sign

                # Then add to the next operand on the top.
                # as stack.pop() is the result calculated before this parenthesis
                # (operand on stack) + (sign on stack * (result from parenthesis))
                res += stack.pop() # stack pop 2, operand

                # Reset the operand
                operand = 0

        return res + sign * operand

</code></pre>
<h1 id="font-colorblue225-implement-stack-using-queues-easy-font"><font color='blue'>225. Implement Stack using Queues (Easy) </font></h1>
<pre><code class="language-python">class MyStack(object):
    def __init__(self):
        self._queue = collections.deque()

    def push(self, x):
        q = self._queue
        q.append(x)
        for _ in range(len(q) - 1):
            q.append(q.popleft())
 
    def pop(self):
        return self._queue.popleft()

    def top(self):
        return self._queue[0]
    
    def empty(self):
        return not len(self._queue)

</code></pre>
<p>三种方法</p>
<h1 id="226-invert-binary-tree-easy">226. Invert Binary Tree （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
        if not root: return root
        root.left,root.right = root.right,root.left
        root.left = self.invertTree(root.left)
        root.right=self.invertTree(root.right)
        return root

</code></pre>
<h1 id="font-colorblue227-basic-calculator-ii-medium-font"><font color='blue'>227. Basic Calculator II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #convert to 后缀表达
        priority = {'+':1,'-':1,'*':2,'/':2,'(':0}
        res = [] #保存后缀表达式
        stack=[] #保存符号
        i=0
        while i&lt;len(s):
            ch=s[i]
            if ch.isdigit():
                tmp=ch
                while i+1&lt;len(s) and s[i+1].isdigit():
                    tmp+=s[i+1]
                    i+=1
                res.append(int(tmp))
            
            elif ch=='(':
                stack.append(ch)
            elif ch==')':
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() 
            elif ch in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                
                while stack and priority[ch] &lt;= priority[stack[-1]]:
                    res.append(stack.pop())

                stack.append(ch)
            
            i+=1
                
        while stack:
            res.append(stack.pop())
        
        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char not in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #char is number
                stack.append(char)
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(y//x)

        return stack.pop()

</code></pre>
<p>直接上通杀法。转成后缀表达然后求结果。</p>
<h1 id="font-colorblue-228-summary-ranges-easy-font"><font color='blue'> 228. Summary Ranges （Easy） </font></h1>
<pre><code class="language-python">class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        # [0]
        # [0,1]
        # [0,2]
        # [0-2,4]
        # [0-2,4,5]
        
        res = []
        stack=[]
        for n in nums:
            if not stack:
                stack.append(n)
            elif len(stack)==1:
                if n==stack[-1]+1:
                    stack.append(n)
                else:
                    res.append(str(stack[-1]))
                    stack=[n]
            else:
                if n==stack[-1]+1:
                    stack[-1]=n
                else:
                    res.append(str(stack[0])+'-&gt;'+str(stack[1]))
                    stack=[n]
 
        if len(stack)==1:
            res.append(str(stack[0]))
        elif len(stack)==2:
            res.append(str(stack[0])+'-&gt;'+str(stack[1]))
        
        return res
#answer way of writting
class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        res = []
        i=0
        for j in range(len(nums)):
            if j+1&lt;len(nums) and nums[j+1]==nums[j]+1:
                continue
            if i==j:
                res.append(str(nums[i]))
            else:
                res.append(str(nums[i])+'-&gt;'+str(nums[j]))
            i=j+1
        return res

</code></pre>
<p>答案更简单</p>
<h1 id="font-colorred229-majority-element-ii-medium-font"><font color='red'>229. Majority Element II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; List[int]:
        
        maj1=nums[0]
        maj2=nums[0]
        c1=0
        c2=0

        for n in nums:
            if n==maj1:
                c1+=1
            elif n==maj2:
                c2+=1
            elif c1==0:
                c1=1
                maj1=n
            elif c2==0:
                c2=1
                maj2=n
            else:
                c1-=1
                c2-=1
        #recalce make sure        
        c1=c2=0
        for n in nums:
            if n==maj1:c1+=1
            if n==maj2:c2+=1
        res=[]
        if c1&gt;len(nums)//3:
            res.append(maj1)
        if c2&gt;len(nums)//3 and maj1!=maj2:
            res.append(maj2)
        return res


</code></pre>
<p>经典算法，在做majorelement 1时候写过，需要记住。</p>
<h1 id="230-kth-smallest-element-in-a-bst-medium">230. Kth Smallest Element in a BST （Medium）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:
        ind=0
        stack=[]
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            ind+=1
            if ind==k:
                return node.val
            
            root=node.right
</code></pre>
]]></content>
    </entry>
</feed>