<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2021-12-19T22:11:59.686Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[书单]]></title>
        <id>https://headhuanglan.github.io/post/shu-dan/</id>
        <link href="https://headhuanglan.github.io/post/shu-dan/">
        </link>
        <updated>2021-11-27T06:31:55.000Z</updated>
        <summary type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
]]></summary>
        <content type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
<!-- more -->
<p><a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史5</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画世界史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf">半小时漫画世界史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画科学史1 2 3全 MOBI</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画预防常见病</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-27]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-27/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-27/">
        </link>
        <updated>2021-11-27T03:05:28.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-241-different-ways-to-add-parentheses-mediumfont"><font color='red'> 241. Different Ways to Add Parentheses （Medium）</font></h1>
<p>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def diffWaysToCompute(self, expression: str) -&gt; List[int]:
        if not expression: return []
         
        exp = []
        start=0
        i=0
        while i&lt;len(expression):
            if expression[i].isdigit():
                i+=1
            else:
                exp.append(expression[start:i])
                exp.append(expression[i])
                start=i+1
                i+=1
        exp.append(expression[start:])
        
        
        #basecase
        res = []
        if len(exp)==1 and ('+' not in exp) and ('-' not in exp) and ('*' not in exp):
            res=[int(exp[0])]
        
        
        for i, op in enumerate(exp):
            if not op.isdigit():
                left = self.diffWaysToCompute(''.join(exp[:i]))
                right= self.diffWaysToCompute(''.join(exp[i+1:]))
                if op=='+':
                    for l in left:
                        for r in right:
                            res.append(l+r)
                elif op=='-':
                     for l in left:
                        for r in right:
                            res.append(l-r)
                else:
                     for l in left:
                        for r in right:
                            res.append(l*r)
                      
 
        return res

</code></pre>
<p>感觉是backtracking但写code出现了问题。。。并不是 a+(b+...)   和 (a+b)+.... 这2种情况， 而是 （left）+ （right）产生不同的组合。  思路错误导致没写出来。。写了个bug。</p>
<h1 id="242-valid-anagram-easy">242. Valid Anagram （Easy）</h1>
<pre><code class="language-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        return collections.Counter(s)==collections.Counter(t)
</code></pre>
<p>答案用了26个字符的数组存储出现次数，s出现+1，t出现-1. 这样相等时候所有位置都应该是0.</p>
<h1 id="243-shortest-word-distance-easy">243. Shortest Word Distance (Easy)</h1>
<pre><code class="language-python">class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        visited = dict()
        res=float('inf')
        for i,w in enumerate(wordsDict):
            if w==word1 and word2 in visited:
                res=min(res,i-visited[word2])
            if w==word2 and word1 in visited:
                res=min(res,i-visited[word1])
            visited[w]=i
        return res

</code></pre>
<h1 id="244-shortest-word-distance-ii-medium">244. Shortest Word Distance II (Medium)</h1>
<pre><code class="language-python">class WordDistance:

    def __init__(self, wordsDict: List[str]):
        self.dic = collections.defaultdict(list)
        for i,w in enumerate(wordsDict):
            self.dic[w].append(i)
        

    def shortest(self, word1: str, word2: str) -&gt; int:
        res=float('inf')
        for pos1 in self.dic[word1]:
            for pos2 in self.dic[word2]:
                res=min(res,abs(pos2-pos1))
        return res
</code></pre>
<h1 id="245-shortest-word-distance-iii-medium">245. Shortest Word Distance III (Medium)</h1>
<pre><code class="language-python">class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        dic=dict()
        res = float('inf')
        for i, w in enumerate(wordsDict):
            if w==word1 and word2 in dic:
                res=min(res,i-dic[word2])
            if w==word2 and word1 in dic:
                res=min(res,i-dic[word1])
            
            dic[w]=i
        return res

</code></pre>
<h1 id="246-strobogrammatic-number-easy">246. Strobogrammatic Number (Easy)</h1>
<pre><code class="language-python">class Solution:
    def isStrobogrammatic(self, num: str) -&gt; bool:
        # 1 6 9 8 0
        if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
            return False
        dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
        num2= ''.join([dic[e] for e in num][::-1])
        return num==num2

</code></pre>
<h1 id="font-colorred247-strobogrammatic-number-ii-medium-font"><font color='red'>247. Strobogrammatic Number II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        if n==1: return [&quot;0&quot;,&quot;1&quot;,&quot;8&quot;]
        nums=['0','1','6','8','9']
        
        def isStrobogrammatic(num: str) -&gt; bool:
            if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
                return False
            dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
            num2= ''.join([dic[e] for e in num][::-1])
            return num==num2
        
        res = []
        def bt(tmp):
            if len(tmp)==n:
                sb = ''.join(tmp[:])
                if isStrobogrammatic(sb) and sb[0]!='0':
                    res.append(sb)
                return 
            for cur in nums:
                tmp.append(cur)
                bt(tmp)
                tmp.pop()
        
        bt([])
        return res
#answer way of writting
class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        evenMidCandidate = [&quot;11&quot;,&quot;69&quot;,&quot;88&quot;,&quot;96&quot;, &quot;00&quot;]
        oddMidCandidate = [&quot;0&quot;, &quot;1&quot;, &quot;8&quot;]
        if n == 1:
            return oddMidCandidate
        if n == 2:
            return evenMidCandidate[:-1]
        if n % 2:
            pre, midCandidate = self.findStrobogrammatic(n-1), oddMidCandidate
        else: 
            pre, midCandidate = self.findStrobogrammatic(n-2), evenMidCandidate
        premid = (n-1)//2
        return [p[:premid] + c + p[premid:] for c in midCandidate for p in pre]
</code></pre>
<p>初次尝试， time limit exceeded。。。 backtracking属于暴力求解。 答案思路：<br>
n == 1: [0, 1, 8]<br>
n == 2: [11, 88, 69, 96]<br>
How about n == 3?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 2<br>
n == 4?<br>
=&gt; it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 2<br>
n == 5?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 4<br>
the same, for n == 6, it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 4</p>
<h1 id="font-colorred248-strobogrammatic-number-iii-hard-font"><font color='red'>248. Strobogrammatic Number III （Hard） </font></h1>
<pre><code class="language-python">class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -&gt; int:
        
        
        dic = {'0': '0','1': '1','6': '9','8': '8','9': '6'}    
        count=[0] # count as list can be modifed without return 
        
        
        
        def dfs(low,high,c,left,right,count):
            if left&gt;right:
                s=''.join(c)
                if (len(s)==len(low) and s&lt;low) or (len(s)==len(high) and s&gt;high):
                    return 
                count[0]+=1
                return
            for k,v in dic.items():
                c[left]=k
                c[right]=v
                if len(c)!=1 and c[0]=='0':
                    continue
                if left==right and k!=v:
                    continue
                
                dfs(low,high,c,left+1,right-1,count)
        
        
        for length in range(len(low),len(high)+1):
   
            dfs(low, high, ['']*length, 0, length-1, count);
        
        return count[0]
    

</code></pre>
<p>give up, 思路 ， 构建length长度的满足条件的string，从两边向中间构建。  做dfs search。<br>
用247的办法也可以感觉。 然后过滤出low，high之间有多少个。</p>
<h1 id="249-group-shifted-strings-medium">249. Group Shifted Strings （Medium）</h1>
<p>We can shift a string by shifting each of its letters to its successive letter.</p>
<pre><code>For example, &quot;abc&quot; can be shifted to be &quot;bcd&quot;.
</code></pre>
<p>We can keep shifting the string to form a sequence.</p>
<pre><code>For example, we can keep shifting &quot;abc&quot; to form the sequence: &quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;.
</code></pre>
<p>Given an array of strings strings, group all strings[i] that belong to the same shifting sequence. You may return the answer in any order.</p>
<pre><code class="language-python">
class Solution:
    def groupStrings(self, strings: List[str]) -&gt; List[List[str]]:
        dic = collections.defaultdict(list)
        for s in strings:
            if len(s)==1:
                dic['NULL'].append(s)
            else:
                key=[]
                for i in range(1,len(s)):
                    tmp = str((ord(s[i])-ord(s[i-1]))%26)
                    key.append(tmp)
                key='-'.join(key)
                dic[key].append(s)
        return dic.values()
</code></pre>
<h1 id="250-count-univalue-subtrees-medium">250. Count Univalue Subtrees (Medium)</h1>
<p>Given the root of a binary tree, return the number of uni-value subtrees.<br>
A uni-value subtree means all nodes of the subtree have the same value.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&gt; int:
        
        count = [0]
        
        def isUnivalSubtrees(root):
            if not root:
                return False
            if not root.left and not root.right:
                count[0]+=1
                return True
            if not root.left:
                res = isUnivalSubtrees(root.right) and root.val==root.right.val
                if res:
                    count[0]+=1
                return res
            if not root.right:
                res= isUnivalSubtrees(root.left) and root.val==root.left.val
                if res:
                    count[0]+=1
                return res
            
            left = isUnivalSubtrees(root.left)
            right= isUnivalSubtrees(root.right)
            res=left and right and root.val==root.left.val and root.val==root.right.val
            if res:
                count[0]+=1
            return res
        
        isUnivalSubtrees(root)
        return count[0]

</code></pre>
<p>从上个题目获得的trick这个题目马上用到， count作为list，边run边更新不影响helper function的bool返回值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-26]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-26/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-26/">
        </link>
        <updated>2021-11-26T14:39:32.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="231-power-of-two-easy">231. Power of Two (Easy)</h1>
<p>Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;0: return False
        c=0
        while n:
            lastbit= n%2
            if lastbit==1:
                c+=1
            n=n&gt;&gt;1
        return c==1

#answer is great
class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;=0: return False
        # 1 000 000 000
        #    111 111 111
        return n&amp;(n-1)==0

</code></pre>
<h1 id="232-implement-queue-using-stacks-easy">232. Implement Queue using Stacks (Easy)</h1>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        

    def push(self, x: int) -&gt; None:
        self.s1.append(x)

    def pop(self) -&gt; int:
        # 1 2 3
        # 3 2 1
        while self.s1:
            self.s2.append(self.s1.pop())
        val=self.s2.pop()
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -&gt; int:
        pre=None
        while self.s1:
            cur=self.s1.pop()
            self.s2.append(cur)
            pre=cur
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return pre
        

    def empty(self) -&gt; bool:
        return len(self.s1)==0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</code></pre>
<p>Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?</p>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        self.front=None

    def push(self, x: int) -&gt; None:
        if self.s1==[]:
            self.front=x
        self.s1.append(x)

    def pop(self) -&gt; int:
        if self.s2==[]:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&gt; int:
        if self.s2:
            return self.s2[-1]
        
        return self.front
          
        
    def empty(self) -&gt; bool:
        return self.s1==[] and self.s2==[]

</code></pre>
<p>follow up的思路挺有意思，push: 数字保存在s1，但是当s1为空时候，保存front。  pop：如果s2有元素，pop s2， 否则 把s1 push到s2    peek: 若s2 有元素，peek s2 否则 就是 front。</p>
<h1 id="font-colorred233-number-of-digit-one-hard-font"><font color='red'>233. Number of Digit One （Hard） </font></h1>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.<br>
Example：<br>
Input: n = 13<br>
Output: 6<br>
1，10， 11，12，13</p>
<pre><code class="language-python">class Solution:
    def countDigitOne(self, n: int) -&gt; int:
        c=0
        i=1
        while i&lt;=n:
            divider = i*10
            c += (n//divider)*i + min(max(n%divider -i+1,0),i)
            i*=10
        return c
</code></pre>
<p>完全不是考算法，对于个位来说，存在1的位置有，1，11，21，31，41，51，61，71 ... 基本10个一循环，比如 1到13的个位为1的有1，11，总共2个。 所以是 13//10 + (13%10)!=0。 对于十位来说存在1的有， 10，11，12，。。。19  |   110，111，112，113，。。。119| 210,...，每100个一循环，比如1到113的十位， (113/ 100) * 10 + min(max(113%100-10+1,0),10)   同理千位100,101,...199| 1100,1101....1199|....     千位中1的个数  (n/1000)*100 + min(max(n%1000-100+1,0),100)   具体的循环截断1的个数是在 0到 100之间， 具体多少是n%1000-100+1.</p>
<h1 id="234-palindrome-linked-list-easy">234. Palindrome Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:
        
        fast=slow=head
        
        while slow and fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        
        if fast:
            mid=slow.next
        else:
            mid=slow
            
        
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        revmid  = rev(mid)
        
        while revmid:
            if revmid.val!=head.val:
                return False
            revmid=revmid.next
            head=head.next
        return True
        #1 2 3 4 5
        #    s m
        #        f
                
        #1 2 3 4
        #    s
        #    m   f  
</code></pre>
<h1 id="font-colorred235-lowest-common-ancestor-of-a-binary-search-tree-easyfont">&lt;/font color='red'&gt;235. Lowest Common Ancestor of a Binary Search Tree （Easy）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        # 
        #    all left ,  all right,    p mid q
        #
        
        if root.val &gt; p.val and root.val &gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val &lt; p.val and root.val &lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

</code></pre>
<p>卡在了一道easy题上确实不应该。。。没仔细看题，忽略了这个是个BST，得用BST性质。</p>
<h1 id="font-colorblue-236-lowest-common-ancestor-of-a-binary-tree-medium-font"><font color='blue'> 236. Lowest Common Ancestor of a Binary Tree （Medium） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    dic=dict()
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        def find(root,node):
            if not root: return False
            if (root.val,node.val) in self.dic:
                return self.dic[(root.val,node.val)]
          
            if root.val==node.val:
                self.dic[(root.val,node.val)]=True
                return True
            if find(root.left,node):
                self.dic[(root.left.val,node.val)]=True
                return True
            if find(root.right,node):
                if root.right:
                    self.dic[(root.right.val,node.val)]=True
                return True
            return False
        
        if find(root.left,p) and find(root.left,q):
            return self.lowestCommonAncestor(root.left,p,q)
        elif find(root.right,p) and find(root.right,q):
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
#answer way of writting
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        if root in [p,q,None]: return root
        
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        
        
        if left and right: 
            return root
        if left: 
            return left
        if right:
            return right
</code></pre>
<p>第一次尝试Time limit exceeded...，得找到p，q是在root的同侧还是异侧。 由于是递归调用，find funciton call了太多次，所以用memerization 方法， pass了。答案思路： 如果root 是{p,q,None} 就返回root， left=从root.left找p，q共同祖先， right=从root.right 找p，q共同祖先。</p>
<h1 id="237-delete-node-in-a-linked-list-easy">237. Delete Node in a Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        
      if node.next:
            node.val=node.next.val
            node.next=node.next.next
</code></pre>
<p>把下一位数字覆盖到当前node， 然后跳过这个node。</p>
<h1 id="238-product-of-array-except-self-medium">238. Product of Array Except Self （Medium）</h1>
<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>
<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>
<pre><code class="language-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        
        prefix_left = [1]*len(nums)
        prefix_right= [1]*len(nums)
        
        for i in range(1,len(nums)):
            prefix_left[i] = prefix_left[i-1]*nums[i-1]
        for j in range(len(nums)-2,-1,-1):
            prefix_right[j] = prefix_right[j+1]*nums[j+1]
        res = []    
        for (l,r) in zip(prefix_left,prefix_right):
            res.append(l*r)
        return res

</code></pre>
<h1 id="font-colorred239-sliding-window-maximum-hard-font"><font color='red'>239. Sliding Window Maximum (Hard) </font></h1>
<p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<pre><code class="language-python">
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        
        #if k==1: return nums
        
        stack_max = []
        queue = []
        res = []
        for n in nums:
            queue.append(n)
            
            
            while stack_max and n&gt;stack_max[-1]:
                stack_max.pop()
            if not stack_max or  n&gt;stack_max[-1]:
                stack_max.append(n)
            
            if len(queue)&gt;k:
                expired = queue.pop(0)
                if expired == stack_max[-1]:
                    stack_max.pop()
            
            if len(queue)==k:
                #print(queue,stack_max)
                if stack_max:
                    res.append(stack_max[-1])
                else:
                    #the expired one is the max and poped out
                    newmax=max(queue)
                    res.append(newmax)
                    stack_max.append(newmax)
            
        return res
#answer way of writting
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &quot;&quot;&quot;
        
        
        queue = collections.deque()
        res = []
        for i, n in enumerate(nums):
            while queue and n&gt; nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            #expire
            if queue[0] == i - k:
                queue.popleft()
            #can add to result
            if i &gt;= k - 1:
                res.append(nums[queue[0]])
        return res
    
#         if not nums:
#             return []
#         start=0
#         r=[]
#         while start+k&lt;=len(nums):
#             r.append(max(nums[start:start+k]))
#             start+=1
            
#         return r
</code></pre>
<p>初次尝试， time limit exceeded。  思路是一致的， 如果过期，踢掉， queue中保存最大值位置。</p>
<h1 id="font-colorblue240-search-a-2d-matrix-ii-mediumfont"><font color='blue'>240. Search a 2D Matrix II （Medium）</font></h1>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        
        
        def search(rowl,rowr,coll,colr,target):
            if rowl==rowr and coll==colr:
                return matrix[rowl][coll]==target
            elif rowl==rowr:
                return target in matrix[rowl]
            elif coll==colr:
                return target in [row[coll] for row in matrix]
            
            if  rowr-rowl==1 and colr-coll==1:    
                if matrix[rowl][coll]==target or matrix[rowr][colr]==target or matrix[rowr][coll]==target or matrix[rowl][colr]==target:
                    return True
                return False
            
            
            rowmid = (rowl+rowr)//2
            colmid = (coll+colr)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif target&lt;matrix[rowmid][colmid]:
                return search(rowl,rowmid,coll,colmid,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            else:
                return search(rowmid,rowr,colmid,colr,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            
        
        return search(0,len(matrix)-1,0,len(matrix[0])-1,target)
</code></pre>
<p>用了分治法，虽然写出来了，但感觉写了陀X。 答案分治法</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target`
        if not matrix:
            return False

        def search_rec(left, up, right, down):
            # this submatrix has no height or no width.
            if left &gt; right or up &gt; down:
                return False
            # `target` is already larger than the largest element or smaller
            # than the smallest element in this submatrix.
            elif target &lt; matrix[up][left] or target &gt; matrix[down][right]:
                return False

            mid = left + (right-left) // 2

            # Locate `row` such that matrix[row-1][mid] &lt; target &lt; matrix[row][mid]
            row = up
            while row &lt;= down and matrix[row][mid] &lt;= target:
                if matrix[row][mid] == target:
                    return True
                row += 1
            
            return search_rec(left, row, mid - 1, down) or \
                   search_rec(mid + 1, up, right, row - 1)

        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)
</code></pre>
<p>最佳答案 思路 ： 从左下角开始，如果target大于cur, 列+1， 如果targe 小于cur，行-1.</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target` (make this check
        # because we want to cache `width` for efficiency's sake)
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        # cache these, as they won't change.
        height = len(matrix)
        width = len(matrix[0])

        # start our &quot;pointer&quot; in the bottom-left
        row = height - 1
        col = 0

        while col &lt; width and row &gt;= 0:
            if matrix[row][col] &gt; target:
                row -= 1
            elif matrix[row][col] &lt; target:
                col += 1
            else: # found it
                return True
        
        return False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-25]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-25/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-25/">
        </link>
        <updated>2021-11-25T08:23:51.000Z</updated>
        <summary type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
<!-- more -->
<h1 id="font-colorred-221-maximal-square-mediumfont"><font color='red'> 221. Maximal Square （Medium）</font></h1>
<p>Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>
<pre><code class="language-python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        rows=len(matrix)
        cols=len(matrix[0])
        maxqlen=0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j]=='1':
                    sqlen=1
                    flag=True
                    while sqlen+i&lt;rows and sqlen+j&lt; cols and flag:
                        for k in range(j,sqlen+j+1):
                            if matrix[i+sqlen][k]=='0':
                                flag=False
                                break
                        for k in range(i,i+sqlen+1):
                            if matrix[k][j+sqlen]=='0':
                                flag=False
                                break
                        if flag:
                            sqlen+=1
                    
                    if maxqlen&lt;sqlen:
                        maxqlen=sqlen
                        
                        
        return maxqlen**2

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        # dp[i][j]  size of box which bottom right in pos[i][j]
        # if matrix[i][j]==1
        #    dp[i][j]=   min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0]*(n+1) for _ in range(m+1)]
        res=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]=='1':
                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1
                    res=max(res,dp[i][j])
        return res**2
</code></pre>
<p>试着用cumsum去解但失败了， 方法1，暴力解。 每次发现是“1”就以它作为正方形左上角起始点， 检查 row: i，i+sqlen col: j, j+sqlen 是否有‘0’.<br>
方法2：dp： dp【i】【j】保存右下角位置在i，j的盒子大小。</p>
<h1 id="font-colorred-222-count-complete-tree-nodes-mediumfont"><font color='red'> 222. Count Complete Tree Nodes （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if not root.right:
            return 1+ self.countNodes(root.left)
        else:
            return  self.countNodes(root.left)+self.countNodes(root.right)+1


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        
        def depth(node):
            d=0
            while node.left:
                node=node.left
                d+=1
            return d
        
        def exists(idx,d,node):
            left=0
            right=2**d-1
            for _ in range(d):
                pivot = (left+right)//2
                if idx&lt;=pivot:
                    node=node.left
                    right=pivot
                else:
                    node=node.right
                    left=pivot +1
            return node is not None
        
        if not root: return 0
        d = depth(root)
        if d==0: return 1
        
        l=1
        r=2**d-1
        while l&lt;=r:
            mid = (l+r)//2
            if exists(mid,d,root):
                l=mid+1
            else:
                r=mid-1
        
        return (2**d-1) +l 
        
</code></pre>
<p>给出了个O（n）解法，但题目要求小于O(n)...<br>
思路： 完全二叉树，第0层2<sup>0个node，第一层，2</sup>1个node，第n层2^n个node，所以假设这个树深度为d=n， 不包含最后一层2<sup>0+2</sup>1+..+2<sup>(n-1)=2</sup>n  -  1 的所有node总和为2^d-1 ,问题转化成求最后一层有多少node。 范围在1~2^n.  因为d=n所以肯定有第一个node。  可以用binary search 求。</p>
<h1 id="223-rectangle-area-medium">223. Rectangle Area （Medium）</h1>
<pre><code class="language-python">class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&gt; int:
        
        # intersect of 1d line
        
        def intersect(a1,a2,b1,b2):
            if a1&gt;b1:
                a1,a2,b1,b2=b1,b2,a1,a2
            
            #print(a1,a2,b1,b2)
            #case 1  --
            #            --
            if a2&lt;b1:
                return 0
            
            #case 2   a1---a2
            #            b1---b2
            if b1&lt;=a2 and a2&lt;=b2:
                return a2-b1
            # case 3  a1------a2
            #            b1-b2
            if b1&lt;a2 and b2&lt;a2:
                return b2-b1
            
            return 'ERROR'
        
        width = intersect(ax1,ax2,bx1,bx2)
        height = intersect(by1,by2,ay1,ay2)
        print(width,height)
        return (ay2-ay1)*(ax2-ax1)+ (by2-by1)*(bx2-bx1)    -width*height

</code></pre>
<h1 id="font-colorred224-basic-calculator-hard-font"><font color='red'>224. Basic Calculator (Hard) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #1+1
        #1 1 +  
        #2-1+3
        #2 1 - 3 + 
        #(1+(4+5+2)-3)+(6-8)
        
        s='('+s+')'
        s_res=[]
        s_char=[]
        i=0
        while i&lt;len(s):
            e=s[i]
            if e==' ':
                i+=1
                continue
            elif e==')':
                while s_char[-1]!='(':
                    op=s_char.pop()
                    s_res.append(op)
                if s_char and s_char[-1]=='(':
                    s_char.pop()
            elif e in '(':
                s_char.append(e)
                    
            elif e in '+-':
                if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    s_res.append(0)
                    
                while s_char[-1] in '+-':
                    s_res.append(s_char.pop())
                s_char.append(e)
            else:
                #e is num
                tmp=int(e)
                while i+1&lt;len(s) and s[i+1] in '0123456789':
                    tmp = tmp*10+ int(s[i+1])
                    i+=1
                s_res.append(tmp)
            
                
            i+=1
        
                
        
        print(s_res)
        if '+' not in s_res and '-' not in s_res:
            return int(''.join(map(str,s_res)))
        
        res = []
        for e in s_res:
            if e=='+' or e=='-':
                b = res.pop() if res else None
                a = res.pop() if res else None
                
                
                if a is None:
                    if e=='+':
                        res.append(b)
                    else:
                        res.append(-b)
                
                else:    
                    if e=='+':
                        res.append(a+b) 
                    else:
                        res.append(a-b)
            else:
                res.append(e)
        #print(res)
        return res[0]

#通解
class Solution:
    def calculate(self, s: str) -&gt; int:
        
        # 转换为 后缀表达式
        # 运算符优先级
        prec = {}
        prec[&quot;*&quot;] = 3
        prec[&quot;/&quot;] = 3
        prec[&quot;+&quot;] = 2
        prec[&quot;-&quot;] = 2
        prec[&quot;(&quot;] = 1

        res = []
        stack = []
        i = 0
        while i &lt; len(s):
            # 数字 直接 接到后缀表达式上
            if s[i] == &quot; &quot;:
                i += 1
                
            elif s[i].isdigit():
                temp = &quot;&quot;
                while i &lt; len(s) and s[i].isdigit():
                    temp += s[i]
                    i += 1
                res.append(temp)

            # 左括号直接入栈
            elif s[i] == &quot;(&quot;:
                stack.append(s[i])
                i += 1

            # 右括号，开始弹栈，直达遇到左括号 左括号出栈 但不输出
            elif s[i] == &quot;)&quot;:
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() # 左括号出战， 但是不输出
                i += 1

            # 遇到运算符
            elif s[i] in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #  对 &quot;-2 + 2&quot; 或者 &quot;1-(-2)&quot; 进行特殊处理
                if s[i] == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    res.append('0')
                # 只要栈顶符号不低于当前符号，就一直输出。最后把当前符号入栈
                while stack and prec[s[i]]&lt;=prec[stack[-1]]:
                    res.append(stack.pop())
                stack.append(s[i])
                i += 1
        
        # 最后把栈里面的元素均 放到后缀表达式后面
        while stack:
            res.append(stack.pop())


        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char.isdigit():
                stack.append(int(char))
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(x/y)

        return stack.pop()
</code></pre>
<p>&quot; 2-1 + 2 &quot; 直接用stack解出现-1时候符号和1是合体的，所以换思路把表达式变成前缀/后坠表达。 又遇到后缀表达如何去括号问题。<br>
1 + (( 2 + 3)* 4 ) – 5   方法：  当读到数时，立即输出， 若读到操作符，判断符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就依次把栈中运算符弹出并加到后缀表达式尾端，但又遇到 &quot;1-(-2)&quot; 无法pass。 同理 &quot;- (3 - (- (4 + 5) ) )&quot; 无法pass。 负号不作为减法，作为符号。 需要特殊处理： 方法：</p>
<pre><code class="language-python">if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
    s_res.append(0)
</code></pre>
<p>答案很简单，问题根源在-号不能互相换 比如(A-B)+C != A-(B+C) , 所以把-看作数字的符号。</p>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:

        stack = []
        operand = 0
        res = 0 # For the on-going result
        sign = 1 # 1 means positive, -1 means negative  

        for ch in s:
            if ch.isdigit():
                # Forming operand, since it could be more than one digit
                operand = (operand * 10) + int(ch)

            elif ch == '+':
                # Evaluate the expression to the left,
                # with result, sign, operand
                res += sign * operand

                # Save the recently encountered '+' sign
                sign = 1
                # Reset operand
                operand = 0

            elif ch == '-':

                res += sign * operand
                sign = -1
                operand = 0

            elif ch == '(':

                # Push the result and sign on to the stack, for later
                # We push the result first, then sign
                stack.append(res)
                stack.append(sign)

                # Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1
                res = 0

            elif ch == ')':

                # Evaluate the expression to the left
                # with result, sign and operand
                res += sign * operand

                # ')' marks end of expression within a set of parenthesis
                # Its result is multiplied with sign on top of stack
                # as stack.pop() is the sign before the parenthesis
                res *= stack.pop() # stack pop 1, sign

                # Then add to the next operand on the top.
                # as stack.pop() is the result calculated before this parenthesis
                # (operand on stack) + (sign on stack * (result from parenthesis))
                res += stack.pop() # stack pop 2, operand

                # Reset the operand
                operand = 0

        return res + sign * operand

</code></pre>
<h1 id="font-colorblue225-implement-stack-using-queues-easy-font"><font color='blue'>225. Implement Stack using Queues (Easy) </font></h1>
<pre><code class="language-python">class MyStack(object):
    def __init__(self):
        self._queue = collections.deque()

    def push(self, x):
        q = self._queue
        q.append(x)
        for _ in range(len(q) - 1):
            q.append(q.popleft())
 
    def pop(self):
        return self._queue.popleft()

    def top(self):
        return self._queue[0]
    
    def empty(self):
        return not len(self._queue)

</code></pre>
<p>三种方法</p>
<h1 id="226-invert-binary-tree-easy">226. Invert Binary Tree （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
        if not root: return root
        root.left,root.right = root.right,root.left
        root.left = self.invertTree(root.left)
        root.right=self.invertTree(root.right)
        return root

</code></pre>
<h1 id="font-colorblue227-basic-calculator-ii-medium-font"><font color='blue'>227. Basic Calculator II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #convert to 后缀表达
        priority = {'+':1,'-':1,'*':2,'/':2,'(':0}
        res = [] #保存后缀表达式
        stack=[] #保存符号
        i=0
        while i&lt;len(s):
            ch=s[i]
            if ch.isdigit():
                tmp=ch
                while i+1&lt;len(s) and s[i+1].isdigit():
                    tmp+=s[i+1]
                    i+=1
                res.append(int(tmp))
            
            elif ch=='(':
                stack.append(ch)
            elif ch==')':
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() 
            elif ch in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                
                while stack and priority[ch] &lt;= priority[stack[-1]]:
                    res.append(stack.pop())

                stack.append(ch)
            
            i+=1
                
        while stack:
            res.append(stack.pop())
        
        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char not in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #char is number
                stack.append(char)
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(y//x)

        return stack.pop()

</code></pre>
<p>直接上通杀法。转成后缀表达然后求结果。</p>
<h1 id="font-colorblue-228-summary-ranges-easy-font"><font color='blue'> 228. Summary Ranges （Easy） </font></h1>
<pre><code class="language-python">class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        # [0]
        # [0,1]
        # [0,2]
        # [0-2,4]
        # [0-2,4,5]
        
        res = []
        stack=[]
        for n in nums:
            if not stack:
                stack.append(n)
            elif len(stack)==1:
                if n==stack[-1]+1:
                    stack.append(n)
                else:
                    res.append(str(stack[-1]))
                    stack=[n]
            else:
                if n==stack[-1]+1:
                    stack[-1]=n
                else:
                    res.append(str(stack[0])+'-&gt;'+str(stack[1]))
                    stack=[n]
 
        if len(stack)==1:
            res.append(str(stack[0]))
        elif len(stack)==2:
            res.append(str(stack[0])+'-&gt;'+str(stack[1]))
        
        return res
#answer way of writting
class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        res = []
        i=0
        for j in range(len(nums)):
            if j+1&lt;len(nums) and nums[j+1]==nums[j]+1:
                continue
            if i==j:
                res.append(str(nums[i]))
            else:
                res.append(str(nums[i])+'-&gt;'+str(nums[j]))
            i=j+1
        return res

</code></pre>
<p>答案更简单</p>
<h1 id="font-colorred229-majority-element-ii-medium-font"><font color='red'>229. Majority Element II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; List[int]:
        
        maj1=nums[0]
        maj2=nums[0]
        c1=0
        c2=0

        for n in nums:
            if n==maj1:
                c1+=1
            elif n==maj2:
                c2+=1
            elif c1==0:
                c1=1
                maj1=n
            elif c2==0:
                c2=1
                maj2=n
            else:
                c1-=1
                c2-=1
        #recalce make sure        
        c1=c2=0
        for n in nums:
            if n==maj1:c1+=1
            if n==maj2:c2+=1
        res=[]
        if c1&gt;len(nums)//3:
            res.append(maj1)
        if c2&gt;len(nums)//3 and maj1!=maj2:
            res.append(maj2)
        return res


</code></pre>
<p>经典算法，在做majorelement 1时候写过，需要记住。</p>
<h1 id="230-kth-smallest-element-in-a-bst-medium">230. Kth Smallest Element in a BST （Medium）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:
        ind=0
        stack=[]
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            ind+=1
            if ind==k:
                return node.val
            
            root=node.right
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-24]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-24/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-24/">
        </link>
        <updated>2021-11-24T15:05:08.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="211-design-add-and-search-words-data-structure-medium">211. Design Add and Search Words Data Structure （Medium）</h1>
<p>Design Add and Search Words Data Structure</p>
<pre><code class="language-python">class WordDictionary:

    def __init__(self):
        self.next = dict()
        self.isword= False
        

    def addWord(self, word: str) -&gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char]=WordDictionary()
            self.next[char].addWord(rest)
        else:
            self.isword=True
        

    def search(self, word: str) -&gt; bool:
        if not word:
            return self.isword
        char = word[0]
        rest = word[1:]
        if char!='.':
            if char not in self.next:
                return False
            else:
                return self.next[char].search(rest)
        else:
            return any([ node.search(rest) for key,node in self.next.items()])
        
        return True
        
</code></pre>
<p>Trie data structure</p>
<h1 id="font-colorred212-word-search-ii-hard-font"><font color='red'>212. Word Search II （Hard） </font></h1>
<p>Given an m x n board of characters and a list of strings words, return all words on the board.<br>
Input: board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]<br>
Output: [&quot;eat&quot;,&quot;oath&quot;]</p>
<pre><code class="language-python">class Solution:
   
    
    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:
        #trie + DFS
        class Trie:
            def __init__(self):
                self.next=dict()
                self.isword=False
            def addwords(self,word):
                if word:
                    char=word[0]
                    rest=word[1:]
                    if char not in self.next:
                        self.next[char]=  Trie()
                    self.next[char].addwords(rest)
                else:
                    self.isword=True           
                
            
        trie =  Trie()
        for word in words:
            trie.addwords(word)
       
        m=len(board)
        n=len(board[0])
        res = []
        def dfs(trie,board,i,j,tmp=''):
            if i&gt;=0 and i&lt;m and j&gt;=0 and j&lt;n:
                char= board[i][j]
                board[i][j]='#'
                tmp+=char
                if char in trie.next:
                    if trie.next[char].isword:
                        res.append(tmp)
                        trie.next[char].isword=False
                   
                    trie = trie.next[char]
                    dfs(trie,board,i+1,j,tmp)
                    dfs(trie,board,i-1,j,tmp)
                    dfs(trie,board,i,j+1,tmp)
                    dfs(trie,board,i,j-1,tmp)
                
                tmp = tmp[:-1]
                board[i][j] = char
              
            
        for i in range(m):
            for j in range(n):
                if board[i][j] in [word[0] for word in words]:
                    dfs(trie,board,i,j,'')
        
        return res

</code></pre>
<p>尝试trie+DFS , time limit exceeded.   什么地方没优化到？？ 原来是 发现isword时候 把isword设为False，这样就不会找到重复的word。</p>
<h1 id="213-house-robber-ii-medium">213. House Robber II （Medium）</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        # dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        # dp[0] = nums[0]
        # dp[1] = max(nums[:2])
        #
        # now circle constraint
        #
        # if select 0, -1 and 1 can not be selected
        #  dp[0] = nums[0]  dp[1] = dp[0] ... dp[-1]=dp[-2]
        # if not select 0, -1 and 1 can be selected
        #  dp[0] = 0 dp[1]=nums[1]  ... dp[-1]=dp[-2]+nums[-1]
        
        if len(nums)&lt;3:
            return max(nums)
       
        #case1) select 0
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=nums[0]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-1]
        res=max(dp)
        #case2)
        dp=[0]*len(nums)
        dp[0]=0
        dp[1]=nums[1]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-2]+nums[-1]
        res=max(res,max(dp))
        return res
</code></pre>
<p>因为循环数组，所以，分两种case， 抢劫第一户和不抢劫第一户。</p>
<h1 id="font-colorred214-shortest-palindrome-hardfont"><font color='red'>214. Shortest Palindrome （Hard）</font></h1>
<p>You are given a string s. You can convert s to a palindrome by adding characters in front of it.</p>
<pre><code class="language-python">class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        # brute force
        l=len(s)
        rev = ''.join(s[::-1])
        
        for i in range(l):
            if s[:l-i]==rev[i:]:
                return rev[:i]+s
        
        return ''
#KMP

class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        # KMP
        l=len(s)
        rev = ''.join(s[::-1])
        s_new = s +'#' + rev
        l_new = len(s_new)
        f = [0]*l_new
        for i in range(1,l_new):
            t = f[i-1]
            while t&gt;0 and s_new[i]!=s_new[t]:
                #can'f find prefix=sufix, t=f[t-1]
                t=f[t-1]
            if s_new[i]==s_new[t]:
                t+=1
            f[i]=t
        
        return rev[:l-f[l_new-1]] +s
</code></pre>
<p>思路： finding the largest palindrome substring from the beginning. O（n）方法用了KMP的loolup table。   rev[f[l_new-1]:]是形成回文的序列。和 s[:len(s)-f[l_new-1]] 是对应的，那么未形成回文的就是 rev[: f[l_new-1]] ，s+rev[: f[l_new-1]] 为答案。 s_new = s +'#' + rev 因为不加#会引起 2 strings could mix with each ther, producing wrong answer. For example, take the string &quot;aaaa&quot; . Had we not inserted &quot;#&quot; in the middle, the new string would be &quot;aaaaaaaa&quot;。</p>
<h1 id="215-kth-largest-element-in-an-array-medium">215. Kth Largest Element in an Array （Medium）</h1>
<pre><code class="language-python">class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        from heapq import heapify, heappush, heappop
        stack=[]
        for i,n in enumerate(nums):
            if len(stack)&lt;k:
                heappush(stack,n)
            else:
                tmp=heappop(stack)
                if n&lt;tmp:
                    heappush(stack,tmp)
                else:
                    heappush(stack,n)
         
        return heappop(stack)
###
class Solution:
    def findKthLargest(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        def partition(left, right, pivot_index):
            pivot = nums[pivot_index]
            # 1. move pivot to end
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  
            
            # 2. move all smaller elements to the left
            store_index = left
            for i in range(left, right):
                if nums[i] &lt; pivot:
                    nums[store_index], nums[i] = nums[i], nums[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            nums[right], nums[store_index] = nums[store_index], nums[right]  
            
            return store_index
        
        def select(left, right, k_smallest):
            &quot;&quot;&quot;
            Returns the k-th smallest element of list within left..right
            &quot;&quot;&quot;
            if left == right:       # If the list contains only one element,
                return nums[left]   # return that element
            
            # select a random pivot_index between 
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return nums[k_smallest]
            # go left
            elif k_smallest &lt; pivot_index:
                return select(left, pivot_index - 1, k_smallest)
            # go right
            else:
                return select(pivot_index + 1, right, k_smallest)

        # kth largest is (n - k)th smallest 
        return select(0, len(nums) - 1, len(nums) - k)
                
        
</code></pre>
<p>min heap<br>
第二种解法quicksort， O（n）<br>
Choose a random pivot.<br>
Use a partition algorithm to place the pivot into its perfect position pos in the sorted array, move smaller elements to the left of pivot, and larger or equal ones - to the right.<br>
Compare pos and N - k to choose the side of array to proceed recursively.</p>
<h1 id="216-combination-sum-iii-medium">216. Combination Sum III （Medium）</h1>
<p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:<br>
Only numbers 1 through 9 are used.<br>
Each number is used at most once.</p>
<pre><code class="language-python">class Solution:
    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:
        
        res = []
        def bt(start,tmp,target):
            if target&lt;0: return
            if len(tmp)==k and target==0:
                res.append(tmp[:])
            
            for i in range(start,10):
                tmp.append(i)
                target -= i
                bt(i+1,tmp,target)
                target+=i
                tmp.pop()
        bt(1,[],n)
        return res

</code></pre>
<h1 id="217-contains-duplicate-easy">217. Contains Duplicate (Easy)</h1>
<pre><code class="language-python">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        s = set()
        for n in nums:
            if n in s:
                return True
            s.add(n)
        return False
</code></pre>
<h1 id="font-colorred218-the-skyline-problem-hard-font"><font color='red'>218. The Skyline Problem (Hard) </font></h1>
<pre><code class="language-python">from heapq import * 
class Solution(object):
    def getSkyline(self, buildings):
        # add start-building events
        # also add end-building events(acts as buildings with 0 height)
        # and sort the events in left -&gt; right order
        events = [(L, -H, R) for L, R, H in buildings]
        events.extend([(R, 0, 0) for _, R, _ in buildings])
        events.sort()

        # res: result, [x, height]
        # live: heap, [-height, ending position]
        res = [[0,0]] 
        live = [(0, float(&quot;inf&quot;))]
        for pos, negH, R in events:
            # 1, pop buildings that are already ended
            # 2, if it's the start-building event, make the building alive
            # 3, if previous keypoint height != current highest height, edit the result
            while pos&gt;= live[0][1]:
                 heappop(live)
            if negH!=0:
                #start building event
                heappush(live, (negH, R))
            if res[-1][1] != -live[0][0]:
                res.append( [pos, -live[0][0]])
        return res[1:]

 #
class Solution:
    def getSkyline(self, buildings: 'List[List[int]]') -&gt; 'List[List[int]]':
        &quot;&quot;&quot;
        Divide-and-conquer algorithm to solve skyline problem,
        which is similar with the merge sort algorithm.
        &quot;&quot;&quot;
        n = len(buildings)
        # The base cases
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            return [[x_start, y], [x_end, 0]]

        # If there is more than one building,
        # recursively divide the input into two subproblems.
        left_skyline = self.getSkyline(buildings[: n // 2])
        right_skyline = self.getSkyline(buildings[n // 2 :])

        # Merge the results of subproblem together.
        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left, right):
        &quot;&quot;&quot;
        Merge two skylines together.
        &quot;&quot;&quot;
        def update_output(x, y):
            &quot;&quot;&quot;
            Update the final output with the new element.
            &quot;&quot;&quot;
            # if skyline change is not vertical -
            # add the new point
            if not output or output[-1][0] != x:
                output.append([x, y])
            # if skyline change is vertical -
            # update the last point
            else:
                output[-1][1] = y

        def append_skyline(p, lst, n, y, curr_y):
            &quot;&quot;&quot;
            Append the rest of the skyline elements with indice (p, n)
            to the final output.
            &quot;&quot;&quot;
            while p &lt; n:
                x, y = lst[p]
                p += 1
                if curr_y != y:
                    update_output(x, y)
                    curr_y = y

        n_l, n_r = len(left), len(right)
        p_l = p_r = 0
        curr_y  = left_y = right_y = 0
        output = []

        # while we're in the region where both skylines are present
        while p_l &lt; n_l and p_r &lt; n_r:
            point_l, point_r = left[p_l], right[p_r]
            # pick up the smallest x
            if point_l[0] &lt; point_r[0]:
                x, left_y = point_l
                p_l += 1
            else:
                x, right_y = point_r
                p_r += 1
            # max height (i.e. y) between both skylines
            max_y = max(left_y, right_y)
            # if there is a skyline change
            if curr_y != max_y:
                update_output(x, max_y)
                curr_y = max_y

        # there is only left skyline
        append_skyline(p_l, left, n_l, left_y, curr_y)

        # there is only right skyline
        append_skyline(p_r, right, n_r, right_y, curr_y)

        return output
</code></pre>
<p>感觉用stack做， 还是直接看答案了， 思路：事件驱动， events 包括开始建筑和终止建筑，【（L，-H，R），（R，0，0）.。。。】 这样遍历events，live存放【（-height，end pos）】 1, pop buildings that are already ended in live 2，if it's the start-building event, make the building alive， 3，if previous keypoint height != current highest height, edit the result， 思路2，分治法 O(Nlog⁡N)</p>
<h1 id="font-colorred219-contains-duplicate-ii-easy-font"><font color='red'>219. Contains Duplicate II （Easy） </font></h1>
<pre><code class="language-python">class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:
        s = set()
        k=k+1
        for i,n in enumerate(nums):
            if len(s)&lt;k:
                if n in s: return True
                #print('s add ',n)
                s.add(n)
            else:
                #remove outdated
                s.remove(nums[i-k])
                #print('s remove ',nums[i-k])
                if n in s:return True
                #print('s add',n)
                s.add(n)
        return False

## correct way of doing
class Solution:
    def containsNearbyDuplicate(self, nums: 'List[int]', k: 'int') -&gt; 'bool':
        dic=dict()
        
        for i,n in enumerate(nums):
            if n in dic:
                if abs(i-dic[n])&lt;=k:
                    return True
            dic[n]=i
        return False
</code></pre>
<p>two pointer timestap&lt;=k 过期，花的时间太长。。。， 正确方法还是用dict 存 mapping n=&gt; i. 这样当遇到重复的n判断  i-dic【n】距离是否小于k，小于则为True。</p>
<h1 id="font-colorred-220-contains-duplicate-iii-mediumfont"><font color='red' >220. Contains Duplicate III （Medium）</font></h1>
<pre><code class="language-python">class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool:
        if t&lt; 0: return False
        dic = dict()
        for i,n in enumerate(nums):
            #remove outdated 
            if i-k&gt;=0 and nums[i-k] in dic and dic[nums[i-k]]&lt;i-k:
                del dic[nums[i-k]] 
            
            #print(i,n,dic)
            
            #check 
            if any([abs(n-key)&lt;=t and abs(i-val)&lt;=k for key,val in dic.items()]):
                #print(i,n)
                #print(dic)
                return True
            
           
            #add current
            dic[n]=i
        return False

#
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool:
        #            0~9 10~19 .. 
        # buketid     0   1
        #   what is 9's buket id, 9//(9+1) 
        #   so bucket size = 10
        
        buket = dict()
        buket_size = t+1
        for i,n in enumerate(nums):
            buket_id  = n//buket_size
            if buket_id in buket or (buket_id-1 in buket and n-buket[buket_id-1]&lt;=t) or(buket_id+1 in buket and buket[buket_id+1]-n&lt;=t):
                return True
            
            buket[buket_id] = n
            if i&gt;=k:
                del buket[nums[i-k]//buket_size]
        return False
</code></pre>
<p>用过期del dict key方法会time limit exceeded。竟然是用bukets。检查当前buket 和上一个或者下一个buket。 这题应该是个hard。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-23]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-23/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-23/">
        </link>
        <updated>2021-11-22T05:20:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred201-bitwise-and-of-numbers-range-mediumfont"><font color='red'>201. Bitwise AND of Numbers Range （Medium）</font></h1>
<p>Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.</p>
<pre><code class="language-python">class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:
        if left==right: return left
        res = 0
        for pos in range(32):
            res |= 1 &lt;&lt; pos
            for n in range(left,right+1):
                if (n &amp; 1&lt;&lt;pos) &gt;&gt; pos ==0:
                    res ^= 1 &lt;&lt; pos
                    break
        return res

#answer way of writing
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&gt; int:
        shift = 0   
        # find the common 1-bits
        while m &lt; n:
            m = m &gt;&gt; 1
            n = n &gt;&gt; 1
            shift += 1
        return m &lt;&lt; shift
#
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&gt; int:
        while m &lt; n:
            # turn off rightmost 1-bit
            n = n &amp; (n - 1)
        return m &amp; n
</code></pre>
<p>初次尝试，time limit exceeded， 32位过一次，一旦发现在pos位上为0，就break。 还是速度慢，  after the AND operation on all the numbers, the remaining part of bit strings is the common prefix of all these bit strings.As a result, we then can reformulate the problem as &quot;given two integer numbers, we are asked to find the common prefix of their binary strings.&quot; 思路： shift 直到m n相等，然后再 shift back。 这样就找到了common prefix。另一解法，思路：关闭右侧最后是1的位，然后和左侧求&amp;。</p>
<blockquote>
<p>When we do AND bit operation between number and number-1, the rightmost bit of one in the original number would be turned off (from one to zero).</p>
</blockquote>
<h1 id="202-happy-number-easy">202. Happy Number （Easy）</h1>
<p>Write an algorithm to determine if a number n is happy.<br>
Input: n = 19<br>
Output: true<br>
Explanation:<br>
12 + 92 = 82<br>
82 + 22 = 68<br>
62 + 82 = 100<br>
12 + 02 + 02 = 1</p>
<pre><code class="language-python">class Solution:
    def isHappy(self, n: int) -&gt; bool:
        visited =set()
        
        while n!=1:
            if n in visited: return False
            visited.add(n)
            new_n =0
            while n:
                lastdig = n%10
                new_n += lastdig*lastdig
                n //= 10
            n=new_n
        
        return True
</code></pre>
<h1 id="203-remove-linked-list-elements-easy">203. Remove Linked List Elements （Easy）</h1>
<p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:
        if not head: return head
        dummyhead = ListNode(val='NULL',next=head)
        cur=dummyhead
        while cur and cur.next:
            while cur.next and cur.next.val==val:
                cur.next=cur.next.next
            cur=cur.next
        return dummyhead.next
</code></pre>
<h1 id="font-colorred204-count-primes-medium-font"><font color='red'>204. Count Primes (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def countPrimes(self, n: int) -&gt; int:
 
        if n &lt;=2:
            return 0
        primes = [True] * n
        primes[0] = primes[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if primes[i]:
                primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
        #如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。 
        return sum(primes)
</code></pre>
<p>直接用判断是否位质数方法会time limit exceeded。 思路：如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。</p>
<pre><code class="language-python">     def isP(num):
            for i in range(2,num//2+1):
                if num%i==0:
                    return False
            return True
</code></pre>
<h1 id="205-isomorphic-strings-easy">205. Isomorphic Strings （Easy）</h1>
<p>Given two strings s and t, determine if they are isomorphic.<br>
Two strings s and t are isomorphic if the characters in s can be replaced to get t.</p>
<pre><code class="language-python">class Solution:
    def isIsomorphic(self, s: str, t: str) -&gt; bool:
        if len(s)!=len(t): return False
        l=len(s)
        dic1 = dict()
        dic2 = dict()
        for i in range(l):
            a = s[i]
            b = t[i]
            if a in dic1:
                if dic1[a]!=b:
                    return False
            if b in dic2:
                if dic2[b]!=a:
                    return False
            dic1[a] = b
            dic2[b] = a
        return True
</code></pre>
<h1 id="206-reverse-linked-list-easy">206. Reverse Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        pre = None
        while head:
            headnext=head.next
            head.next = pre
            pre = head
            head=headnext
        return pre
</code></pre>
<h1 id="font-colorred207-course-schedule-medium-font"><font color='red'>207. Course Schedule (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #DFS 法    
        def dfs(node):
            # return True 无环 False 有环
            node.status=0
            for nei in node.nei:
                if nei.status==-1:
                    if not dfs(nei):
                        return False
                elif nei.status == 0:
                    return False
            
            node.status=1
            return True
        
        for node in nodes:
            if node.status==-1:
                if not dfs(node):
                    return False
        
        return True

# upper DFS lower BFS
class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #bfs 法
        queue=[]
        cnt=0
        for node in nodes:
            if node.ind==0:
                queue.append(node)
        while queue:
            v=queue.pop(0)
            cnt+=1
            for nei in v.nei:
                nei.ind-=1
                if nei.ind==0:
                    queue.append(nei)
        
        return cnt==numCourses
</code></pre>
<p>感觉是图的算法，判断是否为DAG。BFS找入度为0的。  DFS时候，如果正在搜索某V，但又回到了V。证明有环路。注意需要3个状态来表示node状态， 【visited，visiting，not visited】<br>
需要补充拓扑排序算法解决变种题。</p>
<pre><code class="language-python"># TopoSort sudo
queue = []
for 图中每个顶点V:
    if indegree(V)==0:
        queue.append(V)
while queue:
    V=queue.pop(0)
    输出V，记录V的输出序号cnt++
    for V的每个邻居 W:
        indegree(W) -= 1
        if indegree(W)==0:
            queue.append(W)

if cnt!=|V|:
    ERROR(图中有回路)
</code></pre>
<h1 id="208-implement-trie-prefix-tree">208. Implement Trie (Prefix Tree)</h1>
<pre><code class="language-python">class Trie:

    def __init__(self):
        self.next= dict()
        self.isword=False
 

    def insert(self, word: str) -&gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char] = Trie()
            self.next[char].insert(rest)
        else:
            self.isword=True
             

    def search(self, word: str) -&gt; bool:
       
        if not word:
            return self.isword
        
        char = word[0]
        rest = word[1:]
        if char in self.next:
            if not self.next[char].search(rest):
                return False
        else:
            return False
        return True
        

    def startsWith(self, prefix: str) -&gt; bool:
        if not prefix:
            return True
        
        char=prefix[0]
        rest=prefix[1:]
        if char in self.next:
            if not self.next[char].startsWith(rest):
                return False
        else:
            return False
        
        return True
        
</code></pre>
<h1 id="font-colorblue209-minimum-size-subarray-sum-medium-font"><font color='blue'>209. Minimum Size Subarray Sum (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
        # two pointer
        
        l=0
        r=-1
        val=0
        res = float('inf')
        while val&lt;target:
            r+=1
            if r&gt;=len(nums):
                break
            val+=nums[r]  
        if val&gt;=target:
            res=min(res,r-l+1)
        else:
            return 0
        while l&lt;r:
            if val&gt;=target:
                #drop left
                #print('dropleft',l)
                val-=nums[l]
                l+=1
                if val&gt;=target: 
                    #print(l,r)
                    res=min(res,r-l+1)
                
            else:
                #print('expandright',r+1)
                r+=1
                if r&gt;=len(nums):
                    break
                val+=nums[r] 
        
        return res
# answer way of writting
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
        # two pointer
 
        l=len(nums)
        res=float('inf')
        left=0
        sum_=0
        for i,n in enumerate(nums):
            sum_+=n
            while sum_&gt;=target:
                res=min(res,i-left+1)
                sum_-=nums[left]
                left+=1
        
        return res if res!= float('inf') else 0
                
</code></pre>
<p>果然是two pointer, 学习answer写法，很清晰。</p>
<h1 id="210-course-schedule-ii-medium">210. Course Schedule II （Medium）</h1>
<pre><code class="language-python">class Solution:
    class Node:
        def __init__(self,val=None):
            self.val=val
            self.nei = []
            self.indegree = 0
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
        # dag
        
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for a,b in prerequisites:
            nodes[b].nei.append(nodes[a])
            nodes[a].indegree+=1
        
        queue = []
        for node in nodes:
            if node.indegree==0:
                queue.append(node)
                
        res = []
        while queue:
            cur=queue.pop(0)
            res.append(cur.val)
            for w in cur.nei:
                w.indegree-=1
                if w.indegree==0:
                    queue.append(w)
        
        return res if len(res)==numCourses else []
        
</code></pre>
<p>BFS 拓扑排序，找出indegree==0的node output。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-22]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-22/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-22/">
        </link>
        <updated>2021-11-21T04:01:05.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="191-number-of-1-bits-easy">191. Number of 1 Bits (Easy)</h1>
<p>Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).</p>
<pre><code class="language-python">class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        res = 0 
        for _ in range(32):
            lastbit = n &amp; 1
            n = n &gt;&gt;1
            res += 1&amp;lastbit
        return res
</code></pre>
<h1 id="192-word-frequency-medium-bash">192. Word Frequency (Medium) BASH</h1>
<p>Write a bash script to calculate the frequency of each word in a text file words.txt.</p>
<pre><code class="language-BASH">for word in $(cat words.txt);   do echo $word;  done | sort | uniq -c | sort -r | awk '{ print $2 &quot; &quot;$1}'
</code></pre>
<p>Just ignore ....</p>
<h1 id="193-valid-phone-numbers-easy-bash">193. Valid Phone Numbers (Easy) BASH</h1>
<p>Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>
<pre><code class="language-BASH">grep -e '^[0-9]\{3\}-[0-9]\{3\}-[0-9]\{4\}$' -e '^([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}$' file.txt
</code></pre>
<p>Just ignore ....</p>
<h1 id="194-transpose-file-medium-bash">194. Transpose File (Medium) BASH</h1>
<p>Given a text file file.txt, transpose its content.</p>
<pre><code class="language-BASH">cat file.txt | awk '{for(i=0;++i&lt;=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++&lt;NF;)print a[i]}'
</code></pre>
<p>Just ignore ....</p>
<h1 id="195-tenth-line-easy-bash">195. Tenth Line (Easy) BASH</h1>
<p>Given a text file file.txt, print just the 10th line of the file.</p>
<pre><code class="language-BASH">sed -n &quot;10p&quot; file.txt
</code></pre>
<p>Just ignore ....</p>
<h1 id="196-delete-duplicate-emails-easy-sql">196. Delete Duplicate Emails (Easy) SQL</h1>
<pre><code class="language-SQL">DELETE p1 FROM Person p1,
    Person p2
WHERE
    p1.Email = p2.Email AND p1.Id &gt; p2.Id
</code></pre>
<h1 id="197-rising-temperature-easy-sql">197. Rising Temperature (Easy) SQL</h1>
<pre><code class="language-SQL">select w1.id as Id from Weather w1 left join Weather w2 on datediff(w1.RecordDate,w2.RecordDate)=1 where w2.Temperature&lt;w1.Temperature

# answer way of writting
SELECT
    weather.id AS 'Id'
FROM
    weather
        JOIN
    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1
        AND weather.Temperature &gt; w.Temperature
;
</code></pre>
<h1 id="198-house-robber-medium">198. House Robber (Medium)</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        # dp[i] = tthe max amount can rob at house i
        # dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        # dp[0] = nums[0]
        # dp[1] = max(nums[0],nums[1])
        if not nums:return 0
        if len(nums)==1: return nums[0]
        if len(nums)==2: return max(nums)
        dp = [float('-inf')]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(nums[:2])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        return dp[-1]
</code></pre>
<h1 id="199-binary-tree-right-side-view-medium">199. Binary Tree Right Side View (Medium)</h1>
<p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:
        if not root: return root
        queue = [root]
        res = []
        
        while queue:
            level =[]
            l=len(queue)
            for i in range(l):
                cur = queue.pop(0)
                level.append(cur.val)
                if cur.right:
                    queue.append(cur.right)
                if cur.left:
                    queue.append(cur.left)
            res.append(level[0])
        
        return res
</code></pre>
<p>level order tresversal.</p>
<h1 id="font-colorblue200-number-of-islands-medium-font"><font color='blue'>200. Number of Islands (Medium) </font></h1>
<p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.</p>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        
        
        def dfs(grid,i,j):
            m=len(grid)
            n=len(grid[0])
            if i&lt;0 or j&lt;0 or i&gt;=m or j&gt;=n: return 
            if grid[i][j]=='1':
                grid[i][j]='#'
                dfs(grid,i+1,j)
                dfs(grid,i-1,j)
                dfs(grid,i,j+1)
                dfs(grid,i,j-1)
        r=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]=='1':
                    dfs(grid,i,j)
                    r+=1
        
        return r

#UNION FIND
class Solution:
    class UnionFind:
        def __init__(self,grid):
            self.count=0
            self.m=len(grid)
            self.n=len(grid[0])
            self.parent = [None]*(self.m*self.n)
            self.rank = [0]*(self.m*self.n)
            for i in range(self.m):
                for j in range(self.n):
                    if grid[i][j]=='1':
                        self.parent[i*self.n+j]=i*self.n+j
                        self.count+=1
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
                self.count-=1
        
        def getCount(self):
            return self.count
    
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        nr=len(grid)
        nc=len(grid[0])
        uf = self.UnionFind(grid)
        for r in range(nr):
            for c in range(nc):
                if grid[r][c]=='1':
                    grid[r][c]='0'
                    if (r-1&gt;=0 and grid[r-1][c]=='1'):
                        uf.union(r*nc+c,(r-1)*nc+c)
                    if (r + 1 &lt; nr and grid[r+1][c] == '1'):
                        uf.union(r * nc + c, (r+1) * nc + c) 
                    if (c - 1 &gt;= 0 and grid[r][c-1] == '1'):
                        uf.union(r * nc + c, r * nc + c - 1) 
                    if   (c + 1 &lt; nc and grid[r][c+1] == '1'):
                        uf.union(r * nc + c, r * nc + c + 1) 
                    
    
        return uf.getCount() 
        

</code></pre>
<p>答案玩了个新东西，叫UnionFind， 挺有意思。 就是找爸爸的爸爸，然后谁rank高就作为最终父亲。 这样union时候只是pointer在移动， 刚开始所有1 都是自己的爸爸， 然后逐渐union周围的1， 每union一次counter -=1 这样最终counter就是所有独立的岛数目。DFS也很简单， BFS同理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-21]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-21/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-21/">
        </link>
        <updated>2021-11-20T03:29:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="181-employees-earning-more-than-their-managers-easy-sql">181. Employees Earning More Than Their Managers (Easy) SQL</h1>
<p>Write an SQL query to find the employees who earn more than their managers.</p>
<pre><code class="language-SQL">SELECT
    a.Name AS 'Employee'
FROM
    Employee AS a,
    Employee AS b
WHERE
    a.ManagerId = b.Id
        AND a.Salary &gt; b.Salary
;

SELECT
     a.NAME AS Employee
FROM Employee AS a JOIN Employee AS b
     ON a.ManagerId = b.Id
     AND a.Salary &gt; b.Salary
;
</code></pre>
<h1 id="182-duplicate-emails-easy-sql">182. Duplicate Emails (Easy) SQL</h1>
<pre><code class="language-SQL">
# Write your MySQL query statement below

select Email from
(
  select Email, count(Email) as num
  from Person
  group by Email
) as statistic
where num &gt; 1
;

select Email
from Person
group by Email
having count(Email) &gt; 1;
</code></pre>
<h1 id="183-customers-who-never-order-easy-sql">183. Customers Who Never Order (Easy) SQL</h1>
<pre><code class="language-SQL">select name as &quot;Customers&quot; from Customers as c left join Orders o on c.id=o.customerId where o.id is NULL;


select customers.name as 'Customers'
from customers
where customers.id not in
(
    select customerid from orders
);
</code></pre>
<h1 id="184-department-highest-salary-medium-sql">184. Department Highest Salary (Medium) SQL</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
select Department,Employee,Salary from (
    select d.name as &quot;Department&quot;, 
               e.name as &quot;Employee&quot;,  
               e.salary as &quot;Salary&quot;,
              rank()   OVER( partition by e.departmentId order by salary DESC) as &quot;r&quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
     as tmp where r=1


#answer way of writting

SELECT
    Department.name AS 'Department',
    Employee.name AS 'Employee',
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
    )
;

</code></pre>
<h1 id="185-department-top-three-salaries-hard-sql">185. Department Top Three Salaries (Hard) SQL</h1>
<pre><code class="language-SQL">select Department,Employee,Salary from (
    select d.name as &quot;Department&quot;, 
               e.name as &quot;Employee&quot;,  
               e.salary as &quot;Salary&quot;,
              dense_rank()   OVER( partition by e.departmentId order by salary DESC) as &quot;r&quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
as tmp where   r&lt;=3

#answer way of writting
SELECT
    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 &gt; (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary &gt; e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
</code></pre>
<h1 id="186-reverse-words-in-a-string-ii-medium">186. Reverse Words in a String II (Medium)</h1>
<p>Given a character array s, reverse the order of the words.<br>
A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.<br>
Your code must solve the problem in-place, i.e. without allocating extra space.</p>
<pre><code class="language-python">class Solution:
    def reverseWords(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        def rev(s,i,j):
            while i&gt;=0 and j&lt;len(s) and i&lt;j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
        
        l=0
        r=len(s)-1
        rev(s,l,r)
        start=0
        for i in range(r):
            if s[i]==' ':
                rev(s,start,i-1)
                start=i+1
        rev(s,start,r)
</code></pre>
<h1 id="187-repeated-dna-sequences-medium">187. Repeated DNA Sequences (Medium)</h1>
<p>The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.<br>
For example, &quot;ACGAATTCCG&quot; is a DNA sequence.<br>
When studying DNA, it is useful to identify repeated sequences within the DNA.<br>
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findRepeatedDnaSequences(self, s: str) -&gt; List[str]:
        #sliding window s[i,i+10]  drop i add i+10, if in set, append to res
        if len(s)&lt;=10: 
            return []
        set_ = set()
        res = set()
        for i in range(len(s)-10+1):
            cur=s[i:i+10]
            if cur in set_:
                res.add(cur)
            set_.add(cur)
        return list(res)
</code></pre>
<h1 id="font-colorred188-best-time-to-buy-and-sell-stock-iv-hardfont"><font color='red'>188. Best Time to Buy and Sell Stock IV （Hard）</font></h1>
<p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.<br>
Find the maximum profit you can achieve. You may complete at most k transactions.</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&gt; int:
        #  if k==1
        if not prices: return 0
        if k==0: return 0
        min_ = [float('inf')]*k
        p_ = [float('-inf')]*k
        
        for i,n in enumerate(prices):
            min_[0] = min(min_[0],n)
            p_[0] = max(p_[0],n-min_[0])
            for j in range(1,k):
                min_[j]=min(min_[j],n-p_[j-1])
                p_[j]=max(p_[j],n-min_[j])
                

        return p_[-1]
</code></pre>
<p>老老实实写出K=2的情况，然后改写为数组形式。但忘记了K=2怎么写。。。</p>
<h1 id="189-rotate-array-medium">189. Rotate Array （Medium）</h1>
<p>Given an array, rotate the array to the right by k steps, where k is non-negative.<br>
Input: nums = [1,2,3,4,5,6,7], k = 3<br>
Output: [5,6,7,1,2,3,4]<br>
7654321<br>
765|4321<br>
657|1234</p>
<pre><code class="language-python">class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        l=len(nums)
        k = k%l
        def rev(nums,i,j):
            while i&lt;j:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j-=1
        
        rev(nums,0,l-1)
        rev(nums,0,k-1)
        rev(nums,k,l-1)
</code></pre>
<h1 id="190-reverse-bits-easy">190. Reverse Bits (Easy)</h1>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<pre><code class="language-python">class Solution:
    def reverseBits(self, n: int) -&gt; int:
        res = 0
        for _ in range(32):
            lastbit = n &amp; 1
            n = n&gt;&gt;1
            res = res&lt;&lt;1 | lastbit
        return res  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-20]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-20/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-20/">
        </link>
        <updated>2021-11-19T05:25:27.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="171-excel-sheet-column-number-easy">171. Excel Sheet Column Number (Easy)</h1>
<p>convert excel sheet column chars to number</p>
<pre><code class="language-python">class Solution:
    def titleToNumber(self, columnTitle: str) -&gt; int:
        
        s = [e for e in columnTitle]
        res=0
        for char in s:
            n=ord(char)-ord('A')+1
            res  = res*26 +n
        return res
</code></pre>
<h1 id="172-factorial-trailing-zeroes-medium">172. Factorial Trailing Zeroes (Medium)</h1>
<p>Given an integer n, return the number of trailing zeroes in n!.</p>
<pre><code class="language-python">class Solution:
    def trailingZeroes(self, n: int) -&gt; int:
        # n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.
        #     2*5 =10 4*5=20 5*6=30 5*8=40 
        #    5's double time give one zero
        res5=0
        for i in range(n,0,-1):
            if i%5==0:  
                res5+=1
                i=i//5
                while i%5==0 and i!=0:
                    res5+=1
                    i=i//5
        
        return  res5
 
</code></pre>
<p>这个题有点意思，要形成末尾的0只能是5和2的结合，阶乘中公共因子2的数肯定大于公共因子为5的数，所以bound by 5的数目。 所以求所有含有5的因子的个数，特殊情况是25，125，625， 。。。 他们包含2个，3个，4个五，因此能产生更多的尾数0.  答案给出了lgn时间的解法。 就是循环求n能否除power of 5. 另一个思路是让n变小n=n//5.</p>
<pre><code class="language-python">#fives = 0
#power_of_5 = 5
#while n &gt;= power_of_5:
#    fives += n / power_of_5
#    power_of_5 *= 5

tens = fives
def trailingZeroes(self, n: int) -&gt; int:
    zero_count = 0
    current_multiple = 5
    while n &gt;= current_multiple:
        zero_count += n // current_multiple
        current_multiple *= 5
    return zero_count

def trailingZeroes(self, n: int) -&gt; int:
    zero_count = 0
    while n &gt; 0:
        n //= 5
        zero_count += n
    return zero_count
</code></pre>
<h1 id="173-binary-search-tree-iterator-medium">173. Binary Search Tree Iterator (Medium)</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        while root:
            self.stack.append(root)
            root=root.left
        #print([ e.val for e in self.stack])
        #print('##########################')
        

    def next(self) -&gt; int:
        node = self.stack.pop()
        if node.right:
            root=node.right
            while root:
                self.stack.append(root)
                root=root.left
                
        #print('r',node.val)
        return node.val
    def hasNext(self) -&gt; bool:
        return self.stack!=[]
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()

</code></pre>
<h1 id="font-colorred174-dungeon-game-hard-font"><font color='red'>174. Dungeon Game (Hard) </font></h1>
<p>The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.</p>
<pre><code class="language-python">class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int:
        
        # -2 -3  3
        # -5 -10 1
        # 10  30 -5
        #
        #  7  5   2
        #  16 11  5
        #  1  1   6  
        m = len(dungeon)
        n = len(dungeon[0])
        dp=[[0]*n for _ in range(m)]
        dp[-1][-1] = 1 if dungeon[-1][-1]&gt;0 else -1*(dungeon[-1][-1]-1)
        
        
        for i in range(m-2,-1,-1):
            dp[i][n-1] = dp[i+1][n-1]-dungeon[i][n-1] if dp[i+1][n-1]-dungeon[i][n-1]&gt;0 else 1
        for j in range(n-2,-1,-1):
            dp[m-1][j]= dp[m-1][j+1]-dungeon[m-1][j] if dp[m-1][j+1]-dungeon[m-1][j]&gt;0 else 1
        
        for row in range(m-2,-1,-1):
            for col in range(n-2,-1,-1):
                godown = max(dp[row+1][col]-dungeon[row][col],1)    
                goright = max(dp[row][col+1]-dungeon[row][col],1)  
                dp[row][col]=min(godown,goright)
        
        return dp[0][0]

</code></pre>
<p>想复杂了，应该从右下角开始回溯。 回溯血量小于0说明格子给的补药多了，所以保持生命1就可以了。 dp存的是需要的生命值。</p>
<h1 id="175-combine-two-tables-easysql">175. Combine Two Tables （Easy）SQL</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
# first name, last name, city, and state of each person in the Person table.  

select Person.firstName, Person.lastName, Address.city, Address.state  from Person left join Address on Person.personId=Address.personId

select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
</code></pre>
<h1 id="176-second-highest-salary-mediumsql">176. Second Highest Salary （Medium）SQL</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
# select  (
# select salary from Employee where salary&lt; (select max(salary) from Employee ) order by salary desc limit 1
# ) as  SecondHighestSalary

select (select distinct salary from Employee order by salary desc limit 1 offset 1) as SecondHighestSalary
</code></pre>
<h1 id="177-nth-highest-salary-medium-sql">177. Nth Highest Salary (Medium) SQL</h1>
<pre><code class="language-SQL">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
set N=N-1; 
  RETURN (
      # Write your MySQL query statement below.
      
    select distinct Salary from Employee order by Salary Desc limit 1 offset N
  );
END
</code></pre>
<h1 id="178-rank-scores-medium-sql">178. Rank Scores (Medium) SQL</h1>
<pre><code class="language-SQL">select  score,  dense_rank() over ( order by score desc) as 'rank'    from Scores 
</code></pre>
<p>dense_rank和rank不同之处在于是否压缩值。 rank()用法举例</p>
<pre><code class="language-SQL">SELECT * FROM (
	SELECT
		product_id,
		product_name,
		category_id,
		list_price,
		DENSE_RANK () OVER ( 
			PARTITION BY category_id
			ORDER BY list_price DESC
		) price_rank 
	FROM
		production.products
) t
WHERE price_rank &lt; 3;
</code></pre>
<h1 id="font-colorred179-largest-number-medium-font"><font color='red'>179. Largest Number (Medium) </font></h1>
<p>Given a list of non-negative integers nums, arrange them such that they form the largest number.</p>
<pre><code class="language-python">class LargerNumKey(str):
    def __lt__(x, y):
        return x+y &gt; y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))
        return '0' if largest_num[0] == '0' else largest_num

</code></pre>
<p>太晚了，有个初步想法，但似乎在处理最高位相同情况时候还没完全想明白。直接看答案了。答案直接拒绝处理最高位相同情况直接按照string 去compare。。。</p>
<h1 id="180-consecutive-numbers-mediumsql">180. Consecutive Numbers （Medium）SQL</h1>
<p>Write an SQL query to find all numbers that appear at least three times consecutively.</p>
<pre><code class="language-SQL"># Write your MySQL query statement below


SELECT DISTINCT
    l1.Num AS ConsecutiveNums
FROM
    Logs l1,
    Logs l2,
    Logs l3
WHERE
    l1.Id = l2.Id - 1
    AND l2.Id = l3.Id - 1
    AND l1.Num = l2.Num
    AND l2.Num = l3.Num
;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-19]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-19/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-19/">
        </link>
        <updated>2021-11-19T01:20:04.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="161-one-edit-distance-medium">161. One Edit Distance (Medium)</h1>
<p>Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.</p>
<pre><code class="language-python">class Solution:
    def isOneEditDistance(self, s: str, t: str) -&gt; bool:
        #
        #      ''  a  b
        #   '' 0   1  2
        #    a 1   0  1  
        #    c 2   1  1
        #    b 3   2  1
        #
        #    dp[i][j] is s[:i]  t[:j]'s editdistance
        #    dp[i][j] =   min(dp[i][j-1] ,  dp[i-1][j] ,  dp[i-1][j-1]) +1 if s[i]!=t[j]        
        m = len(s)
        n = len(t)
        
        dp = [[0]*(n+1) for _ in range(m+1)]
      
        for i in range(n+1):
            dp[0][i]=i
        for i in range(m+1):
            dp[i][0]=i
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if s[i-1]!=t[j-1]:
                    dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1
                else:
                    dp[i][j] = dp[i-1][j-1]
                
                     
        
        return dp[-1][-1]==1

 #second way of writting
 class Solution:
    def isOneEditDistance(self, s: str, t: str) -&gt; bool:
        
        # s-&gt;t    insert
        
        if len(t)-len(s)==1 and len(set(t))-len(set(s))&lt;=1:
            #s insert
            # ssss sss
            # tttttttt
           
            while s and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while s and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(t)==1:
                return True
            
        elif len(s)-len(t)==1 and len(set(s))-len(set(t))&lt;=1:
            #s del
            # sssssss
            # ttt ttt
             
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            if len(s)==1:
                return True
            
            
        elif len(s)==len(t)  and len(set(s))-len(set(t))&lt;=1:
            # replace
            while t and s[0]==t[0]:
                s=s[1:]
                t=t[1:]
            while t and s[-1]==t[-1]:
                s=s[:len(s)-1]
                t=t[:len(t)-1]
            
            if len(t)==1 and len(s)==1 and t!=s:
                return True
            
        
        
        return False
               
</code></pre>
<p>用dp方法，time limit exceeded。dp是n*n的。所以用定义做。 分3种情况， insert ，del， replace。 头尾之间去除相同的，剩下长度为1 就是可以的。</p>
<h1 id="font-colorred162-find-peak-element-mediumfont"><font color='red'>162. Find Peak Element （Medium）</font></h1>
<p>A peak element is an element that is strictly greater than its neighbors.</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        
#         for i in range(len(nums)-1):
#             if nums[i] &gt; nums[i+1]:
#                 return i
        
#         return len(nums)-1
        
        
        return self.search(nums,0,len(nums)-1)
    
    def search(self, nums,l,r):
        if l==r:
            return l
        
        m = (l+r)//2
        
        if nums[m] &gt; nums[m+1]:
            return self.search(nums,l,m)
        else:
            return self.search(nums,m+1,r)
    
</code></pre>
<p>一定是考binary search的，但木有思路，答案很精彩。 就是比较 m 和 m+1就搞定了。</p>
<h1 id="font-colorred163-missing-ranges-easyfont"><font color='red'>163. Missing Ranges （Easy）</font></h1>
<pre><code class="language-python">class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&gt; List[str]:
        res=[]
        
        def helper(x,y):
            if y-x==2:
                # y=3 x=1
                res.append(str(x+1))
            elif y-x&gt;2:
                res.append(str(x + 1) + '-&gt;' + str(y - 1))
            
        
        pre = lower-1
        for num in nums:
            helper(pre,num)
            pre=num
        
        helper(pre,upper+1)
            
        return res
            
</code></pre>
<p>if else 判断太繁杂， 答案很简单，这个是个easy题目？？？ 为了统一 x 到 y之间判断， lower =lower-1，这样lower就包括进去了， upper=upper+1，这样upper就包括进去了。</p>
<h1 id="font-colorred164-maximum-gap-hard-font"><font color='red'>164. Maximum Gap （Hard） </font></h1>
<p>Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.</p>
<pre><code class="language-python">class Solution:
    def maximumGap(self, nums: List[int]) -&gt; int:
        
        if not nums or len(nums)&lt;2: return 0
        
        maxval = max(nums)
        exp=1 # 1,10,100,...
        radix=10 #base 10 system
        aux = [0]*len(nums)
        while maxval//exp&gt;0:
            count = [0]*radix
            
            for i,n in enumerate(nums):
                count[(n//exp)%10] +=1
            
            for i,n in enumerate(count):
                if i==0: continue
                count[i] += count[i-1]
            
            for i in range(len(nums)-1,-1,-1):
                count[(nums[i]//exp)%10] -= 1
                aux[ count[(nums[i]//exp)%10] ] = nums[i]
                
            nums= aux[:]
            
            exp*=10
        
        print(nums)
        
        maxGap = 0 
        for   i  in range(len(nums)-1): 
            maxGap = max(nums[i + 1] - nums[i], maxGap)

        return maxGap

# answer way of writting
class Solution:
    def maximumGap(self, nums: List[int]) -&gt; int:
        ## RC ##
        ## APPROACH : BUCKET SORT ##
        ## LOGIC ##
        ## 1. lets say we have number from 1 to 10 like, 1,1.1,1.2,2.4,3.5,3.7,4,....10 (not in the same order)
        ## 2. we create n - 1 buckets, why n-1 ? (b1 -&gt; [1-2] b2-&gt; [2-3] b3-&gt;[3-4] ...so on 9 buckets)
        ## 3. we can say size of each bucket will be (10 - 1) // 9 i.e 1 ==&gt; (maximum - mimimum) // (length - 1)
        ## 3. Instead of storing all the elements in the buckets, we store minvalue of that bucket and maximum value of that bucket
        ## 4. Maximum Gap can be Case 1: gap between min and max in the bucket itself (or) Case 2: Gap between bucket1 max and bucket2 and so on..
        
		## TIME COMPLEXITY : O(N) ##
		## SPACE COMPLEXITY : O(N) ##
        
        if len(nums) &lt; 2 or min(nums) == max(nums):
            return 0
        minimum, maximum = min(nums), max(nums)
        size = ( maximum - minimum )//(len(nums)-1) or 1
        buckets = [[None, None] for _ in range(( maximum - minimum )//size+1)]
        for num in nums:
            # getting the bucket number in which it falls into
            bucket = buckets[ ( num - minimum )//size ]
            bucket[0] = num if bucket[0] is None else min(bucket[0], num)
            bucket[1] = num if bucket[1] is None else max(bucket[1], num)
        buckets = [bucket for bucket in buckets if bucket[0] is not None]
        return max(buckets[i][0]-buckets[i-1][1] for i in range(1, len(buckets)))        
</code></pre>
<p>要求O（n）for space and time没思路。答案思路1） Radix Sort 听过，但写不出来。。。2）Buckets 这个思路很好。</p>
<blockquote>
<p>知识点 Radix Sort</p>
</blockquote>
<pre><code class="language-python">
     def count_sort(arr,exp):
           #辅助数组用于返回
           aux = [0]*len(nums)
           #0到9是个数字的计数器
           count=[0]*10
           #计数
           for i,n in enumerate(arr):
               ind= (n//exp)%10
               count[ind]+=1
           #计算位置  count【i】 就是 i 这个位，属于的数字所在的位置
           for i in range(1,10):
               count[i] += count[i-1]
            #从后向前遍历数组
           for i in range(len(arr)-1,-1,-1):
               #找到index
               ind = (arr[i]//exp)%10
               #找到位置 因为位置从0开始所以要-1
               count[ind] -= 1
               #赋值
               aux[count[ind]] = arr[i]
           return aux 


       def Radix_Sort(arr):
           maxval=max(arr)
           exp=1
           while maxval//exp&gt;0:
               #print('#',exp)
               arr = count_sort(arr,exp)
               exp*=10
           return arr
       
       nums = Radix_Sort(nums)


</code></pre>
<h1 id="165-compare-version-numbers-medium">165. Compare Version Numbers （Medium）</h1>
<pre><code class="language-python">class Solution:
    def compareVersion(self, version1: str, version2: str) -&gt; int:
        while version1 or version2:
            v1=0
            v2=0
            while version1 and version1[0]!='.':
                v1 = v1*10+int(version1[0])
                version1=version1[1:]
            while version2 and version2[0]!='.':
                v2 = v2*10+int(version2[0])
                version2=version2[1:]
            
            if v1&gt;v2: return 1
            if v1&lt;v2: return -1
            
            version1 = version1[1:] if version1 else ''
            version2 = version2[1:] if version2 else ''
    
        return 0
</code></pre>
<h1 id="166-fraction-to-recurring-decimal-medium">166. Fraction to Recurring Decimal （Medium）</h1>
<pre><code class="language-python">class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -&gt; str:
        negsign = (numerator&gt;0) ^ (denominator&gt;0)
        numerator= abs(numerator)
        denominator=abs(denominator)
        if numerator==0: negsign=False
        
        integer = numerator//denominator
        if integer*denominator==numerator:
            return str(integer) if not negsign else  '-'+str(integer)
        res_int = str(integer)
        
        numerator -= integer*denominator
        
        def loop(res_dec,denominator_len):
            l=len(res_dec)
            if l&gt;=2:
                for lookback in range(1,l//2+1):     
                    if lookback&gt;=denominator_len and res_dec[l-lookback:l] == res_dec[l-2*lookback :l-lookback] :
                        return True, l-2*lookback, lookback
            return False, 0,0
        res_dec = []
        while True:
            numerator *= 10
            val =numerator//denominator
            res_dec.append(val)
            #print(res_dec)
            flag, start,length =  loop(res_dec,len(str(denominator)))
            if flag:
                l=len(res_dec)
                part1 = res_dec[:start]
                recur = res_dec[start:start+length]
                part1=''.join([str(e) for e in part1])
                recur = '('+''.join([str(e) for e in recur]) +')' if recur else ''
                decpart=part1+recur
                result= res_int+'.'+decpart if decpart else res_int
                return result if not negsign else '-'+result
            numerator=numerator-val*denominator
            if numerator==0:
                break
        
        decpart=''.join([str(e) for e in res_dec])
        result=res_int+'.'+decpart if decpart else res_int
        return result if not negsign else '-'+result

#answer way of writting
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        &quot;&quot;&quot;
        :type numerator: int
        :type denominator: int
        :rtype: str
        &quot;&quot;&quot;
       
        if not numerator: return &quot;0&quot;;
        res=&quot;&quot;
        if  (numerator &lt; 0) ^ (denominator &lt; 0):
            res += '-'
        
        numer = numerator * (-1) if numerator &lt; 0 else numerator
            
        denom =  denominator * (-1) if denominator &lt; 0 else denominator;
        integral = numer // denom;
        res += str(integral);
        rmd = numer % denom;
        if  rmd==0: return res
        res += '.';
        rmd *= 10
        mp=dict() 
        while rmd:
            quotient = rmd / denom
            if rmd in mp:
                #res.insert(mp[rmd], 1, '(');
                res=res[:mp[rmd]]+'('+res[mp[rmd]:]
                res += ')'
                break
            
            mp[rmd] = len(res)
            res += str(quotient);
            rmd = (rmd % denom) * 10
        
        return res;
</code></pre>
<p>判断recurring，lookback需要长度大于被除数。不难但细节太多，垃圾题。答案写的很优雅。用了dict去存reminder，如果重复出现reminder说明存在重复。 我的方法是之间判断数组是否循环。答案更优雅。</p>
<h1 id="167-two-sum-ii-input-array-is-sorted-easy">167. Two Sum II - Input Array Is Sorted （Easy）</h1>
<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        length = len(numbers)
        l=0
        r=length-1
        while l&lt;r:
            if numbers[l]+numbers[r]==target:
                return [l+1,r+1]
            elif  numbers[l]+numbers[r]&lt;target:
                l+=1
            else:
                r-=1
</code></pre>
<p>sorterd 直接上two pointer了。</p>
<h1 id="font-colorred168-excel-sheet-column-title-easyfont"><font color='red'>168. Excel Sheet Column Title （Easy）</font></h1>
<pre><code class="language-python">class Solution:
    def convertToTitle(self, columnNumber: int) -&gt; str:
        # 26 进制数
        
      
        
        
        chars = 'ZABCDEFGHIJKLMNOPQRSTUVWXY'
        dic = dict()
        for i in range(26):
            dic[i]=chars[i]
        
        res = []
        while columnNumber:
            
            reminder = columnNumber%26
            #print(columnNumber,reminder)
            res.append(dic[reminder])
            columnNumber = columnNumber //26
            if reminder==0:
                columnNumber-=1
             
        return ''.join(res[::-1])
             
</code></pre>
<p>就是个26进制数转换问题，这个也能卡。。。 卡在的点为 if reminder==0:   columnNumber-=1<br>
如果没有余数恰巧除干净了，说明需要上一位减去一。</p>
<h1 id="font-colorred169-majority-element-easyfont"><font color='red'>169. Majority Element （Easy）</font></h1>
<pre><code class="language-python">class Solution:
    def majorityElement(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        
        maj = nums[0]
        c = 0
        for n in nums:
            if n==maj:
                c+=1
            else:
                c-=1
            
            if c==0:
                maj=n
                c=1
       
        
        return  maj

</code></pre>
<p>这个是个经典算法 摩尔投票算法，需要记住。 思路：遍历过程中不同元素之间两两抵消，由于一个数组中，出现次数超过n/2最多只有一个，那么遍历结束时，未被抵消掉的即是出现次数超过n/2的元素。在数组中maj元素出现一次，count就自加一次，如果出现了和maj不同的元素，说明maj可被抵消一次，count就自减一次，如果count减为0，也就说明maj元素已经被抵消完了， 更新maj。<br>
如果找超过1/3元素。 最多只有两个元素符合要求。需要设置maj1和count1、maj2和count2来分别记录这两个元素的抵消情况。如果出现了和maj1或maj2相同的元素，那么对应的count1和count2就自加1，如果元素与maj1和maj2都不相同，那么count1和count2就都应当自减1，如果maj1或maj2抵消掉后，就应当更新对应的maj1或maj2。NOTE 注意：  初始值 maj1和maj2、count1和count2相同，所以在判断二者与当前值是否相同时应当使用if else语句，而不是分开的两个if。此外，考虑到可能出现maj1和maj2都同时出现抵消掉的情况，所以也不能同时进行count自减和判断count1或count2是否为0，如果同时判断的话，那么maj1和maj2又会都同时成为当前元素了。</p>
<pre><code class="language-python">maj1=nums[0]
maj2=nums[0]
c1=0
c2=0

for n in nums:
   if n==maj1:
       c1+=1
   elif n==maj2:
       c2+=1
   elif c1==0:
       c1=1
       maj1=n
   elif c2==0:
       c2=1
       maj2=n
   else:
       c1-=1
       c2-=1
#recalce make sure        
c1=c2=0
for n in nums:
   if n==maj1:c1+=1
   if n==maj2:c2+=1
res=[]
if c1&gt;len(nums)//3:
   res.append(maj1)
if c2&gt;len(nums//3) and maj1!=maj2:
   res.append(maj2)
return res
</code></pre>
<h1 id="170-two-sum-iii-data-structure-design-easy">170. Two Sum III - Data structure design (Easy)</h1>
<pre><code class="language-python">class TwoSum:

    def __init__(self):
        self.stack = []
        

    def add(self, number: int) -&gt; None:
        self.stack.append(number)
        

    def find(self, value: int) -&gt; bool:
        dic= dict()
        for i,n in enumerate(self.stack):
            if value-n in dic:
                return True
            dic[n]=i
        return False
        


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)
</code></pre>
]]></content>
    </entry>
</feed>