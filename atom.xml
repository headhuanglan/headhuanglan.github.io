<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2021-12-26T05:50:34.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-29]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-29/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-29/">
        </link>
        <updated>2021-11-29T11:15:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue261-graph-valid-tree-mediumfont"><font color='blue'>261. Graph Valid Tree （Medium）</font></h1>
<p>You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.<br>
Return true if the edges of the given graph make up a valid tree, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent = [None]*n
            self.rank = [0]*n
            for i in range(n):
                self.parent[i]=i
                
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
    
        
    def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
        #UNIONFIND
        uf =self.UnionFind(n)
        for (a,b) in edges:
            uf.union(a,b)
        
        if len(set( [uf.find(i) for i in range(n)]))!=1:
            return False
    
        return len(edges)==n-1

#answer DFS
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            stack.append(neighbour)
    
    return len(seen) == n
#answer 
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = set()

    def dfs(node):
        if node in seen: return
        seen.add(node)
        for neighbour in adj_list[node]:
            dfs(neighbour)

    dfs(0)
    return len(seen) == n

#answer
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    queue = collections.deque([0])
    
    while queue:
        node = queue.popleft()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            queue.append(neighbour)
    
    return len(seen) == n
</code></pre>
<p>猜到了使用UnionFind做，但是还是copy了UnionFind Class 代码，还没熟练到自己写出来。 思路很简单，union后同一个parent，#edges+1=#node      答案思路：DFS或者BFS  判断是树1）n-1 edges， 2）graph fully connected。</p>
<h1 id="262-trips-and-users-hard">262. Trips and Users （Hard）</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
select   request_at as 'Day', round(sum(counter)/sum(total),2) as 'Cancellation Rate' from (
select CASE WHEN Trips.status='completed' THEN 0 else 1 END as counter, 1 as total, Trips.request_at  from
Trips left join Users c on Trips.client_id=c.users_id left join Users d on Trips.driver_id=d.users_id where c.banned!='Yes' and d.banned!='Yes'
) tmp  where Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot; group by request_at

#ANSWER 
SELECT Request_at as Day,
ROUND(SUM(CASE WHEN Status!=&quot;completed&quot; THEN 1 ELSE 0 END)/COUNT(*),2) as &quot;Cancellation Rate&quot; 
FROM Trips
WHERE Client_Id NOT IN
(
    SELECT Users_Id FROM Users
    WHERE Banned=&quot;Yes&quot;
)
AND Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot;
GROUP BY Request_at;
</code></pre>
<h1 id="263-ugly-number-easy">263. Ugly Number (Easy)</h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return true if n is an ugly number.</p>
<pre><code class="language-python">class Solution:
    def isUgly(self, n: int) -&gt; bool:
        if n==0: return False
        if n==1: return True
        
        while n%2==0:
            n//=2
        if n==1: return True
        while n%3==0:
            n//=3
        if n==1: return True
        while n%5==0:
            n//=5
        if n==1: return True
        
        return False

</code></pre>
<h1 id="font-colorred264-ugly-number-ii-medium-font"><font color='red'>264. Ugly Number II (Medium) </font></h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return the nth ugly number.</p>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [0] * n
        t2 = t3 = t5 = 0
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
            if(dp[i] == dp[t2]*2): t2 += 1
            if(dp[i] == dp[t3]*3): t3 += 1
            if(dp[i] == dp[t5]*5): t5 += 1
        return dp[-1]

</code></pre>
<p>没思路 。。。或者知道思路但写不出代码。  要是添加2倍，3倍，4倍，5倍还是会有空隙当n很大时候。 答案，用了dynamic programming。 思路是多个pointer。 t2，t3，t5记录已经遍历的数字里2，3，5都有多少个。 关键点是找到下一个最小的ugly number当乘以2，3，5时候。 又因为已经存在的数字只能被2，3，5乘1次，所以可以用pointer保持下次2，3，5要乘以的位置。</p>
<h1 id="265-paint-house-ii-hard">265. Paint House II （Hard）</h1>
<p>There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br>
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.</p>
<pre><code class="language-python">class Solution:
    def minCostII(self, costs: List[List[int]]) -&gt; int:
        #  cost last =     [a1,a2,a3,a4]
        #  cost last-1 =   [a1'+min(a2,a3,a4),a2'+min(a1,a3,a4),...]
        #  ...
        #  cost  0     =    [a1''',a2'''....]
        # ans= min(cost0)
        for i in range(len(costs)-2,-1,-1):
            for ii in range(len(costs[0])):
                costs[i][ii] = costs[i][ii]+min([costs[i+1][jj] for jj in range(len(costs[0])) if jj!=ii])
        
        return min(costs[0])
</code></pre>
<h1 id="266-palindrome-permutation-easy">266. Palindrome Permutation (Easy)</h1>
<p>Given a string s, return true if a permutation of the string could form a palindrome.</p>
<pre><code class="language-python">class Solution:
    def canPermutePalindrome(self, s: str) -&gt; bool:
        #odd occurance can not &gt;1
        dic = collections.Counter(s)
        c=0
        for k,v in dic.items():
            if v%2==1:
                c+=1
            if c&gt;1:
                return False
        return True
</code></pre>
<h1 id="267-palindrome-permutation-ii-medium">267. Palindrome Permutation II (Medium)</h1>
<pre><code class="language-python">class Solution:
    def generatePalindromes(self, s: str) -&gt; List[str]:
        dic = collections.Counter(s)
        c = 0
        odd_char = ''
        odd_c = 0
        for k,v in dic.items():
            if v%2==1:
                c+=1
                odd_char = k
                odd_c = v
        if c&gt;1: return []
        if len(dic)==1:
            return [list(dic.keys())[0]*dic[list(dic.keys())[0]]]
        if odd_char:
            tmp=odd_char
            dic[odd_char]-=1
            if dic[odd_char]&lt;=0:
                del dic[odd_char]
                 
        res = []
        def bt(dic,tmp):
            if len(tmp)==len(s):
                res.append(tmp)
                return
            
            for k,v in dic.items():
                dic_copy = dic.copy()
                tmp = k+tmp+k
                dic_copy[k]-=2
                if dic_copy[k]==0:
                    del dic_copy[k]
                #print(tmp,dic_copy)
                bt(dic_copy,tmp)
                tmp=tmp[1:-1]

            
        bt(dic,odd_char)
        return  res
</code></pre>
<p>backtracking 分为odd 元素存在时候，中间位置只能是odd元素，然后从中间向两边扩展。</p>
<h1 id="268-missing-number-easy">268. Missing Number （Easy）</h1>
<p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n=len(nums)
        return (0+n)*(n+1)//2 - sum(nums)
</code></pre>
<h1 id="font-colorred269-alien-dictionary-hard-font"><font color='red'>269. Alien Dictionary (Hard) </font></h1>
<p>There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.<br>
You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.<br>
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return &quot;&quot;. If there are multiple solutions, return any of them.<br>
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length &lt; t.length.<br>
Input: words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]<br>
Output: &quot;wertf&quot;</p>
<pre><code class="language-python">class Solution:
     
    
    from collections import defaultdict, Counter, deque

    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: create data structures + the in_degree of each unique letter to 0.
        adj_list = defaultdict(set)
        in_degree = Counter({c : 0 for word in words for c in word})

        # Step 1: We need to populate adj_list and in_degree.
        # For each pair of adjacent words...
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d:
                    if d not in adj_list[c]:
                        adj_list[c].add(d)
                        in_degree[d] += 1
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): return &quot;&quot;

        # Step 2: We need to repeatedly pick off nodes with an indegree of 0.
        output = []
        queue = deque([c for c in in_degree if in_degree[c] == 0])
        while queue:
            c = queue.popleft()
            output.append(c)
            for d in adj_list[c]:
                in_degree[d] -= 1
                if in_degree[d] == 0:
                    queue.append(d)

        # If not all letters are in output, that means there was a cycle and so
        # no valid ordering. Return &quot;&quot; as per the problem description.
        if len(output) &lt; len(in_degree):
            return &quot;&quot;
        # Otherwise, convert the ordering we found into a string and return it.
        return &quot;&quot;.join(output)

#DFS topo sorter reverse adj list and using grey black for node color

class Solution:
    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: Put all unique letters into the adj list.
        reverse_adj_list = {c : [] for word in words for c in word}

        # Step 1: Find all edges and put them in reverse_adj_list.
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d: 
                    reverse_adj_list[d].append(c)
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): 
                    return &quot;&quot;

        # Step 2: Depth-first search.
        seen = {} # False = grey, True = black.
        output = []
        def visit(node):  # Return True iff there are no cycles.
            if node in seen:
                return seen[node] # If this node was grey (False), a cycle was detected.
            seen[node] = False # Mark node as grey.
            for next_node in reverse_adj_list[node]:
                result = visit(next_node)
                if not result: 
                    return False # Cycle was detected lower down.
            seen[node] = True # Mark node as black.
            output.append(node)
            return True

        if not all(visit(node) for node in reverse_adj_list):
            return &quot;&quot;

        return &quot;&quot;.join(output)


</code></pre>
<p>很明显图论相关的题，没复习到还，看答案。思路：1）找到dependence rules， 2）topological sort。用queue来存indegree=0的node，然后遍历neighbors。或者DFS，revse adj list 然后为了防止有环，需要标注node color white grey black。</p>
<pre><code class="language-python">for item in container:
    if search_something(item):
        # Found it!
        process(item)
        break
else:
    # Didn't find anything..
    not_found_in_container()

</code></pre>
<p>这个语法从来没见过，for后面可以带一个else表明for loop中没有break的条件，else 来执行后续操作。</p>
<h1 id="270-closest-binary-search-tree-value-easy">270. Closest Binary Search Tree Value （Easy）</h1>
<p>Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -&gt; int:
        if not root.left and not root.right: return root.val
        if not root.right:
            if target&lt;root.val:
                res=self.closestValue(root.left,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        if not root.left:
            if target&gt;root.val:
                res = self.closestValue(root.right,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        
        if target==root.val:
            return root.val
        elif target&lt;root.val:
            res = self.closestValue(root.left,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val
        else:
            res= self.closestValue(root.right,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val

#ANSWER
class Solution:
    def closestValue(self, root: TreeNode, target: float) -&gt; int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            root = root.left if target &lt; root.val else root.right
        return closest
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-28]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-28/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-28/">
        </link>
        <updated>2021-11-27T20:14:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="251-flatten-2d-vector-medium">251. Flatten 2D Vector (Medium)</h1>
<p>Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.<br>
Implement the Vector2D class:<br>
Vector2D(int[][] vec) initializes the object with the 2D vector vec.<br>
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.<br>
hasNext() returns true if there are still some elements in the vector, and false otherwise.</p>
<pre><code class="language-python">class Vector2D:

    def __init__(self, vec: List[List[int]]):
        self.stack=[]
        self.vec=vec

    def next(self) -&gt; int:
        if self.hasNext():
            val=self.stack.pop(0)
        return val

    def hasNext(self) -&gt; bool:
        if not self.stack:
            if not self.vec:
                return False
            row=self.vec.pop(0)
            if not row: 
                if self.hasNext():
                    return True
                else:
                    return False
            for e in row:
                self.stack.append(e)
        return True


# Your Vector2D object will be instantiated and called as such:
# obj = Vector2D(vec)
# param_1 = obj.next()
# param_2 = obj.hasNext()
#answer way of writing
class Vector2D:

    def __init__(self, v: List[List[int]]):
        # We need to iterate over the 2D vector, getting all the integers
        # out of it and putting them into the nums list.
         
        self.nums = []
        for inner_list in v:
            for num in inner_list:
                self.nums.append(num)
        # We'll keep position 1 behind the next number to return.
        self.position = -1

    def next(self) -&gt; int:
        # Move up to the current element and return it.
        self.position += 1
        return self.nums[self.position]

    def hasNext(self) -&gt; bool:
        # If the next position is a valid index of nums, return True.
        return self.position + 1 &lt; len(self.nums)

</code></pre>
<p>自己写的这个递归调用比较tricky。。。答案很简答。</p>
<h1 id="252-meeting-rooms-easy">252. Meeting Rooms （Easy）</h1>
<p>Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.</p>
<pre><code class="language-python">class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool:
        intervals=sorted(intervals,key=lambda x:x[0])
        pre_end = None
        for interval in intervals:
            if pre_end is not None and interval[0]&lt;pre_end:
                return False
            pre_end = interval[1]
        return True
</code></pre>
<h1 id="font-colorblue253-meeting-rooms-ii-medium-font"><font color='blue'>253. Meeting Rooms II (Medium) </font></h1>
<p>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</p>
<pre><code class="language-python">class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:
        #find max overlapping interval num
        res=1
        c=0
        #at start +=1 at end -=1
        dic=dict()
        for interval in intervals:
            start,end=interval[0],interval[1]
            if start in dic:
                dic[start]+=1
            else:
                dic[start]=1
            
            if end in dic:
                dic[end]-=1
            else:
                dic[end]=-1
        
        for k in sorted(dic.keys()):
            c+=dic[k]
            res=max(res,c)
        return res
</code></pre>
<p>虽然做出来了，感觉下次再做可能会忘记怎么做的， 思路： 把所有时节节点从小到大排序，如果是start， counter+=1 如果是end， counter-=1， 找出counter变化过程中最大值。 答案做的感觉没自己的思路简单。</p>
<h1 id="font-colorred-254-factor-combinations-mediumfont"><font color='red'> 254. Factor Combinations （Medium）</font></h1>
<p>Numbers can be regarded as the product of their factors.</p>
<pre><code>For example, 8 = 2 x 2 x 2 = 2 x 4.
</code></pre>
<p>Given an integer n, return all possible combinations of its factors. You may return the answer in any order.</p>
<p>Note that the factors should be in the range [2, n - 1].</p>
<pre><code class="language-python">#Iterative:

def getFactors(self, n):
    todo, combis = [(n, 2, [])], []
    while todo:
        n, i, combi = todo.pop()
        while i * i &lt;= n:
            if n % i == 0:
                combis += combi + [i, n/i],
                todo += (n/i, i, combi+[i]),
            i += 1
    return combis

#Recursive:

class Solution:
    def getFactors(self, n: int) -&gt; List[List[int]]:
        
        res=[]
        def factor(n, i, tmp):
            while i * i &lt;= n:
                if n % i == 0:
                    res.append(tmp + [i, n//i])
                    factor(n//i, i, tmp+[i])
                i += 1
        factor(n, 2, [])
        return res

</code></pre>
<p>思路类似，但是还是没写粗来，这个不应该， res 先append  tmp+[i,n//i],然后再factor（n//i， i，tmp+【i】，res）</p>
<h1 id="font-colorred255-verify-preorder-sequence-in-binary-search-tree-mediumfont"><font color='red'>255. Verify Preorder Sequence in Binary Search Tree （Medium）</font></h1>
<pre><code class="language-python">def verifyPreorder(self, preorder):
    stack = []
    low = float('-inf')
    for p in preorder:
        if p &lt; low:
            return False
        while stack and p &gt; stack[-1]:
            low = stack.pop()
        stack.append(p)
    return True
</code></pre>
<p>没思路，答案思路： 模拟traversal，stack是左子树的栈。 如果下一个数小于栈顶，说明还在左子树，所以append。  如果当前preorder值大于栈顶，所有小于当前值元素出栈。说明当前元素跳到了右子树。low=stack.pop() 很巧妙， lower bound是满足小于当前值的最后一个pop出去的元素。</p>
<h1 id="font-colorred256-paint-house-mediumfont"><font color='red'>256. Paint House （Medium）</font></h1>
<p>Input: costs = [[17,2,17],[16,16,5],[14,3,19]]<br>
Output: 10<br>
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>
Minimum cost: 2 + 5 + 3 = 10.</p>
<pre><code class="language-python">class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        mem=dict()
        def paint(n,color):
            if (n,color) in mem:
                return mem[(n,color)]
            res = costs[n][color]
            
            if n!=len(costs)-1:
                if color==0:
                    res+=min(paint(n+1,1),paint(n+1,2))
                elif color==1:
                    res+=min(paint(n+1,0),paint(n+1,2))
                else:
                    res+=min(paint(n+1,0),paint(n+1,1))
            mem[(n,color)]=res
            return res
       
        return min([paint(0,0),paint(0,1),paint(0,2)])

#
class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        if not costs:return 0
        for n in range(len(costs)-2,-1,-1):
            costs[n][0]+=min(costs[n+1][1],costs[n+1][2])
            costs[n][1]+=min(costs[n+1][0],costs[n+1][2])
            costs[n][2]+=min(costs[n+1][0],costs[n+1][1])
        return min(costs[0])
</code></pre>
<p>这个应该是递归mem的经典题和dp的经典题。用dynamic programming，但是写出来一版是错的。。。应该定义dp=【#costs】【#color】。从最后一个房子开始， 倒数第二个 cost红=最后一个min（绿，蓝），。。。</p>
<h1 id="257-binary-tree-paths-easy">257. Binary Tree Paths （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:
        res=[]
        def bt(tmp,node):
            if not node: return
            if not node.left and not node.right:
                tmp.append(str(node.val))
                res.append('-&gt;'.join(tmp))
                return
            tmp.append(str(node.val))
            bt(tmp[:],node.left)
            bt(tmp[:],node.right)
        bt([],root)
        return res
</code></pre>
<h1 id="258-add-digits-easy">258. Add Digits (Easy)</h1>
<pre><code class="language-python">class Solution:
    def addDigits(self, num: int) -&gt; int:
        res = 0
        while num:
            #
            tmp=0
            while num:
                lastdig = num%10
                num=num//10
                tmp+=lastdig
            num=tmp
            if num&gt;=0 and num&lt;=9:
                return num
        
        return res 
# answer way of writing
class Solution:
    def addDigits(self, num: int) -&gt; int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9
</code></pre>
<p>答案用了一个数能被九整除，那么他们所有位数和能被9整除。</p>
<h1 id="font-colorblue259-3sum-smaller-mediumfont"><font color='blue'>259. 3Sum Smaller （Medium）</font></h1>
<p>Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<pre><code class="language-python">class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            for left in range(start+1,len(nums)-1):
                right=left+1
                if nums[start]+nums[left]+nums[right]&gt;target:continue
                
                while  right&lt;len(nums) and nums[start]+nums[left]+nums[right]&lt;target:
                    res+=1
                    right+=1
                
               
        return res

#answer
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            tar = target-nums[start]
            #become two sum question
            left=start+1
            right=len(nums)-1
            while left&lt;right:
                #print('@',left,right,tar)
                if nums[left]+nums[right]&lt;tar:
                    #print(left,right)
                    res+=right-left
                    left+=1
                else:
                    right-=1
            
        return res
</code></pre>
<p>写出来个暴力解。。。 几乎是O(n^3)....  O（n^2）思路, 选出一个数字，把3sum转成2sum，然后定义left=start+1，right=len（nums）-1， 若left +right 值小于target 说明 left 到right所有都满足条件，这样left+1求解下一步， 若left +right 值大于target说明right太大得减1.</p>
<h1 id="font-colorred260-single-number-iii-mediumfont"><font color='red'>260. Single Number III （Medium）</font></h1>
<p>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.</p>
<p>You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xor=0
        for n in nums:
            xor = xor^n
        
        # rightmost 1-bit diff between a and b
        diff = xor &amp; -xor
        
        a=0
        for n in nums:
            if n&amp;diff:
                # diff means a's last bit is diff then b's last bit
                # by using this filter we could get a 
                a= a^n
        return [a,xor^a]

</code></pre>
<p>没思路， one pass 只能找出xor=a^b  但不能确定出a，b具体值。<br>
答案思路：用了一个不知道的trick， x &amp; (-x) 保留x中最右边bit，设置其他bit为0.   这样就能用a，b 的diff bit把所有数字过滤一次，只有a可以被过滤出来，因为a的diff bit是1 其余diff bit是1的都出现了2次抵消了。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[书单]]></title>
        <id>https://headhuanglan.github.io/post/shu-dan/</id>
        <link href="https://headhuanglan.github.io/post/shu-dan/">
        </link>
        <updated>2021-11-27T06:31:55.000Z</updated>
        <summary type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
]]></summary>
        <content type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
<!-- more -->
<p><a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史5</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画世界史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf">半小时漫画世界史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画科学史1 2 3全 MOBI</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画预防常见病</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-27]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-27/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-27/">
        </link>
        <updated>2021-11-27T03:05:28.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-241-different-ways-to-add-parentheses-mediumfont"><font color='red'> 241. Different Ways to Add Parentheses （Medium）</font></h1>
<p>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def diffWaysToCompute(self, expression: str) -&gt; List[int]:
        if not expression: return []
         
        exp = []
        start=0
        i=0
        while i&lt;len(expression):
            if expression[i].isdigit():
                i+=1
            else:
                exp.append(expression[start:i])
                exp.append(expression[i])
                start=i+1
                i+=1
        exp.append(expression[start:])
        
        
        #basecase
        res = []
        if len(exp)==1 and ('+' not in exp) and ('-' not in exp) and ('*' not in exp):
            res=[int(exp[0])]
        
        
        for i, op in enumerate(exp):
            if not op.isdigit():
                left = self.diffWaysToCompute(''.join(exp[:i]))
                right= self.diffWaysToCompute(''.join(exp[i+1:]))
                if op=='+':
                    for l in left:
                        for r in right:
                            res.append(l+r)
                elif op=='-':
                     for l in left:
                        for r in right:
                            res.append(l-r)
                else:
                     for l in left:
                        for r in right:
                            res.append(l*r)
                      
 
        return res

</code></pre>
<p>感觉是backtracking但写code出现了问题。。。并不是 a+(b+...)   和 (a+b)+.... 这2种情况， 而是 （left）+ （right）产生不同的组合。  思路错误导致没写出来。。写了个bug。</p>
<h1 id="242-valid-anagram-easy">242. Valid Anagram （Easy）</h1>
<pre><code class="language-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        return collections.Counter(s)==collections.Counter(t)
</code></pre>
<p>答案用了26个字符的数组存储出现次数，s出现+1，t出现-1. 这样相等时候所有位置都应该是0.</p>
<h1 id="243-shortest-word-distance-easy">243. Shortest Word Distance (Easy)</h1>
<pre><code class="language-python">class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        visited = dict()
        res=float('inf')
        for i,w in enumerate(wordsDict):
            if w==word1 and word2 in visited:
                res=min(res,i-visited[word2])
            if w==word2 and word1 in visited:
                res=min(res,i-visited[word1])
            visited[w]=i
        return res

</code></pre>
<h1 id="244-shortest-word-distance-ii-medium">244. Shortest Word Distance II (Medium)</h1>
<pre><code class="language-python">class WordDistance:

    def __init__(self, wordsDict: List[str]):
        self.dic = collections.defaultdict(list)
        for i,w in enumerate(wordsDict):
            self.dic[w].append(i)
        

    def shortest(self, word1: str, word2: str) -&gt; int:
        res=float('inf')
        for pos1 in self.dic[word1]:
            for pos2 in self.dic[word2]:
                res=min(res,abs(pos2-pos1))
        return res
</code></pre>
<h1 id="245-shortest-word-distance-iii-medium">245. Shortest Word Distance III (Medium)</h1>
<pre><code class="language-python">class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int:
        dic=dict()
        res = float('inf')
        for i, w in enumerate(wordsDict):
            if w==word1 and word2 in dic:
                res=min(res,i-dic[word2])
            if w==word2 and word1 in dic:
                res=min(res,i-dic[word1])
            
            dic[w]=i
        return res

</code></pre>
<h1 id="246-strobogrammatic-number-easy">246. Strobogrammatic Number (Easy)</h1>
<pre><code class="language-python">class Solution:
    def isStrobogrammatic(self, num: str) -&gt; bool:
        # 1 6 9 8 0
        if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
            return False
        dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
        num2= ''.join([dic[e] for e in num][::-1])
        return num==num2

</code></pre>
<h1 id="font-colorred247-strobogrammatic-number-ii-medium-font"><font color='red'>247. Strobogrammatic Number II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        if n==1: return [&quot;0&quot;,&quot;1&quot;,&quot;8&quot;]
        nums=['0','1','6','8','9']
        
        def isStrobogrammatic(num: str) -&gt; bool:
            if '2' in num or '3' in num or '4' in num or '5' in num or '7' in num:
                return False
            dic={'6':'9','9':'6','1':'1','8':'8','0':'0'}
            num2= ''.join([dic[e] for e in num][::-1])
            return num==num2
        
        res = []
        def bt(tmp):
            if len(tmp)==n:
                sb = ''.join(tmp[:])
                if isStrobogrammatic(sb) and sb[0]!='0':
                    res.append(sb)
                return 
            for cur in nums:
                tmp.append(cur)
                bt(tmp)
                tmp.pop()
        
        bt([])
        return res
#answer way of writting
class Solution:
    def findStrobogrammatic(self, n: int) -&gt; List[str]:
        evenMidCandidate = [&quot;11&quot;,&quot;69&quot;,&quot;88&quot;,&quot;96&quot;, &quot;00&quot;]
        oddMidCandidate = [&quot;0&quot;, &quot;1&quot;, &quot;8&quot;]
        if n == 1:
            return oddMidCandidate
        if n == 2:
            return evenMidCandidate[:-1]
        if n % 2:
            pre, midCandidate = self.findStrobogrammatic(n-1), oddMidCandidate
        else: 
            pre, midCandidate = self.findStrobogrammatic(n-2), evenMidCandidate
        premid = (n-1)//2
        return [p[:premid] + c + p[premid:] for c in midCandidate for p in pre]
</code></pre>
<p>初次尝试， time limit exceeded。。。 backtracking属于暴力求解。 答案思路：<br>
n == 1: [0, 1, 8]<br>
n == 2: [11, 88, 69, 96]<br>
How about n == 3?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 2<br>
n == 4?<br>
=&gt; it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 2<br>
n == 5?<br>
=&gt; it can be retrieved if you insert [0, 1, 8] to the middle of solution of n == 4<br>
the same, for n == 6, it can be retrieved if you insert [11, 88, 69, 96, 00] to the middle of solution of n == 4</p>
<h1 id="font-colorred248-strobogrammatic-number-iii-hard-font"><font color='red'>248. Strobogrammatic Number III （Hard） </font></h1>
<pre><code class="language-python">class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -&gt; int:
        
        
        dic = {'0': '0','1': '1','6': '9','8': '8','9': '6'}    
        count=[0] # count as list can be modifed without return 
        
        
        
        def dfs(low,high,c,left,right,count):
            if left&gt;right:
                s=''.join(c)
                if (len(s)==len(low) and s&lt;low) or (len(s)==len(high) and s&gt;high):
                    return 
                count[0]+=1
                return
            for k,v in dic.items():
                c[left]=k
                c[right]=v
                if len(c)!=1 and c[0]=='0':
                    continue
                if left==right and k!=v:
                    continue
                
                dfs(low,high,c,left+1,right-1,count)
        
        
        for length in range(len(low),len(high)+1):
   
            dfs(low, high, ['']*length, 0, length-1, count);
        
        return count[0]
    

</code></pre>
<p>give up, 思路 ， 构建length长度的满足条件的string，从两边向中间构建。  做dfs search。<br>
用247的办法也可以感觉。 然后过滤出low，high之间有多少个。</p>
<h1 id="249-group-shifted-strings-medium">249. Group Shifted Strings （Medium）</h1>
<p>We can shift a string by shifting each of its letters to its successive letter.</p>
<pre><code>For example, &quot;abc&quot; can be shifted to be &quot;bcd&quot;.
</code></pre>
<p>We can keep shifting the string to form a sequence.</p>
<pre><code>For example, we can keep shifting &quot;abc&quot; to form the sequence: &quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;.
</code></pre>
<p>Given an array of strings strings, group all strings[i] that belong to the same shifting sequence. You may return the answer in any order.</p>
<pre><code class="language-python">
class Solution:
    def groupStrings(self, strings: List[str]) -&gt; List[List[str]]:
        dic = collections.defaultdict(list)
        for s in strings:
            if len(s)==1:
                dic['NULL'].append(s)
            else:
                key=[]
                for i in range(1,len(s)):
                    tmp = str((ord(s[i])-ord(s[i-1]))%26)
                    key.append(tmp)
                key='-'.join(key)
                dic[key].append(s)
        return dic.values()
</code></pre>
<h1 id="250-count-univalue-subtrees-medium">250. Count Univalue Subtrees (Medium)</h1>
<p>Given the root of a binary tree, return the number of uni-value subtrees.<br>
A uni-value subtree means all nodes of the subtree have the same value.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -&gt; int:
        
        count = [0]
        
        def isUnivalSubtrees(root):
            if not root:
                return False
            if not root.left and not root.right:
                count[0]+=1
                return True
            if not root.left:
                res = isUnivalSubtrees(root.right) and root.val==root.right.val
                if res:
                    count[0]+=1
                return res
            if not root.right:
                res= isUnivalSubtrees(root.left) and root.val==root.left.val
                if res:
                    count[0]+=1
                return res
            
            left = isUnivalSubtrees(root.left)
            right= isUnivalSubtrees(root.right)
            res=left and right and root.val==root.left.val and root.val==root.right.val
            if res:
                count[0]+=1
            return res
        
        isUnivalSubtrees(root)
        return count[0]

</code></pre>
<p>从上个题目获得的trick这个题目马上用到， count作为list，边run边更新不影响helper function的bool返回值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-26]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-26/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-26/">
        </link>
        <updated>2021-11-26T14:39:32.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="231-power-of-two-easy">231. Power of Two (Easy)</h1>
<p>Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;0: return False
        c=0
        while n:
            lastbit= n%2
            if lastbit==1:
                c+=1
            n=n&gt;&gt;1
        return c==1

#answer is great
class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        if n&lt;=0: return False
        # 1 000 000 000
        #    111 111 111
        return n&amp;(n-1)==0

</code></pre>
<h1 id="232-implement-queue-using-stacks-easy">232. Implement Queue using Stacks (Easy)</h1>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        

    def push(self, x: int) -&gt; None:
        self.s1.append(x)

    def pop(self) -&gt; int:
        # 1 2 3
        # 3 2 1
        while self.s1:
            self.s2.append(self.s1.pop())
        val=self.s2.pop()
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -&gt; int:
        pre=None
        while self.s1:
            cur=self.s1.pop()
            self.s2.append(cur)
            pre=cur
        while self.s2:
            self.s1.append(self.s2.pop())
        
        return pre
        

    def empty(self) -&gt; bool:
        return len(self.s1)==0


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</code></pre>
<p>Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity?</p>
<pre><code class="language-python">class MyQueue:

    def __init__(self):
        self.s1=[]
        self.s2=[]
        self.front=None

    def push(self, x: int) -&gt; None:
        if self.s1==[]:
            self.front=x
        self.s1.append(x)

    def pop(self) -&gt; int:
        if self.s2==[]:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&gt; int:
        if self.s2:
            return self.s2[-1]
        
        return self.front
          
        
    def empty(self) -&gt; bool:
        return self.s1==[] and self.s2==[]

</code></pre>
<p>follow up的思路挺有意思，push: 数字保存在s1，但是当s1为空时候，保存front。  pop：如果s2有元素，pop s2， 否则 把s1 push到s2    peek: 若s2 有元素，peek s2 否则 就是 front。</p>
<h1 id="font-colorred233-number-of-digit-one-hard-font"><font color='red'>233. Number of Digit One （Hard） </font></h1>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.<br>
Example：<br>
Input: n = 13<br>
Output: 6<br>
1，10， 11，12，13</p>
<pre><code class="language-python">class Solution:
    def countDigitOne(self, n: int) -&gt; int:
        c=0
        i=1
        while i&lt;=n:
            divider = i*10
            c += (n//divider)*i + min(max(n%divider -i+1,0),i)
            i*=10
        return c
</code></pre>
<p>完全不是考算法，对于个位来说，存在1的位置有，1，11，21，31，41，51，61，71 ... 基本10个一循环，比如 1到13的个位为1的有1，11，总共2个。 所以是 13//10 + (13%10)!=0。 对于十位来说存在1的有， 10，11，12，。。。19  |   110，111，112，113，。。。119| 210,...，每100个一循环，比如1到113的十位， (113/ 100) * 10 + min(max(113%100-10+1,0),10)   同理千位100,101,...199| 1100,1101....1199|....     千位中1的个数  (n/1000)*100 + min(max(n%1000-100+1,0),100)   具体的循环截断1的个数是在 0到 100之间， 具体多少是n%1000-100+1.</p>
<h1 id="234-palindrome-linked-list-easy">234. Palindrome Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:
        
        fast=slow=head
        
        while slow and fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        
        if fast:
            mid=slow.next
        else:
            mid=slow
            
        
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        revmid  = rev(mid)
        
        while revmid:
            if revmid.val!=head.val:
                return False
            revmid=revmid.next
            head=head.next
        return True
        #1 2 3 4 5
        #    s m
        #        f
                
        #1 2 3 4
        #    s
        #    m   f  
</code></pre>
<h1 id="font-colorred235-lowest-common-ancestor-of-a-binary-search-tree-easyfont">&lt;/font color='red'&gt;235. Lowest Common Ancestor of a Binary Search Tree （Easy）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        # 
        #    all left ,  all right,    p mid q
        #
        
        if root.val &gt; p.val and root.val &gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val &lt; p.val and root.val &lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

</code></pre>
<p>卡在了一道easy题上确实不应该。。。没仔细看题，忽略了这个是个BST，得用BST性质。</p>
<h1 id="font-colorblue-236-lowest-common-ancestor-of-a-binary-tree-medium-font"><font color='blue'> 236. Lowest Common Ancestor of a Binary Tree （Medium） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    dic=dict()
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        def find(root,node):
            if not root: return False
            if (root.val,node.val) in self.dic:
                return self.dic[(root.val,node.val)]
          
            if root.val==node.val:
                self.dic[(root.val,node.val)]=True
                return True
            if find(root.left,node):
                self.dic[(root.left.val,node.val)]=True
                return True
            if find(root.right,node):
                if root.right:
                    self.dic[(root.right.val,node.val)]=True
                return True
            return False
        
        if find(root.left,p) and find(root.left,q):
            return self.lowestCommonAncestor(root.left,p,q)
        elif find(root.right,p) and find(root.right,q):
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root
#answer way of writting
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        
        if root in [p,q,None]: return root
        
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        
        
        if left and right: 
            return root
        if left: 
            return left
        if right:
            return right
</code></pre>
<p>第一次尝试Time limit exceeded...，得找到p，q是在root的同侧还是异侧。 由于是递归调用，find funciton call了太多次，所以用memerization 方法， pass了。答案思路： 如果root 是{p,q,None} 就返回root， left=从root.left找p，q共同祖先， right=从root.right 找p，q共同祖先。</p>
<h1 id="237-delete-node-in-a-linked-list-easy">237. Delete Node in a Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        
      if node.next:
            node.val=node.next.val
            node.next=node.next.next
</code></pre>
<p>把下一位数字覆盖到当前node， 然后跳过这个node。</p>
<h1 id="238-product-of-array-except-self-medium">238. Product of Array Except Self （Medium）</h1>
<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>
<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>
<pre><code class="language-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        
        prefix_left = [1]*len(nums)
        prefix_right= [1]*len(nums)
        
        for i in range(1,len(nums)):
            prefix_left[i] = prefix_left[i-1]*nums[i-1]
        for j in range(len(nums)-2,-1,-1):
            prefix_right[j] = prefix_right[j+1]*nums[j+1]
        res = []    
        for (l,r) in zip(prefix_left,prefix_right):
            res.append(l*r)
        return res

</code></pre>
<h1 id="font-colorred239-sliding-window-maximum-hard-font"><font color='red'>239. Sliding Window Maximum (Hard) </font></h1>
<p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<pre><code class="language-python">
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        
        #if k==1: return nums
        
        stack_max = []
        queue = []
        res = []
        for n in nums:
            queue.append(n)
            
            
            while stack_max and n&gt;stack_max[-1]:
                stack_max.pop()
            if not stack_max or  n&gt;stack_max[-1]:
                stack_max.append(n)
            
            if len(queue)&gt;k:
                expired = queue.pop(0)
                if expired == stack_max[-1]:
                    stack_max.pop()
            
            if len(queue)==k:
                #print(queue,stack_max)
                if stack_max:
                    res.append(stack_max[-1])
                else:
                    #the expired one is the max and poped out
                    newmax=max(queue)
                    res.append(newmax)
                    stack_max.append(newmax)
            
        return res
#answer way of writting
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &quot;&quot;&quot;
        
        
        queue = collections.deque()
        res = []
        for i, n in enumerate(nums):
            while queue and n&gt; nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            #expire
            if queue[0] == i - k:
                queue.popleft()
            #can add to result
            if i &gt;= k - 1:
                res.append(nums[queue[0]])
        return res
    
#         if not nums:
#             return []
#         start=0
#         r=[]
#         while start+k&lt;=len(nums):
#             r.append(max(nums[start:start+k]))
#             start+=1
            
#         return r
</code></pre>
<p>初次尝试， time limit exceeded。  思路是一致的， 如果过期，踢掉， queue中保存最大值位置。</p>
<h1 id="font-colorblue240-search-a-2d-matrix-ii-mediumfont"><font color='blue'>240. Search a 2D Matrix II （Medium）</font></h1>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        
        
        def search(rowl,rowr,coll,colr,target):
            if rowl==rowr and coll==colr:
                return matrix[rowl][coll]==target
            elif rowl==rowr:
                return target in matrix[rowl]
            elif coll==colr:
                return target in [row[coll] for row in matrix]
            
            if  rowr-rowl==1 and colr-coll==1:    
                if matrix[rowl][coll]==target or matrix[rowr][colr]==target or matrix[rowr][coll]==target or matrix[rowl][colr]==target:
                    return True
                return False
            
            
            rowmid = (rowl+rowr)//2
            colmid = (coll+colr)//2
            if matrix[rowmid][colmid]==target:
                return True
            elif target&lt;matrix[rowmid][colmid]:
                return search(rowl,rowmid,coll,colmid,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            else:
                return search(rowmid,rowr,colmid,colr,target) or search(rowl,rowmid,colmid,colr,target) or search(rowmid,rowr,coll,colmid,target)
            
        
        return search(0,len(matrix)-1,0,len(matrix[0])-1,target)
</code></pre>
<p>用了分治法，虽然写出来了，但感觉写了陀X。 答案分治法</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target`
        if not matrix:
            return False

        def search_rec(left, up, right, down):
            # this submatrix has no height or no width.
            if left &gt; right or up &gt; down:
                return False
            # `target` is already larger than the largest element or smaller
            # than the smallest element in this submatrix.
            elif target &lt; matrix[up][left] or target &gt; matrix[down][right]:
                return False

            mid = left + (right-left) // 2

            # Locate `row` such that matrix[row-1][mid] &lt; target &lt; matrix[row][mid]
            row = up
            while row &lt;= down and matrix[row][mid] &lt;= target:
                if matrix[row][mid] == target:
                    return True
                row += 1
            
            return search_rec(left, row, mid - 1, down) or \
                   search_rec(mid + 1, up, right, row - 1)

        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)
</code></pre>
<p>最佳答案 思路 ： 从左下角开始，如果target大于cur, 列+1， 如果targe 小于cur，行-1.</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        # an empty matrix obviously does not contain `target` (make this check
        # because we want to cache `width` for efficiency's sake)
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        # cache these, as they won't change.
        height = len(matrix)
        width = len(matrix[0])

        # start our &quot;pointer&quot; in the bottom-left
        row = height - 1
        col = 0

        while col &lt; width and row &gt;= 0:
            if matrix[row][col] &gt; target:
                row -= 1
            elif matrix[row][col] &lt; target:
                col += 1
            else: # found it
                return True
        
        return False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-25]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-25/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-25/">
        </link>
        <updated>2021-11-25T08:23:51.000Z</updated>
        <summary type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感恩节假期中断了刷题，沉迷于半小时漫画系列... 补上月25进度。</p>
<!-- more -->
<h1 id="font-colorred-221-maximal-square-mediumfont"><font color='red'> 221. Maximal Square （Medium）</font></h1>
<p>Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>
<pre><code class="language-python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        rows=len(matrix)
        cols=len(matrix[0])
        maxqlen=0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j]=='1':
                    sqlen=1
                    flag=True
                    while sqlen+i&lt;rows and sqlen+j&lt; cols and flag:
                        for k in range(j,sqlen+j+1):
                            if matrix[i+sqlen][k]=='0':
                                flag=False
                                break
                        for k in range(i,i+sqlen+1):
                            if matrix[k][j+sqlen]=='0':
                                flag=False
                                break
                        if flag:
                            sqlen+=1
                    
                    if maxqlen&lt;sqlen:
                        maxqlen=sqlen
                        
                        
        return maxqlen**2

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        # dp[i][j]  size of box which bottom right in pos[i][j]
        # if matrix[i][j]==1
        #    dp[i][j]=   min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0]*(n+1) for _ in range(m+1)]
        res=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]=='1':
                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1
                    res=max(res,dp[i][j])
        return res**2
</code></pre>
<p>试着用cumsum去解但失败了， 方法1，暴力解。 每次发现是“1”就以它作为正方形左上角起始点， 检查 row: i，i+sqlen col: j, j+sqlen 是否有‘0’.<br>
方法2：dp： dp【i】【j】保存右下角位置在i，j的盒子大小。</p>
<h1 id="font-colorred-222-count-complete-tree-nodes-mediumfont"><font color='red'> 222. Count Complete Tree Nodes （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if not root.right:
            return 1+ self.countNodes(root.left)
        else:
            return  self.countNodes(root.left)+self.countNodes(root.right)+1


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -&gt; int:
        
        def depth(node):
            d=0
            while node.left:
                node=node.left
                d+=1
            return d
        
        def exists(idx,d,node):
            left=0
            right=2**d-1
            for _ in range(d):
                pivot = (left+right)//2
                if idx&lt;=pivot:
                    node=node.left
                    right=pivot
                else:
                    node=node.right
                    left=pivot +1
            return node is not None
        
        if not root: return 0
        d = depth(root)
        if d==0: return 1
        
        l=1
        r=2**d-1
        while l&lt;=r:
            mid = (l+r)//2
            if exists(mid,d,root):
                l=mid+1
            else:
                r=mid-1
        
        return (2**d-1) +l 
        
</code></pre>
<p>给出了个O（n）解法，但题目要求小于O(n)...<br>
思路： 完全二叉树，第0层2<sup>0个node，第一层，2</sup>1个node，第n层2^n个node，所以假设这个树深度为d=n， 不包含最后一层2<sup>0+2</sup>1+..+2<sup>(n-1)=2</sup>n  -  1 的所有node总和为2^d-1 ,问题转化成求最后一层有多少node。 范围在1~2^n.  因为d=n所以肯定有第一个node。  可以用binary search 求。</p>
<h1 id="223-rectangle-area-medium">223. Rectangle Area （Medium）</h1>
<pre><code class="language-python">class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&gt; int:
        
        # intersect of 1d line
        
        def intersect(a1,a2,b1,b2):
            if a1&gt;b1:
                a1,a2,b1,b2=b1,b2,a1,a2
            
            #print(a1,a2,b1,b2)
            #case 1  --
            #            --
            if a2&lt;b1:
                return 0
            
            #case 2   a1---a2
            #            b1---b2
            if b1&lt;=a2 and a2&lt;=b2:
                return a2-b1
            # case 3  a1------a2
            #            b1-b2
            if b1&lt;a2 and b2&lt;a2:
                return b2-b1
            
            return 'ERROR'
        
        width = intersect(ax1,ax2,bx1,bx2)
        height = intersect(by1,by2,ay1,ay2)
        print(width,height)
        return (ay2-ay1)*(ax2-ax1)+ (by2-by1)*(bx2-bx1)    -width*height

</code></pre>
<h1 id="font-colorred224-basic-calculator-hard-font"><font color='red'>224. Basic Calculator (Hard) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #1+1
        #1 1 +  
        #2-1+3
        #2 1 - 3 + 
        #(1+(4+5+2)-3)+(6-8)
        
        s='('+s+')'
        s_res=[]
        s_char=[]
        i=0
        while i&lt;len(s):
            e=s[i]
            if e==' ':
                i+=1
                continue
            elif e==')':
                while s_char[-1]!='(':
                    op=s_char.pop()
                    s_res.append(op)
                if s_char and s_char[-1]=='(':
                    s_char.pop()
            elif e in '(':
                s_char.append(e)
                    
            elif e in '+-':
                if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    s_res.append(0)
                    
                while s_char[-1] in '+-':
                    s_res.append(s_char.pop())
                s_char.append(e)
            else:
                #e is num
                tmp=int(e)
                while i+1&lt;len(s) and s[i+1] in '0123456789':
                    tmp = tmp*10+ int(s[i+1])
                    i+=1
                s_res.append(tmp)
            
                
            i+=1
        
                
        
        print(s_res)
        if '+' not in s_res and '-' not in s_res:
            return int(''.join(map(str,s_res)))
        
        res = []
        for e in s_res:
            if e=='+' or e=='-':
                b = res.pop() if res else None
                a = res.pop() if res else None
                
                
                if a is None:
                    if e=='+':
                        res.append(b)
                    else:
                        res.append(-b)
                
                else:    
                    if e=='+':
                        res.append(a+b) 
                    else:
                        res.append(a-b)
            else:
                res.append(e)
        #print(res)
        return res[0]

#通解
class Solution:
    def calculate(self, s: str) -&gt; int:
        
        # 转换为 后缀表达式
        # 运算符优先级
        prec = {}
        prec[&quot;*&quot;] = 3
        prec[&quot;/&quot;] = 3
        prec[&quot;+&quot;] = 2
        prec[&quot;-&quot;] = 2
        prec[&quot;(&quot;] = 1

        res = []
        stack = []
        i = 0
        while i &lt; len(s):
            # 数字 直接 接到后缀表达式上
            if s[i] == &quot; &quot;:
                i += 1
                
            elif s[i].isdigit():
                temp = &quot;&quot;
                while i &lt; len(s) and s[i].isdigit():
                    temp += s[i]
                    i += 1
                res.append(temp)

            # 左括号直接入栈
            elif s[i] == &quot;(&quot;:
                stack.append(s[i])
                i += 1

            # 右括号，开始弹栈，直达遇到左括号 左括号出栈 但不输出
            elif s[i] == &quot;)&quot;:
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() # 左括号出战， 但是不输出
                i += 1

            # 遇到运算符
            elif s[i] in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #  对 &quot;-2 + 2&quot; 或者 &quot;1-(-2)&quot; 进行特殊处理
                if s[i] == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
                    res.append('0')
                # 只要栈顶符号不低于当前符号，就一直输出。最后把当前符号入栈
                while stack and prec[s[i]]&lt;=prec[stack[-1]]:
                    res.append(stack.pop())
                stack.append(s[i])
                i += 1
        
        # 最后把栈里面的元素均 放到后缀表达式后面
        while stack:
            res.append(stack.pop())


        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char.isdigit():
                stack.append(int(char))
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(x/y)

        return stack.pop()
</code></pre>
<p>&quot; 2-1 + 2 &quot; 直接用stack解出现-1时候符号和1是合体的，所以换思路把表达式变成前缀/后坠表达。 又遇到后缀表达如何去括号问题。<br>
1 + (( 2 + 3)* 4 ) – 5   方法：  当读到数时，立即输出， 若读到操作符，判断符号与栈顶符号的优先级，若该符号优先级高于栈顶元素，则将该操作符入栈，否则就依次把栈中运算符弹出并加到后缀表达式尾端，但又遇到 &quot;1-(-2)&quot; 无法pass。 同理 &quot;- (3 - (- (4 + 5) ) )&quot; 无法pass。 负号不作为减法，作为符号。 需要特殊处理： 方法：</p>
<pre><code class="language-python">if e == &quot;-&quot; and (i == 0 or s[i-1] == &quot;(&quot; ):
    s_res.append(0)
</code></pre>
<p>答案很简单，问题根源在-号不能互相换 比如(A-B)+C != A-(B+C) , 所以把-看作数字的符号。</p>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:

        stack = []
        operand = 0
        res = 0 # For the on-going result
        sign = 1 # 1 means positive, -1 means negative  

        for ch in s:
            if ch.isdigit():
                # Forming operand, since it could be more than one digit
                operand = (operand * 10) + int(ch)

            elif ch == '+':
                # Evaluate the expression to the left,
                # with result, sign, operand
                res += sign * operand

                # Save the recently encountered '+' sign
                sign = 1
                # Reset operand
                operand = 0

            elif ch == '-':

                res += sign * operand
                sign = -1
                operand = 0

            elif ch == '(':

                # Push the result and sign on to the stack, for later
                # We push the result first, then sign
                stack.append(res)
                stack.append(sign)

                # Reset operand and result, as if new evaluation begins for the new sub-expression
                sign = 1
                res = 0

            elif ch == ')':

                # Evaluate the expression to the left
                # with result, sign and operand
                res += sign * operand

                # ')' marks end of expression within a set of parenthesis
                # Its result is multiplied with sign on top of stack
                # as stack.pop() is the sign before the parenthesis
                res *= stack.pop() # stack pop 1, sign

                # Then add to the next operand on the top.
                # as stack.pop() is the result calculated before this parenthesis
                # (operand on stack) + (sign on stack * (result from parenthesis))
                res += stack.pop() # stack pop 2, operand

                # Reset the operand
                operand = 0

        return res + sign * operand

</code></pre>
<h1 id="font-colorblue225-implement-stack-using-queues-easy-font"><font color='blue'>225. Implement Stack using Queues (Easy) </font></h1>
<pre><code class="language-python">class MyStack(object):
    def __init__(self):
        self._queue = collections.deque()

    def push(self, x):
        q = self._queue
        q.append(x)
        for _ in range(len(q) - 1):
            q.append(q.popleft())
 
    def pop(self):
        return self._queue.popleft()

    def top(self):
        return self._queue[0]
    
    def empty(self):
        return not len(self._queue)

</code></pre>
<p>三种方法</p>
<h1 id="226-invert-binary-tree-easy">226. Invert Binary Tree （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
        if not root: return root
        root.left,root.right = root.right,root.left
        root.left = self.invertTree(root.left)
        root.right=self.invertTree(root.right)
        return root

</code></pre>
<h1 id="font-colorblue227-basic-calculator-ii-medium-font"><font color='blue'>227. Basic Calculator II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        
        #convert to 后缀表达
        priority = {'+':1,'-':1,'*':2,'/':2,'(':0}
        res = [] #保存后缀表达式
        stack=[] #保存符号
        i=0
        while i&lt;len(s):
            ch=s[i]
            if ch.isdigit():
                tmp=ch
                while i+1&lt;len(s) and s[i+1].isdigit():
                    tmp+=s[i+1]
                    i+=1
                res.append(int(tmp))
            
            elif ch=='(':
                stack.append(ch)
            elif ch==')':
                while stack and stack[-1] != &quot;(&quot;:
                    res.append(stack.pop())
                stack.pop() 
            elif ch in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                
                while stack and priority[ch] &lt;= priority[stack[-1]]:
                    res.append(stack.pop())

                stack.append(ch)
            
            i+=1
                
        while stack:
            res.append(stack.pop())
        
        # 计算后缀表达式
        stack = []
        
        for char in res:
            if char not in  [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]:
                #char is number
                stack.append(char)
            else:
                x = stack.pop()
                y = stack.pop() 
                if char == &quot;+&quot;:
                    stack.append(x + y)
                elif char == &quot;-&quot;:
                    stack.append(y-x)
                elif char == &quot;*&quot;:
                    stack.append(y*x)
                elif char == &quot;/&quot;:
                    stack.append(y//x)

        return stack.pop()

</code></pre>
<p>直接上通杀法。转成后缀表达然后求结果。</p>
<h1 id="font-colorblue-228-summary-ranges-easy-font"><font color='blue'> 228. Summary Ranges （Easy） </font></h1>
<pre><code class="language-python">class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        # [0]
        # [0,1]
        # [0,2]
        # [0-2,4]
        # [0-2,4,5]
        
        res = []
        stack=[]
        for n in nums:
            if not stack:
                stack.append(n)
            elif len(stack)==1:
                if n==stack[-1]+1:
                    stack.append(n)
                else:
                    res.append(str(stack[-1]))
                    stack=[n]
            else:
                if n==stack[-1]+1:
                    stack[-1]=n
                else:
                    res.append(str(stack[0])+'-&gt;'+str(stack[1]))
                    stack=[n]
 
        if len(stack)==1:
            res.append(str(stack[0]))
        elif len(stack)==2:
            res.append(str(stack[0])+'-&gt;'+str(stack[1]))
        
        return res
#answer way of writting
class Solution:
    def summaryRanges(self, nums: List[int]) -&gt; List[str]:
        res = []
        i=0
        for j in range(len(nums)):
            if j+1&lt;len(nums) and nums[j+1]==nums[j]+1:
                continue
            if i==j:
                res.append(str(nums[i]))
            else:
                res.append(str(nums[i])+'-&gt;'+str(nums[j]))
            i=j+1
        return res

</code></pre>
<p>答案更简单</p>
<h1 id="font-colorred229-majority-element-ii-medium-font"><font color='red'>229. Majority Element II (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; List[int]:
        
        maj1=nums[0]
        maj2=nums[0]
        c1=0
        c2=0

        for n in nums:
            if n==maj1:
                c1+=1
            elif n==maj2:
                c2+=1
            elif c1==0:
                c1=1
                maj1=n
            elif c2==0:
                c2=1
                maj2=n
            else:
                c1-=1
                c2-=1
        #recalce make sure        
        c1=c2=0
        for n in nums:
            if n==maj1:c1+=1
            if n==maj2:c2+=1
        res=[]
        if c1&gt;len(nums)//3:
            res.append(maj1)
        if c2&gt;len(nums)//3 and maj1!=maj2:
            res.append(maj2)
        return res


</code></pre>
<p>经典算法，在做majorelement 1时候写过，需要记住。</p>
<h1 id="230-kth-smallest-element-in-a-bst-medium">230. Kth Smallest Element in a BST （Medium）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:
        ind=0
        stack=[]
        while root or stack:
            while root:
                stack.append(root)
                root=root.left
            
            node=stack.pop()
            ind+=1
            if ind==k:
                return node.val
            
            root=node.right
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-24]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-24/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-24/">
        </link>
        <updated>2021-11-24T15:05:08.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="211-design-add-and-search-words-data-structure-medium">211. Design Add and Search Words Data Structure （Medium）</h1>
<p>Design Add and Search Words Data Structure</p>
<pre><code class="language-python">class WordDictionary:

    def __init__(self):
        self.next = dict()
        self.isword= False
        

    def addWord(self, word: str) -&gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char]=WordDictionary()
            self.next[char].addWord(rest)
        else:
            self.isword=True
        

    def search(self, word: str) -&gt; bool:
        if not word:
            return self.isword
        char = word[0]
        rest = word[1:]
        if char!='.':
            if char not in self.next:
                return False
            else:
                return self.next[char].search(rest)
        else:
            return any([ node.search(rest) for key,node in self.next.items()])
        
        return True
        
</code></pre>
<p>Trie data structure</p>
<h1 id="font-colorred212-word-search-ii-hard-font"><font color='red'>212. Word Search II （Hard） </font></h1>
<p>Given an m x n board of characters and a list of strings words, return all words on the board.<br>
Input: board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]<br>
Output: [&quot;eat&quot;,&quot;oath&quot;]</p>
<pre><code class="language-python">class Solution:
   
    
    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:
        #trie + DFS
        class Trie:
            def __init__(self):
                self.next=dict()
                self.isword=False
            def addwords(self,word):
                if word:
                    char=word[0]
                    rest=word[1:]
                    if char not in self.next:
                        self.next[char]=  Trie()
                    self.next[char].addwords(rest)
                else:
                    self.isword=True           
                
            
        trie =  Trie()
        for word in words:
            trie.addwords(word)
       
        m=len(board)
        n=len(board[0])
        res = []
        def dfs(trie,board,i,j,tmp=''):
            if i&gt;=0 and i&lt;m and j&gt;=0 and j&lt;n:
                char= board[i][j]
                board[i][j]='#'
                tmp+=char
                if char in trie.next:
                    if trie.next[char].isword:
                        res.append(tmp)
                        trie.next[char].isword=False
                   
                    trie = trie.next[char]
                    dfs(trie,board,i+1,j,tmp)
                    dfs(trie,board,i-1,j,tmp)
                    dfs(trie,board,i,j+1,tmp)
                    dfs(trie,board,i,j-1,tmp)
                
                tmp = tmp[:-1]
                board[i][j] = char
              
            
        for i in range(m):
            for j in range(n):
                if board[i][j] in [word[0] for word in words]:
                    dfs(trie,board,i,j,'')
        
        return res

</code></pre>
<p>尝试trie+DFS , time limit exceeded.   什么地方没优化到？？ 原来是 发现isword时候 把isword设为False，这样就不会找到重复的word。</p>
<h1 id="213-house-robber-ii-medium">213. House Robber II （Medium）</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        # dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        # dp[0] = nums[0]
        # dp[1] = max(nums[:2])
        #
        # now circle constraint
        #
        # if select 0, -1 and 1 can not be selected
        #  dp[0] = nums[0]  dp[1] = dp[0] ... dp[-1]=dp[-2]
        # if not select 0, -1 and 1 can be selected
        #  dp[0] = 0 dp[1]=nums[1]  ... dp[-1]=dp[-2]+nums[-1]
        
        if len(nums)&lt;3:
            return max(nums)
       
        #case1) select 0
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=nums[0]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-1]
        res=max(dp)
        #case2)
        dp=[0]*len(nums)
        dp[0]=0
        dp[1]=nums[1]
        for i in range(2,len(nums)):
            if i!=len(nums)-1:
                dp[i]=max(dp[i-2]+nums[i],dp[i-1])
            else:
                dp[i]=dp[i-2]+nums[-1]
        res=max(res,max(dp))
        return res
</code></pre>
<p>因为循环数组，所以，分两种case， 抢劫第一户和不抢劫第一户。</p>
<h1 id="font-colorred214-shortest-palindrome-hardfont"><font color='red'>214. Shortest Palindrome （Hard）</font></h1>
<p>You are given a string s. You can convert s to a palindrome by adding characters in front of it.</p>
<pre><code class="language-python">class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        # brute force
        l=len(s)
        rev = ''.join(s[::-1])
        
        for i in range(l):
            if s[:l-i]==rev[i:]:
                return rev[:i]+s
        
        return ''
#KMP

class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        # KMP
        l=len(s)
        rev = ''.join(s[::-1])
        s_new = s +'#' + rev
        l_new = len(s_new)
        f = [0]*l_new
        for i in range(1,l_new):
            t = f[i-1]
            while t&gt;0 and s_new[i]!=s_new[t]:
                #can'f find prefix=sufix, t=f[t-1]
                t=f[t-1]
            if s_new[i]==s_new[t]:
                t+=1
            f[i]=t
        
        return rev[:l-f[l_new-1]] +s
</code></pre>
<p>思路： finding the largest palindrome substring from the beginning. O（n）方法用了KMP的loolup table。   rev[f[l_new-1]:]是形成回文的序列。和 s[:len(s)-f[l_new-1]] 是对应的，那么未形成回文的就是 rev[: f[l_new-1]] ，s+rev[: f[l_new-1]] 为答案。 s_new = s +'#' + rev 因为不加#会引起 2 strings could mix with each ther, producing wrong answer. For example, take the string &quot;aaaa&quot; . Had we not inserted &quot;#&quot; in the middle, the new string would be &quot;aaaaaaaa&quot;。</p>
<h1 id="215-kth-largest-element-in-an-array-medium">215. Kth Largest Element in an Array （Medium）</h1>
<pre><code class="language-python">class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        from heapq import heapify, heappush, heappop
        stack=[]
        for i,n in enumerate(nums):
            if len(stack)&lt;k:
                heappush(stack,n)
            else:
                tmp=heappop(stack)
                if n&lt;tmp:
                    heappush(stack,tmp)
                else:
                    heappush(stack,n)
         
        return heappop(stack)
###
class Solution:
    def findKthLargest(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        def partition(left, right, pivot_index):
            pivot = nums[pivot_index]
            # 1. move pivot to end
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  
            
            # 2. move all smaller elements to the left
            store_index = left
            for i in range(left, right):
                if nums[i] &lt; pivot:
                    nums[store_index], nums[i] = nums[i], nums[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            nums[right], nums[store_index] = nums[store_index], nums[right]  
            
            return store_index
        
        def select(left, right, k_smallest):
            &quot;&quot;&quot;
            Returns the k-th smallest element of list within left..right
            &quot;&quot;&quot;
            if left == right:       # If the list contains only one element,
                return nums[left]   # return that element
            
            # select a random pivot_index between 
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return nums[k_smallest]
            # go left
            elif k_smallest &lt; pivot_index:
                return select(left, pivot_index - 1, k_smallest)
            # go right
            else:
                return select(pivot_index + 1, right, k_smallest)

        # kth largest is (n - k)th smallest 
        return select(0, len(nums) - 1, len(nums) - k)
                
        
</code></pre>
<p>min heap<br>
第二种解法quicksort， O（n）<br>
Choose a random pivot.<br>
Use a partition algorithm to place the pivot into its perfect position pos in the sorted array, move smaller elements to the left of pivot, and larger or equal ones - to the right.<br>
Compare pos and N - k to choose the side of array to proceed recursively.</p>
<h1 id="216-combination-sum-iii-medium">216. Combination Sum III （Medium）</h1>
<p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:<br>
Only numbers 1 through 9 are used.<br>
Each number is used at most once.</p>
<pre><code class="language-python">class Solution:
    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:
        
        res = []
        def bt(start,tmp,target):
            if target&lt;0: return
            if len(tmp)==k and target==0:
                res.append(tmp[:])
            
            for i in range(start,10):
                tmp.append(i)
                target -= i
                bt(i+1,tmp,target)
                target+=i
                tmp.pop()
        bt(1,[],n)
        return res

</code></pre>
<h1 id="217-contains-duplicate-easy">217. Contains Duplicate (Easy)</h1>
<pre><code class="language-python">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        s = set()
        for n in nums:
            if n in s:
                return True
            s.add(n)
        return False
</code></pre>
<h1 id="font-colorred218-the-skyline-problem-hard-font"><font color='red'>218. The Skyline Problem (Hard) </font></h1>
<pre><code class="language-python">from heapq import * 
class Solution(object):
    def getSkyline(self, buildings):
        # add start-building events
        # also add end-building events(acts as buildings with 0 height)
        # and sort the events in left -&gt; right order
        events = [(L, -H, R) for L, R, H in buildings]
        events.extend([(R, 0, 0) for _, R, _ in buildings])
        events.sort()

        # res: result, [x, height]
        # live: heap, [-height, ending position]
        res = [[0,0]] 
        live = [(0, float(&quot;inf&quot;))]
        for pos, negH, R in events:
            # 1, pop buildings that are already ended
            # 2, if it's the start-building event, make the building alive
            # 3, if previous keypoint height != current highest height, edit the result
            while pos&gt;= live[0][1]:
                 heappop(live)
            if negH!=0:
                #start building event
                heappush(live, (negH, R))
            if res[-1][1] != -live[0][0]:
                res.append( [pos, -live[0][0]])
        return res[1:]

 #
class Solution:
    def getSkyline(self, buildings: 'List[List[int]]') -&gt; 'List[List[int]]':
        &quot;&quot;&quot;
        Divide-and-conquer algorithm to solve skyline problem,
        which is similar with the merge sort algorithm.
        &quot;&quot;&quot;
        n = len(buildings)
        # The base cases
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            return [[x_start, y], [x_end, 0]]

        # If there is more than one building,
        # recursively divide the input into two subproblems.
        left_skyline = self.getSkyline(buildings[: n // 2])
        right_skyline = self.getSkyline(buildings[n // 2 :])

        # Merge the results of subproblem together.
        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left, right):
        &quot;&quot;&quot;
        Merge two skylines together.
        &quot;&quot;&quot;
        def update_output(x, y):
            &quot;&quot;&quot;
            Update the final output with the new element.
            &quot;&quot;&quot;
            # if skyline change is not vertical -
            # add the new point
            if not output or output[-1][0] != x:
                output.append([x, y])
            # if skyline change is vertical -
            # update the last point
            else:
                output[-1][1] = y

        def append_skyline(p, lst, n, y, curr_y):
            &quot;&quot;&quot;
            Append the rest of the skyline elements with indice (p, n)
            to the final output.
            &quot;&quot;&quot;
            while p &lt; n:
                x, y = lst[p]
                p += 1
                if curr_y != y:
                    update_output(x, y)
                    curr_y = y

        n_l, n_r = len(left), len(right)
        p_l = p_r = 0
        curr_y  = left_y = right_y = 0
        output = []

        # while we're in the region where both skylines are present
        while p_l &lt; n_l and p_r &lt; n_r:
            point_l, point_r = left[p_l], right[p_r]
            # pick up the smallest x
            if point_l[0] &lt; point_r[0]:
                x, left_y = point_l
                p_l += 1
            else:
                x, right_y = point_r
                p_r += 1
            # max height (i.e. y) between both skylines
            max_y = max(left_y, right_y)
            # if there is a skyline change
            if curr_y != max_y:
                update_output(x, max_y)
                curr_y = max_y

        # there is only left skyline
        append_skyline(p_l, left, n_l, left_y, curr_y)

        # there is only right skyline
        append_skyline(p_r, right, n_r, right_y, curr_y)

        return output
</code></pre>
<p>感觉用stack做， 还是直接看答案了， 思路：事件驱动， events 包括开始建筑和终止建筑，【（L，-H，R），（R，0，0）.。。。】 这样遍历events，live存放【（-height，end pos）】 1, pop buildings that are already ended in live 2，if it's the start-building event, make the building alive， 3，if previous keypoint height != current highest height, edit the result， 思路2，分治法 O(Nlog⁡N)</p>
<h1 id="font-colorred219-contains-duplicate-ii-easy-font"><font color='red'>219. Contains Duplicate II （Easy） </font></h1>
<pre><code class="language-python">class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:
        s = set()
        k=k+1
        for i,n in enumerate(nums):
            if len(s)&lt;k:
                if n in s: return True
                #print('s add ',n)
                s.add(n)
            else:
                #remove outdated
                s.remove(nums[i-k])
                #print('s remove ',nums[i-k])
                if n in s:return True
                #print('s add',n)
                s.add(n)
        return False

## correct way of doing
class Solution:
    def containsNearbyDuplicate(self, nums: 'List[int]', k: 'int') -&gt; 'bool':
        dic=dict()
        
        for i,n in enumerate(nums):
            if n in dic:
                if abs(i-dic[n])&lt;=k:
                    return True
            dic[n]=i
        return False
</code></pre>
<p>two pointer timestap&lt;=k 过期，花的时间太长。。。， 正确方法还是用dict 存 mapping n=&gt; i. 这样当遇到重复的n判断  i-dic【n】距离是否小于k，小于则为True。</p>
<h1 id="font-colorred-220-contains-duplicate-iii-mediumfont"><font color='red' >220. Contains Duplicate III （Medium）</font></h1>
<pre><code class="language-python">class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool:
        if t&lt; 0: return False
        dic = dict()
        for i,n in enumerate(nums):
            #remove outdated 
            if i-k&gt;=0 and nums[i-k] in dic and dic[nums[i-k]]&lt;i-k:
                del dic[nums[i-k]] 
            
            #print(i,n,dic)
            
            #check 
            if any([abs(n-key)&lt;=t and abs(i-val)&lt;=k for key,val in dic.items()]):
                #print(i,n)
                #print(dic)
                return True
            
           
            #add current
            dic[n]=i
        return False

#
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -&gt; bool:
        #            0~9 10~19 .. 
        # buketid     0   1
        #   what is 9's buket id, 9//(9+1) 
        #   so bucket size = 10
        
        buket = dict()
        buket_size = t+1
        for i,n in enumerate(nums):
            buket_id  = n//buket_size
            if buket_id in buket or (buket_id-1 in buket and n-buket[buket_id-1]&lt;=t) or(buket_id+1 in buket and buket[buket_id+1]-n&lt;=t):
                return True
            
            buket[buket_id] = n
            if i&gt;=k:
                del buket[nums[i-k]//buket_size]
        return False
</code></pre>
<p>用过期del dict key方法会time limit exceeded。竟然是用bukets。检查当前buket 和上一个或者下一个buket。 这题应该是个hard。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-23]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-23/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-23/">
        </link>
        <updated>2021-11-22T05:20:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred201-bitwise-and-of-numbers-range-mediumfont"><font color='red'>201. Bitwise AND of Numbers Range （Medium）</font></h1>
<p>Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.</p>
<pre><code class="language-python">class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:
        if left==right: return left
        res = 0
        for pos in range(32):
            res |= 1 &lt;&lt; pos
            for n in range(left,right+1):
                if (n &amp; 1&lt;&lt;pos) &gt;&gt; pos ==0:
                    res ^= 1 &lt;&lt; pos
                    break
        return res

#answer way of writing
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&gt; int:
        shift = 0   
        # find the common 1-bits
        while m &lt; n:
            m = m &gt;&gt; 1
            n = n &gt;&gt; 1
            shift += 1
        return m &lt;&lt; shift
#
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&gt; int:
        while m &lt; n:
            # turn off rightmost 1-bit
            n = n &amp; (n - 1)
        return m &amp; n
</code></pre>
<p>初次尝试，time limit exceeded， 32位过一次，一旦发现在pos位上为0，就break。 还是速度慢，  after the AND operation on all the numbers, the remaining part of bit strings is the common prefix of all these bit strings.As a result, we then can reformulate the problem as &quot;given two integer numbers, we are asked to find the common prefix of their binary strings.&quot; 思路： shift 直到m n相等，然后再 shift back。 这样就找到了common prefix。另一解法，思路：关闭右侧最后是1的位，然后和左侧求&amp;。</p>
<blockquote>
<p>When we do AND bit operation between number and number-1, the rightmost bit of one in the original number would be turned off (from one to zero).</p>
</blockquote>
<h1 id="202-happy-number-easy">202. Happy Number （Easy）</h1>
<p>Write an algorithm to determine if a number n is happy.<br>
Input: n = 19<br>
Output: true<br>
Explanation:<br>
12 + 92 = 82<br>
82 + 22 = 68<br>
62 + 82 = 100<br>
12 + 02 + 02 = 1</p>
<pre><code class="language-python">class Solution:
    def isHappy(self, n: int) -&gt; bool:
        visited =set()
        
        while n!=1:
            if n in visited: return False
            visited.add(n)
            new_n =0
            while n:
                lastdig = n%10
                new_n += lastdig*lastdig
                n //= 10
            n=new_n
        
        return True
</code></pre>
<h1 id="203-remove-linked-list-elements-easy">203. Remove Linked List Elements （Easy）</h1>
<p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:
        if not head: return head
        dummyhead = ListNode(val='NULL',next=head)
        cur=dummyhead
        while cur and cur.next:
            while cur.next and cur.next.val==val:
                cur.next=cur.next.next
            cur=cur.next
        return dummyhead.next
</code></pre>
<h1 id="font-colorred204-count-primes-medium-font"><font color='red'>204. Count Primes (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def countPrimes(self, n: int) -&gt; int:
 
        if n &lt;=2:
            return 0
        primes = [True] * n
        primes[0] = primes[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if primes[i]:
                primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
        #如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。 
        return sum(primes)
</code></pre>
<p>直接用判断是否位质数方法会time limit exceeded。 思路：如果i是pime 比如i=2  那么 i的倍数肯定不是prime 从i**2 开始。</p>
<pre><code class="language-python">     def isP(num):
            for i in range(2,num//2+1):
                if num%i==0:
                    return False
            return True
</code></pre>
<h1 id="205-isomorphic-strings-easy">205. Isomorphic Strings （Easy）</h1>
<p>Given two strings s and t, determine if they are isomorphic.<br>
Two strings s and t are isomorphic if the characters in s can be replaced to get t.</p>
<pre><code class="language-python">class Solution:
    def isIsomorphic(self, s: str, t: str) -&gt; bool:
        if len(s)!=len(t): return False
        l=len(s)
        dic1 = dict()
        dic2 = dict()
        for i in range(l):
            a = s[i]
            b = t[i]
            if a in dic1:
                if dic1[a]!=b:
                    return False
            if b in dic2:
                if dic2[b]!=a:
                    return False
            dic1[a] = b
            dic2[b] = a
        return True
</code></pre>
<h1 id="206-reverse-linked-list-easy">206. Reverse Linked List (Easy)</h1>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        pre = None
        while head:
            headnext=head.next
            head.next = pre
            pre = head
            head=headnext
        return pre
</code></pre>
<h1 id="font-colorred207-course-schedule-medium-font"><font color='red'>207. Course Schedule (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #DFS 法    
        def dfs(node):
            # return True 无环 False 有环
            node.status=0
            for nei in node.nei:
                if nei.status==-1:
                    if not dfs(nei):
                        return False
                elif nei.status == 0:
                    return False
            
            node.status=1
            return True
        
        for node in nodes:
            if node.status==-1:
                if not dfs(node):
                    return False
        
        return True

# upper DFS lower BFS
class Solution:
    class Node:
        def __init__(self,val=None):
            self.val = val
            self.nei = []
            self.ind = 0 #indegree
            self.status = -1  # -1 not visited, 0 visiting, 1 visited
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        #  DAG 判断
        #
        # 建立graph
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for row in prerequisites:
            a,b =  row
            nodes[b].nei.append(nodes[a])
            nodes[a].ind+=1
        
        #bfs 法
        queue=[]
        cnt=0
        for node in nodes:
            if node.ind==0:
                queue.append(node)
        while queue:
            v=queue.pop(0)
            cnt+=1
            for nei in v.nei:
                nei.ind-=1
                if nei.ind==0:
                    queue.append(nei)
        
        return cnt==numCourses
</code></pre>
<p>感觉是图的算法，判断是否为DAG。BFS找入度为0的。  DFS时候，如果正在搜索某V，但又回到了V。证明有环路。注意需要3个状态来表示node状态， 【visited，visiting，not visited】<br>
需要补充拓扑排序算法解决变种题。</p>
<pre><code class="language-python"># TopoSort sudo
queue = []
for 图中每个顶点V:
    if indegree(V)==0:
        queue.append(V)
while queue:
    V=queue.pop(0)
    输出V，记录V的输出序号cnt++
    for V的每个邻居 W:
        indegree(W) -= 1
        if indegree(W)==0:
            queue.append(W)

if cnt!=|V|:
    ERROR(图中有回路)
</code></pre>
<h1 id="208-implement-trie-prefix-tree">208. Implement Trie (Prefix Tree)</h1>
<pre><code class="language-python">class Trie:

    def __init__(self):
        self.next= dict()
        self.isword=False
 

    def insert(self, word: str) -&gt; None:
        if word:
            char = word[0]
            rest = word[1:]
            if char not in self.next:
                self.next[char] = Trie()
            self.next[char].insert(rest)
        else:
            self.isword=True
             

    def search(self, word: str) -&gt; bool:
       
        if not word:
            return self.isword
        
        char = word[0]
        rest = word[1:]
        if char in self.next:
            if not self.next[char].search(rest):
                return False
        else:
            return False
        return True
        

    def startsWith(self, prefix: str) -&gt; bool:
        if not prefix:
            return True
        
        char=prefix[0]
        rest=prefix[1:]
        if char in self.next:
            if not self.next[char].startsWith(rest):
                return False
        else:
            return False
        
        return True
        
</code></pre>
<h1 id="font-colorblue209-minimum-size-subarray-sum-medium-font"><font color='blue'>209. Minimum Size Subarray Sum (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
        # two pointer
        
        l=0
        r=-1
        val=0
        res = float('inf')
        while val&lt;target:
            r+=1
            if r&gt;=len(nums):
                break
            val+=nums[r]  
        if val&gt;=target:
            res=min(res,r-l+1)
        else:
            return 0
        while l&lt;r:
            if val&gt;=target:
                #drop left
                #print('dropleft',l)
                val-=nums[l]
                l+=1
                if val&gt;=target: 
                    #print(l,r)
                    res=min(res,r-l+1)
                
            else:
                #print('expandright',r+1)
                r+=1
                if r&gt;=len(nums):
                    break
                val+=nums[r] 
        
        return res
# answer way of writting
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
        # two pointer
 
        l=len(nums)
        res=float('inf')
        left=0
        sum_=0
        for i,n in enumerate(nums):
            sum_+=n
            while sum_&gt;=target:
                res=min(res,i-left+1)
                sum_-=nums[left]
                left+=1
        
        return res if res!= float('inf') else 0
                
</code></pre>
<p>果然是two pointer, 学习answer写法，很清晰。</p>
<h1 id="210-course-schedule-ii-medium">210. Course Schedule II （Medium）</h1>
<pre><code class="language-python">class Solution:
    class Node:
        def __init__(self,val=None):
            self.val=val
            self.nei = []
            self.indegree = 0
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
        # dag
        
        nodes = [self.Node(val=i) for i in range(numCourses)]
        for a,b in prerequisites:
            nodes[b].nei.append(nodes[a])
            nodes[a].indegree+=1
        
        queue = []
        for node in nodes:
            if node.indegree==0:
                queue.append(node)
                
        res = []
        while queue:
            cur=queue.pop(0)
            res.append(cur.val)
            for w in cur.nei:
                w.indegree-=1
                if w.indegree==0:
                    queue.append(w)
        
        return res if len(res)==numCourses else []
        
</code></pre>
<p>BFS 拓扑排序，找出indegree==0的node output。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-22]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-22/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-22/">
        </link>
        <updated>2021-11-21T04:01:05.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="191-number-of-1-bits-easy">191. Number of 1 Bits (Easy)</h1>
<p>Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).</p>
<pre><code class="language-python">class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        res = 0 
        for _ in range(32):
            lastbit = n &amp; 1
            n = n &gt;&gt;1
            res += 1&amp;lastbit
        return res
</code></pre>
<h1 id="192-word-frequency-medium-bash">192. Word Frequency (Medium) BASH</h1>
<p>Write a bash script to calculate the frequency of each word in a text file words.txt.</p>
<pre><code class="language-BASH">for word in $(cat words.txt);   do echo $word;  done | sort | uniq -c | sort -r | awk '{ print $2 &quot; &quot;$1}'
</code></pre>
<p>Just ignore ....</p>
<h1 id="193-valid-phone-numbers-easy-bash">193. Valid Phone Numbers (Easy) BASH</h1>
<p>Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>
<pre><code class="language-BASH">grep -e '^[0-9]\{3\}-[0-9]\{3\}-[0-9]\{4\}$' -e '^([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}$' file.txt
</code></pre>
<p>Just ignore ....</p>
<h1 id="194-transpose-file-medium-bash">194. Transpose File (Medium) BASH</h1>
<p>Given a text file file.txt, transpose its content.</p>
<pre><code class="language-BASH">cat file.txt | awk '{for(i=0;++i&lt;=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++&lt;NF;)print a[i]}'
</code></pre>
<p>Just ignore ....</p>
<h1 id="195-tenth-line-easy-bash">195. Tenth Line (Easy) BASH</h1>
<p>Given a text file file.txt, print just the 10th line of the file.</p>
<pre><code class="language-BASH">sed -n &quot;10p&quot; file.txt
</code></pre>
<p>Just ignore ....</p>
<h1 id="196-delete-duplicate-emails-easy-sql">196. Delete Duplicate Emails (Easy) SQL</h1>
<pre><code class="language-SQL">DELETE p1 FROM Person p1,
    Person p2
WHERE
    p1.Email = p2.Email AND p1.Id &gt; p2.Id
</code></pre>
<h1 id="197-rising-temperature-easy-sql">197. Rising Temperature (Easy) SQL</h1>
<pre><code class="language-SQL">select w1.id as Id from Weather w1 left join Weather w2 on datediff(w1.RecordDate,w2.RecordDate)=1 where w2.Temperature&lt;w1.Temperature

# answer way of writting
SELECT
    weather.id AS 'Id'
FROM
    weather
        JOIN
    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1
        AND weather.Temperature &gt; w.Temperature
;
</code></pre>
<h1 id="198-house-robber-medium">198. House Robber (Medium)</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        # dp[i] = tthe max amount can rob at house i
        # dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        # dp[0] = nums[0]
        # dp[1] = max(nums[0],nums[1])
        if not nums:return 0
        if len(nums)==1: return nums[0]
        if len(nums)==2: return max(nums)
        dp = [float('-inf')]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(nums[:2])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i])
        return dp[-1]
</code></pre>
<h1 id="199-binary-tree-right-side-view-medium">199. Binary Tree Right Side View (Medium)</h1>
<p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:
        if not root: return root
        queue = [root]
        res = []
        
        while queue:
            level =[]
            l=len(queue)
            for i in range(l):
                cur = queue.pop(0)
                level.append(cur.val)
                if cur.right:
                    queue.append(cur.right)
                if cur.left:
                    queue.append(cur.left)
            res.append(level[0])
        
        return res
</code></pre>
<p>level order tresversal.</p>
<h1 id="font-colorblue200-number-of-islands-medium-font"><font color='blue'>200. Number of Islands (Medium) </font></h1>
<p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.</p>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        
        
        def dfs(grid,i,j):
            m=len(grid)
            n=len(grid[0])
            if i&lt;0 or j&lt;0 or i&gt;=m or j&gt;=n: return 
            if grid[i][j]=='1':
                grid[i][j]='#'
                dfs(grid,i+1,j)
                dfs(grid,i-1,j)
                dfs(grid,i,j+1)
                dfs(grid,i,j-1)
        r=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]=='1':
                    dfs(grid,i,j)
                    r+=1
        
        return r

#UNION FIND
class Solution:
    class UnionFind:
        def __init__(self,grid):
            self.count=0
            self.m=len(grid)
            self.n=len(grid[0])
            self.parent = [None]*(self.m*self.n)
            self.rank = [0]*(self.m*self.n)
            for i in range(self.m):
                for j in range(self.n):
                    if grid[i][j]=='1':
                        self.parent[i*self.n+j]=i*self.n+j
                        self.count+=1
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
                self.count-=1
        
        def getCount(self):
            return self.count
    
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        nr=len(grid)
        nc=len(grid[0])
        uf = self.UnionFind(grid)
        for r in range(nr):
            for c in range(nc):
                if grid[r][c]=='1':
                    grid[r][c]='0'
                    if (r-1&gt;=0 and grid[r-1][c]=='1'):
                        uf.union(r*nc+c,(r-1)*nc+c)
                    if (r + 1 &lt; nr and grid[r+1][c] == '1'):
                        uf.union(r * nc + c, (r+1) * nc + c) 
                    if (c - 1 &gt;= 0 and grid[r][c-1] == '1'):
                        uf.union(r * nc + c, r * nc + c - 1) 
                    if   (c + 1 &lt; nc and grid[r][c+1] == '1'):
                        uf.union(r * nc + c, r * nc + c + 1) 
                    
    
        return uf.getCount() 
        

</code></pre>
<p>答案玩了个新东西，叫UnionFind， 挺有意思。 就是找爸爸的爸爸，然后谁rank高就作为最终父亲。 这样union时候只是pointer在移动， 刚开始所有1 都是自己的爸爸， 然后逐渐union周围的1， 每union一次counter -=1 这样最终counter就是所有独立的岛数目。DFS也很简单， BFS同理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-21]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-21/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-21/">
        </link>
        <updated>2021-11-20T03:29:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="181-employees-earning-more-than-their-managers-easy-sql">181. Employees Earning More Than Their Managers (Easy) SQL</h1>
<p>Write an SQL query to find the employees who earn more than their managers.</p>
<pre><code class="language-SQL">SELECT
    a.Name AS 'Employee'
FROM
    Employee AS a,
    Employee AS b
WHERE
    a.ManagerId = b.Id
        AND a.Salary &gt; b.Salary
;

SELECT
     a.NAME AS Employee
FROM Employee AS a JOIN Employee AS b
     ON a.ManagerId = b.Id
     AND a.Salary &gt; b.Salary
;
</code></pre>
<h1 id="182-duplicate-emails-easy-sql">182. Duplicate Emails (Easy) SQL</h1>
<pre><code class="language-SQL">
# Write your MySQL query statement below

select Email from
(
  select Email, count(Email) as num
  from Person
  group by Email
) as statistic
where num &gt; 1
;

select Email
from Person
group by Email
having count(Email) &gt; 1;
</code></pre>
<h1 id="183-customers-who-never-order-easy-sql">183. Customers Who Never Order (Easy) SQL</h1>
<pre><code class="language-SQL">select name as &quot;Customers&quot; from Customers as c left join Orders o on c.id=o.customerId where o.id is NULL;


select customers.name as 'Customers'
from customers
where customers.id not in
(
    select customerid from orders
);
</code></pre>
<h1 id="184-department-highest-salary-medium-sql">184. Department Highest Salary (Medium) SQL</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
select Department,Employee,Salary from (
    select d.name as &quot;Department&quot;, 
               e.name as &quot;Employee&quot;,  
               e.salary as &quot;Salary&quot;,
              rank()   OVER( partition by e.departmentId order by salary DESC) as &quot;r&quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
     as tmp where r=1


#answer way of writting

SELECT
    Department.name AS 'Department',
    Employee.name AS 'Employee',
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
    )
;

</code></pre>
<h1 id="185-department-top-three-salaries-hard-sql">185. Department Top Three Salaries (Hard) SQL</h1>
<pre><code class="language-SQL">select Department,Employee,Salary from (
    select d.name as &quot;Department&quot;, 
               e.name as &quot;Employee&quot;,  
               e.salary as &quot;Salary&quot;,
              dense_rank()   OVER( partition by e.departmentId order by salary DESC) as &quot;r&quot;   
    from Employee as e left join Department as d on e.departmentId=d.id )
as tmp where   r&lt;=3

#answer way of writting
SELECT
    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 &gt; (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary &gt; e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
</code></pre>
<h1 id="186-reverse-words-in-a-string-ii-medium">186. Reverse Words in a String II (Medium)</h1>
<p>Given a character array s, reverse the order of the words.<br>
A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.<br>
Your code must solve the problem in-place, i.e. without allocating extra space.</p>
<pre><code class="language-python">class Solution:
    def reverseWords(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        def rev(s,i,j):
            while i&gt;=0 and j&lt;len(s) and i&lt;j:
                s[i],s[j]=s[j],s[i]
                i+=1
                j-=1
        
        l=0
        r=len(s)-1
        rev(s,l,r)
        start=0
        for i in range(r):
            if s[i]==' ':
                rev(s,start,i-1)
                start=i+1
        rev(s,start,r)
</code></pre>
<h1 id="187-repeated-dna-sequences-medium">187. Repeated DNA Sequences (Medium)</h1>
<p>The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.<br>
For example, &quot;ACGAATTCCG&quot; is a DNA sequence.<br>
When studying DNA, it is useful to identify repeated sequences within the DNA.<br>
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findRepeatedDnaSequences(self, s: str) -&gt; List[str]:
        #sliding window s[i,i+10]  drop i add i+10, if in set, append to res
        if len(s)&lt;=10: 
            return []
        set_ = set()
        res = set()
        for i in range(len(s)-10+1):
            cur=s[i:i+10]
            if cur in set_:
                res.add(cur)
            set_.add(cur)
        return list(res)
</code></pre>
<h1 id="font-colorred188-best-time-to-buy-and-sell-stock-iv-hardfont"><font color='red'>188. Best Time to Buy and Sell Stock IV （Hard）</font></h1>
<p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.<br>
Find the maximum profit you can achieve. You may complete at most k transactions.</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&gt; int:
        #  if k==1
        if not prices: return 0
        if k==0: return 0
        min_ = [float('inf')]*k
        p_ = [float('-inf')]*k
        
        for i,n in enumerate(prices):
            min_[0] = min(min_[0],n)
            p_[0] = max(p_[0],n-min_[0])
            for j in range(1,k):
                min_[j]=min(min_[j],n-p_[j-1])
                p_[j]=max(p_[j],n-min_[j])
                

        return p_[-1]
</code></pre>
<p>老老实实写出K=2的情况，然后改写为数组形式。但忘记了K=2怎么写。。。</p>
<h1 id="189-rotate-array-medium">189. Rotate Array （Medium）</h1>
<p>Given an array, rotate the array to the right by k steps, where k is non-negative.<br>
Input: nums = [1,2,3,4,5,6,7], k = 3<br>
Output: [5,6,7,1,2,3,4]<br>
7654321<br>
765|4321<br>
657|1234</p>
<pre><code class="language-python">class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        l=len(nums)
        k = k%l
        def rev(nums,i,j):
            while i&lt;j:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j-=1
        
        rev(nums,0,l-1)
        rev(nums,0,k-1)
        rev(nums,k,l-1)
</code></pre>
<h1 id="190-reverse-bits-easy">190. Reverse Bits (Easy)</h1>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<pre><code class="language-python">class Solution:
    def reverseBits(self, n: int) -&gt; int:
        res = 0
        for _ in range(32):
            lastbit = n &amp; 1
            n = n&gt;&gt;1
            res = res&lt;&lt;1 | lastbit
        return res  
</code></pre>
]]></content>
    </entry>
</feed>