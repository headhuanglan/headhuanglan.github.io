<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2023-07-24T04:08:45.663Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[股票买卖问题总结]]></title>
        <id>https://headhuanglan.github.io/post/gu-piao-mai-mai-wen-ti-zong-jie/</id>
        <link href="https://headhuanglan.github.io/post/gu-piao-mai-mai-wen-ti-zong-jie/">
        </link>
        <updated>2023-07-02T16:32:44.000Z</updated>
        <summary type="html"><![CDATA[<p>总结股票买卖问题，所有case都化简为DP处理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结股票买卖问题，所有case都化简为DP处理。</p>
<!-- more -->
<h1 id="通解">通解</h1>
<p>i 代表 ith day<br>
k 代表最大交易次数<br>
0/1 代表手中是否持有股票</p>
<p>T【i】【k】【0】 代表 在ith day 最多k次交易，ith day结束后不持有股票的 profit<br>
T【i】【k】【1】 代表 在ith day 最多k次交易，ith day结束后持有股票的 profit</p>
<p>那么base case<br>
T【-1】【k】【0】 = 0   （1）<br>
T【-1】【k】【1】 = -INF （2）<br>
T【i】【0】【0】 = 0 （3）<br>
T【i】【0】【1】= -INF （4）<br>
递推关系<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入</p>
<p>（只有买入操作消耗交易次数）</p>
<h1 id="应用">应用</h1>
<h2 id="k1">K=1</h2>
<p>T【i】【1】【0】=max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）<br>
T【i】【1】【1】=max（T【i-1】【1】【1】，T【i-1】【0】【0】-prices【i】）<br>
因为（3）<br>
所以<br>
T【i】【1】【0】=max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）<br>
T【i】【1】【1】=max（T【i-1】【1】【1】，-prices【i】）</p>
<pre><code class="language-java">public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i10;
}
</code></pre>
<h2 id="kinf">K=INF</h2>
<p>K无穷大时候，K和K-1 没区别<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入<br>
变成<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入</p>
<pre><code class="language-java">public int maxProfit(int[] prices) {
    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
    
    return T_ik0;
}
</code></pre>
<h2 id="k2">K=2</h2>
<p>T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入<br>
变成<br>
T【i】【2】【0】 = max（T【i-1】【2】【0】，T【i-1】【2】【1】+prices【i】）<br>
T【i】【2】【1】 = max（T【i-1】【2】【1】，T【i-1】【1】【0】- prices【i】）<br>
T【i】【1】【0】 = max（T【i-1】【1】【0】，T【i-1】【1】【1】+prices【i】）<br>
T【i】【1】【1】 = max（T【i-1】【1】【1】，- prices【i】）</p>
<pre><code class="language-java">public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i20 = Math.max(T_i20, T_i21 + price);
        T_i21 = Math.max(T_i21, T_i10 - price);
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i20;
}

</code></pre>
<h2 id="k-是任何数">K 是任何数</h2>
<p>T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入</p>
<pre><code class="language-java">public int maxProfit(int k, int[] prices) {
    //如果K 大于等于Prices长度的一半，那么相当于K=INF的情况
    if (k &gt;= prices.length &gt;&gt;&gt; 1) {
        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
        for (int price : prices) {
            int T_ik0_old = T_ik0;
            T_ik0 = Math.max(T_ik0, T_ik1 + price);
            T_ik1 = Math.max(T_ik1, T_ik0_old - price);
        }
    
        return T_ik0;
    }
        
    int[] T_ik0 = new int[k + 1];
    int[] T_ik1 = new int[k + 1];
    Arrays.fill(T_ik1, Integer.MIN_VALUE);
        
    for (int price : prices) {
        for (int j = k; j &gt; 0; j--) {
            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);
            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);
        }
    }
        
    return T_ik0[k];
}
</code></pre>
<h2 id="kinf-with-cooldown">K=INF with Cooldown</h2>
<p>T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入<br>
当K=INF变为<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入<br>
但是有cooldown时候，变为<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-2】【k】【0】- prices【i】）#买入<br>
因为不能在i天买入如果股票是在i-1天卖出的，所以只能用T【i-2】【k】【0】</p>
<pre><code class="language-java">public int maxProfit(int[] prices) {
    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);
        T_ik0_pre = T_ik0_old;
    }
    
    return T_ik0;
}
</code></pre>
<h2 id="kinf-with-transaction-fee">K=INF with Transaction Fee</h2>
<p>T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k-1】【0】- prices【i】）#买入<br>
当K=INF变为<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入<br>
但是有Fee时候，变为因为fee只在卖出时候付清<br>
T【i】【k】【0】 = max（T【i-1】【k】【0】，T【i-1】【k】【1】+prices【i】-fee） #卖出<br>
T【i】【k】【1】 = max（T【i-1】【k】【1】，T【i-1】【k】【0】- prices【i】）#买入</p>
<pre><code class="language-java">public int maxProfit(int[] prices, int fee) {
    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        long T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
        
    return (int)T_ik0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SUM相关数据结构总结]]></title>
        <id>https://headhuanglan.github.io/post/sum-xiang-guan-shu-ju-jie-gou-zong-jie/</id>
        <link href="https://headhuanglan.github.io/post/sum-xiang-guan-shu-ju-jie-gou-zong-jie/">
        </link>
        <updated>2023-02-22T21:59:08.000Z</updated>
        <summary type="html"><![CDATA[<p>BIT ， SEGMENT TREE， UnionFind</p>
]]></summary>
        <content type="html"><![CDATA[<p>BIT ， SEGMENT TREE， UnionFind</p>
<!-- more -->
<h1 id="binary-indexed-tree">Binary Indexed Tree</h1>
<pre><code class="language-python">class BIT:
    def __init__(self,n):
        self.size = n
        self.bit = [0]*(self.size+1)
    
    def update(self,index,val):
         #index in BIT is 1 more than original index
        while index&lt;=self.size:
            self.bit[index]+=val
            index += index&amp;-index
    def query(self,index):
         #index in BIT is 1 more than original index
        res = 0 
        while index&gt;0:
            res+=self.bit[index]
            index-= index&amp;-index
        return res

#2D
class BIT:
    def __init__(self,m,n):
        self.m= m
        self.n = n
        self.bit = [[0]*(self.n+1) for _ in range(self.m+1)]
    
    def update(self,r,c,val):
        i = r
        while i&lt;=self.m:
            j = c
            while j&lt;=self.n:
                self.bit[i][j]+=val
                j+= j&amp;-j
            i+= i&amp;-i

    def query(self,r,c):
        res = 0
        i=r
        while i&gt;0:
            j = c
            while j&gt;0:
                res+=self.bit[i][j]
                j-= j&amp;-j
            i-= i&amp;-i
        return res
        

</code></pre>
<p>update / \ query 注意index from 1</p>
<h1 id="segment-tree">Segment Tree</h1>
<pre><code class="language-python">class ST:
    def __init__(self,n):
        self.size = n
        self.tree = [0]*(2*self.size)
    
    def update(self,ind,val):
        #       1
        #     2   3
        #    4 5 6 7
        #  self.tree is:
        #  @ 1 2 3 4 5 6 7
        
        #offset index by size, the leave save value node save summation
        ind+=self.size
        self.tree[ind] += val
        while ind&gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&gt;0:
                self.tree[ind//2]=self.tree[left]+self.tree[right]
            ind //=2


    def query(self,left,right):
        left+=self.size
        right+=self.size
        res=0
        while left&lt;=right:
            if right%2==0:
                res+=self.tree[right]
                right-=1
            if left%2==1:
                res+=self.tree[left]
                left+=1
            left//=2
            right//=2
        return res

</code></pre>
<p>原始值保存在叶子节点中，所以ind是要加slef.size的</p>
<h1 id="unionfind">UnionFind</h1>
<pre><code class="language-python">     class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2023-01-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2023-01-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2023-01-06/">
        </link>
        <updated>2023-02-22T00:39:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="491-non-decreasing-subsequences-medium">491. Non-decreasing Subsequences （Medium）</h1>
<p>Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:
        res = set()
        def bt(start, tmp):
            if len(tmp)&gt;1:
                res.add(tuple(tmp))
            for i in range(start,len(nums)):
                if i-1&gt;= start and nums[i]==nums[i-1]: continue
                if not tmp or nums[i]&gt;=tmp[-1]:
                    tmp.append(nums[i])
                    bt(i+1,tmp)
                    tmp.pop()
    
        bt(0,[])
        return list(res)

#ANSWER 
class Solution:
    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:
        res = set()
        def bt(start, tmp):
            
            if start==len(nums):
                if len(tmp)&gt;1:
                    res.add(tuple(tmp))
                return

            
            #add num[i]
            if not tmp or nums[start]&gt;=tmp[-1]:
                tmp.append(nums[start])
                bt(start+1,tmp)
                tmp.pop()
            #not add num[i]
            bt(start+1,tmp)
    
        
        bt(0,[])
        return list(res)

#BIT MASK 方法
class Solution:
    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:
        n=len(nums)
        res = set()
        for mask in range(1, 1&lt;&lt;n):
            tmp = [nums[i] for i in range(n) if (mask&gt;&gt;i)&amp;1  ]
            if len(tmp)&gt;=2 and all([tmp[i]&lt;=tmp[i+1] for i in range(len(tmp)-1)]):
                res.add(tuple(tmp))
        return res
            
</code></pre>
<p>感觉是个backtracking问题， debug了一会解决了。。答案更好</p>
<h1 id="492-construct-the-rectangle-easy">492. Construct the Rectangle （Easy）</h1>
<p>A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:<br>
The area of the rectangular web page you designed must equal to the given target area.<br>
The width W should not be larger than the length L, which means L &gt;= W.<br>
The difference between length L and width W should be as small as possible.<br>
Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.</p>
<pre><code class="language-python">class Solution:
    def constructRectangle(self, area: int) -&gt; List[int]:
        # L*W=area
        # L&gt;=W
        # min(abs(L-W))

        L=res_L=area
        W=res_W=1
        while L&gt;=W:
            W+=1
            L=area//W
            if L&gt;=W and L*W==area:
                res_L=L
                res_W=W
        return res_L,res_W
#ANSWER

class Solution:
    def constructRectangle(self, area: int) -&gt; List[int]:
        # L*W=area
        # L&gt;=W
        # min(abs(L-W))

         
        W=int(math.sqrt(area))
        while area%W!=0:
            W-=1
        return area//W, W

#ANSWER
class Solution:
    def constructRectangle(self, area: int) -&gt; List[int]:
        middle=int(sqrt(area))
        for i in range(middle,0,-1):
            if area%i==0:
                return[int(area/i),i]
</code></pre>
<h1 id="font-colorred-493-reverse-pairs-hard-font"><font color='red'> 493. Reverse Pairs (Hard) </font></h1>
<p>Given an integer array nums, return the number of reverse pairs in the array.<br>
A reverse pair is a pair (i, j) where:<br>
0 &lt;= i &lt; j &lt; nums.length and<br>
nums[i] &gt; 2 * nums[j].</p>
<pre><code class="language-python">class Solution:
    def reversePairs(self, nums: List[int]) -&gt; int:
        # i&lt;j
        #  nums[i]&gt; 2*nums[j]

        class BIT:
            def __init__(self,n):
                self.n = n
                self.bits = [0]*(n+1)
            
            def insert(self,idx):
                idx+=1
                while idx&gt;0:
                    self.bits[idx]+=1
                    idx-=idx&amp;-idx
            
            def query(self,idx):
                idx+=1
                res = 0 
                while idx&lt;=self.n:
                    res+=self.bits[idx]
                    idx+=idx&amp;-idx
                return res
        

        bit = BIT(len(nums))
        tmp = nums[:]
        tmp.sort()
        res =0 
        for n in nums:
            #n是nums[j]要找到有多少nums[i]&gt;2nums[j]
            #query 2n+1 ~ end
            #由于bit一般是从0还是，加到idx，反向需要把insert 和 query反向
            idx = bisect.bisect_left(tmp,2*n+1)
            res+= bit.query(idx)
            idx = bisect.bisect_left(tmp,n)
            bit.insert(idx)
        return res    

#ANSWER 2 Merge SORT
class Solution:
    def reversePairs(self, nums: List[int]) -&gt; int:

        def ms(l,r):
            if l&gt;=r: return 0
            m = (l+r)//2
            count = ms(l,m)+ms(m+1,r)

            j=m+1
            for i in range(l,m+1):
                while j&lt;=r and nums[i]&gt;2*nums[j]:
                    j+=1
                count+=(j-1)-m
            
            nums[l:r+1] = sorted(nums[l:r+1])
            return count
        return ms(0,len(nums)-1)
</code></pre>
<p>初看像用stack做 但是做不出来。。。答案用了BIT。。。。但是不是通常意义的BIT。反了insert 和update function。<br>
For our case, the running total is simply the number of elements encountered during the traversal process. If we stick to the convention above, the running total will be the number of elements smaller than the one at the given index, since the copy array is sorted in ascending order. However, we'd actually like to find the number of elements greater than some value (i.e., twice of the element being scanned), therefore we need to flip the convention. This is what you see inside the search and insert functions: the former traversing towards the end of the bit while the latter towards the root.<br>
MergeSort方法二 。。。</p>
<h1 id="font-colorred-494-target-sum-medium-font"><font color='red'> 494. Target Sum (Medium) </font></h1>
<p>You are given an integer array nums and an integer target.</p>
<p>You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.</p>
<pre><code>For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression &quot;+2-1&quot;.
</code></pre>
<p>Return the number of different expressions that you can build, which evaluates to target.</p>
<pre><code class="language-python">class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -&gt; int:
        @lru_cache(None)
        def bt(start,target):
            if start==len(nums) and target==0: return 1
            if start&gt;=len(nums): return 0
            
            # +
            res1 = bt(start+1,target-nums[start])
            # - 
            res2 = bt(start+1,target+nums[start])
            return res1+res2
        return bt(0,target)
#ANSWER
 def findTargetSumWays(self, nums, S):
        if not nums:
            return 0
        dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2}
        for i in range(1, len(nums)):
            tdic = {}
            for d in dic:
                tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)
                tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)
            dic = tdic
        return dic.get(S, 0)  

#ANSWER
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -&gt; int:
        # dp[i][t]   using upto ith number of target t
        total=sum(nums)
        if abs(target)&gt;total:return 0
        dp=[  [0]*(2*total+1)  for _ in range(len(nums))]
        dp[0][nums[0]+total] = 1
        dp[0][-nums[0]+total] +=1

        for i in range(1,len(nums)):
            for sum_ in range(-total,total+1):
                if dp[i-1][sum_+total]&gt;0:
                    dp[i][sum_+nums[i]+total]+=dp[i-1][sum_+total]
                    dp[i][sum_-nums[i]+total]+=dp[i-1][sum_+total]
        
        return dp[len(nums)-1][target+total]  

</code></pre>
<p>DP。 因为数字和在-sum到sum之间，offset到0开始需要+sum。</p>
<h1 id="495-teemo-attacking-easy">495. Teemo Attacking （Easy）</h1>
<p>Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.</p>
<p>You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.</p>
<p>Return the total number of seconds that Ashe is poisoned.</p>
<pre><code class="language-python">class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int:
        # input:[1,2] 2
        #     1        2
        #    start     end
        #           start2           new_end3

          
        start = timeSeries[0]
        end = start+duration-1
        res = end-start+1
        for t in timeSeries[1:]:
            new_end = t+duration-1
            if new_end&gt;end:
                start = end+1 if t&lt;=end else t
                end = new_end
                res+=end-start+1
        return res

#MY ANSWER
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int:
        res = 0
        right = 0
        for i,t in enumerate(timeSeries):
            if t &gt;= right:
                res+= min(duration, timeSeries[i+1]-t) if i+1&lt;len(timeSeries) else duration
            
            right = min(t+duration-1,  timeSeries[i+1] ) if i+1&lt;len(timeSeries) else t+duration-1

          
        return res


#ANSER ORZ indeed EZ
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int:
        n = len(timeSeries)
        if n == 0:
            return 0
        
        total = 0
        for i in range(n - 1):
            total += min(timeSeries[i + 1] - timeSeries[i], duration)
        return total + duration
</code></pre>
<h1 id="496-next-greater-element-i-easy">496. Next Greater Element I (Easy)</h1>
<p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p>
<p>You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</p>
<p>For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.</p>
<p>Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</p>
<pre><code class="language-python">class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        minheap=[ ]
        dic= dict()
        for n in nums2:
            while minheap and minheap[0]&lt;n:
                dic[heappop(minheap)] = n
            heappush(minheap,n)
        
        return [dic.get(n,-1) for n in nums1]

class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        
        dic = dict()
        
        stack = []
        
        while nums2:
            cur = nums2.pop(0)
            if not stack:
                stack.append(cur)
            else:
                while stack and cur&gt;stack[-1]:
                    dic[stack[-1]] = cur
                    stack.pop()
                stack.append(cur)
        
        return [dic.get(e,-1) for e in nums1]
             
#MY ANSWER
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:

        dic = dict()
        stack = []
        for n in nums2:
            if not stack or stack and n&lt;stack[-1]:
                stack.append(n)
            else:
                while stack and  n&gt;stack[-1]:
                    dic[stack.pop()] = n
                stack.append(n)
        
        return [dic.get(n,-1) for n in nums1]
        
</code></pre>
<p>用不着用minheap 直接用stack就好，因为插入时候顺序已经是从左到右满足条件了。</p>
<h1 id="497-random-point-in-non-overlapping-rectangles-medium">497. Random Point in Non-overlapping Rectangles （Medium）</h1>
<p>You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.<br>
Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.<br>
Note that an integer point is a point that has integer coordinates.<br>
Implement the Solution class:<br>
Solution(int[][] rects) Initializes the object with the given rectangles rects.<br>
int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.area = [ (p[2]-p[0]+1)*(p[3]-p[1]+1) for p in self.rects]
        

    def pick(self) -&gt; List[int]:
        #pick rect based on area
        pick_rect = random.random()*sum(self.area)
        now = 0
        ind = -1
        while now&lt;pick_rect:
            ind+=1
            now+=self.area[ind]
        rect = self.rects[ind]
        return [random.randint(rect[0], rect[2]),random.randint(rect[1], rect[3])]
       
        
</code></pre>
<p>这题有个tricky地方，area为0的rect也是有点包含在里面的，要想包含边上的点需要 （width+1）*（height+1）</p>
<h1 id="498-diagonal-traverse-medium">498. Diagonal Traverse （Medium）</h1>
<p>iven an m x n matrix mat, return an array of all the elements of the array in a diagonal order.</p>
<pre><code class="language-python">#TLE
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]:        
        m=len(mat)
        n=len(mat[0])
        res = []
        ij_sum=0
        for level in range(m+n-1):
            tmp=[]
            for i in range(level+1):
                j = ij_sum-i
                if i&gt;=0 and i&lt;m and j&gt;=0 and j&lt;n:
                    tmp.append(mat[i][j])
            if level%2==0:
                tmp=tmp[::-1]
            res.extend(tmp)
            ij_sum+=1
        return res

class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]:        
        dic = defaultdict(list)
        res = []
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                key=i+j
                dic[key].append(mat[i][j])
        

        for key in range(len(mat)-1+len(mat[0])):
            if key%2==0:
                res.extend(dic[key][::-1])
            else:
                res.extend(dic[key])
        return res

#ANSWER
class Solution:
    
    def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        
        # Check for empty matrices
        if not matrix or not matrix[0]:
            return []
        
        # Variables to track the size of the matrix
        N, M = len(matrix), len(matrix[0])
        
        # The two arrays as explained in the algorithm
        result, intermediate = [], []
        
        # We have to go over all the elements in the first
        # row and the last column to cover all possible diagonals
        for d in range(N + M - 1):
            
            # Clear the intermediate array everytime we start
            # to process another diagonal
            intermediate.clear()
            
            # We need to figure out the &quot;head&quot; of this diagonal
            # The elements in the first row and the last column
            # are the respective heads.
            r, c = 0 if d &lt; M else d - M + 1, d if d &lt; M else M - 1
            
            # Iterate until one of the indices goes out of scope
            # Take note of the index math to go down the diagonal
            while r &lt; N and c &gt; -1:
                intermediate.append(matrix[r][c])
                r += 1
                c -= 1
            
            # Reverse even numbered diagonals. The
            # article says we have to reverse odd 
            # numbered articles but here, the numbering
            # is starting from 0 :P
            if d % 2 == 0:
                result.extend(intermediate[::-1])
            else:
                result.extend(intermediate)
        return result        
</code></pre>
<p>初次尝试TLE，用dic后满足条件。。。</p>
<h1 id="font-colorred-499-the-maze-iii-hard-font"><font color='red'> 499. The Maze III （Hard） </font></h1>
<p>There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.</p>
<p>Given the m x n maze, the ball's position ball and the hole's position hole, where ball = [ballrow, ballcol] and hole = [holerow, holecol], return a string instructions of all the instructions that the ball should follow to drop in the hole with the shortest distance possible. If there are multiple valid instructions, return the lexicographically minimum one. If the ball can't drop in the hole, return &quot;impossible&quot;.</p>
<p>If there is a way for the ball to drop in the hole, the answer instructions should contain the characters 'u' (i.e., up), 'd' (i.e., down), 'l' (i.e., left), and 'r' (i.e., right).</p>
<p>The distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).</p>
<p>You may assume that the borders of the maze are all walls</p>
<pre><code class="language-python">
#ANSWER
class Solution:
    def findShortestWay(self, maze, ball, hole):
        m, n, q, stopped = len(maze), len(maze[0]), [(0, &quot;&quot;, ball[0], ball[1])], {(ball[0], ball[1]): [0, &quot;&quot;]}
        while q:
            dist, pattern, x, y = heapq.heappop(q)
            if [x, y] == hole:
                return pattern
            for i, j, p in ((-1, 0, &quot;u&quot;), (1, 0, &quot;d&quot;), (0, -1, &quot;l&quot;), (0, 1, &quot;r&quot;)):
                newX, newY, d = x, y, 0
                while 0 &lt;= newX + i &lt; m and 0 &lt;= newY + j &lt; n and maze[newX + i][newY + j] != 1:
                    newX += i
                    newY += j
                    d += 1
                    if [newX, newY] == hole:
                        break
                if (newX, newY) not in stopped or [dist + d, pattern + p] &lt; stopped[(newX, newY)]:
                    stopped[(newX, newY)] = [dist + d, pattern + p]
                    heapq.heappush(q, (dist + d, pattern + p, newX, newY))
        return &quot;impossible&quot;

</code></pre>
<p>BFS 写了答案能过60/64 个test case。。。不知道哪里还有BUG。看答案。难点在，循环queue时候，这个queue不是普通的queue，是minheap。 这样就能取出距离最小的而且lexcially最小的next node做计算。</p>
<h1 id="500-keyboard-row-easy">500. Keyboard Row （Easy）</h1>
<p>Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.<br>
In the American keyboard:<br>
the first row consists of the characters &quot;qwertyuiop&quot;,<br>
the second row consists of the characters &quot;asdfghjkl&quot;, and<br>
the third row consists of the characters &quot;zxcvbnm&quot;</p>
<pre><code class="language-python">class Solution:
    def findWords(self, words: List[str]) -&gt; List[str]:
        s1 = set(&quot;qwertyuiopQWERTYUIOP&quot;)
        s2=set(&quot;asdfghjklASDFGHJKL&quot;)
        s3=set(&quot;zxcvbnmZXCVBNM&quot;)
        
        return [w for w in words if any(set(w)&amp;s==set(w) for s in [s1,s2,s3]  )  ]

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2023-01-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2023-01-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2023-01-05/">
        </link>
        <updated>2023-01-03T01:52:43.000Z</updated>
        <summary type="html"><![CDATA[<p>没想到都拖到2023年了 还没上500</p>
]]></summary>
        <content type="html"><![CDATA[<p>没想到都拖到2023年了 还没上500</p>
<!-- more -->
<h1 id="font-colorred-481-magical-string-mediumfont"><font color='red'> 481. Magical String （Medium）</font></h1>
<p>A magical string s consists of only '1' and '2' and obeys the following rules:<br>
The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.<br>
The first few elements of s is s = &quot;1221121221221121122……&quot;. If we group the consecutive 1's and 2's in s, it will be &quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot; and the occurrences of 1's or 2's in each group are &quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;. You can see that the occurrence sequence is s itself.<br>
Given an integer n, return the number of 1's in the first n number in the magical string s.</p>
<pre><code class="language-python">#MY ANSWER   死扣出来的，。。。 不如答案
class Solution:
    def magicalString(self, n: int) -&gt; int:
        if n&lt;=3: return 1
        l=2
        s= [1,2]
        c = 0
        res = 1
        while s:
            c+=1
            num=s.pop(0)
            if c &amp; 1:
                
                if c==1:
                     continue
                else:
                    s.extend([1]*num)
                    l+=num
         
                if l&lt;n:
                    #print('@',l,c,res+num)
                    res+=num 
                elif l==n:
                    #print('#',l,c,res+num)
                    res+=num
                    break 
                else:
                    #print('&amp;',l,c,res+num-(l-n))
                    res+= num-(l-n) 
                    break

            else:
                if c==2:
                    s.append(2)
                    l+=1
                else:
                    s.extend([2]*num)
                    l+=num
                
                if l&gt;=n: break
                
        return res
        ###


class Solution:
    def magicalString(self, n: int) -&gt; int:
        #          #
        #     1 2  2
        #            #
     
        if n &lt;= 0: return 0
        if n &lt;= 3: return 1

        nums = [0]*n
        nums[0] = 1
        nums[1] = 2
        nums[2] = 2
        countIdx = 2 #the count of next number
        num = 1 # next number to fill
        pos = 3 # empty position we will fill
        res = 1 # the number of 1's

        while pos &lt; n:
            count = nums[countIdx]
            countIdx+=1
            
            while count &gt; 0 and pos &lt; n:
                res += int(num == 1) 
                nums[pos] = num
                pos+=1
                count-=1
            
            num = 3 - num
        

        return res
</code></pre>
<p>理解题目意思后，思路还是很清楚的。</p>
<h1 id="482-license-key-formatting-easy">482. License Key Formatting （Easy）</h1>
<p>You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.<br>
We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.</p>
<pre><code class="language-python">class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -&gt; str:

        s = s.replace('-','').upper()
        first = len(s)%k
        res = []
        while s:
            if first:
                res.append(s[:first])
                s = s[first:]
                first = 0
            else:
                res.append(s[:k])
                s= s[k:]


        return '-'.join(res)

#
class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -&gt; str:
        if set(s)=={'-'}: return ''
        li=[]
        for char in s:
            if char!='-' and (char.isalpha or char.isnumeric):
                li.append(char.upper())
        res=[]
        c=0
        while li:
            res.append(li.pop())
            c+=1
            if c==k:
                c=0
                res.append('-')
        
        
        return (''.join(res[::-1])) if ''.join(res[::-1])[0]!='-' else (''.join(res[::-1]))[1:]

</code></pre>
<p>计算头的长度，或者，得到chars后从后往前填充。res.append(li.pop())</p>
<h1 id="font-colorred-483-smallest-good-base-hardfont"><font color='red'> 483. Smallest Good Base （Hard）</font></h1>
<p>Given an integer n represented as a string, return the smallest good base of n.<br>
We call k &gt;= 2 a good base of n, if all digits of n base k are 1's.</p>
<pre><code class="language-python">import math
class Solution(object):
    def smallestGoodBase(self, n):
        &quot;&quot;&quot;
        :type n: str
        :rtype: str
        &quot;&quot;&quot;
        n = int(n)
        max_m = int(math.log(n,2)) # Refer [7]
        for m in range(max_m,1,-1):
            k = int(n**m**-1)  # Refer [6]
            if (k**(m+1)-1)//(k-1) == n:
                # Refer [3]
                return str(k)
        
        return str(n-1)  
</code></pre>
<p>初始想法是写个function(base,order)但得binary search 2个参数。。感觉不可行。<br>
答案很精彩 完全是数学问题<br>
For a given m &gt; 1:<br>
From n = k^m + ... + k^0 &gt; k^m you get k &lt; m-th root of n<br>
From n = k^m + ... + k^0 &lt; (k+1)^m (see binomial theorem) you also get k+1 &gt; m-th root of n.</p>
<p>So k &lt; m-th root of n &lt; k+1. Thus ⌊m-th root of n⌋ is the only candidate that needs to be tested. As</p>
<p>From given information, we can say one thing- Numbers will be of form-</p>
<p>n = k^m + k^(m-1) + ... + k + 1<br>
=&gt; n-1 = k^m + k^(m-1) + ... + k<br>
=&gt; n-1 = k (k^(m-1) + k^(m-2) + ... + k + 1) ...... [1]</p>
<p>Also, from n = k^m + k^(m-1) + ... + k + 1, we can say,<br>
n-k^m = k^(m-1) + k^(m-2) + ... + k + 1 ...... [2]</p>
<p>from [1] and [2],</p>
<p>n-1 = k (n - k^m)<br>
=&gt;k^(m+1) = nk - n + 1</p>
<p>if you shuffle sides you will end up getting following form,</p>
<p>(k^(m+1) - 1)/(k - 1) = n .... [3]</p>
<p>Also from [1] note that, (n - 1) must be divisible by k.</p>
<p>We know that, n = k^m + k^(m-1) + ... + k + 1</p>
<p>=&gt; n &gt; k^m<br>
=&gt; m-th root of n &gt; k .... [4]</p>
<p>With inputs from @StefanPochmann we can also say, from binomial thorem, n = k^m + ... + 1 &lt; (k+1)^m .... [5]<br>
Therefore, k+1 &gt; m-th root of n &gt; k. .... from [4] and [5]<br>
Thus ⌊m-th root of n⌋ is the only candidate that needs to be tested. [6]<br>
So our number should satisfy this equation where k will be our base and m will be (number of 1s - 1)<br>
This brings us to the search problem where we need to find k and m.<br>
Linear search from 1 to n does not work. it gives us TLE. So it leaves us with performing some optimization on search space.<br>
From [6] we know that the only candidate that needs to be tested is, ⌊m-th root of n⌋<br>
We also know that the smallest base is 2 so we can find our m must be between 2 and log2n else m is (n-1) [7]</p>
<h1 id="font-colorred-484-find-permutation-mediumfont"><font color='red'> 484. Find Permutation （Medium）</font></h1>
<p>A permutation perm of n integers of all the integers in the range [1, n] can be represented as a string s of length n - 1 where:</p>
<pre><code>s[i] == 'I' if perm[i] &lt; perm[i + 1], and
s[i] == 'D' if perm[i] &gt; perm[i + 1].
</code></pre>
<p>Given a string s, reconstruct the lexicographically smallest permutation perm and return it.</p>
<pre><code class="language-python">class Solution:
    def findPermutation(self, s: str) -&gt; List[int]:
        stack = []
        res = []
        n=len(s)+1
       
        for i,ch in enumerate(s):
            idx = i+1
            if ch== 'I':
                stack.append(idx)
                while stack:
                    res.append(stack.pop())
            else:
                stack.append(idx)
        
        stack.append(n)
        while stack:
            res.append(stack.pop())
        return res 


#ANSWER
class Solution:
    def findPermutation(self, s: str) -&gt; List[int]:
        # 1 2 3 4 5 6
        # d d d I I
        # 4 3 2 1 5 6
        n = len(s)+1
        res  = list(range(1,n+1))
        def rev(l,r):
            while l&lt;r:
                res[l],res[r]=res[r],res[l]
                r-=1
                l+=1
        i = 0
        while i&lt;len(s):
            j = i
            while j&lt;len(s) and s[j]=='D':
                j+=1
            rev(i,j)
            i=j+1
        return res
        

</code></pre>
<p>two pointer 思路和答案是一样的  但就是写不出来。。。</p>
<h1 id="485-max-consecutive-ones-easy">485. Max Consecutive Ones （Easy）</h1>
<p>Given a binary array nums, return the maximum number of consecutive 1's in the array.</p>
<pre><code class="language-python">class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:
        c=0
        res = 0
        for n in nums:
            if n==1:
                c+=1
            else:
                c=0            
            res = max(res,c)
        return res

</code></pre>
<h1 id="font-colorred-486-predict-the-winner-mediumfont"><font color='red'> 486. Predict the Winner （Medium）</font></h1>
<p>You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.</p>
<p>Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.</p>
<p>Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.</p>
<pre><code class="language-python">class Solution:
    def PredictTheWinner(self, nums: List[int]) -&gt; bool:
        #[a b c d]   
        # 0 0 0 0
        # 0 0 0 0                      
        # 0 0 0 0                         
        # 0 0 0 0

        # dp[i,j] is i to j score.
        # dp[i,j] = max(nums[i]-dp[i+1,j]  , nums[j]-dp[i,j-1]   )

        n=len(nums)
       
        @lru_cache(None)
        def score(i,j):
            if i==j: return nums[i]
            left = nums[i]-score(i+1,j)  
            right = nums[j]-score(i,j-1)  
            return max(left,right)
        
        return score(0,n-1) &gt;=0
 #MY ANSWER
 class Solution:
    def PredictTheWinner(self, nums: List[int]) -&gt; bool:
        @lru_cache(None)
        def score(l,r):
            #opp will make sure I get a min score
            if l&gt;r: return 0
            if l==r: return nums[l]

            # if I choose l
            # opp score
            #score(l+1,r)

            myscore1 = nums[l]+ min(score(l+2,r),score(l+1,r-1))

            # if I choose r
            # opp score
            #score(l,r-1)
            myscore2 =  nums[r] + min(score(l+1,r-1),score(l,r-2))
            return max(myscore1,myscore2)

        
        l=0
        r=len(nums)-1
        
        return score(l,r)&gt;=score(l+1,r) or score(l,r)&gt;=score(l,r-1)       
</code></pre>
<p>dp can be tricky to write</p>
<pre><code class="language-java">public boolean PredictTheWinner(int[] nums) {
    int n = nums.length;
    int[][] dp = new int[n][n];
    for (int i = 0; i &lt; n; i++) { 
             dp[i][i] = nums[i]; 
             }
    for (int len = 1; len &lt; n; len++) {
        for (int i = 0; i &lt; n - len; i++) {
            int j = i + len;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] &gt;= 0;
}
</code></pre>
<h1 id="font-colorred-487-max-consecutive-ones-ii-medium-font"><font color='red'> 487. Max Consecutive Ones II (Medium) </font></h1>
<p>Given a binary array nums, return the maximum number of consecutive 1's in the array if you can flip at most one 0.</p>
<pre><code class="language-python">class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        # previous and current length of consecutive 1 
        pre, curr, maxlen = -1, 0, 0
        for n in nums:
            if n == 0:
                pre, curr = curr, 0
            else:
                curr += 1
            maxlen = max(maxlen, pre + 1 + curr )
        
        return maxlen


#通解
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:
        
        res = 0
        zero = 0
        k=1
        start = 0
        for i,n in enumerate(nums):
            if n==0:
                zero+=1
            
            while zero&gt;k:
                if nums[start]==0:
                    zero-=1
                start+=1
                

            res = max(res,i-start+1)
        return res 
</code></pre>
<p>知道是sliding window但写不出来。。。store the length of previous and current consecutive 1's (separated by the last 0) as pre and curr , respectively.<br>
Whenever we get a new number, update these two variables accordingly. The consecutive length would be pre + 1 + curr, where the 1 is a zero that got flipped to 1. (note that pre is initialized to -1, meaning that we haven't seen any 0 yet)</p>
<pre><code class="language-java">    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0, zero = 0, k = 1; // flip at most k zero
        for (int l = 0, h = 0; h &lt; nums.length; h++) {
            if (nums[h] == 0)                                           
                zero++;
            while (zero &gt; k)
                if (nums[l++] == 0)
                    zero--;                                     
            max = Math.max(max, h - l + 1);
        }                                                               
        return max;             
    }
</code></pre>
<p>flip k 的通解</p>
<h1 id="font-colorred-488-zuma-game-hardfont"><font color='red'> 488. Zuma Game （Hard）</font></h1>
<p>You are playing a variation of the game Zuma.<br>
In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.<br>
Your goal is to clear all of the balls from the board. On each turn:<br>
Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.<br>
If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.<br>
If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.<br>
If there are no more balls on the board, then you win the game.<br>
Repeat this process until you either win or do not have any more balls in your hand.<br>
Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.</p>
<pre><code class="language-python">class Solution:
    def findMinStep(self, board: str, hand: str) -&gt; int:

        @lru_cache(None)
        def clean(board):
            stack = []
            for b in board:
                if stack and stack[-1][0] != b and stack[-1][1] &gt;= 3:
                    stack.pop()
                if not stack or stack[-1][0] != b:
                    stack += [b, 1],
                else:
                    stack[-1][1] += 1
            if stack and stack[-1][1] &gt;= 3:
                stack.pop()
            return ''.join([a*b for a,b in stack])

        @lru_cache(None)
        def dfs(board, hand):
            if not board:
                return 0
            if not hand:
                return float('inf')
            m = len(board)
            ans = float('inf')
            for j, b in enumerate(hand):
                new_hand = hand[:j] + hand[j+1:]
                for i in range(m + 1):
                    new_board = clean(board[:i] + b + board[i:])
                    ans = min(ans, 1 + dfs(new_board, new_hand))
            return ans
        
        ans = dfs(board, hand)
        return ans if ans &lt; float('inf') else -1

</code></pre>
<p>TLE backtracking dfs, bfs with optimize pass</p>
<pre><code class="language-python">class Solution:
    def findMinStep(self, board: str, hand: str) -&gt; int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i &lt; 0:
                return s
            
            left = right = i
            while left &gt; 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 &lt; len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length &gt;= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = &quot;&quot;.join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j &gt; 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i &gt; 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i &lt; len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0&lt;i&lt;len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1

</code></pre>
<p>bfs 优化有意思，1）board 过到i位置相同情况下，ball之前见过的直接skip， 2）在board 【i-1】==ball时候skip，相当于不在末尾放ball。 3）board【i】=hand【j】放置ball容易理解 4）发现之前boad 已经连续2个了board【i-1】==board【i】，可以随便放置ball碰运气。但是不要放置和i一样的ball这样违背了rule2不在末尾放球的规定.</p>
<h1 id="489-robot-room-cleaner-hard">489. Robot Room Cleaner (hard)</h1>
<p>You are controlling a robot that is located somewhere in a room. The room is modeled as an m x n binary grid where 0 represents a wall and 1 represents an empty slot.</p>
<p>The robot starts at an unknown location in the room that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API Robot.</p>
<p>You are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. Each turn is 90 degrees.</p>
<p>When the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.</p>
<p>Design an algorithm to clean the entire room using the following APIs:</p>
<p>interface Robot {<br>
// returns true if next cell is open and robot moves into the cell.<br>
// returns false if next cell is obstacle and robot stays on the current cell.<br>
boolean move();</p>
<p>// Robot will stay on the same cell after calling turnLeft/turnRight.<br>
// Each turn will be 90 degrees.<br>
void turnLeft();<br>
void turnRight();</p>
<p>// Clean the current cell.<br>
void clean();<br>
}</p>
<p>Note that the initial direction of the robot will be facing up. You can assume all four edges of the grid are all surrounded by a wall.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the robot's control interface.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class Robot:
#    def move(self):
#        &quot;&quot;&quot;
#        Returns true if the cell in front is open and robot moves into the cell.
#        Returns false if the cell in front is blocked and robot stays in the current cell.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def turnLeft(self):
#        &quot;&quot;&quot;
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def turnRight(self):
#        &quot;&quot;&quot;
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def clean(self):
#        &quot;&quot;&quot;
#        Clean the current cell.
#        :rtype void
#        &quot;&quot;&quot;

class Solution:
    def cleanRoom(self, robot):
        &quot;&quot;&quot;
        :type robot: Robot
        :rtype: None
        &quot;&quot;&quot;
        
        visited=set()
        degree = 90
        #degree direction dic
        dic = {'u':90,'r':0,'l':180,'d':270}
        dix = {'u':0,'r':1,'l':-1,'d':0}
        diy = {'u':1,'r':0,'l':0,'d':-1}
        drev = {'u':'d','d':'u','l':'r','r':'l'}
        #assume init is up
        def move(dir):
            nonlocal degree
            delta = degree - dic[dir]
            if delta&gt;0:
                for _ in range(delta//90):
                    robot.turnRight()
            if delta&lt;0:
                for _ in range(-delta//90):
                    robot.turnLeft()
            degree = dic[dir]
            return robot.move()
        
        def dfs(x,y):
            if (x,y) in visited: return
            visited.add((x,y))
            robot.clean()
            for dir in ['u','d','l','r']:
                new_x = x+dix[dir]
                new_y = y+diy[dir]
                if (new_x,new_y) not in visited:
                    if move(dir):
                        dfs(new_x,new_y)
                        move(drev[dir])
                        
        
        dfs(0,0)


</code></pre>
<p>backtracking... nothing hard</p>
<h1 id="490-the-maze-medium">490. The Maze (Medium)</h1>
<p>There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.<br>
Given the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return true if the ball can stop at the destination, otherwise return false.</p>
<pre><code class="language-python">class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -&gt; bool:
        #    d  r l  u
        dx = [0,1,-1,0]
        dy = [1,0,0,-1]
        m=len(maze)
        n=len(maze[0])
        if start==destination: return True
        visited = set()
        self.res = False
        def dfs(x,y):
            visited.add((x,y))
            if [x,y]==destination:
                self.res = True
                return
            
            for i in range(4):
                new_x = x+dx[i]
                new_y = y+dy[i]
                while new_x&gt;=0 and new_x&lt;m and new_y&gt;=0 and new_y&lt;n and maze[new_x][new_y]==0:
                    new_x+=dx[i]
                    new_y+=dy[i]
                
                new_x -= dx[i]
                new_y -= dy[i]
                if (new_x,new_y) not in visited:
                    dfs(new_x,new_y) 
            
        dfs(*start)
        return self.res

</code></pre>
<p>有点卡，卡在了dfs 不能直接return true or false， 设置了个self.res捕捉结果。还能用BFS。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自装KIDD-10/22不同品牌子弹Group分析 ]]></title>
        <id>https://headhuanglan.github.io/post/zi-zhuang-kidd-1022-bu-tong-pin-pai-zi-dan-group-fen-xi/</id>
        <link href="https://headhuanglan.github.io/post/zi-zhuang-kidd-1022-bu-tong-pin-pai-zi-dan-group-fen-xi/">
        </link>
        <updated>2022-08-17T14:24:39.000Z</updated>
        <summary type="html"><![CDATA[<p>找到适合首把22LR定制枪的最佳子弹</p>
]]></summary>
        <content type="html"><![CDATA[<p>找到适合首把22LR定制枪的最佳子弹</p>
<!-- more -->
<h1 id="器材">器材</h1>
<h2 id="枪">枪</h2>
<ul>
<li>KIDD Bolt</li>
<li>KIDD Two Stage Trigger （Pull Weight: 8oz/8oz=1lb ）</li>
<li>KIDD Bolt Handle Charging Assembly With Guide Rod &amp; Springs</li>
<li>KIDD Aftermarket .22LR Receiver Classic Slip Fit Model</li>
<li>KIDD 22LR Match Stainless Steel Rifle Bull Barrel 20'' Bead Blasted</li>
<li>Boyds At-One Applejack Stock</li>
<li>Vortex Optics Diamondback Tactical 6-24x50 First Focal Plane Riflescopes - EBR-2C</li>
</ul>
<h2 id="脚架及支撑">脚架及支撑</h2>
<ul>
<li>Harris Engineering S-BRM Hinged Base 6 - 9-Inch BiPod</li>
<li>Caldwell Deadshot Filled, Rear Shooting Bag</li>
<li>MIM Mfg S Lock for S Series Harris Bipod</li>
</ul>
<h2 id="弹药">弹药</h2>
<blockquote>
<p>Speed of Sound (30 Celsius) = 1145 fps</p>
</blockquote>
<ul>
<li>CCI Standard Velocity  （1070fps）</li>
<li>Eley Semi-Auto Benchrest Precision （1060 fps）</li>
<li>Norma TAC-22  （1083 fps）</li>
<li>Eley Match（1085 fps）</li>
<li>SK Pistol Match Special（955 fps）</li>
<li>SK Rifle Match（955 fps）</li>
<li>Blazer Ammunition 22 Long Rifle 40 Grain Lead Round Nose （1235 fps）</li>
<li>Lapua Pistol King （950 fps）</li>
<li>Aguila Super Maximum （1750 fps）</li>
<li>CCI MiniMag (1235 fps)</li>
<li>Federal AutoMatch 325 (1200 fps)</li>
</ul>
<h1 id="实验">实验</h1>
<h2 id="气温">气温</h2>
<ul>
<li>30度</li>
</ul>
<h2 id="风力风向">风力风向</h2>
<ul>
<li>微风</li>
</ul>
<h2 id="射击距离">射击距离</h2>
<ul>
<li>55码</li>
</ul>
<h2 id="实验方式">实验方式</h2>
<ul>
<li>最左边的标定靶纸调整瞄准镜的高度和风向，20发。</li>
<li>每5发一个group射击5次</li>
<li>每完成一种子弹射击用枪绳清理枪管2次，清理bolt和breechface 。等待枪管冷却。</li>
</ul>
<blockquote>
<p>所有的射击实验的 Takedown Screw 10 inch lbs 遵照KIDD给出的推荐值.</p>
</blockquote>
<h2 id="分析软件">分析软件</h2>
<ul>
<li>（Android） Range Buddy</li>
</ul>
<h1 id="结果">结果</h1>
<ul>
<li>day1 shooting<br>
<img src="https://headhuanglan.github.io/post-images/KIDD.JPG" alt="" loading="lazy"></li>
<li>day2 shooting<br>
<img src="https://headhuanglan.github.io/post-images/KIDD2.JPG" alt="" loading="lazy"></li>
</ul>
<h2 id="分析-moa">分析 （MOA）</h2>
<table>
<thead>
<tr>
<th>弹药</th>
<th>50发价格</th>
<th>Group1</th>
<th>Group2</th>
<th>Group3</th>
<th>Group4</th>
<th>Group5</th>
<th>Min</th>
<th>Max</th>
<th>Avg</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SK Pistol Match Special</strong></td>
<td>$11.99</td>
<td>0.62</td>
<td>0.62</td>
<td>0.79</td>
<td>0.91</td>
<td>0.74</td>
<td>0.62</td>
<td>0.79</td>
<td><strong>0.736</strong></td>
</tr>
<tr>
<td>Eley Match</td>
<td>$21.99</td>
<td>0.34</td>
<td>0.68</td>
<td>0.57</td>
<td>0.74</td>
<td>1.59</td>
<td>0.34</td>
<td>1.59</td>
<td>0.784</td>
</tr>
<tr>
<td>Lapua Pistol King</td>
<td>$14.72</td>
<td>1.09</td>
<td>0.54</td>
<td>0.6</td>
<td>0.76</td>
<td>0.98</td>
<td>0.54</td>
<td>1.09</td>
<td>0.794</td>
</tr>
<tr>
<td>Eley Semi-Auto Benchrest Precision</td>
<td>$15.99</td>
<td>0.53</td>
<td>0.79</td>
<td>0.74</td>
<td>0.95</td>
<td>1.0</td>
<td>0.53</td>
<td>1.0</td>
<td>0.802</td>
</tr>
<tr>
<td>SK Rifle Match</td>
<td>$12.99</td>
<td>0.68</td>
<td>0.68</td>
<td>1.19</td>
<td>0.91</td>
<td>0.96</td>
<td>0.68</td>
<td>1.19</td>
<td>0.884</td>
</tr>
<tr>
<td>CCI Standard Velocity</td>
<td>$4.99</td>
<td>0.89</td>
<td>1.05</td>
<td>1.05</td>
<td>1.32</td>
<td>0.95</td>
<td>0.89</td>
<td>1.32</td>
<td>1.052</td>
</tr>
<tr>
<td>Blazer</td>
<td>$3.99</td>
<td>1.24</td>
<td>1.01</td>
<td>2.07</td>
<td>1.01</td>
<td>0.83</td>
<td>0.83</td>
<td>2.07</td>
<td>1.232</td>
</tr>
<tr>
<td>Norma TAC-22</td>
<td>$4.29</td>
<td>0.74</td>
<td>1.79</td>
<td>1.63</td>
<td>1.21</td>
<td>1.26</td>
<td>0.74</td>
<td>1.79</td>
<td>1.326</td>
</tr>
<tr>
<td>CCI MiniMag</td>
<td>$6.0</td>
<td>1.07</td>
<td>1.28</td>
<td>2.39</td>
<td>1.24</td>
<td>1.67</td>
<td>1.07</td>
<td>2.39</td>
<td>1.53</td>
</tr>
<tr>
<td>Federal AutoMatch 325</td>
<td>$3.23</td>
<td>1.54</td>
<td>1.58</td>
<td>2.91</td>
<td>2.27</td>
<td>2.1</td>
<td>1.54</td>
<td>2.91</td>
<td>2.08</td>
</tr>
<tr>
<td>Aguila Super Maximum</td>
<td>$8.06</td>
<td>5.48</td>
<td>3.64</td>
<td>6.84</td>
<td>3.96</td>
<td>6.3</td>
<td>3.64</td>
<td>6.84</td>
<td>5.244</td>
</tr>
</tbody>
</table>
<h1 id="结论">结论</h1>
<ul>
<li>枪的精度在1MOA以下</li>
<li>fps不能超过声速Group大到没法看, impact target 时候存在超声速-声速转换区。</li>
<li>SK Pistol Match Special 最好结果</li>
<li>Eley Match应该是操作问题导致outlier比较大，除去outlier Eley Match结果最好。</li>
<li>性价比最高的CCI Standard Velocity</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统设计]]></title>
        <id>https://headhuanglan.github.io/post/system-design/</id>
        <link href="https://headhuanglan.github.io/post/system-design/">
        </link>
        <updated>2022-03-27T23:23:07.000Z</updated>
        <summary type="html"><![CDATA[<p>System Design 资源汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>System Design 资源汇总</p>
<!-- more -->
<p><a href="https://www.youtube.com/watch?v=PdtlXdse7pw&amp;list=PL4KdJM8LzAMecwInbBK5GJ3Anz-ts75RQ">DDIA书视频总结</a></p>
<p><a href="https://www.interviewbit.com/courses/system-design/">InterviewBit系统设计题汇总</a></p>
<p><a href="https://github.com/donnemartin/system-design-primer">system design primer github repo</a></p>
<p><a href="https://www.hiredintech.com/classrooms/system-design/lesson/52">system design class</a></p>
<p><a href="https://www.educative.io/courses/grokking-the-system-design-interview">付费 grokking system design interview</a></p>
<p><a href="https://luanjunyi.medium.com/the-table-of-contents-416d2240fa8e">大佬的medium文章</a></p>
<p><a href="http://blog.gainlo.co/index.php/category/system-design-interview-questions/">已经解决的系统设计问题合集</a></p>
<p><a href="http://highscalability.com/blog/2022/1/25/designing-uber.html/">Design Uber</a></p>
<p><a href="http://highscalability.com/blog/2022/1/17/designing-tinder.html">Design Tinder</a></p>
<p><a href="http://highscalability.com/blog/2022/1/11/designing-instagram.html">Design Instagram</a></p>
<p><a href="http://highscalability.com/blog/2022/1/3/designing-whatsapp.html">Design Whatsapp</a></p>
<p><a href="http://highscalability.com/blog/2021/12/13/designing-netflix.html">Design Netflix</a></p>
<p>https://leetcode.com/company/facebook/discuss/229177/My-System-Design-Template<br>
(1) FEATURE EXPECTATIONS [5 min]</p>
<pre><code>    (1) Use cases
    (2) Scenarios that will not be covered
    (3) Who will use
    (4) How many will use
    (5) Usage patterns
</code></pre>
<p>(2) ESTIMATIONS [5 min]</p>
<pre><code>    (1) Throughput (QPS for read and write queries)
    (2) Latency expected from the system (for read and write queries)
    (3) Read/Write ratio
    (4) Traffic estimates
            - Write (QPS, Volume of data)
            - Read  (QPS, Volume of data)
    (5) Storage estimates
    (6) Memory estimates
            - If we are using a cache, what is the kind of data we want to store in cache
            - How much RAM and how many machines do we need for us to achieve this ?
            - Amount of data you want to store in disk/ssd
</code></pre>
<p>(3) DESIGN GOALS [5 min]</p>
<pre><code>    (1) Latency and Throughput requirements
    (2) Consistency vs Availability  [Weak/strong/eventual =&gt; consistency | Failover/replication =&gt; availability]
</code></pre>
<p>(4) HIGH LEVEL DESIGN [5-10 min]</p>
<pre><code>    (1) APIs for Read/Write scenarios for crucial components
    (2) Database schema
    (3) Basic algorithm
    (4) High level design for Read/Write scenario
</code></pre>
<p>(5) DEEP DIVE [15-20 min]</p>
<pre><code>    (1) Scaling the algorithm
    (2) Scaling individual components: 
            -&gt; Availability, Consistency and Scale story for each component
            -&gt; Consistency and availability patterns
    (3) Think about the following components, how they would fit in and how it would help
            a) DNS
            b) CDN [Push vs Pull]
            c) Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
            d) Reverse Proxy
            e) Application layer scaling [Microservices, Service Discovery]
            f) DB [RDBMS, NoSQL]
                    &gt; RDBMS 
                        &gt;&gt; Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
                    &gt; NoSQL
                        &gt;&gt; Key-Value, Wide-Column, Graph, Document
                            Fast-lookups:
                            -------------
                                &gt;&gt;&gt; RAM  [Bounded size] =&gt; Redis, Memcached
                                &gt;&gt;&gt; AP [Unbounded size] =&gt; Cassandra, RIAK, Voldemort
                                &gt;&gt;&gt; CP [Unbounded size] =&gt; HBase, MongoDB, Couchbase, DynamoDB
            g) Caches
                    &gt; Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
                    &gt; Eviction policies:
                            &gt;&gt; Cache aside
                            &gt;&gt; Write through
                            &gt;&gt; Write behind
                            &gt;&gt; Refresh ahead
            h) Asynchronism
                    &gt; Message queues
                    &gt; Task queues
                    &gt; Back pressure
            i) Communication
                    &gt; TCP
                    &gt; UDP
                    &gt; REST
                    &gt; RPC
</code></pre>
<p>(6) JUSTIFY [5 min]</p>
<pre><code>    (1) Throughput of each layer
    (2) Latency caused between each layer
    (3) Overall latency justification
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-08]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-08/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-08/">
        </link>
        <updated>2022-03-07T10:50:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-471-encode-string-with-shortest-length-hardfont"><font color='red'> 471. Encode String with Shortest Length （Hard）</font></h1>
<p>Given a string s, encode the string such that its encoded length is the shortest.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. k should be a positive integer.<br>
If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    @lru_cache(None)
    def encode(self, s: str) -&gt; str:
        i=(s+s).find(s,1)
        encoded=str(len(s)//i)+'['+self.encode(s[:i])+']' if i&lt;len(s) else s
        splitEncoded=[self.encode(s[:i])+self.encode(s[i:]) for i in range(1,len(s))]
        return min(splitEncoded+[encoded],key=len)
</code></pre>
<p>答案绝了。。。<br>
For any s, you can either<br>
Do not encode it<br>
Or encode it to one string if possible<br>
Or, split it into two, encode the two substring to their shortest possible length, and combine them<br>
Pick up the shortest result from 1~3.<br>
During this process, you should remember the best encoding result for all substrings so that it can be reused.<br>
For #2, you can use LeetCode 459: Repeated Substring Pattern to find out whether the &quot;s&quot; is repeated or not, and how many times it is repeated:<br>
&quot;i=(s+s).find(s,1)&quot;<br>
&quot;i&quot; is the length of repeating pattern. If i&gt;=len(s), then s is not repeated.</p>
<h1 id="font-colorred-472-concatenated-words-hardfont"><font color='red'> 472. Concatenated Words （Hard）</font></h1>
<p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.<br>
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<pre><code class="language-python">
#TLE TRIE
class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -&gt; List[str]:

        class T:
            def __init__(self):
                self.data = collections.defaultdict(T)
                self.isword = False
            
            def insert(self,word):
                cur = self
                for ch in word:
                    cur = cur.data[ch]
                cur.isword = True
            
            def search(self,word,start,root, count):
                
                n = len(word)
                cur = root
                for i in range(start,n):
                    cur= cur.data[word[i]]
                    if cur.isword:
                        if i==n-1:
                            return count&gt;=1
                        elif self.search(word,i+1,root,count+1):
                            return True
                return False
            
        tire = T()
        for w in words:
            tire.insert(w)
        
        res =[]
        for w in words:
            if tire.search(w,0,tire,0):
                res.append(w)
        
        return res

###
class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -&gt; List[str]:
        d = set(words)
        @lru_cache(None)
        def dfs(word):
            for i in range(1, len(word)):
                prefix = word[:i]
                suffix = word[i:]
                
                if prefix in d and suffix in d:
                    return True
                if prefix in d and dfs(suffix):
                    return True
                if suffix in d and dfs(prefix):
                    return True
            
            return False
        
        res = []
        for word in words:
            if dfs(word):
                res.append(word)
        
        return res

</code></pre>
<p>看答案捐膝盖。。</p>
<h1 id="font-colorred-473-matchsticks-to-square-medium-font"><font color='red'> 473. Matchsticks to Square (Medium) </font></h1>
<p>You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.<br>
Return true if you can make this square and false otherwise.</p>
<pre><code class="language-python">#TLE
class Solution:
    def makesquare(self, matchsticks: List[int]) -&gt; bool:
        length = sum(matchsticks)//4
        if length*4!= sum(matchsticks): return False
        
        holds=[[],[],[],[]]
        self.result=False
        def bt(i):
            if i&gt;=len(matchsticks): return
            for hold in holds:
                val=matchsticks[i]
                hold.append(val)
                if len(set(map(sum,holds)))==1 and i==len(matchsticks)-1:
                    self.result=True
                    return 
                bt(i+1)
                hold.pop()
        
        bt(0)
        
        return self.result
#MY ANSWER
class Solution:
    def makesquare(self, matchsticks: List[int]) -&gt; bool:
        matchsticks.sort(key=lambda x:-x)
        L=sum(matchsticks)//4
        if sum(matchsticks)%4!=0: return False
        sums  = [0]*4
        def dfs(i):
            if i==len(matchsticks): 
                if len(set(sums))==1 and sums[0]==L:
                    return True
                return False

            for j in range(4):
                if sums[j]+matchsticks[i]&lt;=L:
                    sums[j]+=matchsticks[i]
                    if dfs(i+1):
                        return True
                    sums[j]-=matchsticks[i]
                    #after recursion we can not put any stick ，so a fail。
                    if sums[j]==0: return False
            return False
        
        return dfs(0)
#ANSWER
class Solution:
    def makesquare(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # If there are no matchsticks, then we can't form any square
        if not nums:
            return False

        # Number of matchsticks we have
        L = len(nums)

        # Perimeter of our square (if one can be formed)
        perimeter = sum(nums)

        # Possible side of our square.
        possible_side =  perimeter // 4

        # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).
        if possible_side * 4 != perimeter:
            return False

        # Reverse sort the matchsticks because we want to consider the biggest one first.
        nums.sort(reverse=True)

        # This array represents the 4 sides and their current lengths
        sums = [0 for _ in range(4)]

        # Our recursive dfs function.
        def dfs(index):

            # If we reach the end of matchsticks array, we check if the square was formed or not
            if index == L:
                # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.
                return sums[0] == sums[1] == sums[2] == possible_side

            # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are &gt;= the size of the current matchstick)
            for i in range(4):
                # If this matchstick can fir in the space left for the current side
                if sums[i] + nums[index] &lt;= possible_side:
                    # Recurse
                    sums[i] += nums[index]
                    if dfs(index + 1):
                        return True
                    # Revert the effects of recursion because we no longer need them for other recursions.
                    sums[i] -= nums[index]
            return False        
        return dfs(0)
</code></pre>
<p>初次尝试backtracking TLE。。。答案same idea with trick can pass， reverse sorting and early stopping。</p>
<h1 id="font-colorred-474-ones-and-zeroes-mediumfont"><font color='red'> 474. Ones and Zeroes （Medium）</font></h1>
<p>You are given an array of binary strings strs and two integers m and n.<br>
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.<br>
A set x is a subset of a set y if all elements of x are also elements of y.</p>
<pre><code class="language-python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        
        dp=[[0 for _ in range(n+1)] for __ in range(m+1)]
        for s in strs:
            c0=s.count('0')
            c1=s.count('1')
            for zeros in range(m,c0-1,-1):
                for ones in range(n,c1-1,-1):
                    dp[zeros][ones] = max(1+dp[zeros-c0][ones-c1],dp[zeros][ones])
        
        return dp[m][n]
#ANSWER
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        @lru_cache(None)
        def calculate(i,zeroes,ones):
            if i==len(strs): return 0
            c1=strs[i].count('1')
            c0=strs[i].count('0')        
            taken=-1
            if zeroes-c0&gt;=0 and ones-c1&gt;=0:
                taken = calculate(i+1,zeroes-c0,ones-c1) +1
            not_taken=calculate(  i + 1, zeroes, ones )
            return max(taken, not_taken)
        return calculate(0, m, n) 
    
</code></pre>
<p>greedy failed....   DP? Should have got this one.   dp[i][j] denotes the maximum number of strings that can be included in the subset given only i 0's and j 1's are available. 从后向前因为不能覆盖之前的结果。</p>
<h1 id="font-colorred-475-heaters-mediumfont"><font color='red'> 475. Heaters （Medium）</font></h1>
<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.<br>
Every house can be warmed, as long as the house is within the heater's warm radius range.<br>
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.</p>
<pre><code class="language-python">
#TLE
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        #bfs
        visited=set()
        houses=set(houses)-set(heaters)
        dis=0
        while visited!=houses:
            #print(visited,houses)
            dis+=1
            for cur in heaters: 
                if cur+dis in houses and cur+dis not in visited:
                    visited.add(cur+dis)    
                if cur-dis in houses  and cur-dis not in visited:
                    visited.add(cur-dis)
        return dis
            
#ANSWER
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        #   h1    h2     h3
        heaters.sort()
        res = float('-inf')
        for h in houses:
            idx = bisect.bisect_left(heaters,h)
            leftHeaterDistance = h - heaters[idx - 1] if idx &gt; 0 else float('inf')
            rightHeaterDistance = heaters[idx] - h if idx &lt; len(heaters) else float('inf')
            res = max(res,min(leftHeaterDistance,rightHeaterDistance))
        return res
        
</code></pre>
<p>变种FBS 每次增加1 distance，TLE。看答案。max min + binary search</p>
<h1 id="476-number-complement-easy">476. Number Complement (Easy)</h1>
<p>The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.<br>
For example, The integer 5 is &quot;101&quot; in binary and its complement is &quot;010&quot; which is the integer 2.<br>
Given an integer num, return its complement.</p>
<pre><code class="language-python">class Solution:
    def findComplement(self, num: int) -&gt; int:
        mask= 2**len(bin(num)[2:])-1
        print(bin(mask),bin(num))
        return mask^num
#ANSWER
from math import log2
class Solution:
    def findComplement(self, num):
        # n is a length of num in binary representation
        n = floor(log2(num)) + 1        
        # bitmask has the same length as num and contains only ones 1...1
        bitmask = (1 &lt;&lt; n) - 1
        # flip all bits
        return bitmask ^ num
#ANSWER
class Solution:
    def findComplement(self, num):
        todo, bit = num, 1
        while todo:
            # flip current bit
            num = num ^ bit
            # prepare for the next run
            bit = bit &lt;&lt; 1
            todo = todo &gt;&gt; 1
        return num
</code></pre>
<h1 id="477-total-hamming-distance-medium">477. Total Hamming Distance (Medium)</h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.</p>
<pre><code class="language-python">#TLE
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:
        nums.sort()
        @lru_cache(None)
        def cal(a,b):
            val=a^b
            c=0
            while val:
                if val%2==1:
                    c+=1
                val&gt;&gt;=1
            return c
        res=0
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                res+=cal(nums[i],nums[j])
        return res


 

#MY ANSWER        
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:

        nbits = len(bin(max(nums))[2:])
        res =0
        for i in range(nbits):
            one = 0
            mask = 1&lt;&lt;i
            for n in nums:
                if n&amp;mask:
                    one+=1
            zero = len(nums)-one
            res +=  one*zero
        return res         
</code></pre>
<p>按照每一位计算hamming distance， one位置有m个 zero位置有n个，则distance += mn</p>
<h1 id="478-generate-random-point-in-a-circle-medium">478. Generate Random Point in a Circle （Medium）</h1>
<p>Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.<br>
Implement the Solution class:<br>
Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).<br>
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].</p>
<pre><code class="language-python">from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r
        x=r*(random()-0.5)*2
        y=r*(random()-0.5)*2
        while x*x+y*y&gt;r*r:
            x=r*(random()-0.5)*2
            y=r*(random()-0.5)*2
            
        
        return [self.x+x,self.y+y]
#ANSWER hard
from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r*math.sqrt(random())
        theta = 2*math.pi*random()
        x=r*math.cos(theta)
        y=r*math.sin(theta)
     
        return [self.x+x,self.y+y]
#ANSWER
import math
import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x = x_center
        self.y = y_center
        self.area = math.pi * radius ** 2

    def randPoint(self) -&gt; List[float]:
        theta = 2 * math.pi * random.random()
        R = math.sqrt(random.uniform(0, self.area) / math.pi)
        return [self.x + R * math.cos(theta), self.y + R * math.sin(theta)]
</code></pre>
<p>The area under any probability density function curve must be 1 . Therefore, the equation must be f(x)=2x Using our probability density function f , we can compute the cumulative distribution function F , where F(x) is the probability of sampling a point within a distance of x from the origin.F(x)=∫f(x)=∫2x=x2<br>
Lastly, we can use our cumulative distribution function F  to compute the inverse cumulative distribution function  F^{-1} , which accepts uniform random value between 0  and 1  and returns a random distance from origin in accordance with f</p>
<h1 id="font-colorred-479-largest-palindrome-product-hard-font"><font color='red'> 479. Largest Palindrome Product (Hard) </font></h1>
<p>Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.</p>
<pre><code class="language-python">class Solution:
    def largestPalindrome(self, n: int) -&gt; int:
        max_=10**n-1
        min_=max_//10
        for h in range(max_,min_,-1):
            left=h
            right=0
            #// construct the palindrome
            i=h
            while i:
                right=right*10+i%10
                left*=10
                i//=10
            
            palindrom=left+right
            #print(palindrom)
            for i in range(max_,min_,-1):
                j=palindrom//i
                #// terminate if the other number is greater than current number
                if j&gt;i: break
                if  palindrom%i==0: return palindrom%1337
        #// account for case n = 1
        return 9
</code></pre>
<p>没思路。。。先生成palin，再验证能否拆分成乘的形式。</p>
<h1 id="font-colorred-480-sliding-window-median-hardfont"><font color='red'> 480. Sliding Window Median （Hard）</font></h1>
<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.<br>
For examples, if arr = [2,3,4], the median is 3.<br>
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.<br>
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.<br>
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.</p>
<pre><code class="language-python">class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        odd=False
        pos1=0
        pos2=0
        if k%2==1:
            odd=True
            pos1=k//2
        else:
            pos1=k//2-1
            pos2=k//2
        
        res = []
        for i in range(k,len(nums)+1):
            tmp = sorted(nums[i-k:i])
            if odd: 
                res.append(tmp[pos1])
            else:
                res.append( (tmp[pos1]+tmp[pos2])/2)
        return res

#ANSWER O(nk)
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        window = sorted(nums[:k])
        medians = []
        for a, b in zip(nums, nums[k:] + [0]):
            if k&amp;1:
                medians.append( window[k//2])
            else:
                medians.append( (window[k//2]+window[k//2-1])/2.0)
            window.remove(a)
            bisect.insort(window, b)
        return medians

#ANSWER O(nlogk)
import heapq
from collections import defaultdict
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        if not nums or not k:
            return []
        #lo  hi
        lo = [] # max heap   
        hi = [] # min heap
        for i in range(k):
            if len(lo) == len(hi):
                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))
            else:
                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))
        ans = [float(hi[0])] if k &amp; 1 else [(hi[0] - lo[0]) / 2.0]
        to_remove = defaultdict(int)
        for i in range(k, len(nums)): # right bound of window
            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo
            out_num = nums[i-k]
            #out_num恰巧在lo的边界上，所以要更新边界
            if out_num &gt; -lo[0]:
                heapq.heappush(hi, -heapq.heappop(lo))
            to_remove[out_num] += 1

            #在lo边界上可以直接去掉
            while lo and to_remove[-lo[0]]:
                to_remove[-lo[0]] -= 1
                heapq.heappop(lo)
            #在hi边界上可以直接去掉
            while to_remove[hi[0]]:
                to_remove[hi[0]] -= 1
                heapq.heappop(hi)
            if k % 2:
                ans.append(float(hi[0]))
            else:
                ans.append((hi[0] - lo[0]) / 2.0)
        return ans
</code></pre>
<p>思路：维持small ，large 连个queue， 所有samll中元素都小于large， 所以median是 （max（small）+min（large））除以2，如果small ，large等长， 如果large长，则返回min（large）<br>
所以用heap， small用的是maxheap， large用的是minheap。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-07]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-07/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-07/">
        </link>
        <updated>2022-03-06T18:06:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="461-hamming-distance-easy">461. Hamming Distance (Easy)</h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given two integers x and y, return the Hamming distance between them.</p>
<pre><code class="language-python">class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        res=x^y
        c=0
        for i in range(32):
            if res &gt;&gt;i &amp; 1:
                c+=1
        return c
#
class Solution(object):
    def hammingDistance(self, x, y):
        &quot;&quot;&quot;
        :type x: int
        :type y: int
        :rtype: int
        &quot;&quot;&quot;
        xor = x ^ y
        distance = 0
        while xor:
            # mask out the rest bits
            if xor &amp; 1:
                distance += 1
            xor = xor &gt;&gt; 1
        return distance

#
class Solution:
    def hammingDistance(self, x, y):
        xor = x ^ y
        distance = 0
        while xor:
            distance += 1
            # remove the rightmost bit of '1'
            xor = xor &amp; (xor - 1)
        return distance
</code></pre>
<h1 id="462-minimum-moves-to-equal-array-elements-ii-medium">462. Minimum Moves to Equal Array Elements II (Medium)</h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment or decrement an element of the array by 1.<br>
Test cases are designed so that the answer will fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def minMoves2(self, nums: List[int]) -&gt; int:
        # nums[i]-mid
        nums.sort()
        mid= nums[len(nums)//2]
        return sum([abs(val-mid) for val in nums])

#O（n） use quickselect
class Solution:
    def minMoves2(self, nums: List[int]) -&gt; int:
        n = len(nums)
        
        def partition(idx,left,right):
            pval = nums[idx]
            nums[idx],nums[right] = nums[right],nums[idx]
            store_idx  = left
            for i in range(left,right):
                if nums[i]&lt;pval:
                    nums[store_idx],nums[i] = nums[i],nums[store_idx]
                    store_idx+=1
            
            nums[right],nums[store_idx] = nums[store_idx],nums[right]

            return store_idx
        
        def select(l,r,k):
            
            idx = random.randint(l,r)
            idx = partition(idx,l,r)
            
            if idx==k:
                return nums[k]
            elif idx&lt;k:
                return select(idx+1,r,k)
            else:
                return select(l,idx-1,k)
        
        mid = select(0,n-1,n//2)
        res =0 
        for n in nums:
            res+=abs(n-mid)
        return res
#JAVA ANSWER good to know
public class Solution {
    public int minMoves2(int[] nums) {
        int l = 0, r = nums.length - 1, sum = 0;
        Arrays.sort(nums);
        while (l &lt; r) {
            sum += nums[r] - nums[l];
            l++;
            r--;
        }
        return sum;
    }
}
</code></pre>
<h1 id="463-island-perimeter-easy">463. Island Perimeter (Easy)</h1>
<p>You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.<br>
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).<br>
The island doesn't have &quot;lakes&quot;, meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>
<pre><code class="language-python">class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:
        # find a neighor + neighbor4 but contact need to -contact number.
        visited=set()
        def nei(i,j):
            neis=[]
            for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if ii&lt;0 or ii&gt;=len(grid) or jj&lt;0 or jj&gt;=len(grid[0]) or grid[ii][jj]==0: 
                        continue
                neis.append((ii,jj))
            return neis
        
        self.res = 0
        
        def dfs(i,j):
            if (i,j) in visited: return
            visited.add((i,j))
            self.res+=4
            neis = nei(i,j)
            self.res-=len(neis)
            for ne in neis:
                if ne not in visited:
                    dfs(*ne)
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    dfs(i,j)
                    break
        return self.res

#MY ANSWER
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:
        
        matrix = []
        ncols = len(grid[0])
        row0 = [0]*(ncols+2)
        matrix.append(row0)
        for row in grid:
            matrix.append([0]+row+[0])
        matrix.append(row0[:])
        
        m,n = len(matrix),len(matrix[0])
        res = 0

        for i in range(1,m):
            for j in range(1,n):
                if  matrix[i][j]==1 and matrix[i][j-1]==0 and matrix[i-1][j]==0:
                    res+=2
                elif matrix[i][j]==0 and matrix[i][j-1]==1 and matrix[i-1][j]==0:
                    res+=1

                elif matrix[i][j]==1 and matrix[i][j-1]==0 and matrix[i-1][j]==1:
                    res+=1
                elif matrix[i][j]==0 and matrix[i][j-1]==1 and matrix[i-1][j]==1:
                    res+=2
                
                elif matrix[i][j]==0 and matrix[i][j-1]==0 and matrix[i-1][j]==1:
                    res+=1
                elif matrix[i][j]==0 and matrix[i][j-1]==0 and matrix[i-1][j]==0:
                    res+=0
                
                elif matrix[i][j]==1 and matrix[i][j-1]==1 and matrix[i-1][j]==1:
                    res+=0
                elif matrix[i][j]==1 and matrix[i][j-1]==1 and matrix[i-1][j]==0:
                    res+=1


        return res
            
</code></pre>
<h1 id="font-colorred-464-can-i-win-medium-font"><font color='red'> 464. Can I Win (Medium) </font></h1>
<p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.<br>
What if we change the game so that players cannot re-use integers?<br>
For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.<br>
Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.</p>
<pre><code class="language-python">class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool:
        if desiredTotal &lt;= 0: return True
        if maxChoosableInteger * (maxChoosableInteger + 1) // 2 &lt; desiredTotal: return False
        memo = {}

        def helper(nums, desiredTotal):
            hash = str(nums)
            if hash in memo:
                return memo[hash]
            #if nums[-1] &gt;= desiredTotal:
            #    return True
            if desiredTotal&lt;=0: return False
            for i in range(len(nums) - 1, -1, -1):
                if not helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):
                    memo[hash] = True
                    return True
            memo[hash] = False
            return False
         

        return helper(list(range(1, maxChoosableInteger + 1)), desiredTotal)
 
 #ANSWER
 class Solution:
    def canIWin(self, maxChoosableInteger, desiredTotal):
        total_sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2
        if total_sum &lt; desiredTotal:
            return False
        if desiredTotal &lt;= 0:
            return True

        self.map = {}
        self.used = [False] * (maxChoosableInteger + 1)
        return self.helper(desiredTotal)

    def helper(self, desiredTotal):
        if desiredTotal &lt;= 0:
            return False
        key = self.format(self.used)
        if key not in self.map:
            # try every unchosen number as the next step
            for i in range(1, len(self.used)):
                if not self.used[i]:
                    self.used[i] = True
                    # check whether this leads to a win (i.e. the other player loses)
                    if not self.helper(desiredTotal - i):
                        self.map[key] = True
                        self.used[i] = False
                        return True
                    self.used[i] = False
            self.map[key] = False
        return self.map[key]

    # transfer boolean[] to an Integer
    def format(self, used):
        num = 0
        for b in used:
            num &lt;&lt;= 1
            if b:
                num |= 1
        return num

</code></pre>
<p>can not reuse integer， Force Win return True.</p>
<h1 id="font-colorred-465-optimal-account-balancing-hardfont"><font color='red'> 465. Optimal Account Balancing （Hard）</font></h1>
<p>You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.<br>
Return the minimum number of transactions required to settle the debt.</p>
<pre><code class="language-python">class Solution:
    def minTransfers(self, transactions: List[List[int]]) -&gt; int:
        dic = defaultdict(int)
        for a,b,val in transactions:
            dic[a]-=val
            dic[b]+=val
    
        debt = [d for d in dic.values() ]
    
        def dfs(i):
            if i==len(debt): return 0 
            if debt[i]==0: return dfs(i+1)
            r = float('inf')
            for j in range(i+1,len(debt)):
                if debt[i]*debt[j]&lt;0:
                    #j will be total responsable for i's debt
                    debt[j]+=debt[i]
                    r = min(r,1+dfs(i+1))
                    debt[j]-=debt[i]
            return r 
        return dfs(0)



</code></pre>
<p>idea is tricky...  person index i have debt[i] for other person j , if other person have neg sign then person s. update debt[i] with debt[j] (so person j will take full responsiblity of person i). r=min(r,1+dfs(i+1))</p>
<h1 id="font-colorred-466-count-the-repetitions-hard-font"><font color='red'> 466. Count The Repetitions (Hard) </font></h1>
<p>We define str = [s, n] as the string str which consists of the string s concatenated n times.<br>
For example, str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;.<br>
We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.<br>
For example, s1 = &quot;abc&quot; can be obtained from s2 = &quot;abdbec&quot; based on our definition by removing the bolded underlined characters.<br>
You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].<br>
Return the maximum integer m such that str = [str2, m] can be obtained from str1.</p>
<pre><code class="language-python">
class Solution:
    def getMaxRepetitions(self, s1, n1, s2, n2):
        d, l1, l2, i1, i2 = {}, len(s1), len(s2), 0, 0
        tot = l1 * n1

        while i1 &lt; tot:
            if s1[i1 % l1] == s2[i2 % l2]:
                if (i1 % l1, i2 % l2) in d:
                    prev1, prev2 = d[(i1 % l1, i2 % l2)]
                    cir1, cir2 = i1 - prev1, i2 - prev2
                    count_cir1 = (tot - i1) // cir1
                    i1 += count_cir1 * cir1
                    i2 += count_cir1 * cir2
                    if i1 &gt;= tot: break
                else:
                    d[(i1 % l1, i2 % l2)] = (i1, i2)
                i2 += 1
            i1 += 1
        return i2 // l2 // n2

#TLE BINARY SEARCH
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -&gt; int:
        # s1 acbacbacbacb s2 = abab
        l=1
        r=len(s1)*n1//len(s2)//n2+1

        def GCD(a,b):
            while b:
                a, b = b, a%b
            return a

        def s2ins1(s2,s1):
            ls2 = len(s2)
            ls1 = len(s1)
            start = 0
            for i in range(ls1):
                if s1[i] == s2[start]:
                    start+=1
                    if start==ls2:
                        break
            return start == ls2

        while l&lt;=r:
            m = (l+r)//2
            tmp = GCD(m*n2,n1)
            #print(tmp,m*n2,n1)
            if s2ins1(s2*(m*n2//tmp) , s1*(n1//tmp)):
                # m is large:
                l = m+1
            else:
                r = m-1
        
        return l-1 
</code></pre>
<p>直接数出现的次数算重复不行，因为还有字母出现次序问题。。。 得找重复pattern。 答案厉害。BINARY SEARCH TLE</p>
<h1 id="font-colorred-467-unique-substrings-in-wraparound-string-medium-font"><font color='red'> 467. Unique Substrings in Wraparound String (Medium) </font></h1>
<p>We define the string s to be the infinite wraparound string of &quot;abcdefghijklmnopqrstuvwxyz&quot;, so s will look like this:<br>
&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;.<br>
Given a string p, return the number of unique non-empty substrings of p are present in s.</p>
<pre><code class="language-python">def findSubstringInWraproundString(self, p):
        res = {i: 1 for i in p}
        l = 1
        for i, j in zip(p, p[1:]):
            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
            res[j] = max(res[j], l)
        return sum(res.values())

#ANSWER DP 思路：若字符连续，当前可形成的substring个数+1，若不连续substring个数=1，更新count 为防止重复字符overwrite，更新时候取max。 
class Solution:
    def findSubstringInWraproundString(self, p: str) -&gt; int:
        count=[0]*26
        cur_maxlen=0
        for i in range(len(p)):
            if i&gt;0 and (ord(p[i])-ord(p[i-1]))%26==1:
                cur_maxlen+=1
            else:
                cur_maxlen=1
            
            index=ord(p[i])-ord('a')
            count[index]=max(count[index],cur_maxlen)
        
        return sum(count)

#
class Solution:
    def findSubstringInWraproundString(self, s: str) -&gt; int:
         
        dp = [0]*26
        cur_maxlen = 0

    
        for i,n in enumerate(s):
            if i&gt;0 and (ord(n) - ord(s[i-1])) % 26==1:
                cur_maxlen+=1
            else:
                cur_maxlen = 1
            
            idx = ord(n)-ord('a')
            dp[idx] = max(dp[idx],cur_maxlen)
             
        return sum(dp)
</code></pre>
<p>DP[i] 意思是以s【i】为结尾的substring的个数。 注意取max<br>
Each single charecter contribution is initialized to 1<br>
if the order is continued, the contribution is increased by 1 from previous character contribution</p>
<p>example string zabce</p>
<p>Values got incremented in the following way</p>
<pre><code>z -&gt; 1
a -&gt; 1 + 1 (or) z + 1 -&gt; 2
b -&gt; 1 + 1 + 1 (or) a + 1 -&gt; 3
c -&gt; 1 + 1 + 1 + 1 (or) b + 1 -&gt; 4
e -&gt; 1 (ord(j) - ord(i)) % 26 != 1 here
</code></pre>
<p>So the final answer is contribution from z + a + b + c + e (1 + 2 + 3 + 4 + 1 = 11)</p>
<pre><code>max(res[j], l) is required to handle cases where the character is repeated.
</code></pre>
<p>For example in zaba, since each each unique character is assigned as key to res, the 2nd a contribution should not replace the 1st a contribution until it exceeds the 1st a contribution</p>
<h1 id="468-validate-ip-address-medium">468. Validate IP Address （Medium）</h1>
<p>Given a string queryIP, return &quot;IPv4&quot; if IP is a valid IPv4 address, &quot;IPv6&quot; if IP is a valid IPv6 address or &quot;Neither&quot; if IP is not a correct IP of any type.<br>
A valid IPv4 address is an IP in the form &quot;x1.x2.x3.x4&quot; where 0 &lt;= xi &lt;= 255 and xi cannot contain leading zeros. For example, &quot;192.168.1.1&quot; and &quot;192.168.1.0&quot; are valid IPv4 addresses but &quot;192.168.01.1&quot;, while &quot;192.168.1.00&quot; and &quot;192.168@1.1&quot; are invalid IPv4 addresses.<br>
A valid IPv6 address is an IP in the form &quot;x1:x2:x3:x4:x5:x6:x7:x8&quot; where:<br>
1 &lt;= xi.length &lt;= 4<br>
xi is a hexadecimal string which may contain digits, lower-case English letter ('a' to 'f') and upper-case English letters ('A' to 'F').<br>
Leading zeros are allowed in xi.<br>
For example, &quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; and &quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot; are valid IPv6 addresses, while &quot;2001:0db8:85a3::8A2E:037j:7334&quot; and &quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; are invalid IPv6 addresses.</p>
<pre><code class="language-python">class Solution:
    def validIPAddress(self, queryIP: str) -&gt; str:
        
        def convert4(string):
            # in range 0~255
            # cannot leading zeros
            # number only
            if not string: return False
            if len(string)&gt;1 and string[0]=='0': return False
            val=0
            for s in string:
                if s not in '0123456789':
                    return False
                val=val*10+int(s)
            
            #return True if success, else False
            if val&gt;=0 and val&lt;=255:
                return True
            return False
        
        def convert6(string):
            if not string: return False
            #length 1~4
            # hexadecial string 0~9 a~f A~F
            if len(string)&gt;4: return False
            for s in string:
                if s not in '0123456789abcdefABCDEF':
                    return False
            return True
        
        if '.' in queryIP:
            data = queryIP.split('.')
            if len(data)==4 and all([convert4(string) for string in data]):
                return 'IPv4'        
            
        elif ':' in queryIP:
            data = queryIP.split(':')
            if len(data)==8 and all([convert6(string) for string in data]):
                return 'IPv6'
        
        return 'Neither'

</code></pre>
<p>只需要细心的题目</p>
<h1 id="469-convex-polygon-medium">469. Convex Polygon （Medium）</h1>
<p>You are given an array of points on the X-Y plane points where points[i] = [xi, yi]. The points form a polygon when joined sequentially.<br>
Return true if this polygon is convex and false otherwise.<br>
You may assume the polygon formed by given points is always a simple polygon. In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don't intersect each other.</p>
<pre><code class="language-python">def isConvex(self, p: List[List[int]]) -&gt; bool:
    def ccw(a, b, c):
        # (b-a) X (c-a)
        return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) 
    res = [ccw(p[i-2], p[i-1], p[i]) for i in range(len(p))]
    return abs(sum(res)) == sum(abs(i) for i in res)

#MY ANSWER
class Solution:
    def isConvex(self, points: List[List[int]]) -&gt; bool:
        #  x X y = ad-bc  
        #  i j k
        #  a b 0 
        #  c d 0

        vects = []
        for i in range(len(points)):
            a = points[i]
            b = points[i-1]
            vects.append([a[0]-b[0],a[1]-b[1]])
        
        aXb = []
        for i in range(len(vects)):
            a = vects[i]
            b = vects[i-1]
            aXb.append(a[0]*b[1]-a[1]*b[0])
        print(aXb)
        return all(map(lambda x:x&gt;=0 ,aXb)) or  all(map(lambda x:x&lt;=0 ,aXb)) 
</code></pre>
<p>convex...beyond my knowledge  CCW算法。。。Note: |Σxi| = Σ|xi| is only true when all xi are the same sign.</p>
<h1 id="470-implement-rand10-using-rand7-medium">470. Implement Rand10() Using Rand7() (Medium)</h1>
<p>Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.<br>
Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<pre><code class="language-python"># The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        # rand1  1~7   取1~6  奇偶决定生成左区间1~5 还是右区间6~10
        # rand2        取1~5  
        rand1=rand7()
        while rand1==7:
            rand1=rand7()
        flag = rand1%2==1
        rand2=rand7()
        while rand2&gt;5:
            rand2=rand7()
        return 5+rand2 if flag else rand2

#ANSWER
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        n1=rand7()
        n2=rand7()
        while n1+(n2-1)*7 &gt;40:
            n1=rand7()
            n2=rand7()
        return (n1+(n2-1)*7)%10 +1
</code></pre>
<p>(n2-1)乘7+n1<br>
&quot;(randN - 1)*N + randN&quot; is the uniform random variable rand{N^2}.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-06/">
        </link>
        <updated>2022-03-05T22:20:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="451-sort-characters-by-frequency-medium">451. Sort Characters By Frequency （Medium）</h1>
<p>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.<br>
Return the sorted string. If there are multiple answers, return any of them</p>
<pre><code class="language-python">class Solution:
    def frequencySort(self, s: str) -&gt; str:
        d=Counter(s)
        res=''
        for k in sorted(d,key=lambda x: d[x],reverse=True):
            res+=k*d[k]
        return res
#O(n) bucket sort
class Solution:
    def frequencySort(self, s: str) -&gt; str:
        if not s: return s
        counts=collections.Counter(s)
        max_freq=max(counts.values())
        
        buckets=[[] for _ in range(max_freq+1)]
        for c,i in counts.items():
            buckets[i].append(c)
        
        string_builder=[]
        for i in range(len(buckets)-1,0,-1):
            for c in buckets[i]:
                string_builder.append(c*i)
        return ''.join(string_builder)
        
</code></pre>
<p>答案的On解法好。bucketsort</p>
<h1 id="452-minimum-number-of-arrows-to-burst-balloons-medium">452. Minimum Number of Arrows to Burst Balloons (Medium)</h1>
<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.<br>
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.<br>
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</p>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        #merge range by min range calculate len

        points.sort()
        res = []
        for a,b in points:
            #         a   b
            # res  a'  b'
            if res and a&lt;=res[-1][1]  :
                res[-1][1] = min(res[-1][1],b)
               
            else:
                res.append([a,b])
               
        return len(res)
#ANSWER WAY OF WRITTING
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        if not points:
            return 0
        
        # sort by x_end
        points.sort(key = lambda x : x[1])
        
        arrows = 1
        first_end = points[0][1]
        for x_start, x_end in points:
            # if the current balloon starts after the end of another one,
            # one needs one more arrow
            if first_end &lt; x_start:
                arrows += 1
                first_end = x_end
        
        return arrows
</code></pre>
<p>我的思路是找到相交的区间，看总共多少个就行。。。答案思路是track球右边位置，让碰到新气球左边大于cur end位置+1，更新end位置的greedy算法。</p>
<h1 id="453-minimum-moves-to-equal-array-elements-medium">453. Minimum Moves to Equal Array Elements （Medium）</h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment n - 1 elements of the array by 1.</p>
<pre><code class="language-python">#TLE naive solution
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        c=0
        while len(set(nums))!=1:
            ind = nums.index(max(nums))
            for i in range(len(nums)):
                if i!=ind:
                    nums[i]+=1
            #print(nums)
            c+=1
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        nums.sort()
        c=0
        for i in range(len(nums)-1,0,-1):
            c+=nums[i]-nums[0]
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int: 
        moves=0
        min_=float('inf')
        for i in range(len(nums)):
            moves+=nums[i]
            min_=min(min_,nums[i])
        return moves-min_*len(nums)

#MY ANSWER
class Solution:
    # 除了一个位置，其余位置同时加1。 等效于这个位置减去1。 
    def minMoves(self, nums: List[int]) -&gt; int:
        me=min(nums)
        res = 0
        for n in nums:
            res+= n-me
        return res
</code></pre>
<p>答案很巧妙，如果是答案1） 思路先sort，那么每次需要move是nums【i】-nums【0】，这样move后nums【i】和nums【0】相等，然后其余数字都加上了move次，再次move时候，求nums【i-1】-nums【0】，这样nums【0】就和nums【i-1】相等，自然也和nums【i】相等。 以此类推，可求出总共move数目。 如果是答案2）所有加1除了1个不加，和只有一个减去1是等效的。 所以就是减多少次能使所有数平衡，sum（all）-min（all）乘n。</p>
<h1 id="454-4sum-ii-medium">454. 4Sum II （Medium）</h1>
<p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:<br>
0 &lt;= i, j, k, l &lt; n<br>
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
<pre><code class="language-python">class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:
        dic2sum=collections.defaultdict(int)
        for i in nums1:
            for j in nums2:
                dic2sum[i+j]+=1
        
        res=0
        for k in nums3:
            for l in nums4:
                if -k-l in dic2sum:
                    res+=dic2sum[-k-l]
        return res

#
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:

        d1 = collections.defaultdict(int)
        d2 = collections.defaultdict(int)

        for a in nums1:
            for b in nums2:
                d1[a+b]+=1
        
        for c in nums3:
            for d in nums4:
                d2[c+d]+=1
        
        res = 0
        for k1,v1 in d1.items():
            for k2,v2 in d2.items():
                if k1+k2==0:
                    res+=v1*v2
        return res

#ANSWER GENERALIZED 
class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int:
        m = collections.defaultdict(int)
        lists = [A, B, C, D]

        def nSumCount() -&gt; int:
            addToHash(0, 0)
            return countComplements(len(lists) // 2, 0)

        def addToHash(i: int, total: int) -&gt; None:
            if i == len(lists) // 2:
                m[total] = m[total] + 1
            else:
                for a in lists[i]:
                    addToHash(i + 1, total + a)

        def countComplements(i: int, complement: int) -&gt; int:
            if i == len(lists):
                return m[complement]
            cnt = 0
            for a in lists[i]:
                cnt += countComplements(i + 1, complement - a)
            return cnt

        return nSumCount()
</code></pre>
<h1 id="455-assign-cookies-easy">455. Assign Cookies (Easy)</h1>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.<br>
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<pre><code class="language-python">class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:

        g.sort()
        s.sort()
        res = 0
        while g:
            need = g.pop(0)
            while s and s[0]&lt;need:
                s.pop(0)
            
            if s:
                s.pop(0)
                res+=1
        return res
        
#
# 先对g, s两个数组进行排序
# 贪心算法
# 贪心思想1 优先满足需求因子较小的孩子。因为如果较小需求的孩子无法被满足，则之后的较大的需求更不可能能被满足了。
#贪心思想2 尽量用较小的糖果去优先满足孩子。

class Solution:
    def findContentChildren(self, g, s):
        &quot;&quot;&quot;
        :type g: List[int]
        :type s: List[int]
        :rtype: int
        &quot;&quot;&quot;
        g.sort()    # 对需求因子进行排序，从小到大
        s.sort()    # 对糖果数组进行排序，从小到大
        child  = 0  # 记录可以被满足孩子数
        cookie = 0  # 记录可以满足的糖果数
        while  child &lt;len(g) and cookie &lt; len(s):
            if g[child] &lt;= s[cookie]: 
                child += 1
            cookie += 1
        return child
</code></pre>
<h1 id="font-colorred-456-132-pattern-mediumfont"><font color='red'> 456. 132 Pattern （Medium）</font></h1>
<p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].<br>
Return true if there is a 132 pattern in nums, otherwise, return false.</p>
<pre><code class="language-python">class Solution:
    def find132pattern(self, nums: List[int]) -&gt; bool:
        if len(nums) &lt; 3:
            return False
        stack=[]
        min_array = [-1] * len(nums)
        min_array[0] = nums[0]
        for i in range(1, len(nums)):
            min_array[i] = min(min_array[i - 1], nums[i])
        
        
        for j in range(len(nums) - 1, -1, -1):
            if nums[j] &lt;= min_array[j]:
                continue
            while stack and stack[-1] &lt;= min_array[j]:
                stack.pop()
            #到此 确保了stack[-1] 大于 min_array[j]，只需要确保下一步了
            if stack and stack[-1] &lt; nums[j]:
                return True
            stack.append(nums[j])
        return False

</code></pre>
<p>估计是用stack但是。。。看答案思路：从前往后算minarry，从后往前用stack。</p>
<h1 id="font-colorred-457-circular-array-loop-mediumfont"><font color='red'> 457. Circular Array Loop （Medium）</font></h1>
<p>You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:<br>
If nums[i] is positive, move nums[i] steps forward, and<br>
If nums[i] is negative, move nums[i] steps backward.<br>
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.<br>
A cycle in the array consists of a sequence of indices seq of length k where:<br>
Following the movement rules above results in the repeating index sequence seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...<br>
Every nums[seq[j]] is either all positive or all negative.<br>
k &gt; 1<br>
Return true if there is a cycle in nums, or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
        #two pointer
        n=len(nums)
        #check every start location
        for start in range(n):
            if nums[start]==0: continue
                
            slow=start
            fast=(slow+nums[slow])%n
            
            #if sign of fast and fast.next is the same we do the while loop
            while nums[start]*nums[fast]&gt;0 and  nums[start] * nums[(fast+nums[fast])%n] &gt; 0:
                if slow == fast:
                    if slow == (slow+nums[slow])%n:  
                        break #  1-element loop
                    return True 


                slow = (slow+nums[slow])%n
                fast = (fast+nums[fast])%n
                fast = (fast+nums[fast])%n
            
            #we are here know start from start have no loop so mark visited as 0
            slow = start 
            sgn = nums[start] 
            while sgn * nums[slow] &gt; 0:
                nxt = (slow+nums[slow])%n
                nums[slow] = 0 
                slow = nxt 

        return False
        
#MY ANSWER DFS
class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:

        n = len(nums)

        visited = set()
        
        self.res =False
        def dfs(i,visited):
            if i in visited:
                if (i+nums[i])%n!=i :
                    #no self loop
                    start = i
                    sign = [ ]
                    while (start+nums[start])%n!=i:
                        sign.append(nums[start]&gt;0)
                        start = (start+nums[start])%n
                    sign.append(nums[start]&gt;0)
                    if len(sign)&gt;1 and (all(sign) or not any(sign)):
                       self.res = True
                return 

            visited.add(i)
            dfs( (i+nums[i])%n, visited)

        for i in range(n):
            dfs(i,set())
        return self.res

#ANSWER PYTHONIC
class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
 
        t = {i: (i + v) % len(nums) for i, v in enumerate(nums)}
        inc = {k: v for k, v in t.items() if k != v}

        while inc:
            if any(k == v for k, v in inc.items()): return True
            inc = {k: t[v] for k, v in inc.items() if nums[k] * nums[v] &gt; 0 and v in inc} 
        return False
</code></pre>
<p>two pointer, but tricky ....if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.</p>
<h1 id="font-colorred-458-poor-pigs-hard-font"><font color='red'> 458. Poor Pigs (Hard) </font></h1>
<p>There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.<br>
You can feed the pigs according to these steps:<br>
Choose some live pigs to feed.<br>
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.<br>
Wait for minutesToDie minutes. You may not feed any other pigs during this time.<br>
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.<br>
Repeat this process until you run out of time.<br>
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.</p>
<pre><code class="language-python">class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
        return int(math.ceil(math.log(buckets, 2) / math.log(minutesToTest / minutesToDie + 1, 2)))


#MY ANSWER
class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
        if buckets == 1: return 0
        
        round = minutesToTest//minutesToDie
        # 1pig is 1 bit has 2 state only when round == 1
        # 2**pig &gt;= buckets
        round =  minutesToTest//minutesToDie 
        states  = round+1
        l=1
        r = buckets
   
        while l&lt;=r:
            m = (l+r)//2
            if states**m&lt;buckets:
                #pig too small
                l=m+1
            else:
                #pig too large
                r=m-1
        
        return l
</code></pre>
<p>good to knwo but not algorithm..</p>
<h1 id="459-repeated-substring-pattern-easy">459. Repeated Substring Pattern （Easy）</h1>
<p>Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        for i in range(1,len(s)//2+1):
            if s[:i]*(len(s)//i)==s:
                return True
        return False
#ANSWER
def repeatedSubstringPattern(self, str):

        &quot;&quot;&quot;
        :type str: str
        :rtype: bool
        &quot;&quot;&quot;
        if not str:
            return False
            
        ss = (str + str)[1:-1]
        return ss.find(str) != -1
#ANSWER
def repeatedSubstringPattern(self, str):
    return s in (s+s)[1:-1]
    

</code></pre>
<p>答案思路很好， If the string S has repeated block, it could be described in terms of pattern.<br>
S = SpSp (For example, S has two repeatable block at most)<br>
If we repeat the string, then SS=SpSpSpSp.<br>
Destroying first and the last pattern by removing each character, we generate a new S2=SxSpSpSy.</p>
<h1 id="font-colorred-460-lfu-cache-hardfont"><font color='red'> 460. LFU Cache （Hard）</font></h1>
<p>Design and implement a data structure for a Least Frequently Used (LFU) cache.<br>
Implement the LFUCache class:<br>
LFUCache(int capacity) Initializes the object with the capacity of the data structure.<br>
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.<br>
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.<br>
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.<br>
When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.<br>
The functions get and put must each run in O(1) average time complexity.</p>
<pre><code class="language-python">class Node:
    def __init__(self,key,val):
        self.key = key
        self.val = val
        self.freq = 1
        self.pre = None
        self.next = None


class DLL:
    def __init__(self):
        self.head = Node('H','H')
        self.tail = Node('T','T')
        self.head.next =self.tail
        self.tail.pre = self.head
        self.size = 0
    
    def append(self,node):
        self.tail.pre.next = node
        node.pre = self.tail.pre
        node.next =self.tail
        self.tail.pre = node
        self.size+=1
    
    def pop(self, node=None):
        #pop from head
        if self.size == 0: return None
        if not node:
            node = self.head.next
        node.pre.next =node.next
        node.next.pre = node.pre
        self.size-=1
        return node
    
    def __len__(self):
        return self.size

    def __repr__(self):
        res = []
        cur = self.head
        while cur:
            res.append( '-'.join(map(str,[cur.freq,cur.key,cur.val]))  )
            cur = cur.next
        return ','.join(res)
    
    
class LFUCache:
    #
    #   freq1             freq2 .
    #   H  1 2 T        H  3 4  T
    
    def __init__(self, capacity: int):
        self.size = 0
        self.cap = capacity
        self.key2node = dict()
        self.freq2dll = defaultdict(DLL)
        self.minfreq = 0
    
    def debug(self,flag=False):
        if flag:
            print('#'*10)
            for f, dll in  self.freq2dll.items():
                print(f)
                print(dll)
            print('#'*10)
        
    def _update(self,node):
        freq = node.freq
        self.freq2dll[freq].pop(node)
        
        if self.minfreq==freq and len(self.freq2dll[freq])==0:
            self.minfreq+=1
        
        node.freq+=1
        freq = node.freq
        self.freq2dll[freq].append(node)
        

    def get(self, key: int) -&gt; int:
        #print('get',key)
        if key not in self.key2node: return -1
        node = self.key2node[key]
        self._update(node)
        self.debug()
        return node.val
        

    def put(self, key: int, value: int) -&gt; None:
        if self.cap == 0: return 

        if key in self.key2node:
            node = self.key2node[key]
            self._update(node)
            node.val = value
        else:
            if self.size==self.cap:
                node = self.freq2dll[self.minfreq].pop()
                del self.key2node[node.key]
                self.size-=1
                #if not len(self.freq2dll[self.minfreq]):
                #    self.minfreq+=1
            
            node = Node(key,value)
            self.key2node[key] = node
            self.freq2dll[1].append(node)
            self.minfreq = 1
            self.size+=1
        self.debug()
        


# Your LFUCache object will be instantiated and called as such:
# obj = LFUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)


</code></pre>
<p>Each key is mapping to the corresponding node (self._node), where we can retrieve the node in O(1) time.</p>
<p>Each frequency freq is mapped to a Doubly Linked List (self._freq), where all nodes in the DLinkedList have the same frequency, freq. Moreover, each node will be always inserted in the head (indicating most recently used).</p>
<p>A minimum frequency self._minfreq is maintained to keep track of the minimum frequency of across all nodes in this cache, such that the DLinkedList with the min frequency can always be retrieved in O(1) time.</p>
<p>Here is how the algorithm works</p>
<p>get(key)</p>
<pre><code>query the node by calling self._node[key]
find the frequency by checking node.freq, assigned as f, and query the DLinkedList that this node is in, through calling self._freq[f]
pop this node
update node's frequence, append the node to the new DLinkedList with frequency f+1
if the DLinkedList is empty and self._minfreq == f, update self._minfreq to f+1.
return node.val
</code></pre>
<p>put(key, value)</p>
<pre><code>If key is already in cache, do the same thing as get(key), and update node.val as value
Otherwise:
    if the cache is full, pop the least frequenly used element (*)
    add new node to self._node
    add new node to self._freq[1]
    reset self._minfreq to 1
</code></pre>
<p>(*) The least frequently used element is the tail element in the DLinkedList with frequency self._minfreq</p>
<pre><code class="language-python">#MY ANSWER
#   freq1    freq 2       freq3
#  H 1   T   H  2  T   H 3   T
debug_flag  = False

class Node:
    def __init__(self,key,value):
        self.key = key
        self.val = value
        self.pre = None
        self.next = None

class DLL:
    def __init__(self):
        self.size = 0
        self.head = Node('H','H')
        self.tail = Node('T','T')
        self.head.next = self.tail
        self.tail.pre = self.head
        self.key2node = dict()

    def append(self,node):
        key = node.key
        self.key2node[key] = node
        self.size+=1
        #append before tail
        self.tail.pre.next = node
        node.pre =self.tail.pre
        node.next = self.tail
        self.tail.pre = node

    def pop0(self, node = None):
        if not node:
            node = self.head.next
        self.size-=1
        key = node.key
        node = self.key2node[key]
        del self.key2node[key]
        #remove node
        node.pre.next = node.next
        node.next.pre = node.pre
        return node

    def get_node(self,key):
        if key in self.key2node:
            return self.key2node[key]
        return None

    def __len__(self):
        return self.size

    
    def __repr__(self):
        res = []
        cur = self.head
        while cur:
            res.append('-'.join([str(cur.key),str(cur.val)]))
            cur =cur.next
        return ','.join(res)



class LFUCache:

    def __init__(self, capacity: int):
        self.cap = capacity
        self.c = 0
        self.freq2dll = collections.defaultdict(DLL)
        self.key2freq = collections.defaultdict(int)
        self.minfreq = None

        self.debugcounter = -1
    
    def debug(self):
        if debug_flag:
            print('#'*10)
            for f in sorted(self.freq2dll):
                dll = self.freq2dll[f]    
                print(f)
                print(dll)
            print('#'*10)

    def get(self, key: int) -&gt; int:
        self.debugcounter+=1
        
        if debug_flag:print(self.debugcounter  , 'get',key)
        if key not in self.key2freq: return -1

        old_freq = self.key2freq[key]
        new_freq = self.key2freq[key]+1
        self.key2freq[key] = new_freq

        node = self.freq2dll[old_freq].get_node(key)
        self.freq2dll[old_freq].pop0(node)
        if old_freq==self.minfreq and not self.freq2dll[old_freq]:
            del self.freq2dll[old_freq]
            self.minfreq = new_freq
        
        if new_freq not in self.freq2dll:
            self.freq2dll[new_freq] = DLL()
        self.freq2dll[new_freq].append(node)
        self.debug()
        return node.val


        
    def put(self, key: int, value: int) -&gt; None:
        self.debugcounter+=1
        if debug_flag:print(self.debugcounter,'put',key,value)
        
        if key not in self.key2freq:
            self.c+=1
            if self.c&gt;self.cap:
                #remove least frequent
                node = self.freq2dll[self.minfreq].pop0()
                del self.key2freq[node.key]
                if not self.freq2dll[self.minfreq]:
                    del self.freq2dll[self.minfreq]
                self.c-=1

            self.key2freq[key] = 1
            if 1 not in self.freq2dll:
                self.freq2dll[1] = DLL()
            node = Node(key,value)
            self.freq2dll[1].append(node)
            self.minfreq = 1
           
        else:
            #key in key2freq
            self.key2freq[key] += 1
            old_freq = self.key2freq[key]-1
            new_freq = self.key2freq[key]
            
            #update old_freq dll
            node = self.freq2dll[old_freq].get_node(key)
            self.freq2dll[old_freq].pop0(node)
            if not  self.freq2dll[old_freq]:
                del self.freq2dll[old_freq]
            node.val = value

            # update minfreq 
            if old_freq == self.minfreq and not self.freq2dll[old_freq]:
                self.minfreq = new_freq 

            #node ready to insert to new_freq dll 
            if new_freq not in self.freq2dll:
                self.freq2dll[new_freq] = DLL()
            self.freq2dll[new_freq].append(node)

       
        self.debug()
            
</code></pre>
<p>要特别注意  update minfreq，<br>
if old_freq == self.minfreq and not self.freq2dll[old_freq]:<br>
self.minfreq = new_freq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-05/">
        </link>
        <updated>2022-03-04T22:11:11.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="441-arranging-coins-easy">441. Arranging Coins （Easy）</h1>
<p>You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.<br>
Given the integer n, return the number of complete rows of the staircase you will build.</p>
<pre><code class="language-python">class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        r=0
        while n&gt;0:
            r+=1
            n-=r
        return r-1 if n&lt;0 else r

class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        
        # (1+ x) x /2 &lt;= n
        #      (1+x)x &lt;= 2n
        # max x which (1+x)x &lt;=2n
        
        l, r = 0, n
        
        while l &lt;= r:
            
            m = (l + r) // 2
            
            if (m+1)*m &lt;= 2*n and (m+2)*(m+1) &gt; 2*n:
                return m
            
            if (m+1)*m &lt; 2*n:
                l = m + 1
            else:
                r = m - 1
    
</code></pre>
<p>答案是binary  search啊。。</p>
<h1 id="442-find-all-duplicates-in-an-array-medium">442. Find All Duplicates in an Array （Medium）</h1>
<p>Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.<br>
You must write an algorithm that runs in O(n) time and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        # 0 1 2 3 4 5 6 7
        # 4 3 2 7 8 2 3 1
        
        # -4 3 2-7    -3-1 
        
        n=len(nums)
        
        for i in range(n):
            ind=(abs(nums[i])%n-1)
            nums[ind] =   abs(nums[ind])+n if nums[ind]&lt;0 else -abs(nums[ind])-n
        
        #print(nums)
        res=[]
        for i in range(n):
            if nums[i]&gt;n:
                res.append(i+1)
        return res

#ANSWER BEST
class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        res=[]
        for n in nums:
            if nums[abs(n)-1]&lt;0: #seen before
                res.append(abs(n))
            
            nums[abs(n)-1]*=-1
        
        return res

#MY ANSWER
class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:

        # nums from 1 to n, length is n
        # nums index from 0 to n-1
        res = []
        s = set(nums)
        for i in range(len(nums)):
            idx = abs(nums[i])-1
            nums[idx] *= -1

        for i in range(len(nums)):
            if nums[i]&gt;0:
                if i+1 in s:
                    res.append(i+1)
        return res 
</code></pre>
<p>特殊的bookkeeping。 答案写的更好</p>
<h1 id="443-string-compression-medium">443. String Compression （Medium）</h1>
<p>Given an array of characters chars, compress it using the following algorithm:<br>
Begin with an empty string s. For each group of consecutive repeating characters in chars:<br>
If the group's length is 1, append the character to s.<br>
Otherwise, append the character followed by the group's length.<br>
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.<br>
After you are done modifying the input array, return the new length of the array.<br>
You must write an algorithm that uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def compress(self, chars: List[str]) -&gt; int:

        pos = 0
        pre = None
        c=0
        chars.append(' ')# for reduce corner case  ch != pre
        for i,ch in enumerate(chars):
            if i!=0 and ch!=pre:
                #add to result
                if c==1:
                    chars[pos]=pre
                    pos+=1
                else:
                    chars[pos]=pre
                    pos+=1
                    for char in str(c):
                        chars[pos] = char
                        pos+=1

                c=1
            else:
                c+=1
            
            pre = ch
        

        print(chars[:pos])
        return pos
#ANSWER 更简单
 
class Solution:
    def compress(self, chars: List[str]) -&gt; int:
        walker, runner = 0, 0
        while runner &lt; len(chars):
		
            chars[walker] = chars[runner]
            count = 1
			
            while runner + 1 &lt; len(chars) and chars[runner] == chars[runner+1]:
                runner += 1
                count += 1
			
            if count &gt; 1:
                for c in str(count):
                    chars[walker+1] = c
                    walker += 1
            
            runner += 1
            walker += 1
        
        return walker

</code></pre>
<p>two pointer 写出来了，但是cornercase很多边test边写的。。。。答案很简单。。。。</p>
<h1 id="font-colorblue-444-sequence-reconstruction-medium-font"><font color='blue'> 444. Sequence Reconstruction (Medium) </font></h1>
<p>You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.<br>
Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.<br>
For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].<br>
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.<br>
Return true if nums is the only shortest supersequence for sequences, or false otherwise.<br>
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<pre><code class="language-python">class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -&gt; bool:
        values = {x for seq in sequences for x in seq}
        graph = {x: [] for x in values}
        indegrees = {x: 0 for x in values}
        for seq in sequences:
            for i in range(len(seq) - 1):
                s = seq[i]
                t = seq[i+1]
                graph[s].append(t)
                indegrees[t] += 1
        queue = collections.deque()
        for node, count in indegrees.items():
            if count == 0:
                queue.append(node)
        res = []
        while queue:
            if len(queue) != 1:
                return False
            source = queue.popleft()
            res.append(source)
            for target in graph[source]:
                indegrees[target] -= 1
                if indegrees[target] == 0:
                    queue.append(target)
        return len(res) == len(values) and res == nums

#MY ANSWER
class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -&gt; bool:
        # a&lt;-b
        # topo sort dependency
        # nums is topo sort
        
        if len(nums)==1: return sequences==[[nums[0]]]
        dic = collections.defaultdict(set)
        indegree = collections.defaultdict(int)
        visited = set()
        for seq in sequences:
            for a, b in zip(seq,seq[1:]):
                if (a,b) not in visited:
                    visited.add((a,b))
                    indegree[a]+=1
                    dic[b].add((a,b))
        
        while nums:
            val = nums.pop()
            if val not in dic:
                return False
            c=0
            for aa,bb in  dic[val]:
                indegree[aa]-=1
                if indegree[aa]==0:
                    c+=1
                    del indegree[aa]
            del dic[val]
            if c!=1: return False
            if len(nums)==1: return True
        
        return True

</code></pre>
<p>。。。topological sort... 第一步建立dependency graph， 第二部toposort，每一步检查是否只有一个node的可能性，如果比一个多，return False。 第三步，在得到toposortlist 后，检查长度是否和sequence中所有unique 元素个数一样而且 是input nums。<br>
解释：<br>
TopSort order exists<br>
Whether the TopSort order is the only one (Uniqueness of Topological sort, Hamilton path, see https://en.wikipedia.org/wiki/Topological_sorting#Uniqueness).如果不是，那么说明有些pair只有偏序关系，没有全序关系，这样不能完全确定元素之间的顺序<br>
the only top sort order constructed should be equal to the org.</p>
<p>index == org.length (check condition 3) &amp;&amp; index == map.size() (check all the vertex in the graph has been visited, so the top sort order exists, check condition 1)</p>
<p>How to check only one order? queue.size() should always be one, then only one element at a time has indegree to be 0, so you only have one choice (check condition 2)</p>
<h1 id="445-add-two-numbers-ii-medium">445. Add Two Numbers II （Medium）</h1>
<p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.<br>
You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        l1=rev(l1)
        l2=rev(l2)
        
        carry=0
        head=ListNode(val=None)
        savehead=head
        while l1 or l2:
            v1= l1.val if l1 else 0
            v2= l2.val if l2 else 0
            val=(v1+v2+carry)%10
            carry=(v1+v2+carry)//10
            head.next=ListNode(val)
            head=head.next
            
            l1=l1.next if l1 else None
            l2=l2.next if l2 else None
            
        if carry:
            head.next=ListNode(carry)
            head=head.next
        
        return rev(savehead.next)

#
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
        
 #####
 class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
               
</code></pre>
<p>followup 是不revlist能否。。。那就用stack。</p>
<h1 id="font-colorred-446-arithmetic-slices-ii-subsequence-hard-font"><font color='red'> 446. Arithmetic Slices II - Subsequence (Hard) </font></h1>
<p>Given an integer array nums, return the number of all the arithmetic subsequences of nums.<br>
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.<br>
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.<br>
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.<br>
For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].<br>
The test cases are generated so that the answer fits in 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        
        #f[i][d] denotes the number of weak arithmetic subsequences that ends with A[i] and its common difference is d.
        #Now the state transitions are quite straightforward:

        # for all j &lt; i, f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1).
        # The 1 appears here because we can form a new weak arithmetic subsequence for the pair (i, j)
        
        #when we are appending new elements to existing weak arithmetic subsequences, we are forming arithmetic subsequences. So the first part, f[j][A[i] - A[j]] is the number of new formed arithmetic subsequences, and can be added to the answer.

        
        n=len(nums)
        res=0
        cnt=dict()
        for i in range(n):
            cnt[i]=dict()
            for j in range(i):
                delta=nums[i]-nums[j]
                
                diff=delta
                sum_=cnt[j].get(diff,0)
                origin=cnt[i].get(diff,0)
                cnt[i][diff]=origin+sum_+1
                res+=sum_
        return res


#MY ANSWER
#cnt[i][d] denotes the number of weak arithmetic subsequences that ends with A[i] and its common difference is d.
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        n = len(nums)
        res = 0
        cnt =dict()
        # j  i #
        for i in range(n):
            cnt[i] = defaultdict(int)
            for j in range(i):
                diff = nums[i]-nums[j]
                cnt[i][diff] +=  cnt[j][diff]  +1
                res+=cnt[j][diff]
        return res
</code></pre>
<p>是应该用DP但看答案。。。答案这个DP解法不是一般的DP。。。先dp【i】【diff】是以ith nums为最终位置的weak arithmetic subsequences的个数，这个weak值2个元素也能形成subsequence。 要想得到真正的3个元素的arithmetic subsequences个数，每次可以把nums【i】添加到dp【j】【diff】时候这个dp【j】【diff】个数就是arithmetic subsequences个数。很难想到这个方法啊。。。<br>
backtracking 方法超时</p>
<pre><code class="language-java">class Solution {
    private int n;
    private int ans;
    private void dfs(int dep, int[] A, List&lt;Long&gt; cur) {
        if (dep == n) {
            if (cur.size() &lt; 3) {
                return;
            }
            long diff = cur.get(1) - cur.get(0);
            for (int i = 1; i &lt; cur.size(); i++) {                
                if (cur.get(i) - cur.get(i - 1) != diff) {
                    return;
                }
            }
            ans ++;
            return;
        }
        dfs(dep + 1, A, cur);
        cur.add((long)A[dep]);
        dfs(dep + 1, A, cur);
        cur.remove((long)A[dep]);
    }
    public int numberOfArithmeticSlices(int[] A) {
        n = A.length;
        ans = 0;
        List&lt;Long&gt; cur = new ArrayList&lt;Long&gt;();
        dfs(0, A, cur);
        return (int)ans;        
    }
}
</code></pre>
<h1 id="font-colorblue-447-number-of-boomerangs-medium-font"><font color='blue'> 447. Number of Boomerangs (Medium) </font></h1>
<p>You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).<br>
Return the number of boomerangs.</p>
<pre><code class="language-python">class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        
        def dis(p1,p2):
            return (p1[0]-p2[0])**2+(p1[1]-p2[1])**2
        
        
        dic=collections.defaultdict(set)
        
        for i,p1 in enumerate(points):
            for j,p2 in enumerate(points):
                if i!=j:
                    dic[dis(p1,p2)].add((i,j))
                    dic[dis(p1,p2)].add((j,i))
        #print(dic)
        res=0
        for k, s in dic.items():
            #find i,j i,k
            d=dict()
            for t in s:
                d[t[0]]=d.get(t[0],0)+1
            
            #print(d)
            
            for key,val in d.items():
                res+= val*(val-1) if val&gt;1 else 0
        
        return res
#ANSWER 同样思路但超级简单
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        res = 0
        for p in points:
            cmap = {}
            for q in points:
                f = p[0]-q[0]
                s = p[1]-q[1]
                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)
            for k in cmap:
                res += cmap[k] * (cmap[k] -1)
        return res


#MY ANSWER
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:

        #dp[i][dist] 以i为顶点的长度为diff的 个数 i-j i-k  （i，j，k） 也可以是 i k j
        
        def distance(i,j):
            a,b = points[i]
            x,y = points[j]
            return (a-x)**2+(b-y)**2
        
        n = len(points)
        res = 0
        #   j ... i  #
        for i in range(n):
            dic = defaultdict(int)
            for j in range(n):
                if i!=j:
                    dist = distance(i,j)
                    dic[dist]+=1
            #以i为顶点的，第一个边有n种选择，第二个边有n-1 种选择
            for dist in dic:
                res+=  dic[dist]*(dic[dist]-1)  
        
        return res
</code></pre>
<p>pass了 hashmap先按照距离分类， 然后每个距离下按照起始点分类，比如距离为1下 其实点为0的edge总共有n个，那么组成三角形能组成n*n-1个。</p>
<h1 id="448-find-all-numbers-disappeared-in-an-array-easy">448. Find All Numbers Disappeared in an Array (Easy)</h1>
<pre><code class="language-python">class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]:
        #
        n=len(nums)
        
        for i in range(n):
            ind = abs(nums[i])-1
            nums[ind]=-abs(nums[ind])
        
        res=[]
        for i in range(n):
            if nums[i]&gt;0:
                res.append(i+1)
        return res

</code></pre>
<h1 id="449-serialize-and-deserialize-bst-medium">449. Serialize and Deserialize BST (Medium)</h1>
<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.<br>
The encoded string should be as compact as possible.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: Optional[TreeNode]) -&gt; str:
        &quot;&quot;&quot;Encodes a tree to a single string.
        &quot;&quot;&quot;
        res=[]
        def pre(root):
            if not root: 
                res.append('#')
                return
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
        return ','.join(res)
        

    def deserialize(self, data: str) -&gt; Optional[TreeNode]:
        &quot;&quot;&quot;Decodes your encoded data to tree.
        &quot;&quot;&quot;
        data=data.split(',')
        def pre(data):
            if not data: return None
            cur=data.pop(0) 
            root=None
            if cur!='#':
                root=TreeNode(int(cur))
            
            if root and data:
                root.left=pre(data)
            if root and data:
                root.right=pre(data)
            return root
        return pre(data)
#MY ANSWER
class Codec:

    def serialize(self, root: Optional[TreeNode]) -&gt; str:
        &quot;&quot;&quot;Encodes a tree to a single string.
        &quot;&quot;&quot;
        if not root: return '#'
        rootval = str(root.val)
        l = self.serialize(root.left)
        r = self.serialize(root.right)
        return ','.join([rootval,l,r])

    def deserialize(self, data: str) -&gt; Optional[TreeNode]:
        &quot;&quot;&quot;Decodes your encoded data to tree.
        &quot;&quot;&quot;
        if data=='#': return None
        data = data.split(',')
        print(data)
        def decode(data):
            val = data.pop(0)
            if val=='#': return None
            root = TreeNode(int(val))
            root.left = decode(data)
            root.right = decode(data)
            return root
        #print(data)
        
        return decode(data)

#答案用postorder compressed string 更好
class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;
        Encodes a tree to a single string.
        &quot;&quot;&quot;
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        &quot;&quot;&quot;
        Decodes your encoded data to tree.
        &quot;&quot;&quot;
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] &lt; lower or data[-1] &gt; upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()
</code></pre>
<h1 id="font-colorred-450-delete-node-in-a-bst-mediumfont"><font color='red'> 450. Delete Node in a BST （Medium）</font></h1>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.<br>
Basically, the deletion can be divided into two stages:<br>
Search for a node to remove.<br>
If the node is found, delete the node.</p>
<pre><code class="language-python">class Solution:
    def successor(self, root):
        &quot;&quot;&quot;
        One step right and then always left
        &quot;&quot;&quot;
        root = root.right
        while root.left:
            root = root.left
        return root.val
    
    def predecessor(self, root):
        &quot;&quot;&quot;
        One step left and then always right
        &quot;&quot;&quot;
        root = root.left
        while root.right:
            root = root.right
        return root.val
        
    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:
        if not root:
            return None
        
        # delete from the right subtree
        if key &gt; root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key &lt; root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # the node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root

#MY SOLUTION
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:

        def successor(root):
            root =root.right
            while root.left:
                root = root.left
            return root.val
        
        def predecessor(root):
            root = root.left
            while root.right:
                root =root.right
            return root.val
        

        if not root: return None
        
        # del from right
        if key&gt;root.val:
            root.right = self.deleteNode(root.right,key)
        elif key&lt;root.val:
            root.left = self.deleteNode(root.left,key)
        else:
            #key==root.val

            if not  root.left and not root.right:
                root = None
            
            elif root.right:
                # the node is not a leaf and has a right child
                root.val = successor(root)
                root.right = self.deleteNode(root.right,root.val)
            else:
                root.val = predecessor(root)
                root.left = self.deleteNode(root.left,root.val)
        
        return root
</code></pre>
<p>这个是很经典的一个题目。recursion方法很经典。</p>
]]></content>
    </entry>
</feed>