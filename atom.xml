<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-01-23T00:16:43.918Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-06/">
        </link>
        <updated>2021-12-06T05:36:37.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue331-verify-preorder-serialization-of-a-binary-tree-font"><font color='blue'>331. Verify Preorder Serialization of a Binary Tree </font></h1>
<p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.</p>
<pre><code class="language-python">class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        
        stack = []
        for char in preorder.split(','):
            while char=='#' and stack and stack[-1]=='#':
                if len(stack)&lt;2: return False
                stack.pop()
                stack.pop()
            
            stack.append(char)
        
        return stack==['#']
                
 #ANSWER           
 class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        # number of available slots
        slots = 1

        for node in preorder.split(','):
            # one node takes one slot
            slots -= 1
            
            # no more slots available
            if slots &lt; 0:
                return False
            
            # non-empty node creates two children slots
            if node != '#':
                slots += 2
        
        # all slots should be used up
        return slots == 0
</code></pre>
<p>没思路初看， 但是用stack解决了， 如果遇到‘X,#,#’ X一定是个leave，出栈，但X本身可能是其他人的child，所以补一个#。  最后如果valid，应该stack为【#】。答案思路没用stack用了计算slot的方法。</p>
<h1 id="font-colorred332-reconstruct-itinerary-hardfont"><font color='red'>332. Reconstruct Itinerary （Hard）</font></h1>
<p>You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.<br>
All of the tickets belong to a man who departs from &quot;JFK&quot;, thus, the itinerary must begin with &quot;JFK&quot;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>
<pre><code class="language-python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
        
        self.visitBitmap=dict()
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
            self.visitBitmap[origin]=[False]*len(itinerary)
        
        self.flights=len(tickets)
        self.result=[]
        route=['JFK']
        self.backtracking('JFK',route)
        return self.result
    
    def backtracking(self,origin,route):
        if len(route)==self.flights+1:
            self.result=route
            return True
        
        for i, nextDest in enumerate(self.flightMap[origin]):
            if not self.visitBitmap[origin][i]:
                self.visitBitmap[origin][i]=True
                ret=self.backtracking(nextDest,route+[nextDest])
                self.visitBitmap[origin][i]=False
                if ret:
                    return True
        return False

#
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
 
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
         
        self.result=[]
        self.DFS('JFK')
       
        return self.result[::-1]
    
    def DFS(self,origin):
        destList=self.flightMap[origin]
        while destList:
            nextDest=destList.pop(0)
            self.DFS(nextDest)
        self.result.append(origin)
</code></pre>
<p>这个明显是个一笔画问题，不知道答案。。。有两个问题，判断能否是一笔画，怎么能画出一笔画。一笔画算法：<br>
It starts with a random node and then follows an arbitrary unvisited edge to a neighbor. This step is repeated until one returns to the starting node. This yields a first circle in the graph.</p>
<pre><code>If this circle covers all nodes it is an Eulerian cycle and the algorithm is finished. Otherwise, one chooses another node among the cycles' nodes with unvisited edges and constructs another circle, called subtour.
By connecting all the circles in the above process, we build the Eulerian cycle at the end
</code></pre>
<p>答案1：backtracking+greedy  答案2： 在倒序添加一个机场前，必须已经visited 所有这个机场的outgoing edge。否则就是还有路径没有浏览过。 所以算法是postorder DFS</p>
<h1 id="font-colorblue333-largest-bst-subtree-medium-font"><font color='blue'>333. Largest BST Subtree （Medium） </font></h1>
<p>Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -&gt; int:
         
        self.res=0
        
        def isBST(root):
            if not root: 
                return True
            res=[]
            def inorder(root):
                if not root: return 
                inorder(root.left)
                res.append(root.val)
                inorder(root.right)
            inorder(root)
            for i in range(1,len(res)):
                if res[i-1] &gt;= res[i]:
                    return False
            root.size=len(res)
            return True
            
        
        def helper(root):
            if not root: return
            helper(root.left)
            helper(root.right)
            if isBST(root):
                self.res=max(self.res,root.size)  
     
        helper(root)
        return self.res          

</code></pre>
<p>因为要判断isBST，call很多次，自己写的时间复杂度感觉比较大。。。 isBST同时设置了 BST大小，所以call完isBST后直接更新self.res.  看答案思路：答案是preorder 和postorder 。。。 postorder优于preorder，因为没有重复判断isvalidBST. 但需要通知parent node maxleft minright是多少，感觉更繁琐，不如自己的答案。</p>
<h1 id="font-colorred334-increasing-triplet-subsequence-mediumfont"><font color='red'>334. Increasing Triplet Subsequence （Medium）</font></h1>
<p>Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.</p>
<pre><code class="language-python">class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        if len(nums)&lt;3: return False
        
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                 if nums[i]&gt;nums[j]:
                    dp[i]= max(dp[j]+1,dp[i])  
                    if dp[i]&gt;=3: return True
        
        return False


class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        first_num = float(&quot;inf&quot;)
        second_num = float(&quot;inf&quot;)
        for n in nums:
            if n &lt;= first_num:
                first_num = n
            elif n &lt;= second_num:
                second_num = n
            else:
                return True
        return False
</code></pre>
<p>初次尝试用increasing subsequence DP方法， time limit exceeded。。。直接看答案了。。。直接比较难相到这个方法，思路：scan num list。 边scan边保存看到的最小的和次小的数字，如果遇到比这两个数字都大的，那么找到了答案，如果都没有return False。</p>
<h1 id="font-colorred335-self-crossing-hard-font"><font color='red'>335. Self Crossing （Hard） </font></h1>
<p>You are given an array of integers distance.<br>
You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.<br>
Return true if your path crosses itself, and false if it does not.</p>
<pre><code class="language-python">class Solution:
    def isSelfCrossing(self, distance: List[int]) -&gt; bool:
        
        x=distance
        for i in range(3,len(x)):
            
            if i &gt;= 3 and x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]:
                return True
            
            if i &gt;= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] &gt;= x[i - 2]:
                return True
            
            if i &gt;= 5 and x[i - 2] &gt;= x[i - 4] and x[i - 5] + x[i - 1] &gt;= x[i - 3] and x[i - 1] &lt;= x[i - 3] and x[i - 4] + x[i] &gt;= x[i - 2]:
                return True
        
        return False

#GREAT ANSWER
def isSelfCrossing(self, x):
    b = c = d = e = 0
    for a in x:
        if d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c-e &gt;= 0 and f &gt;= d-b):
            return True
        b, c, d, e, f = a, b, c, d, e
    return False
</code></pre>
<p>直接看答案， 只有3种情况会crossing， 第一种包含4条线段 最后一条穿过第一条， 第二种包括5条线段，最后一条嵌入第一条。 第三种包含6条线段，最后一条与第一条十字交叉穿过。</p>
<p>第二种解法：</p>
<pre>
            b                              b
   +----------------+             +----------------+
   |                |             |                |
   |                |             |                | a
 c |                |           c |                |
   |                | a           |                |    f
   +----------->    |             |                | <----+
            d       |             |                |      | e
                    |             |                       |
                                  +-----------------------+
                                               d
</pre>
<h1 id="font-colorred336-palindrome-pairs-hard-font"><font color='red'>336. Palindrome Pairs (Hard) </font></h1>
<p>Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.</p>
<pre><code class="language-python">class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
        res= []
        def isp(w):
            res = [e for e in w]
            return res==res[::-1]
        for i in range(len(words)):
            for j in range(i+1,len(words)):
                if not words[i] or not words[j] or words[i][0]==words[j][-1]:
                    if isp(words[i]+words[j]):
                        res.append([i,j])
                if not words[i] or not words[j] or words[j][0]==words[i][-1]:
                    if isp(words[j]+words[i]):
                        res.append([j,i])
        return res
#answer                  
class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
      
        def all_valid_prefixes(word):
            valid_prefixes = []
            for i in range(len(word)):
                if word[i:] == word[i:][::-1]:
                    valid_prefixes.append(word[:i])
            return valid_prefixes

        def all_valid_suffixes(word):
            valid_suffixes = []
            for i in range(len(word)):
                if word[:i+1] == word[:i+1][::-1]:
                    valid_suffixes.append(word[i + 1:])
            return valid_suffixes

        word_lookup = {word: i for i, word in enumerate(words)}
        solutions = []

        for word_index, word in enumerate(words):
            reversed_word = word[::-1]

            # Build solutions of case #1. This word will be word 1.
            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:
                solutions.append([word_index, word_lookup[reversed_word]])

            # Build solutions of case #2. This word will be word 2.
            for suffix in all_valid_suffixes(word):
                reversed_suffix = suffix[::-1]
                if reversed_suffix in word_lookup:
                    solutions.append([word_lookup[reversed_suffix], word_index])

            # Build solutions of case #3. This word will be word 1.
            for prefix in all_valid_prefixes(word):
                reversed_prefix = prefix[::-1]
                if reversed_prefix in word_lookup:
                    solutions.append([word_index, word_lookup[reversed_prefix]])

        return solutions
#ANSWER TRIE

class TrieNode:
    def __init__(self):
        self.next = collections.defaultdict(TrieNode)
        self.ending_word = -1
        self.palindrome_suffixes = []

class Solution:
    def palindromePairs(self, words):

        # Create the Trie and add the reverses of all the words.
        trie = TrieNode()
        for i, word in enumerate(words):
            word = word[::-1] # We want to insert the reverse.
            current_level = trie
            for j, c in enumerate(word):
                # Check if remainder of word is a palindrome.
                if word[j:] == word[j:][::-1]:# Is the word the same as its reverse?
                    current_level.palindrome_suffixes.append(i)
                # Move down the trie.
                current_level = current_level.next[c]
            current_level.ending_word = i

        # Look up each word in the Trie and find palindrome pairs.
        solutions = []
        for i, word in enumerate(words):
            current_level = trie
            for j, c in enumerate(word):
                # Check for case 3.
                if current_level.ending_word != -1:
                    if word[j:] == word[j:][::-1]: # Is the word the same as its reverse?
                        solutions.append([i, current_level.ending_word])
                if c not in current_level.next:
                    break
                current_level = current_level.next[c]
            else: # Case 1 and 2 only come up if whole word was iterated.
                # Check for case 1.
                if current_level.ending_word != -1 and current_level.ending_word != i:
                    solutions.append([i, current_level.ending_word])
                # Check for case 2.
                for j in current_level.palindrome_suffixes:
                    solutions.append([i, j])
        return solutions
</code></pre>
<p>初次尝试，time limit exceeded。 基本暴力解，无优化。如何优化？  感觉是用Trie。。。看答案了。思路1： 三种情况，1）word本身是palindrome，2）AB_PALINDROME     BA  找到第一个词所有满足第一个pattern的prefix，然后找prefix[::-1]  3)    BA    PALINDROM_AB,找第二个词所有满足第二个patern的suffix，然后找suffix[::-1]<br>
思路2： Trie， case1） CAT TAC     case2）  CAT   PALINDROME_TAC case3） CAT_PALINDROME  TAC.     只有在扫过所有word1字符情况都不break情况下才会再检查case1和2. 逆序在tire保存word和保存满足palindrome suffix的word ids是简化算法的关键。</p>
<h1 id="337-house-robber-iii-medium">337. House Robber III （Medium）</h1>
<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.<br>
Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.<br>
Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -&gt; int:
        # root.val =  root.left_rob+root.right.rob                         1)rob2child
        # root.val =  root.left_norob + root.right.norob + root.val        2)rob root no rob child
        # root.val = root.left/right.rob   root.right/left.norob      3) rob one of child norob root
        
    
        #postorder transversal  add two value, rob  norob
        
        def helper(root):
            if not root: return 
            helper(root.left)
            helper(root.right)
            
            #processing leaves
            if not root.left and not root.right:
                root.rob=root.val
                root.norob=0
            
            #if decide rob root:
            root_left_max = root.left.norob if root.left else 0
            root_right_max= root.right.norob if root.right else 0
            root.rob = root.val + root_left_max + root_right_max
            #if decide norob root:
            root_left_max =max([root.left.norob,root.left.rob]) if root.left else 0
            root_right_max= max([root.right.norob,root.right.rob]) if root.right else 0
            root.norob = root_left_max + root_right_max
        
        helper(root)
        return max([root.rob,root.norob])


#ANSWER
class Solution:
    def rob(self, root: TreeNode) -&gt; int:
        def helper(node):
            # return [rob this node, not rob this node]
            if not node:
                return (0, 0)
            left = helper(node.left)
            right = helper(node.right)
            # if we rob this node, we cannot rob its children
            rob = node.val + left[1] + right[1]
            # else we could choose to either rob its children or not
            not_rob = max(left) + max(right)
            return [rob, not_rob]

        return max(helper(root))
</code></pre>
<h1 id="338-counting-bits-easy">338. Counting Bits (Easy)</h1>
<p>Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1's in the binary representation of i.</p>
<pre><code class="language-python">class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        if n==0: return [0]
        if n==1: return [0,1]
        cur=[0,1]
        while len(cur)&lt;=n:
            cur = cur+[1+e for e in cur]
        return cur[:n+1]
        
#ANSWER
class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        ans = [0] * (n + 1)
        for x in range(1, n + 1):
            ans[x] = ans[x &amp; (x - 1)] + 1
        return ans 

</code></pre>
<p>答案更优雅，x&amp;x-1 得到去掉最后一个significant bit的数字  X&gt; X&amp;(X-1) 然后从1遍历到n用dp。</p>
<h1 id="339-nested-list-weight-sum-medium">339. Nested List Weight Sum （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.<br>
Return the sum of each integer in nestedList multiplied by its depth.</p>
<pre><code class="language-python">
class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -&gt; int:
        def helper(nestli,level):
            res=0
            for nl in nestli:
                if nl.isInteger():
                    res+=nl.getInteger() * level
                else:
                    res+=helper(nl.getList(),level+1)
            
            return res
        return helper(nestedList,1)
</code></pre>
<h1 id="font-colorblue340-longest-substring-with-at-most-k-distinct-characters-medium-font"><font color='blue'>340. Longest Substring with At Most K Distinct Characters (Medium) </font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        #  e c e b a  a a a a a a c d a a 
        # two pointer
        #   
        dic=dict()
        start=0
        res=0
        for j,char in enumerate(s):
            #process over k case
            if dic and char not in dic and len(dic)==k:
                while len(dic)==k:
                    dic[s[start]]-=1
                    if dic[s[start]]==0:
                        del dic[s[start]]
                    start+=1
            
            elif char in dic and len(dic)&lt;=k:
                res=max(res,j-start+1)
            
            
            elif len(dic)&lt;k:
                res+=1
        
            
            dic[char]=dic.get(char,0)+1
        
        return res



#ANSWER
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        n = len(s)
        if n * k == 0:
            return 0

        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -&gt; its rightmost position
        # in the sliding window
        hashmap = defaultdict()

        max_len = 1

        while right &lt; n:
            # add new character and move right pointer
            hashmap[s[right]] = right
            right += 1

            if len(hashmap) == k + 1:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len
</code></pre>
<p>典型的two pointer 写的磕磕绊绊 但写出来了。。。dic存放window中遇到字符的个数，  case1）如果目前dic有内容而且当前char不在dic而且window已经达到容量，start得向前移动，每前进一位，dic中s【start】数目减少一个，如果减少到0需要删除key。 退出while循环现在len（dic）小于k，后续这个不在dic中的char会加入dic。 case2）char in dic and len（dic）小于等于k，直接算结果 case3） len（dic）小于k，res+1.  答案方法思路也差不多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-05/">
        </link>
        <updated>2021-12-05T10:46:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred321-create-maximum-number-hard-font"><font color='red'>321. Create Maximum Number (Hard) </font></h1>
<p>You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.<br>
Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.<br>
Return an array of the k digits representing the answer.<br>
Example<br>
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5<br>
Output: [9,8,6,5,3]</p>
<pre><code class="language-python">class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[int]:
        # 思路。。。
        # 最大需要每个位置数字最大，
        # 但选择最大的数字有顺序约束
        # 而且当可选最大数字相同时，需要程序tracking 2种不同结果。
        

        def prep(nums, k):
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] &lt; num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            return [max(a, b).pop(0) for _ in a+b]

        return max(merge(prep(nums1, i), prep(nums2, k-i))  for i in range(k+1)   if i &lt;= len(nums1) and k-i &lt;= len(nums2))

</code></pre>
<p>没思路。。。看到答案用了greedy方法。。。  prep function只是在一个数组中按照顺序找出K个最大的数。先算一下需要drop多少个数， 如果当前值大于栈顶元素，说明需要更新栈顶。  merge function这一步是按照a，b的lexcial顺序找到最大的元素，a+b总共有K个元素，所以pop k次。 最后return所有K+1个分割可能产生的结果取最大的。基本不可能现想出来解法。</p>
<h1 id="322-coin-change-medium">322. Coin Change （Medium）</h1>
<p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.<br>
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.<br>
You may assume that you have an infinite number of each kind of coin.</p>
<pre><code class="language-python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        if amount==0: return 0 if coins else -1
        dp = dict()
        for c in coins:
            dp[c]=1
        for a in range(1,amount+1):
            for c in coins:
                if a+c&lt;=amount and a in dp:
                    if a+c in dp:
                        dp[a+c]=min(dp[a+c],dp[a]+1) 
                    else:
                        dp[a+c]=dp[a]+1
        return dp[amount] if   amount in dp else -1

#ANSWER
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
</code></pre>
<p>感觉是个DP问题，递归关系？  dp【i】是需要达到amount i需要的次数。 初始coins值的dp【coins_val】=1.   对于每一个有dp值的位置，都用coints_val 更新， dp【i+val】=min（dp【i+val】，dp【i】+1）直到amount。 由于不能开过大内存，所以dp变成dict。<br>
答案写法更标准， dp【x】=min（dp【x】，dp【x-coin】+1） x大于等于coin小于等于amount。</p>
<h1 id="323-number-of-connected-components-in-an-undirected-graph-medium">323. Number of Connected Components in an Undirected Graph （Medium）</h1>
<p>You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.<br>
Return the number of connected components in the graph.</p>
<pre><code class="language-python">class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        #  BFS
        neis = collections.defaultdict(list)
        for edge in edges:
            neis[edge[0]].append(edge[1])
            neis[edge[1]].append(edge[0])
        
        
        res=0
        visited=set()
        while len(visited)!=n:
            res+=1
            for i in range(n):
                if i not in visited:
                    visited.add(i)
                    q=[i]
                    break     
            while q:
                l=len(q)
                for _ in range(l):
                    cur=q.pop(0)
                    for nei in neis[cur]:
                        if nei not in visited:
                            visited.add(nei)
                            q.append(nei)
        return res
#UNIONFIND
class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1
                    
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        uf=self.UnionFind(n)
        for edge in edges:
            uf.union(*edge)
        return uf.n

</code></pre>
<p>注意unionfind中   if x!=self.parent[x]   爸爸=找爸爸（爸爸）  self.parent[x]=self.find(self.parent[x])， union只有rank相同时候才需要+rank。</p>
<h1 id="font-colorred324-wiggle-sort-ii-mediumfont"><font color='red'>324. Wiggle Sort II （Medium）</font></h1>
<p>Given an integer array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....<br>
You may assume the input array always has a valid answer.</p>
<pre><code class="language-python">     def wiggleSort(self, nums):
        count = [0]*5001
        
        for n in nums:
            count[n]+=1
        
        odd = 1
        even = 0
        for n in range(5000,-1,-1):
            if odd &gt;= len(nums) and even &gt;= len(nums):
                break
                
            if count[n] == 0:
                continue
            
            while count[n] and (odd &lt; len(nums) or even &lt; len(nums)):
                count[n]-=1
                if odd &lt; len(nums):
                    nums[odd] = n
                    odd+=2
                else:
                    nums[even] = n
                    even+=2
        
 class Solution(object):
    def wiggleSort(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
      
        arr = sorted(nums)
        for i in range(1, len(nums), 2): nums[i] = arr.pop() 
        for i in range(0, len(nums), 2): nums[i] = arr.pop() 

class Solution:
    def wiggleSort(self, A: List[int]) -&gt; None:        
        N = len(A)                    
        count = [0] * 5001        
        self.curr_val = A[0]
        
        for v in A:
            count[v] += 1
            self.curr_val = max(self.curr_val, v)
        
        def next_val():
            while count[self.curr_val] == 0: self.curr_val -= 1            
            count[self.curr_val] -= 1
            return self.curr_val
                            
        for i in range(1, N, 2): A[i] = next_val()     
        for i in range(0, N, 2): A[i] = next_val() 
</code></pre>
<p>思路：从sorted 最大到最小，奇数位置放置，然后偶数位置放置数字。时间要降低到O（n）只能用count sort了。</p>
<h1 id="font-colorred325-maximum-size-subarray-sum-equals-k-mediumfont"><font color='red'>325. Maximum Size Subarray Sum Equals k （Medium）</font></h1>
<p>Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.</p>
<pre><code class="language-python">class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:
        
        prefix_sum = 0 
        res = 0
        indices = dict()
        
        for i,n in enumerate(nums):
            prefix_sum+=n
            
            if prefix_sum==k:
                res=i+1
            
            if prefix_sum-k in indices:
                res=max(res,i-indices[prefix_sum-k])
            
            if prefix_sum not in indices:
                indices[prefix_sum]=i
        
        return res

</code></pre>
<p>没思路，直接看答案了。看错题目了，题目是subarray。。。是连续的字符串，并不是sublist。。。。<br>
思路：用到了prefix sum和 two sum的解法。 因为是subarray，prefix【j】-prefix【i】==k 就是一个答案。  具体扫predix过程借鉴two sum，在predix-k在 dict中，更新res。 不在dict中，更新dict。 不能无条件更新dict，因为prefix在dict中与之间prefix重复，应该保留更早的index使长度更长。</p>
<h1 id="326-power-of-three-easy">326. Power of Three （Easy）</h1>
<p>Given an integer n, return true if it is a power of three. Otherwise, return false.<br>
An integer n is a power of three, if there exists an integer x such that n == 3x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n==0: return False
        while n:
            if n==1: return True
            if n%3!=0:
                return False
            n//=3
        return True

class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n&lt;1: return False
        while n%3==0:
            n//=3
            
        return n==1
</code></pre>
<h1 id="font-colorred327-count-of-range-sum-hard-font"><font color='red'>327. Count of Range Sum (Hard) </font></h1>
<p>Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.<br>
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i &lt;= j.</p>
<pre><code class="language-python">class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        presum = [0]*(len(nums)+1)
        for i,n in enumerate(nums):
            presum[i+1]=presum[i]+n
        
        res=0
        for i in range(1,len(nums)+1):
            for j in range(i):
                if upper&gt;=presum[i]-presum[j]&gt;=lower:
                    res+=1
        return res
#ANSWER 1 PrefixSum+MergeSort
class Solution:
    def countRangeSum(self, nums, lower, upper):
        cumsum = [0]*(len(nums)+1)
        for i,num in enumerate(nums):
            cumsum[i+1]=cumsum[i]+num
        def sort(lo, hi):
            mid = (lo + hi) // 2
            if mid == lo:
                return 0
            count = sort(lo, mid) + sort(mid, hi)
            i = j = mid
            for left in cumsum[lo:mid]:
                while i &lt; hi and cumsum[i] - left &lt;  lower: i += 1
                while j &lt; hi and cumsum[j] - left &lt;= upper: j += 1
                count += j - i
            cumsum[lo:hi] = sorted(cumsum[lo:hi])
            return count
        return sort(0, len(cumsum))


#ANSER Binary Indexed Tree + Binary Search
class BinaryIndexedTree:
    
    def __init__(self, n):
        self.n = n
        self.tree = [0 for _ in range(n+1)]
    
    def update(self, idx, val):
        while idx &lt;= self.n:
            self.tree[idx] += val
            idx += idx &amp; -idx
    
    def query(self, idx):
        total = 0
        while idx &gt; 0:
            total += self.tree[idx]
            idx -= idx &amp; -idx
        return total

    
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        n, prefixes = len(nums), list(itertools.accumulate(nums))
        
        sortedPrefixes = sorted(set(prefixes))
        ranks = { prefix: idx + 1 for idx, prefix in enumerate(sortedPrefixes) }
        
        ds = BinaryIndexedTree(len(sortedPrefixes))
        for prefix in prefixes:
            ds.update(ranks[prefix], 1)
        
        res = 0
        processed = 0
        for prefix in prefixes:
            l = bisect.bisect_left(sortedPrefixes, lower + processed)
            r = bisect.bisect_right(sortedPrefixes, upper + processed)  
            res += ds.query(r) - ds.query(l)
            ds.update(ranks[prefix], -1)
            processed = prefix
        
        return res
</code></pre>
<p>首次尝试O（n^2）time limit exccded。  看来得低于O（n^2）才可以。。。改进方法是增加mergesort。 思路：先算cumsum。 目标找出cumsum【right】-cumsum【left】在upper lower 之间的这样的pair个数。 定义helper function merge sort。 返回值是满足条件的个数，先递归找出只在lo<sub>mid和mid</sub>hi之间的个数。若left~right横跨mid， 对于每一个left in sumsum【lo：mid】 找出满足upper lower bond的 right。其中满足lower bound的index 是i， 满足upper bound 的index 是j 所以 count+=j-i。<br>
又忘记了有segment tree 和binary indexed tree这两种数据结构。。。。</p>
<h1 id="328-odd-even-linked-list-medium">328. Odd Even Linked List (Medium)</h1>
<p>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.<br>
The first node is considered odd, and the second node is even, and so on.<br>
Note that the relative order inside both the even and odd groups should remain as it was in the input.<br>
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if not head: return head
        odd_head=head
        even_head=head.next
        
        cur=head
        odd_tail=None
        c=0
        while cur:
            curnext=cur.next
            c+=1
            if c%2==1:
                #cur is odd node
                cur.next=cur.next.next if cur.next else None
                odd_tail=cur
            else:
                #cur is even node
                cur.next=cur.next.next if cur.next else None
            
            cur=curnext
        
        if odd_tail:
            odd_tail.next=even_head
        
        return odd_head


#ANSWER 
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        
        if not head: return head
        
        odd  = head
        even = head.next
        evenhead = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        return head
</code></pre>
<h1 id="font-colorred329-longest-increasing-path-in-a-matrix-hard-font"><font color='red'>329. Longest Increasing Path in a Matrix (Hard) </font></h1>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.<br>
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<pre><code class="language-python">class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int:
        dirs = [[0,1],[1,0],[0,-1],[-1,0]]
        m=len(matrix)
        n=len(matrix[0])
        if not matrix: return 0
        cache= [[0]*n for _ in range(m)]
        res=0
        
        def dfs(i,j):
            if cache[i][j]!=0: return cache[i][j]
            for d in dirs:
                x=i+d[0]
                y=j+d[1]
                if m&gt;x&gt;=0 and n&gt;y&gt;=0 and matrix[x][y]&gt;matrix[i][j]:
                    cache[i][j]=max(cache[i][j],dfs(x,y))
            
            cache[i][j]+=1
            return cache[i][j] 
        
        
        for i in range(m):
            for j in range(n):
                res=max(res,dfs(i,j))
                
        return res
</code></pre>
<p>DFS+mem  太晚了直接看答案了。。。因为是strictly increasing path 所以是DAG，所以dfs（i，j） path length 是可以用mem记住的。 但通常的DFS是不能用mem的。</p>
<h1 id="font-colorred330-patching-array-hardfont"><font color='red'>330. Patching Array （Hard）</font></h1>
<p>Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.<br>
Return the minimum number of patches required.</p>
<pre><code class="language-python">class Solution:
    def minPatches(self, nums: List[int], n: int) -&gt; int:
        
        '''Initialize the range [1, miss) = [1, 1) = empty
        While n is not covered yet
            if the current element nums[i] is less than or equal to miss
                extends the range to [1, miss + nums[i])
                increase i by 1
            otherwise
                patch the array with miss, extends the range to [1, miss + miss)
                increase the number of patches
        Return the number of patches
        '''
        
        patches=0
        i=0
        miss=1
        while miss&lt;=n:
            if i&lt;len(nums) and nums[i]&lt;=miss:
                #miss is covered
                miss+=nums[i]
                i+=1
            else:
                #patch miss to aray
                miss+=miss
                patches+=1
        return patches

</code></pre>
<p>太晚没思路直接看答案， 答案思路：假设miss 是最小的missing number， 但我们知道【1，miss） 已经covered。 要cover miss，需要添加小于等于miss的数字。<br>
假设我们添加的数字是x，那么区间【1，miss） 【x，x+miss）都covered。由于x小于等于miss。 所以两个区间可以合并为【1，x+miss）我们想选一个range cover最大的x，显然当x=miss时候区间最大。所以算法是：<br>
初始化区间【1，miss）=【1，1）<br>
当n还没covered，如果 nums【i】小于等于miss，增加区间为【1，miss+nums【i】），i++ 否则， 数组里添加miss， 增加区间为【1，miss+miss), res+=1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-04]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-04/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-04/">
        </link>
        <updated>2021-12-04T13:17:02.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="311-sparse-matrix-multiplication-medium">311. Sparse Matrix Multiplication (Medium)</h1>
<p>Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.</p>
<pre><code class="language-python">class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -&gt; List[List[int]]:
        l=len(mat1)
        m=len(mat1[0])
        n=len(mat2[0])
        #1m*mn = ln
        res = [[0]*n for _ in range(l)]
        
        for i in range(l):
            for j in range(n):
                for k in range(m):
                    res[i][j]+=mat1[i][k]*mat2[k][j]
        return res
</code></pre>
<p>因为题目是sparse table 所以更好的做饭是把table 存成hashmap。</p>
<h1 id="font-colorred312-burst-balloons-hardfont"><font color='red'>312. Burst Balloons （Hard）</font></h1>
<p>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.<br>
If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.<br>
Return the maximum coins you can collect by bursting the balloons wisely</p>
<pre><code class="language-python">#TIME LIMIT EXCCEEDED.
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int:
        res = []
        def bt(nums,val):
            if not nums:
                res.append(val)
            for i,n in enumerate(nums):
                new_nums = nums[:i]+nums[i+1:]
                a = nums[i-1] if i-1&gt;=0 else 1
                b= n
                c= nums[i+1] if i+1&lt;len(nums) else 1
                bt(new_nums,val+a*b*c)
        
        
        bt(nums,0)
        #print(res)
        return max(res) if res else 1

#ANSWER 1
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int: 
        #ith is the last to burst
        nums = [1]+nums+[1]
        @lru_cache(None)
        def dp(left,right):
            if left&gt;right: return 0
            res=0
            for i in range(left,right+1):
                gain=nums[left-1]*nums[i]*nums[right+1]
                remaining=dp(left,i-1)+dp(i+1,right)
                res=max(res,gain+remaining)
            return res
  
        
        return dp(1,len(nums)-2)

#
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int: 
        #ith is the last to burst
        nums = [1]+nums+[1]
        n=len(nums)
        dp=[[0]*n for _ in range(n)]
        for left in range(n-2,0,-1):
            for right in range(left,n-1):
                for i in range(left,right+1):
                    gain=nums[left-1]*nums[i]*nums[right+1]
                    remaining=dp[left][i-1]+dp[i+1][right]
                    dp[left][right]=max(dp[left][right],gain+remaining)
        return dp[1][n-2]
</code></pre>
<p>初次尝试，backtraking 方法会time limit exceeded， 需要更优方法。 答案1） top down dp， ith气球是最后一个burst的，所以left到i-1，i+1到right先burst。 思路是分治法，能拆分为互相不干扰的left，right部分是因为ith定义是最后一个burst，要ith定义是先burst，就会出现left，right部分dependent关系，right部分数值取决于left最右一个气球是否burst。所以定义ith气球最后一个burst是很聪明的解决了分治法左右depenent问题。2）Bottom-Up dp 算 dp【left】【right】必须知道dp【left】【i-1】和dp【i+1】【right】 i在left right之间，所以dp更新路线是从右下角zigzag更新。</p>
<h1 id="font-colorred313-super-ugly-number-mediumfont"><font color='red'>313. Super Ugly Number （Medium）</font></h1>
<p>A super ugly number is a positive integer whose prime factors are in the array primes.<br>
Given an integer n and an array of integers primes, return the nth super ugly number.<br>
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p>
<pre><code class="language-python">class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:
        dp = [0]*n
        t = [0]*len(primes)
        dp[0]=1
        for i in range(1,n):
            dp[i]=min(dp[t[ii]]*primes[ii] for ii in range(len(primes)))
            for j in range(len(primes)):
                if dp[i]==dp[t[j]]*primes[j]:
                    t[j]+=1
        return dp[-1]
 
        
        # dp = [0] * n
        # t2 = t3 = t5 = 0
        # dp[0] = 1
        # for i in range(1,n):
        #     dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
        #     if(dp[i] == dp[t2]*2): t2 += 1
        #     if(dp[i] == dp[t3]*3): t3 += 1
        #     if(dp[i] == dp[t5]*5): t5 += 1
        # return dp[-1]
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:
 
        dp=[1]
        res=1
        s=set()
        for _ in range(n):
            while res in s:
                res = heapq.heappop(dp)
            s.add(res)
            for p in primes:
                heapq.heappush(dp,res*p)
        return res
 
#ANSWER
 class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:

        uglies = [1]
        def gen(prime):
            for ugly in uglies:
                yield ugly * prime
        merged = heapq.merge(*map(gen, primes))
        while len(uglies) &lt; n:
            ugly = next(merged)
            if ugly != uglies[-1]:
                uglies.append(ugly)
        return uglies[-1]
</code></pre>
<p>仿照ugly unmber II 写出一个dp的解但time limit excceded。   用heapq还是time limit excceded。 这个题目python不友好， 答案用了generator。</p>
<h1 id="314-binary-tree-vertical-order-traversal-medium">314. Binary Tree Vertical Order Traversal （Medium）</h1>
<p>Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column).<br>
If two nodes are in the same row and column, the order should be from left to right.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        dic = dict()
        def pre(root,level,hight):
            hight+=1
            if not root: return 
            if level not in dic:
                dic[level]=[]
            dic[level].append((root.val,hight))
            pre(root.left,level-1,hight) 
            pre(root.right,level+1,hight)
        pre(root,0,0)
        res= [ [val[0] for val in sorted(v,key=lambda x:x[1])] for k,v in  sorted(dic.items(),key=lambda x:x[0])]
        return res

</code></pre>
<p>记录左右移动同时记录上下移动。</p>
<h1 id="font-colorred-315-count-of-smaller-numbers-after-self-hardfont"><font color='red'> 315. Count of Smaller Numbers After Self （Hard）</font></h1>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].<br>
Input: nums = [5,2,6,1]<br>
Output: [2,1,1,0]<br>
Explanation:<br>
To the right of 5 there are 2 smaller elements (2 and 1).<br>
To the right of 2 there is only 1 smaller element (1).<br>
To the right of 6 there is 1 smaller element (1).<br>
To the right of 1 there is 0 smaller element.</p>
<pre><code class="language-python">class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
        #   5  2   6   1
        #
        #   0 1 2 3 4 5 6
        #     1 1     1 1
        #
        #  找出 i-1 到 -inf 的cumsum ，而且update 从右往左。
        #  -OFFSET ~0 ~ OFFSET
        
        OFFSET=10000
        size=2 * OFFSET+1  
        tree=[0]*(2*size)
        
        #####
        #   1
        # 2   3
        #4 5 6 7
        # 1 2 3 4 5 6 7
       
                    
            
        def update(ind):
            tree[ind]+=1
           
            while ind&gt;0:
                left=ind
                right=ind
                if ind%2==0:
                    right+=1
                else:
                    left-=1
                if ind//2&gt;0:
                    tree[ind//2]=tree[left]+tree[right]
                ind//=2
                
        def query(left,right):
            res=0
            while left&lt;=right:
                if right%2==0:
                    res+=tree[right]
                    right-=1
                if left%2==1:
                    res+=tree[left]
                    left+=1

                left//=2
                right//=2
    
            return res
                    
        ans = []
        for num in nums[::-1]:
            ind = num+OFFSET+size 
            ans.append(query(size,ind-1))
            update(ind)
             
            
        return ans[::-1]


#ANSWER 2
class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
 
        OFFSET=10000
        size=2 * OFFSET+1 + 1 #total possible values in nums plus one dummy 
        tree=[0]*size
        ans = []
            
        def update(ind):
            ind=ind+1   #index in BIT is 1 more than original index
            while ind&lt;size:
                tree[ind]+=1
                ind+= ind&amp;-ind
        def query(ind):
            ind=ind+ 1  #index in BIT is 1 more than original index
            res=0
            while ind&gt;0:
                res+=tree[ind]
                ind-= ind&amp;-ind
            return res
           
          
        ans = []
        for num in nums[::-1]:
            ind = num+OFFSET
            ans.append(query(ind-1))
            update(ind)
             
            
        return ans[::-1]
    
#ANSWER3
class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
        def sort(enum):
            half = len(enum) // 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                m, n = len(left), len(right)
                i = j = 0
                while i &lt; m or j &lt; n:
                    if j == n or i &lt; m and left[i][1] &lt;= right[j][1]:
                        enum[i+j] = left[i]
                        smaller[left[i][0]] += j
                        i += 1
                    else:
                        enum[i+j] = right[j]
                        j += 1
            return enum
        smaller = [0] * len(nums)
        sort(list(enumerate(nums)))
        return smaller
 

</code></pre>
<p>错误以为用stack可以解决~~，答案方法1）Segment Tree 2）Binary index Tree 3)Merge Sort,当选取左边元素，记录 smaller[left[i][0]] += j  ；  left【i】【0】是左边元素在原始数组种的index， j是right中未被选中元素的index，恰巧是小于左边被选中元素的在右边需要变换位置元素的长度。</p>
<h1 id="font-colorred316-remove-duplicate-letters-mediumfont"><font color='red'>316. Remove Duplicate Letters （Medium）</font></h1>
<p>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.<br>
Example 1:<br>
Input: s = &quot;bcabc&quot;<br>
Output: &quot;abc&quot;<br>
Example 2:<br>
Input: s = &quot;cbacdcbc&quot;<br>
Output: &quot;acdb&quot;</p>
<pre><code class="language-python">class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        # maintain smalleset lexicographical order How?
        
        # find pos - the index of the leftmost letter in our solution
        # we create a counter and end the iteration once the suffix doesn't have each unique character
        # pos will be the index of the smallest character we encounter before the iteration ends
        c=Counter(s)
        pos=0
        for i in range(len(s)):
            if s[i]&lt;s[pos]:
                pos=i
            c[s[i]]-=1
            if c[s[i]]==0:
                break
        return s[pos]+self.removeDuplicateLetters(s[pos:].replace(s[pos],&quot;&quot;)) if s  else ''

#ANSWER
class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        stack=[]
        seen=set()
        last_occurrence = {c:i for i,c in enumerate(s)}
        for i,c in enumerate(s):
            if c not in seen:
                #只有c不在seen中才能试图在stack中加c
                while stack and c&lt;stack[-1] and i&lt;last_occurrence[stack[-1]]:  
                    # 如果当前试图加入的c&lt;stack[-1] 而且 c的位置&lt; stack[-1]最后出现位置
                    # 可以安全移除stack【-1】
                    val=stack.pop()
                    seen.discard(val)
                    
                seen.add(c)
                stack.append(c)
                
        return ''.join(stack)
</code></pre>
<p>思路1） 找到第一个qualify的pos，s【i】小于s【pos】需要更新pos成i，当counter s【i】==0时候说明s【i】是当前必须加入结果的字符，然后找下一个字符用recursive方法。<br>
思路2）  见代码 Greedy 方法的应用</p>
<h1 id="font-colorred317-shortest-distance-from-all-buildings-hard-font"><font color='red'>317. Shortest Distance from All Buildings （Hard） </font></h1>
<p>You are given an m x n grid grid of values 0, 1, or 2, where:<br>
each 0 marks an empty land that you can pass by freely,<br>
each 1 marks a building that you cannot pass through, and<br>
each 2 marks an obstacle that you cannot pass through.<br>
You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.<br>
Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.</p>
<pre><code class="language-python">#METHOD 1 BFS from Biulding
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&gt; int:
        
        
        #Use hit to record how many times a 0 grid has been reached and use distSum to record the sum of distance from all 1 grids to this 0 grid. A powerful pruning is that during the BFS we use count1 to count how many 1 grids we reached. If count1 &lt; buildings then we know not all 1 grids are connected are we can return -1 immediately, which greatly improved speed (beat 100% submissions).

 
        if not grid or not grid[0]: return -1
        M, N, buildings = len(grid), len(grid[0]), sum(val for line in grid for val in line if val == 1)
        hit, distSum = [[0] * N for i in range(M)], [[0] * N for i in range(M)]

        def BFS(start_x, start_y):
            visited = [[False] * N for k in range(M)]
            visited[start_x][start_y], count1, queue = True, 1, collections.deque([(start_x, start_y, 0)])
            while queue:
                x, y, dist = queue.popleft()
                for i, j in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if 0 &lt;= i &lt; M and 0 &lt;= j &lt; N and not visited[i][j]:
                        visited[i][j] = True
                        if not grid[i][j]:
                            queue.append((i, j, dist + 1))
                            hit[i][j] += 1
                            distSum[i][j] += dist + 1
                        elif grid[i][j] == 1:
                            count1 += 1
            return count1 == buildings  

        for x in range(M):
            for y in range(N):
                if grid[x][y] == 1:
                    if not BFS(x, y): return -1
        return min([distSum[i][j] for i in range(M) for j in range(N) if not grid[i][j] and hit[i][j] == buildings] or [-1])
    

#METHOD 2 BFS from Empty space
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&gt; int:
        M=len(grid)
        N=len(grid[0])
        totalHouses = sum([v for row in grid for v in row if v==1])
        minDistance=float('inf')
        def bfs(row,col):
            distanceSum=0
            housesReached=0
            visited =[[False]*N for _ in range(M)]
            q=collections.deque()
            q.append((row,col))
            step=0
            while q and housesReached!=totalHouses:
                l=len(q)
                for _ in range(l):
                    row,col=q.popleft()
                    
                    if grid[row][col]==1:
                        distanceSum+=step
                        housesReached+=1
                        continue
                    
                    for new_row,new_col in [(row+1,col),(row-1,col),(row,col+1),(row,col-1)]:
                        if M&gt;new_row&gt;=0 and N&gt;new_col&gt;=0:
                            if not visited[new_row][new_col] and grid[new_row][new_col]!=2:
                                visited[new_row][new_col]=True
                                q.append((new_row,new_col))
                                
                step+=1
            
            if housesReached!=totalHouses:
                for row in  range(M):
                    for col in range(N):
                        if grid[row][col]==0 and visited[row][col]:
                            grid[row][col]=2
                
                return float('inf')
            return distanceSum
        
        
        
        #main
        for row in range(M):
            for col in range(N):
                if grid[row][col]==0:
                    minDistance=min(minDistance,bfs(row,col))
        
        if minDistance==float('inf'):
            return -1
        return minDistance         

</code></pre>
<p>直接看答案了。。。。方法一更好点， 从building处做BFS，保存hits数目。BFS返回count1==#Buildings 这样可以提前截断如果存在不能完全到达所有building情况。</p>
<h1 id="318-maximum-product-of-word-lengths-medium">318. Maximum Product of Word Lengths （Medium）</h1>
<p>Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.</p>
<pre><code class="language-python">class Solution:
    def maxProduct(self, words: List[str]) -&gt; int:
        ss  = [set() for _ in range(len(words))]
        for i,word in enumerate(words):
            for w in word:
                ss[i].add(w)
        res=float('-inf')
        for i in range(len(words)-1):
            for j in range(i+1,len(words)):
                if not ss[i] &amp; ss[j]:
                    res=max(res,len(words[i])*len(words[j]))
        return res if res!=float('-inf') else 0
#ANSWER
from collections import defaultdict
class Solution:
    def maxProduct(self, words: List[str]) -&gt; int:
        hashmap = defaultdict(int)
        bit_number = lambda ch : ord(ch) - ord('a')
        
        for word in words:
            bitmask = 0
            for ch in word:
                # add bit number bit_number in bitmask
                bitmask |= 1 &lt;&lt; bit_number(ch)
            # there could be different words with the same bitmask
            # ex. ab and aabb
            hashmap[bitmask] = max(hashmap[bitmask], len(word))
        
        max_prod = 0
        for x in hashmap:
            for y in hashmap:
                if x &amp; y == 0:
                    max_prod = max(max_prod, hashmap[x] * hashmap[y])
        return max_prod
</code></pre>
<p>答案用了bitmask作为key来优化。思路很好。</p>
<h1 id="319-bulb-switcher-medium">319. Bulb Switcher （Medium）</h1>
<p>There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.<br>
On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.<br>
Return the number of bulbs that are on after n rounds.</p>
<pre><code class="language-python">class Solution:
    def bulbSwitch(self, n: int) -&gt; int:
        return int(math.sqrt(n))
        
</code></pre>
<p>这题比较tricky， 灯泡1到n， 只有灯泡被拨动奇数次才会亮， 比如第i个灯泡，i%round==0时候会被拨动一次， 这样第i个灯泡比如第12个，1，12，2，6，3，4轮时候会被拨到，但是对于完全平方数，比如36个灯泡，1，36，2，18，3，12，4，9，6轮时候会被拨到但为奇数轮。所以找到有多少个完全平方数在1到n之间就可以了。</p>
<h1 id="font-colorred320-generalized-abbreviation-mediumfont"><font color='red'>320. Generalized Abbreviation （Medium）</font></h1>
<p>A word's generalized abbreviation can be constructed by taking any number of non-overlapping and non-adjacent substrings and replacing them with their respective lengths.<br>
For example, &quot;abcde&quot; can be abbreviated into:<br>
&quot;a3e&quot; (&quot;bcd&quot; turned into &quot;3&quot;)<br>
&quot;1bcd1&quot; (&quot;a&quot; and &quot;e&quot; both turned into &quot;1&quot;)<br>
&quot;5&quot; (&quot;abcde&quot; turned into &quot;5&quot;)<br>
&quot;abcde&quot; (no substrings replaced)<br>
However, these abbreviations are invalid:<br>
&quot;23&quot; (&quot;ab&quot; turned into &quot;2&quot; and &quot;cde&quot; turned into &quot;3&quot;) is invalid as the substrings chosen are adjacent.<br>
&quot;22de&quot; (&quot;ab&quot; turned into &quot;2&quot; and &quot;bc&quot; turned into &quot;2&quot;) is invalid as the substring chosen overlap.<br>
Given a string word, return a list of all the possible generalized abbreviations of word. Return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def generateAbbreviations(self, word: str) -&gt; List[str]:
        if not word: return []
        res= set()
        res.add(str(len(word)))
        res.add(word)
        for seg_pos in range(len(word)):
            left=word[:seg_pos]
            right=word[seg_pos:]
            
            if left:
                res.add(str(len(left))+right)
            if right:
                res.add(left+str(len(right)))
            
            for left_res in self.generateAbbreviations(left):
                for right_res in self.generateAbbreviations(right):
                    if not (left_res and left_res[-1].isdigit() and right_res and right_res[0].isdigit()):
                        res.add(left_res+right_res)
        
        return sorted(list(res))
#ANSWER
class Solution:
    def generateAbbreviations(self, word: str) -&gt; List[str]:
        def rec(idx, curr_list):
            if idx == L:
                res.append(''.join(curr_list))
                return
            
            #Abbreviate
            if curr_list and curr_list[-1].isdigit():
                curr_list[-1] = str(int(curr_list[-1]) + 1)
                rec(idx + 1, curr_list)
                curr_list[-1] = str(int(curr_list[-1]) - 1)
            else:
                rec(idx + 1, curr_list + ['1'])
            
            #Not to abbreviate
            rec(idx + 1, curr_list + [word[idx]])
                
        L = len(word)
        res = []
        rec(0, [])
        return res
</code></pre>
<p>初次尝试time limit exceeded。。。但这题只能backtracking解。 time complexity应该是相同的，看答案的backtracking写的很完美。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-03/">
        </link>
        <updated>2021-12-02T07:07:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred301-remove-invalid-parentheses-hard-font"><font color='red'>301. Remove Invalid Parentheses (Hard) </font></h1>
<p>Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.<br>
Return all the possible results. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution(object):
    def removeInvalidParentheses(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: List[str]
        &quot;&quot;&quot;
        
        res=[] 
        if not s: return [s]
        visited=set()
        q=[]
        
        q.append(s)
        visited.add(s)
        
      
        
        def isValid(s):
            c=0
            for e in s:
                if e=='(':c+=1
                if e==')':c-=1
                
                if c&lt;0: return False
            return c==0

        found=False
        
        while q:
            s=q.pop(0)
            
            if isValid(s):
                res.append(s)
                found=True
            
            if found: continue
            
            for i in range(len(s)):
                if s[i]!='(' and s[i]!=')': continue
                t=s[:i]+s[i+1:]
                
                if not t in visited:
                    q.append(t)
                    visited.add(t)
        
        return res
    
#         def valid(s):
#             stack=[]
#             ss=[ i for i in s if (i in '()') ]
#             for e in ss:
#                 if e==')':
#                     if (not stack) or (not stack.pop()=='('):
#                         return False
#                 else:
#                     stack.append(e)
#             return not stack

#ANSWER
class Solution:
    
  
    
    def removeInvalidParentheses(self, s: str) -&gt; List[str]:
        #based on hint 
        #1) figure out how many misplaced left and right parenthesis
        left=0
        right=0
        for i,p in enumerate(s):
            if p=='(':
                left+=1
            elif p==')':
                if left&gt;0:
                    left-=1
                else:
                    right+=1
        
        #2)recursion process 
        res =set()
        def bt(left_rem,right_rem,left,right,tmp,index):
            #left_rem is the left error position ( remained
            #right_rem is the right error position ) remained
            #left is # of ( in current expression tmp
            #right is # of ) in current expression tmp
            #tmp is current expression
            #index is the index of char in original string s
            
            #BASE CASE
            if index==len(s):     
                #print(left_rem,right_rem,left,right,tmp)
                if left_rem==0 and right_rem==0:
                    res.add(&quot;&quot;.join(tmp))
                return
            
            #discard current
            if (s[index]=='(' and left_rem&gt;0) or (s[index]==')' and right_rem&gt;0):
                bt(left_rem-(s[index]=='('),right_rem-(s[index]==')'),left,right,tmp,index+1)

            #add current
            tmp.append(s[index])

            #if current is not in {()}
            if s[index] not in [&quot;(&quot;,&quot;)&quot;]:
                bt(left_rem,right_rem,left,right,tmp,index+1)
            elif s[index]=='(':
                #consider an opening bracket
                bt(left_rem,right_rem,left+1,right,tmp,index+1)
            elif s[index]==')' and left&gt;right:
                # consider a closing bracket
                bt(left_rem,right_rem,left,right+1,tmp,index+1)

            tmp.pop()                 

         
        bt(left,right,0,0,[],0)
        return list(res)

</code></pre>
<p>思路1 最快最吊炸天） 类似bfs，用queue 做，验证每一个可能的结果。但为了找到最少的变动就能valid的string，所以一旦找到remove后可以valid的string就不在queue中添加后续元素了。 2）backtracking，先计算错位的left right 括号个数。需要track的， left_remain,right_remain,left_counter,right_counter, tmp=[], index.  比较复杂。</p>
<h1 id="302-smallest-rectangle-enclosing-black-pixels-hard">302. Smallest Rectangle Enclosing Black Pixels （Hard）</h1>
<p>You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel.<br>
The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.<br>
Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.<br>
You must write an algorithm with less than O(mn) runtime complexity</p>
<pre><code class="language-python">class Solution:
    minx=float('inf')
    miny=float('inf')
    maxx=float('-inf')
    maxy=float('-inf')
    def minArea(self, image: List[List[str]], x: int, y: int) -&gt; int:
        
        m=len(image)
        n=len(image[0])
        def dfs(x,y):
            self.minx=min(self.minx,x)
            self.miny=min(self.miny,y)
            self.maxx=max(self.maxx,x)
            self.maxy=max(self.maxy,y)
            image[x][y]='#'
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n and image[xx][yy]=='1':
                    dfs(xx,yy)
        dfs(x,y)
        return (self.maxx-self.minx+1)*(self.maxy-self.miny+1)
</code></pre>
<p>除了bfs ，dfs外 答案给出了一种project 图片到1D，然后用binary search 找上下界，来算面积。</p>
<h1 id="303-range-sum-query-immutable-easy">303. Range Sum Query - Immutable （Easy）</h1>
<pre><code class="language-python">class NumArray:

    def __init__(self, nums: List[int]):
        
        for i,n in enumerate(nums):
            if i==0: continue
            nums[i]+=nums[i-1]
        self.cumsum=nums

    def sumRange(self, left: int, right: int) -&gt; int:
        # 1 2 3
        # 1 3 6
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)

#OR ANSWER WAY OF WRITTEN
class NumArray(object):

    def __init__(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        &quot;&quot;&quot;
        
        nums = [0] + nums
        
        for i in range(1,len(nums)):
            nums[i] +=nums[i-1]
        
        self.nums=nums
     

    def sumRange(self, i, j):
        &quot;&quot;&quot;
        :type i: int
        :type j: int
        :rtype: int
        &quot;&quot;&quot;
        return self.nums[j+1]-self.nums[i]
</code></pre>
<h1 id="304-range-sum-query-2d-immutable-medium">304. Range Sum Query 2D - Immutable (Medium)</h1>
<p>Given a 2D matrix matrix, handle multiple queries of the following type:<br>
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        # original matrix
        # 1 2 3
        # 4 5 6
        # 7 8 9
        #
        #cumsum matrix
        #             c1
        #        0 0  0    0
        #        0 1  3    6
        # row1   0 5  #12  21
        # row2   0 12 27  #45 
        #                 c2
        # do cumsum on row
        # do cumsum on col
        #
        #  row2,col2 -(row1-1)col2 - row2(col1-1) + (row1-1)(col1-1)
        self.matrix = [[0]*(len(matrix[0])+1)]
        for row in matrix:
            self.matrix.append([0]+row)
        
    
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row][col-1]
        
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row-1][col]
        
        
        
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        return self.matrix[row2+1][col2+1]-self.matrix[row1][col2+1]-self.matrix[row2+1][col1]+self.matrix[row1][col1]
        


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<h1 id="font-colorred305-number-of-islands-ii-hard-font"><font color='red'>305. Number of Islands II (Hard) </font></h1>
<p>You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0's represent water and 1's represent land. Initially, all the cells of grid are water cells (i.e., all the cells are 0's).<br>
We may perform an add land operation which turns the water at position into a land. You are given an array positions where positions[i] = [ri, ci] is the position (ri, ci) at which we should operate the ith operation.<br>
Return an array of integers answer where answer[i] is the number of islands after turning the cell (ri, ci) into a land.</p>
<pre><code class="language-python">class Solution:
    
    class unionfind:
        
        def __init__(self,m,n):
            self.m=m
            self.n=n
            self.parent=[-1]*(m*n) 
            self.rank = [0]*(m*n)
            self.counter=0
           
        def isvalid(self,row,col):
            ind=row*self.n+col
            return self.parent[ind]&gt;=0
        
        def setparent(self,row,col):
            ind=row*self.n+col
            if self.parent[ind]==-1:
                self.parent[ind]=ind
                self.counter+=1
            
        def find(self,row,col):
            ind= row*self.n+col
            if self.parent[ind]!=ind:
                new_col = self.parent[ind]%self.n
                new_row = (self.parent[ind]-new_col)//self.n
                self.parent[ind]=self.find(new_row,new_col)
            return self.parent[ind]
            
            
        def union(self,p1,p2):
            x1,y1=p1
            x2,y2=p2
            root1=self.find(x1,y1)
            root2=self.find(x2,y2)
            if root1!=root2:
                self.counter-=1
                if self.rank[root1]&gt;self.rank[root2]:
                    self.parent[root2]=root1
                elif self.rank[root1]&lt;self.rank[root2]:
                    self.parent[root1]=root2
                else:
                    self.parent[root1]=root2
                    self.rank[root2]+=1
                    
        def getcount(self):
            return self.counter
         
                    
                
            
    
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -&gt; List[int]:
        
       
        res=[]
        
        uf=self.unionfind(m,n)
    
        def get_nei(pos,uf):
            nei = []
            x,y=pos
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n:
                    if uf.isvalid(xx,yy):
                        nei.append((xx,yy))
            return nei
    
        for pos in positions:
            uf.setparent(*pos)
            for nei in get_nei(pos,uf):
                uf.union(nei,pos)
            res.append(uf.getcount())
            
        return res
            
            
   

</code></pre>
<p>试过用neighbor_list做，但是无法分辨新加入的点是否会引起2个或3个不同island合并。 思路不正确， 感觉是用UNIONFIND做。还是不能顺畅写出UNIONFIND calss。这次的unionfind class是个变种。 注意增加相同点的时候，setparent做check，必须self.parent[i]==-1 才能做self.conter+=1 。 思路： 每次增加一个点，做setparent，counter++，找这个点所有valid neighbors，然后做union。没发现以个union则counter--。</p>
<h1 id="font-colorblue-306-additive-number-mediumfont"><font color='blue'> 306. Additive Number （Medium）</font></h1>
<p>An additive number is a string whose digits can form an additive sequence.<br>
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.<br>
Given a string containing only digits, return true if it is an additive number or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def isAdditiveNumber(self, num: str) -&gt; bool:
        if not num or len(num)&lt;3: 
            return False
        
        mem=dict()
        def helper(num):
            if not num: return True
            if num in mem: return mem[num]
            Found=False
            for len_a in range(1,len(num)):
                if len_a&gt;1 and num[0]=='0': continue
                for len_b in range(1,len(num)):
                    if len_b&gt;1 and num[len_a]=='0': continue
                    temp_flag=False
                    if len_a+len_b&gt;=len(num):continue
                    a = num[:len_a]
                    b = num[len_a:len_a+len_b]
                    c = str(int(a)+int(b))
                    #print(a,b,c)
                    len_c= len(c)
                    if len_a+len_b+len_c&gt;len(num):continue
                    if len_a+len_b+len_c==len(num) and num[len_a+len_b:len_a+len_b+len_c]==c:
                        return True
                    elif num[len_a+len_b:len_a+len_b+len_c]==c:
                        temp_flag = True and helper(num[len_a:])
                    Found=Found or temp_flag
            mem[num]=Found
            print(num,Found)
            return Found
        
        return helper(num)
        
#ANSWER WAY
def isAdditiveNumber(self, num):
    n = len(num)
    for i, j in itertools.combinations(range(1, n), 2):
        a, b = num[:i], num[i:j]
        if a != str(int(a)) or b != str(int(b)):
            continue
        while j &lt; n:
            c = str(int(a) + int(b))
            if not num.startswith(c, j):
                break
            j += len(c)
            a, b = b, c
        if j == n:
            return True
    return False                

</code></pre>
<p>自己通过recursion with mem解决的，头部为0问题用2个continue 判断去解决。<br>
答案大神用了itertools.combinatons i 是a的长度，j是 a+b的长度，确定了a，b可以算出来c，如果不满足条件跳出while，如果满足条件，则j+len（c），前进一位做下一次判断。 推出时候如果j==n说明找到了。</p>
<h1 id="font-colorred-307-range-sum-query-mutable-medium-font"><font color='red'> 307. Range Sum Query - Mutable (Medium) </font></h1>
<p>Given an integer array nums, handle multiple queries of the following types:<br>
Update the value of an element in nums.<br>
Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.cumsum=nums[:]
        for i in range(1,len(nums)):
            self.cumsum[i]+=self.cumsum[i-1]
 
    def update(self, index: int, val: int) -&gt; None:
        diff=val-self.nums[index]
        self.nums[index]=val
        for i in range(index,len(self.cumsum)):
            self.cumsum[i]+=diff
    def sumRange(self, left: int, right: int) -&gt; int:
        
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]
#METHOD 1  SQRT DECOMPOSTION
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.len =  len(nums)//int(math.sqrt(len(nums)))+1 
        self.b=[0]*self.len
        for i,n in enumerate(nums):
            self.b[i//self.len]+=n
         

    def update(self, index: int, val: int) -&gt; None:
        block_index = index//self.len
        self.b[block_index] = self.b[block_index] - self.nums[index]+val
        self.nums[index]=val

    def sumRange(self, left: int, right: int) -&gt; int:
        res=0
        startblock=left//self.len
        endblock=right//self.len
        if startblock==endblock:
            for ind in range(left,right+1):
                res+=self.nums[ind]
        else:
            for ind in range(left,(startblock+1)*self.len):
                res+=self.nums[ind]
            for block_ind in range(startblock+1,endblock):
                res+=self.b[block_ind]
            for ind in range(endblock*self.len,right+1):
                res+=self.nums[ind]
        return res
        
# METHOD 2 ＳＥＧＭＥＮＴ　ＴＲＥＥ
class NumArray:

    def __init__(self, nums: List[int]):
        self.n=len(nums)
        self.tree=['#']*(2*self.n)
        self.buildtree(nums)
        print(self.tree)
    
    def buildtree(self,nums):
        #populate leaves
        j=0
        for i in range(self.n,2*self.n):
            self.tree[i]=nums[j]
            j+=1
        #populate parent nodes
        for i in range(self.n-1,0,-1):
            self.tree[i]=self.tree[i*2]+self.tree[i*2+1]
        

    def update(self, index: int, val: int) -&gt; None:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        #     22 9 13 4  5  6   7
        pos = index+self.n
        self.tree[pos]=val
        while pos&gt;0:
            left=pos
            right=pos
            #这里比较巧妙，tree变成数组后可以理解。
            if pos%2==0:
                right=pos+1
            else:
                left=pos-1
            
            if left&gt;0:
                self.tree[pos//2] = self.tree[left]+self.tree[right]
            pos //=2
        

    def sumRange(self, left: int, right: int) -&gt; int:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        # #  22 9  13 4  5  6   7
        l = left+self.n
        r = right+self.n
        res=0
        while l&lt;=r:
            if l%2==1:
                res+=self.tree[l]
                l+=1
            if r%2==0:
                res+=self.tree[r]
                r-=1
            l//=2
            r//=2
        return res
        
　

</code></pre>
<p>第一版本用cumsum，time limit exceeded。原因在于update时候，要更新所有后续影响的cumsum值。 看答案了。思路1） Sqrt Decomposition，把nums分成 sqrt（len）个block求和。 思路2） Segment Tree。 这个没见过，是最优解。  构造方法很巧妙。可能需要记住．</p>
<h1 id="font-colorred308-range-sum-query-2d-mutable-hard-font"><font color='red'>308. Range Sum Query 2D - Mutable (Hard) </font></h1>
<p>1D to 2D of rang sum Query</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.trees=[self.buildtree(nums) for nums in matrix]
        
        #for tree in self.trees:
        #    print(tree)
    
    def buildtree(self,nums):
        #   1
        #  2  3
        # 4 5 6 7
        # 1 2 3 4 5 6 7
        tree=['#']*self.n*2
        for i,n in enumerate(nums):
            ind=i+self.n
            tree[ind]=n
        
        for ind in range(self.n-1,0,-1):
            tree[ind]=tree[2*ind]+tree[2*ind+1]
        return tree
    
    def update(self, row: int, col: int, val: int) -&gt; None:
        tree=self.trees[row]
        #   1
        #  2  3
        # 4 5 6 7
        # 1   2  3  4 5 6 7
        # 22  9  13 4 5 6 7
        ind = self.n+col
        self.matrix[row][col]=val
        tree[ind]=val
        while ind&gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&gt;0:
                tree[ind//2]=tree[left]+tree[right]
            ind=ind//2
        self.trees[row]=tree
      

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        res = 0
        for row in range(row1,row2+1):
            tree=self.trees[row]
            #   1
            #  2  3
            # 4 5 6 7
            # 1   2  3  4 5 6 7
            # 22  9  13 4 5 6 7
            l=col1+self.n
            r=col2+self.n
            while l&lt;=r:
                if l%2==1:
                    res+=tree[l]
                    l+=1
                if r%2==0:
                    res+=tree[r]
                    r-=1
                l//=2
                r//=2
        return res
            
# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)

#ANSWER
class NumMatrix:
    
    def lsb(self,n):
        return n&amp;-n
    
    def updateBIT(self,r,c,val):
        i=r
        while i&lt;=self.m:
            j=c
            while j&lt;=self.n:
                self.bit[i][j]+=val
                j+=self.lsb(j)
            i+=self.lsb(i)
    
    def queryBIT(self,r,c):
        res=0
        i=r
        while i&gt;0:
            j=c
            while j&gt;0:
                res+=self.bit[i][j]
                j-=self.lsb(j)
            i-=self.lsb(i)
        return res
    def buildBIT(self,matrix):
        for i in range(1,self.m+1):
            for j in range(1,self.n+1):
                val=matrix[i-1][j-1]
                self.updateBIT(i,j,val)
    
    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.bit= [[0]*(self.n+1) for _ in range(self.m+1)]
        self.buildBIT(matrix)
        
    def update(self, row: int, col: int, val: int) -&gt; None:
        old_val=self.sumRegion(row,col,row,col)
        #handling 1-based indexing
        row+=1
        col+=1
        diff=val-old_val
        self.updateBIT(row,col,diff)
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        #handling 1-based indexing
        row1+=1;col1+=1;row2+=1;col2+=1
        a=self.queryBIT(row2,col2)
        b=self.queryBIT(row1-1,col1-1)
        c=self.queryBIT(row2,col1-1)
        d=self.queryBIT(row1-1,col2)
        return a-c-d+b
    


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<p>自己套用之前的1d segment tree用在2d问题，可以pass。 但不是最优解。 答案用了 Fenwick Tree (Binary Index Tree)  https://www.youtube.com/watch?v=uSFzHCZ4E-8  没见过。而且最终还是用的2D版本的 Binary Index Tree。bit操作下，X，Y不影响，bit位置是bit，保存的值是partial sum。</p>
<h1 id="font-colorred309-best-time-to-buy-and-sell-stock-with-cooldown-mediumfont"><font color='red'>309. Best Time to Buy and Sell Stock with Cooldown （Medium）</font></h1>
<p>You are given an array prices where prices[i] is the price of a given stock on the ith day.<br>
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:<br>
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int: 
        
    
        &quot;&quot;&quot;
        state machine  
                  O held    -sell-&gt;  sold 
                    /\                |
                    |_ buy_ O reset &lt;-rest
       
       O is self loop
       
       DP:
         sold[i]=held[i-1]+price[i]
         held[i]=max(held[i-1],reset[i-1]-price[i])
         reset[i]=max(rest[i-1],sold[i-1])
         
         return max(reset[n],sold[n]
         &quot;&quot;&quot;
        sold, held, reset = float('-inf'), float('-inf'), 0
        for price in prices:
            pre_sold = sold
            sold = held + price               #sell operation
            held = max(held, reset - price)   #buy operation
            reset = max(reset, pre_sold)      # do nothing operation
            
        return max(sold, reset)
 
        #309 直接看答案了
        # profit on ith day kth transanction 0 means 0 stock at our hand after the end of ith day， 1 means 1 stock at our hand after the end of ith day
        #T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) #sell
        #T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])  # buy 
        #Base cases:
        # T[-1][k][0] = 0, T[-1][k][1] = -Infinity
        # T[i][0][0] = 0, T[i][0][1] = -Infinity
        #constain to cooldown
        
        T_ik0=0
        T_ik0_pre=0
        T_ik1=-float('inf')
        
        for p in prices:
            T_ik0_old=T_ik0
            T_ik0 = max(T_ik0, T_ik1+p)
            T_ik1 = max(T_ik1, T_ik0_pre-p)
            T_ik0_pre=T_ik0_old
        
        return T_ik0


</code></pre>
<p>这是一类问题，很多变种。。。。https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75924/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 答案的state machine 思维方法很有意思。</p>
<h1 id="310-minimum-height-trees-medium">310. Minimum Height Trees （Medium）</h1>
<p>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.</p>
<p>Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).</p>
<p>Return a list of all MHTs' root labels. You can return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]:
        #remove those leafves what left is root 
        
        
        dic={i:[] for i in range(n)}
        q = []
        for edge in edges:
            n1,n2=edge
            dic[n1].append(n2)
            dic[n2].append(n1)
        
        for i in range(n):
            if len(dic[i])==1:
                q.append(i)
                
        res=q
        while q:
            l=len(q)
            res=q[:]
            for _ in range(l):
                cur=q.pop(0)
                for nei in dic[cur]:
                    dic[nei].remove(cur)
                if len(dic[nei])==1:
                    q.append(nei)
        return res if res else [0]
    
</code></pre>
<p>看一下hint才做出来，思路topological sort，leaves 直接砍掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-02/">
        </link>
        <updated>2021-12-02T06:05:58.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="291-word-pattern-ii-medium">291. Word Pattern II （Medium）</h1>
<p>Given a pattern and a string s, return true if s matches the pattern.<br>
A string s matches a pattern if there is some bijective mapping of single characters to strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.</p>
<pre><code class="language-python">class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -&gt; bool:
        
        
        
        def helper(pattern,s,dic1,dic2):
            if not s: return not pattern
            if not pattern: return not s
            key = pattern[0]
            res=False
            for i in range(1,len(s)+1):
                dic1_copy=dic1.copy() 
                dic2_copy=dic2.copy()
                s_val = s[:i]
                
                #print(key,s_val)
                if key in dic1_copy and dic1_copy[key]!=s_val: 
                    res=res or False
                    continue
                else:
                    dic1_copy[key]=s_val
                
                if s_val in dic2_copy and dic2_copy[s_val]!=key: 
                    res=res or False
                    continue
                else:
                    dic2_copy[s_val]=key
                    
                s_rest = s[i:]
                res = res or helper(pattern[1:],s_rest,dic1_copy,dic2_copy)
            #if res:
            #    print(pattern,s)
            return res
        
        return helper(pattern,s,dict(),dict())
</code></pre>
<p>知道使用backtracking，但是得小心 dic1 dic2 copy问题，以及res = res or False， 既然当前s[:i] 已经是False了就skip，所以用cotinue。</p>
<h1 id="292-nim-game-easy">292. Nim Game （Easy）</h1>
<p>You are playing the following Nim Game with your friend:<br>
Initially, there is a heap of stones on the table.<br>
You and your friend will alternate taking turns, and you go first.<br>
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br>
The one who removes the last stone is the winner.</p>
<pre><code class="language-python">class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # dp [0]   [1]     [2]   [3]    [4]     [5]
        #    True   True   True  True   False  
        
        dp = [False] * (n+1)
        if n&lt;=3: return True
        dp[0]=True
        dp[1]=True
        dp[2]=True
        dp[3]=True
        for nn in range(2,n+1):
            for i_select in [1,2,3]:
                dp[nn] = dp[nn] or  (not dp[nn-i_select])
        
        #print(dp)
        return dp[n]
    
class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # 只要对方等于4个 对方必然输。
        # 我先开始，如何让对方等于4个
        # n=4 我输
        # n=5 我选1
        # n=6 我选2
        # n=7 我选3
        # n=8 我选1 不行 我选2 不行 我选3 还是不行
        # n=9 选1
        # n=10 选2
        # n=11 选3
        # n=12 都不行
        
        return  not n%4==0

</code></pre>
<p>用dp写了一个答案，但time limit exceeded。 逐渐发现规律。。。就是是否被4整除。</p>
<h1 id="293-flip-game-easy">293. Flip Game （Easy）</h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].</p>
<pre><code class="language-python">class Solution:
    def generatePossibleNextMoves(self, currentState: str) -&gt; List[str]:
        res= []
        for i in range(len(currentState)-1):
            if currentState[i]=='+' and currentState[i+1]=='+':
                res.append(currentState[:i]+'--'+currentState[i+2:])
        return res
</code></pre>
<h1 id="font-colorred294-flip-game-ii-medium-font"><font color='red'>294. Flip Game II (Medium) </font></h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return true if the starting player can guarantee a win, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    def canWin(self, currentState: str) -&gt; bool:
            return any(currentState[i:i+2] == '++' and not self.canWin(currentState[:i] + '--' + currentState[i+2:])  for i in range(len(currentState)))
#ANSWER
class Solution(object):
    _memo = {}
    def canWin(self, s):
        memo = self._memo
        if s not in memo:
            memo[s] = any(s[i:i+2] == '++' and not self.canWin(s[:i] + '--' + s[i+2:])
                          for i in range(len(s)))
        return memo[s]

#ANSWER
class Solution(object):
    def canWin(self, s):
        memo = {}
        def can(s):
            if s not in memo:
                memo[s] = any(s[i:i+2] == '++' and not can(s[:i] + '--' + s[i+2:])
                              for i in range(len(s)))
            return memo[s]
        return can(s)

</code></pre>
<p>没思路。。 。。。backtracking with mem。。。。</p>
<h1 id="font-colorred295-find-median-from-data-stream-hardfont"><font color='red'>295. Find Median from Data Stream （Hard）</font></h1>
<pre><code class="language-python">from heapq import *


class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))
        else:
            heappush(self.small, -heappushpop(self.large, num))

    def findMedian(self):
        if len(self.small) == len(self.large):
            return float(self.large[0] - self.small[0]) / 2.0
        else:
            return float(self.large[0])

</code></pre>
<p>最简单方法的是sort， 复杂点的比如答案，用了min heap。 思路： small 保存较小的，large保存较大的， 由于需要small的最大元素，minheap头是最小元素，所以push到small要反向。  large能最多比small多存一个元素。 heappushpop同时 push一个元素取出一个元素。TimeCoplex O(logn).</p>
<h1 id="296-best-meeting-point-hard">296. Best Meeting Point （Hard）</h1>
<p>Given an m x n binary grid grid where each 1 marks the home of one friend, return the minimal total travel distance.<br>
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.<br>
The distance is calculated using Manhattan Distance</p>
<pre><code class="language-python">class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -&gt; int:
        
        m=len(grid)
        n=len(grid[0])
        rows=[]
        cols=[]
        for row in range(m):
            for col in range(n):
                if grid[row][col]==1:
                    rows.append(row)
                    cols.append(col)
        
        rows = sorted(rows)
        cols = sorted(cols)
        row=rows[len(rows)//2]
        col=cols[len(cols)//2]
        
        def mindis1d(points,origin):
            distance=0
            for point in points:
                distance += abs(point-origin)
            return distance
        
        return mindis1d(rows,row)+mindis1d(cols,col)
                    

</code></pre>
<p>第一想法多次BFS。。。一次cost mn   最差情况有mn个1， 所以最差有O（mmnn）。 不可行。 答案思路：1）分解成2个1d的问题，最小值点出现在median位置。  O(mnlog⁡mn)    2）只要不sort，时间复杂度还能降低到O(mn) 。 拉出来行和列分别遍历即可。</p>
<h1 id="font-colorred-297-serialize-and-deserialize-binary-tree-hard-font"><font color='red'> 297. Serialize and Deserialize Binary Tree （Hard） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;
        res = []
        def pre(root):
            if not root:
                res.append('#')
                return  
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
         
        return '@'.join(res)
        

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        
        data = [ e.strip() for e in data.split('@')  ]
        
        def deser(data):
            if not data: return None
            if data[0]=='#':
                data.pop(0)
                return None
            
            root=TreeNode(int(data.pop(0))) 
            root.left=deser(data)
            root.right=deser(data)
            return root
        
        return deser(data)
        
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

</code></pre>
<p>有个什么儿子兄弟表示法，但忘记了。。。这个题目只用了preorder。 但要注意递归时候，传入data必须是list，这样随着递归list本身会变化，要是str会出错。</p>
<h1 id="font-colorred298-binary-tree-longest-consecutive-sequence-mediumfont"><font color='red'>298. Binary Tree Longest Consecutive Sequence （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -&gt; int:
        res=[0]
        def pre(root,parent, length):
            if not root:
                return 
            if parent and root.val==parent.val+1:
                length+=1
            else:
                length=1
            res[0]=max(res[0],length)
            pre(root.left,root,length)
            pre(root.right,root,length)
        pre(root,None,0)
        
        return res[0]
         
</code></pre>
<p>太晚了，应该能做出来，直接看答案改写。 pre order， 如果 parent+1=current ， length+=1 else length=1</p>
<h1 id="299-bulls-and-cows-medium">299. Bulls and Cows （Medium）</h1>
<pre><code class="language-python">class Solution:
    def getHint(self, secret: str, guess: str) -&gt; str:
        aaa=0
        dic1=dict()
        dic2=dict()
        for a,b in zip(secret,guess):
            if a==b:
                aaa+=1
            dic1[a]=dic1.get(a,0)+1
            dic2[b]=dic2.get(b,0)+1
        bbb=0
        for k in dic1:
            if k in dic2:
                bbb+=min(dic1[k],dic2[k])
        
        bbb=bbb-aaa
        
        return str(aaa)+'A'+str(bbb)+'B'
</code></pre>
<h1 id="font-colorblue300-longest-increasing-subsequence-medium-font"><font color='blue'>300. Longest Increasing Subsequence (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        # dp[i] means the LIS till ith number including i
        # dp[i] =  max(dp[i],dp[j]+1)   j&lt;i and nums[j]&lt;nums[i]
        if not nums: return 0
        if len(nums)==1: return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j]&lt;nums[i]:
                    dp[i]=max(dp[i],dp[j]+1)
        
        return max(dp)
</code></pre>
<p>classical DP problem O(n^2)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-01/">
        </link>
        <updated>2021-11-30T05:36:09.000Z</updated>
        <summary type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
]]></summary>
        <content type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
<!-- more -->
<h1 id="281-zigzag-iterator-medium">281. Zigzag Iterator （Medium）</h1>
<p>Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.</p>
<pre><code class="language-python">class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        li=[v1,v2]
        self.li = [[v,len(v)] for v in li if v]
        self.select = 0
    
    def next(self) -&gt; int:
        if self.li[self.select][1]&gt;0:
            self.li[self.select][1]-=1
            val= self.li[self.select][0].pop(0)
            if self.li[self.select][1]==0:
                self.li.pop(self.select)
            self.select=(self.select+1)%len(self.li) if self.li else 0
            return val
         
    def hasNext(self) -&gt; bool:
        return sum([e[1] for e in self.li])&gt;0
        
        

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
</code></pre>
<h1 id="282-expression-add-operators-hard">282. Expression Add Operators (Hard)</h1>
<p>Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.Note that operands in the returned expressions should not contain leading zeros.</p>
<pre><code class="language-python">class Solution:
    def addOperators(self, num: 'str', target: 'int') -&gt; 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append(&quot;&quot;.join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand &gt; 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
</code></pre>
<p>第一眼感觉是用backtracking，写出了第一版，但是没考虑1） number 可以是1位可以是2位，3位 etc， 2）乘法的优先级高于加减，所以需要tracking operator是什么。 3）不可以backtracking到最后eval结果，太费时间。 直接看答案了。。。答案： 关键在于除了加减乘以外，增加一个不操作operator， 12--&gt;123  是 12乘以10+3     extending 当前值12 by one digit， 12乘以10。  看了答案还是懵逼。细节太多但都符合逻辑。</p>
<h1 id="283-move-zeroes-easy">283. Move Zeroes （Easy）</h1>
<p>Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.</p>
<pre><code class="language-python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos]=n
                pos+=1
        while pos&lt;len(nums):
            nums[pos]=0
            pos+=1

#SWAP is a better solution
class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos],nums[i] = nums[i],nums[pos]
                pos+=1
     
</code></pre>
<h1 id="284-peeking-iterator-medium">284. Peeking Iterator (Medium)</h1>
<pre><code class="language-python"># Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         &quot;&quot;&quot;
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         &quot;&quot;&quot;
#
#     def hasNext(self):
#         &quot;&quot;&quot;
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         &quot;&quot;&quot;
#
#     def next(self):
#         &quot;&quot;&quot;
#         Returns the next element in the iteration.
#         :rtype: int
#         &quot;&quot;&quot;

class PeekingIterator:
    def __init__(self, iterator):
        &quot;&quot;&quot;
        Initialize your data structure here.
        :type iterator: Iterator
        &quot;&quot;&quot;
        self.iterator=iterator
        self.peekval=None

    def peek(self):
        &quot;&quot;&quot;
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval:
            return self.peekval
        else:
            self.peekval=self.iterator.next()
            return self.peekval
        

    def next(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval is not None:
            peekval=self.peekval
            self.peekval=None
            return peekval
        else:
            return self.iterator.next()
        

    def hasNext(self):
        &quot;&quot;&quot;
        :rtype: bool
        &quot;&quot;&quot;
        return self.iterator.hasNext() or self.peekval is not None
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].

</code></pre>
<h1 id="285-inorder-successor-in-bst-medium">285. Inorder Successor in BST (Medium)</h1>
<p>Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'Optional[TreeNode]':
        stack = []
        while root and root.val!=p.val:
            stack.append(root)
            if p.val&lt;root.val:
                root=root.left
            else:
                root=root.right
        
        if p.right:
            node=p.right
            while node.left:
                node=node.left
            return node
                
        else:
            while stack:
                node=stack.pop()
                if node.val&gt;p.val:
                    return node
            return None


#ANSWER
class Solution:
    
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'TreeNode':
        
        successor = None
        
        while root:
            
            if p.val &gt;= root.val:
                root = root.right
            else:
                successor = root
                root = root.left
                
        return successor

</code></pre>
<p>答案更巧妙。</p>
<h1 id="286-walls-and-gates-medium">286. Walls and Gates （Medium）</h1>
<p>You are given an m x n grid rooms initialized with these three possible values.</p>
<pre><code>-1 A wall or an obstacle.
0 A gate.
INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
</code></pre>
<p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.</p>
<pre><code class="language-python">class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        visited = set()
        while q:
            level+=1
            for _ in range(len(q)):
                i,j = q.popleft()
                visited.add((i,j))
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and (ii,jj) not in visited:
                        if rooms[ii][jj]!=0 and rooms[ii][jj]!=-1:
                            rooms[ii][jj] = level
                            q.append((ii,jj))
                            visited.add((ii,jj))

#ANSWER
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        while q:
            for _ in range(len(q)):
                i,j = q.popleft()
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and  rooms[ii][jj]==INF :
                        rooms[ii][jj] = rooms[i][j]+1
                        q.append((ii,jj))
                           
</code></pre>
<p>第一眼感觉用bfs做，从gates 处扫不是墙和gate的rooms距离。 差点忘了bfs 要for _ in range(len(queue))  .....   答案不用visited level 解决， 因为BFS所以只要INF 变成距离就是最短距离， 从什么地方变得距离？就是rooms[ii][jj] = rooms[i][j]+1</p>
<h1 id="font-colorred-287-find-the-duplicate-number-mediumfont"><font color='red'> 287. Find the Duplicate Number （Medium）</font></h1>
<p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.<br>
There is only one repeated number in nums, return this repeated number.<br>
You must solve the problem without modifying the array nums and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        for num in nums:
            cur = abs(num)
            if nums[cur] &lt; 0:
                duplicate = cur
                break
            nums[cur] = -nums[cur]

        # Restore numbers
        for i in range(len(nums)):
            nums[i] = abs(nums[i])

        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        duplicate = 0
        n = len(nums)
        bits = n.bit_length()
        for bit in range(bits):
            mask = 1 &lt;&lt; bit
            base_count = 0
            nums_count = 0
            for i in range(n):
                # If bit is set in number (i) then add 1 to base_count
                if i &amp; mask:
                    base_count += 1
                    
                # If bit is set in nums[i] then add 1 to nums_count
                if nums[i] &amp; mask:
                    nums_count += 1
                    
            # If the current bit is more frequently set in nums than it is in 
            # the range [1, 2, ..., n] then it must also be set in the duplicate number.
            if nums_count - base_count &gt; 0:
                duplicate |= mask
                
        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: 'List[int]') -&gt; 'int':
        
        low = 1
        high = len(nums)-1
        
        while low &lt; high:
            mid = low+(high-low)//2
            count = 0
            for i in nums:
                if i &lt;= mid:
                    count+=1
            if count &lt;= mid:
                low = mid+1
            else:
                high = mid
        return low

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        
        #who can think it as cycled two pointer problem?
        
        slow = nums[0]
        fast = nums[0]
        
        while True:
            slow =  nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        
        fast = nums[0]
        while slow!=fast:
            slow=nums[slow]
            fast=nums[fast]
        return slow
</code></pre>
<p>一堆double数中找single容易，用xor就可以， 但一堆single中找double。。。 答案思路： 思路1）标负。符号所在位置表示数出现过没。 nums[cur]小于0表示 cur这个数出现过。 2）bitmask 3）binary search 4）Cycle Detection，这个方法最妙。</p>
<h1 id="288-unique-word-abbreviation-medium">288. Unique Word Abbreviation （Medium）</h1>
<p>The abbreviation of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an abbreviation of itself.</p>
<pre><code class="language-python">class ValidWordAbbr:
    
    
    def __init__(self, dictionary: List[str]):
        import collections 
        self.dic= collections.defaultdict(set)
        for w in dictionary:
            key=self.sort(w)
            self.dic[key].add(w)
        #print(self.dic)
        
    def sort(self,w):
        if len(w)&lt;=2:
            key=w
        else:
            key=w[0]+str(len(w[1:-1])) +w[-1]
        return key
    
    def isUnique(self, word: str) -&gt; bool:
        key=self.sort(word)
        if key not in self.dic or (len(self.dic[key])==1 and list(self.dic[key])[0]==word):
            return True
        return False


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)

#Better solution
class ValidWordAbbr(object):
    
    def getkey(self,word):
        if len(word)&lt;=2: 
            return word
        else:
            return word[0]+str(len(word[1:-1]))+word[-1]
        
    
    def __init__(self, dictionary):
        &quot;&quot;&quot;
        :type dictionary: List[str]
        &quot;&quot;&quot;
         
        self.dic=dict()
        for word in dictionary:
            key=self.getkey(word)
            if key in self.dic and word!=self.dic[key]:
                self.dic[key]='#'
            else:
                self.dic[key]=word
        

    def isUnique(self, word):
        &quot;&quot;&quot;
        :type word: str
        :rtype: bool
        &quot;&quot;&quot;

        key=self.getkey(word)
        
        if key in self.dic and self.dic[key]==word:
            return True
        elif key not in self.dic:
            return True
        return False
</code></pre>
<h1 id="289-game-of-life-medium">289. Game of Life (Medium)</h1>
<pre><code class="language-python">class Solution:
    def gameOfLife(self, board: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        m=len(board)
        n=len(board[0])
        #solve it in-place
        #rule
        #  live cell =1
        #            #nei &lt;2      die
        #            #nei 2 or 3  live
        #            #nei &gt;3      die
        #  dead cell = 0
        #            #nei 3       live
        #
        #  save live die in next round with (X//10)%2   if live save as 10+old
        #                                               if die  save as 20+old
        #  when get old value   old = old%10
        
        for i in range(m):
            for j in range(n):
                live=0
                old=board[i][j]%10
                if old==1:
                    livecell=True
                else:
                    livecell=False
                    
                for nei in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    ii,jj=nei
                    if ii&lt;m and ii&gt;=0 and jj&lt;n and jj&gt;=0:
                        live+=board[ii][jj]%10
                
                if livecell:
                    if live==2 or live==3:
                        board[i][j]= 10+old
                    else:
                        board[i][j]= 20+old
                else:
                    if live==3:
                        board[i][j] = 10+old
                        
        for i in range(m):
            for j in range(n):
                board[i][j] = (board[i][j]//10)%2
        
#INF CASE
def gameOfLifeInfinite(self, live):
    ctr = collections.Counter((I, J)
                              for i, j in live
                              for I in range(i-1, i+2)
                              for J in range(j-1, j+2)
                              if I != i or J != j)
    return {ij
            for ij in ctr
            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}

def gameOfLife(self, board):
    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}
    live = self.gameOfLifeInfinite(live)
    for i, row in enumerate(board):
        for j in range(len(row)):
            row[j] = int((i, j) in live)
</code></pre>
<h1 id="290-word-pattern-easy">290. Word Pattern （Easy）</h1>
<pre><code class="language-python">class Solution:
    def wordPattern(self, pattern: str, s: str) -&gt; bool:
        
        dic1=dict()
        dic2=dict()
        if len(pattern)!=len(s.split()): return False
        for k,v in zip(s.split(),pattern):
            if k not in dic1:
                dic1[k]=v
            else:
                if dic1[k]!=v:
                    return False
            
            if v not in dic2:
                dic2[v]=k
            else:
                if dic2[v]!=k:
                    return False
        return True
</code></pre>
<p>注意是一一映射，所以需要2个dict检查， 注意corner case。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-30]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-30/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-30/">
        </link>
        <updated>2021-11-30T03:53:48.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="271-encode-and-decode-strings-medium">271. Encode and Decode Strings (Medium)</h1>
<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<pre><code class="language-python">class Codec:
    def encode(self, strs: [str]) -&gt; str:
        &quot;&quot;&quot;Encodes a list of strings to a single string.
        &quot;&quot;&quot;
        candidate='a'
        set_ = set()
        for str in strs:
            for s in str:
                set_.add(s)
        while candidate in set_:
            candidate = chr(ord(candidate)+1)
        return candidate + candidate.join(strs)
        

    def decode(self, s: str) -&gt; [str]:
        &quot;&quot;&quot;Decodes a single string to a list of strings.
        &quot;&quot;&quot;
        candidate = s[0]
        s = s[1:]
        return s.split(candidate)
        


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))
</code></pre>
<h1 id="font-colorblue272-closest-binary-search-tree-value-ii-hard-font"><font color='blue'>272. Closest Binary Search Tree Value II (Hard) </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -&gt; List[int]:
        stack  = []
        s  =[]
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            root=stack.pop()
            diff = abs(root.val-target)
            if len(s)&lt;k:
                s.append((diff,root.val))
            else:
                s.sort(key=lambda x:x[0])
                if s and s[-1][0]&gt;diff:
                    s.pop()
                    s.append((diff,root.val))
                    s.sort(key=lambda x:x[0])
            
            root=root.right
        
        return [e[1] for e in s]

#ANSWER 1 Recursive Inorder + Sort, O(N log N) time
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        nums = inorder(root)
        nums.sort(key = lambda x: abs(x - target))
        return nums[:k]

#ANSWER 2 
from heapq import heappush, heappop
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            if not r:
                return
            
            inorder(r.left)
            heappush(heap, (- abs(r.val - target), r.val))
            if len(heap) &gt; k:
                heappop(heap)
            inorder(r.right) 
    
        heap = []
        inorder(root)
        return [x for _, x in heap]

#ANSWER 3 QuickSelect, O(N) time.
class Solution:
    def closestKValues(self, root: TreeNode, target: float, k: int) -&gt; List[int]:
        def inorder(r: TreeNode):
            return inorder(r.left) + [r.val] + inorder(r.right) if r else []
        
        def partition(pivot_idx, left, right):
            pivot_dist = dist(pivot_idx)
            
            # 1. move pivot to end
            nums[right], nums[pivot_idx] = nums[pivot_idx], nums[right]
            store_idx = left
            
            # 2. move more close elements to the left
            for i in range(left, right):
                if dist(i) &lt; pivot_dist:
                    nums[i], nums[store_idx] = nums[store_idx], nums[i]
                    store_idx += 1
                    
            # 3. move pivot to its final place
            nums[right], nums[store_idx] = nums[store_idx], nums[right]
            
            return store_idx
            
        def quickselect(left, right):
            &quot;&quot;&quot;
            Sort a list within left..right till kth less close element
            takes its place.
            &quot;&quot;&quot;
            # base case: the list contains only one element
            if left == right:
                return 
            
            # select a random pivot_index
            pivot_idx = randint(left, right)
            
            # find the pivot position in a sorted list
            true_idx = partition(pivot_idx, left, right)
            
            # if the pivot is in its final sorted position
            if true_idx == k:
                return
            
            if true_idx &lt; k:
                # go left
                quickselect(true_idx, right)
            else:
                # go right
                quickselect(left, true_idx)
        
        nums = inorder(root)
        dist = lambda idx : abs(nums[idx] - target)
        quickselect(0, len(nums) - 1)
        return nums[:k]
</code></pre>
<p>虽然做出来了，但是感觉用minheap会更好。我的方法得一直sort，时间复杂度太高。  需要记住 from heapq import heappush，heappop 用法 heappush（heap，val） heappop（heap） 每次pop出来的是最小的元素。  O（n）方法用到了快排。</p>
<h1 id="273-integer-to-english-words-hard">273. Integer to English Words （Hard）</h1>
<p>Convert a non-negative integer num to its English words representation.</p>
<pre><code class="language-python">class Solution:
    def numberToWords(self, num: int) -&gt; str:
      
        nums = []
      
        if num==0: nums.append(0)
        while num:
            nums.append(num%1000)
            num//=1000
        
    
        res = []
        l=len(nums)
        dic = {0:'',1:'Thousand',2:'Million',3:'Billion',4:'Trillion'}
        def helper(n):
            if type(n)==str: return ''
            s  = ''
            dic = {0:'Zero',1:'One',2:'Two',3:'Three',4:'Four',5:'Five',6:'Six',7:'Seven',8:'Eight',9:'Nine',10:'Ten',11:'Eleven',12:'Twelve',13:'Thirteen',14:'Fourteen',15:'Fifteen',16:'Sixteen',17:'Seventeen',18:'Eighteen',19:'Nineteen',20:'Twenty',30:'Thirty',40:'Forty',50:'Fifty',60:'Sixty',70:'Seventy',80:'Eighty',90:'Ninety'}
            
            if n&lt;10: return dic[n]
            if n&gt;99:
                s+= dic[n//100]+' Hundred'
            n = n%100
            if n==0: return s
            if n in dic:
                s+= ' '+dic[n]
                return s
            else:
                s+=' '+dic[10*(n//10)]
                n=n%10
                if n==0:
                    return s
                else:
                    s+= ' '+ dic[n]
                    return s
       
        tmp=[]
        while nums:
            if nums[0]==0:
                nums.pop(0)
                tmp.append('#')
            else:
                tmp.append(nums.pop(0))

        nums=tmp
        if nums==['#']:
            nums=[0]
        for i,number in enumerate(nums):
            if number!='#':
                res.append(helper(number)+ ' ' + dic[i])
        return ' '.join([ e.strip() for e in res[::-1] if e.strip()])
#ANSWER
class Solution:
    def numberToWords(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: str
        &quot;&quot;&quot;
        def one(num):
            switcher = {
                1: 'One',
                2: 'Two',
                3: 'Three',
                4: 'Four',
                5: 'Five',
                6: 'Six',
                7: 'Seven',
                8: 'Eight',
                9: 'Nine'
            }
            return switcher.get(num)

        def two_less_20(num):
            switcher = {
                10: 'Ten',
                11: 'Eleven',
                12: 'Twelve',
                13: 'Thirteen',
                14: 'Fourteen',
                15: 'Fifteen',
                16: 'Sixteen',
                17: 'Seventeen',
                18: 'Eighteen',
                19: 'Nineteen'
            }
            return switcher.get(num)
        
        def ten(num):
            switcher = {
                2: 'Twenty',
                3: 'Thirty',
                4: 'Forty',
                5: 'Fifty',
                6: 'Sixty',
                7: 'Seventy',
                8: 'Eighty',
                9: 'Ninety'
            }
            return switcher.get(num)
        

        def two(num):
            if not num:
                return ''
            elif num &lt; 10:
                return one(num)
            elif num &lt; 20:
                return two_less_20(num)
            else:
                tenner = num // 10
                rest = num - tenner * 10
                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)
        
        def three(num):
            hundred = num // 100
            rest = num - hundred * 100
            if hundred and rest:
                return one(hundred) + ' Hundred ' + two(rest) 
            elif not hundred and rest: 
                return two(rest)
            elif hundred and not rest:
                return one(hundred) + ' Hundred'
        
        billion = num // 1000000000
        million = (num - billion * 1000000000) // 1000000
        thousand = (num - billion * 1000000000 - million * 1000000) // 1000
        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000
        
        if not num:
            return 'Zero'
        
        result = ''
        if billion:        
            result = three(billion) + ' Billion'
        if million:
            result += ' ' if result else ''    
            result += three(million) + ' Million'
        if thousand:
            result += ' ' if result else ''
            result += three(thousand) + ' Thousand'
        if rest:
            result += ' ' if result else ''
            result += three(rest)
        return result

</code></pre>
<p>corner case 有点太多了。。。写出来是写出来了。</p>
<h1 id="274-h-index-medium">274. H-Index （Medium）</h1>
<p>Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        # [1,3,1]
        # 
        #  0 1 2 3
        # []
        
        dp = [0]*(len(citations)+1)
        for c in citations:
            if c&gt;len(citations):
                c=len(citations)
            dp[c]+=1
        
        for i in range(len(dp)-2,-1,-1):
            dp[i]=dp[i]+dp[i+1]
        
        hindex=[]
        print(dp)
        for ind, n in enumerate(dp):
            if n&gt;=ind:
                hindex.append(ind)
        
        return max(hindex)

#ANSWER reverse SORT
class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
    
        citations.sort(reverse=True)
        print(citations)
        hindex=0
        for ind, cit in enumerate(citations):
            hindex_candidate = ind+1
            if cit&gt;=hindex_candidate:
                hindex = hindex_candidate
                
        return hindex

</code></pre>
<h1 id="font-colorblue275-h-index-ii-medium-font"><font color='blue'>275. H-Index II (Medium) </font></h1>
<p>sorted citations O(lgn) time to solve</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        # already sorterd so binary search
        
        #hindex=0
        #for idx in range(len(citations)-1,-1,-1):
        #    cit = citations[idx]
        #    hidx =  len(citations)-idx 
        #    if cit&gt;=hidx:
        #        hindex=hidx
        # 
        #return hindex
        
        l=0
        r=len(citations)-1
        res = [0]
        while l&lt;=r:
            m=(l+r)//2
            
            cit=citations[m]
            hidx=len(citations)-m
            if cit&gt;=hidx:
                res.append(hidx)
                r=m-1
            else:
                l=m+1
        
        return max(res)

#ANSWER
class Solution:
    def hIndex(self, citations):
        &quot;&quot;&quot;
        :type citations: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(citations)
        for idx, c in enumerate(citations):
            if c &gt;= n - idx:
                return n - idx
        return 0
#binary serach
class Solution:
    def hIndex(self, citations):
        &quot;&quot;&quot;
        :type citations: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(citations)
        left, right = 0, n - 1

        # We need to find the rightmost 'index' such that: (citations[index] &lt;= n - index)
        while left &lt;= right:
            mid = left + (right - left) // 2

            # There's (n - mid) papers with an equal or higher citation count than citations[mid]
            # If (citations[mid] == n - mid) it's the optimal result and can be returned right away
            if citations[mid] == n - mid:
                return n - mid

            # If citations[mid] is less than (n - mid), narrow down on the right half to look for a paper
            # at a future index that meets the h-index criteria. Otherwise, narrow down on the left half
            if citations[mid] &lt; n - mid:
                left = mid + 1
            else:
                right = mid - 1

        # We didn't find an exact match, so there's exactly (n - left) papers that have citations
        # greater than or equal to citations[left] and that is our answer
        return n - left
</code></pre>
<p>虽然做出来了，但是还是不熟。</p>
<h1 id="font-colorred276-paint-fence-medium-font"><font color='red'>276. Paint Fence (Medium) </font></h1>
<p>You are painting a fence of n posts with k different colors. You must paint the posts following these rules:<br>
Every post must be painted exactly one color.<br>
There cannot be three or more consecutive posts with the same color.<br>
Given the two integers n and k, return the number of ways you can paint the fence.</p>
<pre><code class="language-python">class Solution:
    def numWays(self, n: int, k: int) -&gt; int:
        # dp    
        # n = 0    0  
        # n = 1    k
        # n = 2    k*k    
        # n = 3    diff color  (k-1)*dp[i-1]   same color 1*  (k-1)*dp[i-2]  
        # so, dp[i] = (k-1)dp[i-1]+(k-1)*dp[i-2]
        
        if n==1:
            return k
        if n==2:
            return k*k
        dp=[0]*(n+1)
        dp[1]=k
        dp[2]=k*k
        for i in range(3,n+1):
            dp[i] = (k-1)*(dp[i-1]+dp[i-2])
        
        return dp[n]
</code></pre>
<p>感觉是DP，递推关系是？ 已经想到了，但是没仔细去想。 当前颜色和前一个相同， 当前颜色和前一个不同。</p>
<h1 id="font-colorred-277-find-the-celebrity-mediumfont"><font color='red'> 277. Find the Celebrity （Medium）</font></h1>
<pre><code class="language-python">
class Solution:
    def findCelebrity(self, n: int) -&gt; int:
        self.n = n
        celebrity_candidate = 0
        for i in range(1, n):
            if knows(celebrity_candidate, i):
                celebrity_candidate = i
        if self.is_celebrity(celebrity_candidate):
            return celebrity_candidate
        return -1

    def is_celebrity(self, i):
        for j in range(self.n):
            if i == j: continue
            if knows(i, j) or not knows(j, i):
                return False
        return True
</code></pre>
<p>答案找possible candidate O（n）时间的方法第一次没想出来。。。</p>
<h1 id="278-first-bad-version-easy">278. First Bad Version （Easy）</h1>
<p>Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<pre><code class="language-python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if isBadVersion(m):
                r=m-1
            else:
                l=m+1
        return l

</code></pre>
<h1 id="font-colorred279-perfect-squares-medium-font"><font color='red'>279. Perfect Squares (Medium) </font></h1>
<p>Given an integer n, return the least number of perfect square numbers that sum to n.</p>
<pre><code class="language-python">class Solution:
    def numSquares(self, n: int) -&gt; int:
        #dp   1 2  3  4  5  6  7  8
        #     1 2  3  1  2  3  4  2
        if n&lt;=3: return n
        def is_sqrt(num):
            for i in range(1,num//2+1):
                if i*i==num:
                    return True
            return False
        dp = [float('inf')]*(n+1)
        dp[0]=0
        dp[1]=1
        dp[2]=2
        dp[3]=3
        for i in range(4,n+1):
            if is_sqrt(i):
                dp[i]=1
            else:
                for ii in range(1,i//2+1):
                    dp[i]=min(dp[i],dp[ii]+dp[i-ii])
        
        print(dp)
        return dp[n]

#ANSWER O（n*sqrt（n））
class Solution(object):
    def numSquares(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        # bottom case
        dp[0] = 0
        
        for i in range(1, n+1):
            for square in square_nums:
                if i &lt; square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
</code></pre>
<p>第一次整了个time limit exceeded。 思路类似,答案pre calculate square_nums  省了很多时间也不用判断是否为完全平方数。</p>
<h1 id="font-colorred280-wiggle-sort-mediumfont"><font color='red'>280. Wiggle Sort （Medium）</font></h1>
<p>Given an integer array nums, reorder it such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]....<br>
You may assume the input array always has a valid answer.</p>
<pre><code class="language-python">class Solution:
    def wiggleSort(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        nums.sort()
        for i in range(1,len(nums)-1,2):
            nums[i],nums[i+1]=nums[i+1],nums[i]

#ANSWER
class Solution:
    def wiggleSort(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        less=True
        for i in range(len(nums)-1):
            if less:
                if nums[i]&gt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            else:
                if nums[i]&lt;nums[i+1]:
                    nums[i],nums[i+1]=nums[i+1],nums[i]
            
            less=not less
</code></pre>
<p>too late today。  思路1  sort first， 从第二个元素开始swap。 思路2，如果顺序不正确就纠正。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-29]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-29/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-29/">
        </link>
        <updated>2021-11-29T11:15:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue261-graph-valid-tree-mediumfont"><font color='blue'>261. Graph Valid Tree （Medium）</font></h1>
<p>You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.<br>
Return true if the edges of the given graph make up a valid tree, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent = [None]*n
            self.rank = [0]*n
            for i in range(n):
                self.parent[i]=i
                
        def find(self,i):
            if self.parent[i]!=i:
                self.parent[i]=self.find(self.parent[i])
            return self.parent[i]
        
        def union(self,x,y):
            rootx=self.find(x)
            rooty=self.find(y)
            if rootx!=rooty:
                if self.rank[rootx]&gt;self.rank[rooty]:
                    self.parent[rooty]=rootx
                elif self.rank[rootx]&lt;self.rank[rooty]:
                    self.parent[rootx]=rooty
                else:
                    self.parent[rooty]=rootx
                    self.rank[rootx]+=1
                
    
        
    def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
        #UNIONFIND
        uf =self.UnionFind(n)
        for (a,b) in edges:
            uf.union(a,b)
        
        if len(set( [uf.find(i) for i in range(n)]))!=1:
            return False
    
        return len(edges)==n-1

#answer DFS
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    stack = [0]
    
    while stack:
        node = stack.pop()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            stack.append(neighbour)
    
    return len(seen) == n
#answer 
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = set()

    def dfs(node):
        if node in seen: return
        seen.add(node)
        for neighbour in adj_list[node]:
            dfs(neighbour)

    dfs(0)
    return len(seen) == n

#answer
def validTree(self, n: int, edges: List[List[int]]) -&gt; bool:
    
    if len(edges) != n - 1: return False
    
    # Create an adjacency list.
    adj_list = [[] for _ in range(n)]
    for A, B in edges:
        adj_list[A].append(B)
        adj_list[B].append(A)
    
    # We still need a seen set to prevent our code from infinite
    # looping if there *is* cycles (and on the trivial cycles!)
    seen = {0}
    queue = collections.deque([0])
    
    while queue:
        node = queue.popleft()
        for neighbour in adj_list[node]:
            if neighbour in seen:
                continue
            seen.add(neighbour)
            queue.append(neighbour)
    
    return len(seen) == n
</code></pre>
<p>猜到了使用UnionFind做，但是还是copy了UnionFind Class 代码，还没熟练到自己写出来。 思路很简单，union后同一个parent，#edges+1=#node      答案思路：DFS或者BFS  判断是树1）n-1 edges， 2）graph fully connected。</p>
<h1 id="262-trips-and-users-hard">262. Trips and Users （Hard）</h1>
<pre><code class="language-SQL"># Write your MySQL query statement below
select   request_at as 'Day', round(sum(counter)/sum(total),2) as 'Cancellation Rate' from (
select CASE WHEN Trips.status='completed' THEN 0 else 1 END as counter, 1 as total, Trips.request_at  from
Trips left join Users c on Trips.client_id=c.users_id left join Users d on Trips.driver_id=d.users_id where c.banned!='Yes' and d.banned!='Yes'
) tmp  where Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot; group by request_at

#ANSWER 
SELECT Request_at as Day,
ROUND(SUM(CASE WHEN Status!=&quot;completed&quot; THEN 1 ELSE 0 END)/COUNT(*),2) as &quot;Cancellation Rate&quot; 
FROM Trips
WHERE Client_Id NOT IN
(
    SELECT Users_Id FROM Users
    WHERE Banned=&quot;Yes&quot;
)
AND Request_at&gt;=&quot;2013-10-01&quot; AND Request_at&lt;=&quot;2013-10-03&quot;
GROUP BY Request_at;
</code></pre>
<h1 id="263-ugly-number-easy">263. Ugly Number (Easy)</h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return true if n is an ugly number.</p>
<pre><code class="language-python">class Solution:
    def isUgly(self, n: int) -&gt; bool:
        if n==0: return False
        if n==1: return True
        
        while n%2==0:
            n//=2
        if n==1: return True
        while n%3==0:
            n//=3
        if n==1: return True
        while n%5==0:
            n//=5
        if n==1: return True
        
        return False

</code></pre>
<h1 id="font-colorred264-ugly-number-ii-medium-font"><font color='red'>264. Ugly Number II (Medium) </font></h1>
<p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.<br>
Given an integer n, return the nth ugly number.</p>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [0] * n
        t2 = t3 = t5 = 0
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
            if(dp[i] == dp[t2]*2): t2 += 1
            if(dp[i] == dp[t3]*3): t3 += 1
            if(dp[i] == dp[t5]*5): t5 += 1
        return dp[-1]

</code></pre>
<p>没思路 。。。或者知道思路但写不出代码。  要是添加2倍，3倍，4倍，5倍还是会有空隙当n很大时候。 答案，用了dynamic programming。 思路是多个pointer。 t2，t3，t5记录已经遍历的数字里2，3，5都有多少个。 关键点是找到下一个最小的ugly number当乘以2，3，5时候。 又因为已经存在的数字只能被2，3，5乘1次，所以可以用pointer保持下次2，3，5要乘以的位置。</p>
<h1 id="265-paint-house-ii-hard">265. Paint House II （Hard）</h1>
<p>There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br>
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.</p>
<pre><code class="language-python">class Solution:
    def minCostII(self, costs: List[List[int]]) -&gt; int:
        #  cost last =     [a1,a2,a3,a4]
        #  cost last-1 =   [a1'+min(a2,a3,a4),a2'+min(a1,a3,a4),...]
        #  ...
        #  cost  0     =    [a1''',a2'''....]
        # ans= min(cost0)
        for i in range(len(costs)-2,-1,-1):
            for ii in range(len(costs[0])):
                costs[i][ii] = costs[i][ii]+min([costs[i+1][jj] for jj in range(len(costs[0])) if jj!=ii])
        
        return min(costs[0])
</code></pre>
<h1 id="266-palindrome-permutation-easy">266. Palindrome Permutation (Easy)</h1>
<p>Given a string s, return true if a permutation of the string could form a palindrome.</p>
<pre><code class="language-python">class Solution:
    def canPermutePalindrome(self, s: str) -&gt; bool:
        #odd occurance can not &gt;1
        dic = collections.Counter(s)
        c=0
        for k,v in dic.items():
            if v%2==1:
                c+=1
            if c&gt;1:
                return False
        return True
</code></pre>
<h1 id="267-palindrome-permutation-ii-medium">267. Palindrome Permutation II (Medium)</h1>
<pre><code class="language-python">class Solution:
    def generatePalindromes(self, s: str) -&gt; List[str]:
        dic = collections.Counter(s)
        c = 0
        odd_char = ''
        odd_c = 0
        for k,v in dic.items():
            if v%2==1:
                c+=1
                odd_char = k
                odd_c = v
        if c&gt;1: return []
        if len(dic)==1:
            return [list(dic.keys())[0]*dic[list(dic.keys())[0]]]
        if odd_char:
            tmp=odd_char
            dic[odd_char]-=1
            if dic[odd_char]&lt;=0:
                del dic[odd_char]
                 
        res = []
        def bt(dic,tmp):
            if len(tmp)==len(s):
                res.append(tmp)
                return
            
            for k,v in dic.items():
                dic_copy = dic.copy()
                tmp = k+tmp+k
                dic_copy[k]-=2
                if dic_copy[k]==0:
                    del dic_copy[k]
                #print(tmp,dic_copy)
                bt(dic_copy,tmp)
                tmp=tmp[1:-1]

            
        bt(dic,odd_char)
        return  res
</code></pre>
<p>backtracking 分为odd 元素存在时候，中间位置只能是odd元素，然后从中间向两边扩展。</p>
<h1 id="268-missing-number-easy">268. Missing Number （Easy）</h1>
<p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>
<pre><code class="language-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n=len(nums)
        return (0+n)*(n+1)//2 - sum(nums)
</code></pre>
<h1 id="font-colorred269-alien-dictionary-hard-font"><font color='red'>269. Alien Dictionary (Hard) </font></h1>
<p>There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.<br>
You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.<br>
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return &quot;&quot;. If there are multiple solutions, return any of them.<br>
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length &lt; t.length.<br>
Input: words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]<br>
Output: &quot;wertf&quot;</p>
<pre><code class="language-python">class Solution:
     
    
    from collections import defaultdict, Counter, deque

    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: create data structures + the in_degree of each unique letter to 0.
        adj_list = defaultdict(set)
        in_degree = Counter({c : 0 for word in words for c in word})

        # Step 1: We need to populate adj_list and in_degree.
        # For each pair of adjacent words...
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d:
                    if d not in adj_list[c]:
                        adj_list[c].add(d)
                        in_degree[d] += 1
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): return &quot;&quot;

        # Step 2: We need to repeatedly pick off nodes with an indegree of 0.
        output = []
        queue = deque([c for c in in_degree if in_degree[c] == 0])
        while queue:
            c = queue.popleft()
            output.append(c)
            for d in adj_list[c]:
                in_degree[d] -= 1
                if in_degree[d] == 0:
                    queue.append(d)

        # If not all letters are in output, that means there was a cycle and so
        # no valid ordering. Return &quot;&quot; as per the problem description.
        if len(output) &lt; len(in_degree):
            return &quot;&quot;
        # Otherwise, convert the ordering we found into a string and return it.
        return &quot;&quot;.join(output)

#DFS topo sorter reverse adj list and using grey black for node color

class Solution:
    def alienOrder(self, words: List[str]) -&gt; str:

        # Step 0: Put all unique letters into the adj list.
        reverse_adj_list = {c : [] for word in words for c in word}

        # Step 1: Find all edges and put them in reverse_adj_list.
        for first_word, second_word in zip(words, words[1:]):
            for c, d in zip(first_word, second_word):
                if c != d: 
                    reverse_adj_list[d].append(c)
                    break
            else: # Check that second word isn't a prefix of first word.
                if len(second_word) &lt; len(first_word): 
                    return &quot;&quot;

        # Step 2: Depth-first search.
        seen = {} # False = grey, True = black.
        output = []
        def visit(node):  # Return True iff there are no cycles.
            if node in seen:
                return seen[node] # If this node was grey (False), a cycle was detected.
            seen[node] = False # Mark node as grey.
            for next_node in reverse_adj_list[node]:
                result = visit(next_node)
                if not result: 
                    return False # Cycle was detected lower down.
            seen[node] = True # Mark node as black.
            output.append(node)
            return True

        if not all(visit(node) for node in reverse_adj_list):
            return &quot;&quot;

        return &quot;&quot;.join(output)


</code></pre>
<p>很明显图论相关的题，没复习到还，看答案。思路：1）找到dependence rules， 2）topological sort。用queue来存indegree=0的node，然后遍历neighbors。或者DFS，revse adj list 然后为了防止有环，需要标注node color white grey black。</p>
<pre><code class="language-python">for item in container:
    if search_something(item):
        # Found it!
        process(item)
        break
else:
    # Didn't find anything..
    not_found_in_container()

</code></pre>
<p>这个语法从来没见过，for后面可以带一个else表明for loop中没有break的条件，else 来执行后续操作。</p>
<h1 id="270-closest-binary-search-tree-value-easy">270. Closest Binary Search Tree Value （Easy）</h1>
<p>Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -&gt; int:
        if not root.left and not root.right: return root.val
        if not root.right:
            if target&lt;root.val:
                res=self.closestValue(root.left,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        if not root.left:
            if target&gt;root.val:
                res = self.closestValue(root.right,target)
                return res if abs(target-res)&lt;abs(root.val-target) else root.val
            else:
                return root.val
        
        if target==root.val:
            return root.val
        elif target&lt;root.val:
            res = self.closestValue(root.left,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val
        else:
            res= self.closestValue(root.right,target)
            return res if abs(target-res)&lt;abs(root.val-target) else root.val

#ANSWER
class Solution:
    def closestValue(self, root: TreeNode, target: float) -&gt; int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            root = root.left if target &lt; root.val else root.right
        return closest
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-11-28]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-11-28/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-11-28/">
        </link>
        <updated>2021-11-27T20:14:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="251-flatten-2d-vector-medium">251. Flatten 2D Vector (Medium)</h1>
<p>Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.<br>
Implement the Vector2D class:<br>
Vector2D(int[][] vec) initializes the object with the 2D vector vec.<br>
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.<br>
hasNext() returns true if there are still some elements in the vector, and false otherwise.</p>
<pre><code class="language-python">class Vector2D:

    def __init__(self, vec: List[List[int]]):
        self.stack=[]
        self.vec=vec

    def next(self) -&gt; int:
        if self.hasNext():
            val=self.stack.pop(0)
        return val

    def hasNext(self) -&gt; bool:
        if not self.stack:
            if not self.vec:
                return False
            row=self.vec.pop(0)
            if not row: 
                if self.hasNext():
                    return True
                else:
                    return False
            for e in row:
                self.stack.append(e)
        return True


# Your Vector2D object will be instantiated and called as such:
# obj = Vector2D(vec)
# param_1 = obj.next()
# param_2 = obj.hasNext()
#answer way of writing
class Vector2D:

    def __init__(self, v: List[List[int]]):
        # We need to iterate over the 2D vector, getting all the integers
        # out of it and putting them into the nums list.
         
        self.nums = []
        for inner_list in v:
            for num in inner_list:
                self.nums.append(num)
        # We'll keep position 1 behind the next number to return.
        self.position = -1

    def next(self) -&gt; int:
        # Move up to the current element and return it.
        self.position += 1
        return self.nums[self.position]

    def hasNext(self) -&gt; bool:
        # If the next position is a valid index of nums, return True.
        return self.position + 1 &lt; len(self.nums)

</code></pre>
<p>自己写的这个递归调用比较tricky。。。答案很简答。</p>
<h1 id="252-meeting-rooms-easy">252. Meeting Rooms （Easy）</h1>
<p>Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.</p>
<pre><code class="language-python">class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool:
        intervals=sorted(intervals,key=lambda x:x[0])
        pre_end = None
        for interval in intervals:
            if pre_end is not None and interval[0]&lt;pre_end:
                return False
            pre_end = interval[1]
        return True
</code></pre>
<h1 id="font-colorblue253-meeting-rooms-ii-medium-font"><font color='blue'>253. Meeting Rooms II (Medium) </font></h1>
<p>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</p>
<pre><code class="language-python">class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:
        #find max overlapping interval num
        res=1
        c=0
        #at start +=1 at end -=1
        dic=dict()
        for interval in intervals:
            start,end=interval[0],interval[1]
            if start in dic:
                dic[start]+=1
            else:
                dic[start]=1
            
            if end in dic:
                dic[end]-=1
            else:
                dic[end]=-1
        
        for k in sorted(dic.keys()):
            c+=dic[k]
            res=max(res,c)
        return res
</code></pre>
<p>虽然做出来了，感觉下次再做可能会忘记怎么做的， 思路： 把所有时节节点从小到大排序，如果是start， counter+=1 如果是end， counter-=1， 找出counter变化过程中最大值。 答案做的感觉没自己的思路简单。</p>
<h1 id="font-colorred-254-factor-combinations-mediumfont"><font color='red'> 254. Factor Combinations （Medium）</font></h1>
<p>Numbers can be regarded as the product of their factors.</p>
<pre><code>For example, 8 = 2 x 2 x 2 = 2 x 4.
</code></pre>
<p>Given an integer n, return all possible combinations of its factors. You may return the answer in any order.</p>
<p>Note that the factors should be in the range [2, n - 1].</p>
<pre><code class="language-python">#Iterative:

def getFactors(self, n):
    todo, combis = [(n, 2, [])], []
    while todo:
        n, i, combi = todo.pop()
        while i * i &lt;= n:
            if n % i == 0:
                combis += combi + [i, n/i],
                todo += (n/i, i, combi+[i]),
            i += 1
    return combis

#Recursive:

class Solution:
    def getFactors(self, n: int) -&gt; List[List[int]]:
        
        res=[]
        def factor(n, i, tmp):
            while i * i &lt;= n:
                if n % i == 0:
                    res.append(tmp + [i, n//i])
                    factor(n//i, i, tmp+[i])
                i += 1
        factor(n, 2, [])
        return res

</code></pre>
<p>思路类似，但是还是没写粗来，这个不应该， res 先append  tmp+[i,n//i],然后再factor（n//i， i，tmp+【i】，res）</p>
<h1 id="font-colorred255-verify-preorder-sequence-in-binary-search-tree-mediumfont"><font color='red'>255. Verify Preorder Sequence in Binary Search Tree （Medium）</font></h1>
<pre><code class="language-python">def verifyPreorder(self, preorder):
    stack = []
    low = float('-inf')
    for p in preorder:
        if p &lt; low:
            return False
        while stack and p &gt; stack[-1]:
            low = stack.pop()
        stack.append(p)
    return True
</code></pre>
<p>没思路，答案思路： 模拟traversal，stack是左子树的栈。 如果下一个数小于栈顶，说明还在左子树，所以append。  如果当前preorder值大于栈顶，所有小于当前值元素出栈。说明当前元素跳到了右子树。low=stack.pop() 很巧妙， lower bound是满足小于当前值的最后一个pop出去的元素。</p>
<h1 id="font-colorred256-paint-house-mediumfont"><font color='red'>256. Paint House （Medium）</font></h1>
<p>Input: costs = [[17,2,17],[16,16,5],[14,3,19]]<br>
Output: 10<br>
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>
Minimum cost: 2 + 5 + 3 = 10.</p>
<pre><code class="language-python">class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        mem=dict()
        def paint(n,color):
            if (n,color) in mem:
                return mem[(n,color)]
            res = costs[n][color]
            
            if n!=len(costs)-1:
                if color==0:
                    res+=min(paint(n+1,1),paint(n+1,2))
                elif color==1:
                    res+=min(paint(n+1,0),paint(n+1,2))
                else:
                    res+=min(paint(n+1,0),paint(n+1,1))
            mem[(n,color)]=res
            return res
       
        return min([paint(0,0),paint(0,1),paint(0,2)])

#
class Solution:
    def minCost(self, costs: List[List[int]]) -&gt; int:
        if not costs:return 0
        for n in range(len(costs)-2,-1,-1):
            costs[n][0]+=min(costs[n+1][1],costs[n+1][2])
            costs[n][1]+=min(costs[n+1][0],costs[n+1][2])
            costs[n][2]+=min(costs[n+1][0],costs[n+1][1])
        return min(costs[0])
</code></pre>
<p>这个应该是递归mem的经典题和dp的经典题。用dynamic programming，但是写出来一版是错的。。。应该定义dp=【#costs】【#color】。从最后一个房子开始， 倒数第二个 cost红=最后一个min（绿，蓝），。。。</p>
<h1 id="257-binary-tree-paths-easy">257. Binary Tree Paths （Easy）</h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:
        res=[]
        def bt(tmp,node):
            if not node: return
            if not node.left and not node.right:
                tmp.append(str(node.val))
                res.append('-&gt;'.join(tmp))
                return
            tmp.append(str(node.val))
            bt(tmp[:],node.left)
            bt(tmp[:],node.right)
        bt([],root)
        return res
</code></pre>
<h1 id="258-add-digits-easy">258. Add Digits (Easy)</h1>
<pre><code class="language-python">class Solution:
    def addDigits(self, num: int) -&gt; int:
        res = 0
        while num:
            #
            tmp=0
            while num:
                lastdig = num%10
                num=num//10
                tmp+=lastdig
            num=tmp
            if num&gt;=0 and num&lt;=9:
                return num
        
        return res 
# answer way of writing
class Solution:
    def addDigits(self, num: int) -&gt; int:
        if num == 0:
            return 0
        if num % 9 == 0:
            return 9
        return num % 9
</code></pre>
<p>答案用了一个数能被九整除，那么他们所有位数和能被9整除。</p>
<h1 id="font-colorblue259-3sum-smaller-mediumfont"><font color='blue'>259. 3Sum Smaller （Medium）</font></h1>
<p>Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<pre><code class="language-python">class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            for left in range(start+1,len(nums)-1):
                right=left+1
                if nums[start]+nums[left]+nums[right]&gt;target:continue
                
                while  right&lt;len(nums) and nums[start]+nums[left]+nums[right]&lt;target:
                    res+=1
                    right+=1
                
               
        return res

#answer
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        res=0
        for start in range(len(nums)-2):
            tar = target-nums[start]
            #become two sum question
            left=start+1
            right=len(nums)-1
            while left&lt;right:
                #print('@',left,right,tar)
                if nums[left]+nums[right]&lt;tar:
                    #print(left,right)
                    res+=right-left
                    left+=1
                else:
                    right-=1
            
        return res
</code></pre>
<p>写出来个暴力解。。。 几乎是O(n^3)....  O（n^2）思路, 选出一个数字，把3sum转成2sum，然后定义left=start+1，right=len（nums）-1， 若left +right 值小于target 说明 left 到right所有都满足条件，这样left+1求解下一步， 若left +right 值大于target说明right太大得减1.</p>
<h1 id="font-colorred260-single-number-iii-mediumfont"><font color='red'>260. Single Number III （Medium）</font></h1>
<p>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.</p>
<p>You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xor=0
        for n in nums:
            xor = xor^n
        
        # rightmost 1-bit diff between a and b
        diff = xor &amp; -xor
        
        a=0
        for n in nums:
            if n&amp;diff:
                # diff means a's last bit is diff then b's last bit
                # by using this filter we could get a 
                a= a^n
        return [a,xor^a]

</code></pre>
<p>没思路， one pass 只能找出xor=a^b  但不能确定出a，b具体值。<br>
答案思路：用了一个不知道的trick， x &amp; (-x) 保留x中最右边bit，设置其他bit为0.   这样就能用a，b 的diff bit把所有数字过滤一次，只有a可以被过滤出来，因为a的diff bit是1 其余diff bit是1的都出现了2次抵消了。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[书单]]></title>
        <id>https://headhuanglan.github.io/post/shu-dan/</id>
        <link href="https://headhuanglan.github.io/post/shu-dan/">
        </link>
        <updated>2021-11-27T06:31:55.000Z</updated>
        <summary type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
]]></summary>
        <content type="html"><![CDATA[<p>半小时漫画系列经济和历史不错，虽然历史从来没学好，但也可能是吸收姿势不对。 侵权删。</p>
<!-- more -->
<p><a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画中国史5</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画世界史1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharingf">半小时漫画世界史2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学1</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学2</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学3</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画经济学4</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画科学史1 2 3全 MOBI</a><br>
<a href="https://drive.google.com/drive/folders/1iFAFtnyGwr5OBYPSWCVVAmCWxlJXSg1K?usp=sharing">半小时漫画预防常见病</a></p>
]]></content>
    </entry>
</feed>