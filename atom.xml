<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-04-30T06:54:34.868Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[系统设计]]></title>
        <id>https://headhuanglan.github.io/post/system-design/</id>
        <link href="https://headhuanglan.github.io/post/system-design/">
        </link>
        <updated>2022-03-27T23:23:07.000Z</updated>
        <summary type="html"><![CDATA[<p>System Design 资源汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>System Design 资源汇总</p>
<!-- more -->
<p><a href="https://www.youtube.com/watch?v=PdtlXdse7pw&amp;list=PL4KdJM8LzAMecwInbBK5GJ3Anz-ts75RQ">DDIA书视频总结</a></p>
<p><a href="https://www.interviewbit.com/courses/system-design/">InterviewBit系统设计题汇总</a></p>
<p><a href="https://github.com/donnemartin/system-design-primer">system design primer github repo</a></p>
<p><a href="https://www.hiredintech.com/classrooms/system-design/lesson/52">system design class</a></p>
<p><a href="https://www.educative.io/courses/grokking-the-system-design-interview">付费 grokking system design interview</a></p>
<p><a href="https://luanjunyi.medium.com/the-table-of-contents-416d2240fa8e">大佬的medium文章</a></p>
<p><a href="http://blog.gainlo.co/index.php/category/system-design-interview-questions/">已经解决的系统设计问题合集</a></p>
<p><a href="http://highscalability.com/blog/2022/1/25/designing-uber.html/">Design Uber</a></p>
<p><a href="http://highscalability.com/blog/2022/1/17/designing-tinder.html">Design Tinder</a></p>
<p><a href="http://highscalability.com/blog/2022/1/11/designing-instagram.html">Design Instagram</a></p>
<p><a href="http://highscalability.com/blog/2022/1/3/designing-whatsapp.html">Design Whatsapp</a></p>
<p><a href="http://highscalability.com/blog/2021/12/13/designing-netflix.html">Design Netflix</a></p>
<p>https://leetcode.com/company/facebook/discuss/229177/My-System-Design-Template<br>
(1) FEATURE EXPECTATIONS [5 min]</p>
<pre><code>    (1) Use cases
    (2) Scenarios that will not be covered
    (3) Who will use
    (4) How many will use
    (5) Usage patterns
</code></pre>
<p>(2) ESTIMATIONS [5 min]</p>
<pre><code>    (1) Throughput (QPS for read and write queries)
    (2) Latency expected from the system (for read and write queries)
    (3) Read/Write ratio
    (4) Traffic estimates
            - Write (QPS, Volume of data)
            - Read  (QPS, Volume of data)
    (5) Storage estimates
    (6) Memory estimates
            - If we are using a cache, what is the kind of data we want to store in cache
            - How much RAM and how many machines do we need for us to achieve this ?
            - Amount of data you want to store in disk/ssd
</code></pre>
<p>(3) DESIGN GOALS [5 min]</p>
<pre><code>    (1) Latency and Throughput requirements
    (2) Consistency vs Availability  [Weak/strong/eventual =&gt; consistency | Failover/replication =&gt; availability]
</code></pre>
<p>(4) HIGH LEVEL DESIGN [5-10 min]</p>
<pre><code>    (1) APIs for Read/Write scenarios for crucial components
    (2) Database schema
    (3) Basic algorithm
    (4) High level design for Read/Write scenario
</code></pre>
<p>(5) DEEP DIVE [15-20 min]</p>
<pre><code>    (1) Scaling the algorithm
    (2) Scaling individual components: 
            -&gt; Availability, Consistency and Scale story for each component
            -&gt; Consistency and availability patterns
    (3) Think about the following components, how they would fit in and how it would help
            a) DNS
            b) CDN [Push vs Pull]
            c) Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
            d) Reverse Proxy
            e) Application layer scaling [Microservices, Service Discovery]
            f) DB [RDBMS, NoSQL]
                    &gt; RDBMS 
                        &gt;&gt; Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
                    &gt; NoSQL
                        &gt;&gt; Key-Value, Wide-Column, Graph, Document
                            Fast-lookups:
                            -------------
                                &gt;&gt;&gt; RAM  [Bounded size] =&gt; Redis, Memcached
                                &gt;&gt;&gt; AP [Unbounded size] =&gt; Cassandra, RIAK, Voldemort
                                &gt;&gt;&gt; CP [Unbounded size] =&gt; HBase, MongoDB, Couchbase, DynamoDB
            g) Caches
                    &gt; Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
                    &gt; Eviction policies:
                            &gt;&gt; Cache aside
                            &gt;&gt; Write through
                            &gt;&gt; Write behind
                            &gt;&gt; Refresh ahead
            h) Asynchronism
                    &gt; Message queues
                    &gt; Task queues
                    &gt; Back pressure
            i) Communication
                    &gt; TCP
                    &gt; UDP
                    &gt; REST
                    &gt; RPC
</code></pre>
<p>(6) JUSTIFY [5 min]</p>
<pre><code>    (1) Throughput of each layer
    (2) Latency caused between each layer
    (3) Overall latency justification
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022-03-08 Leetcode]]></title>
        <id>https://headhuanglan.github.io/post/2022-03-08-leetcode/</id>
        <link href="https://headhuanglan.github.io/post/2022-03-08-leetcode/">
        </link>
        <updated>2022-03-07T23:50:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-471-encode-string-with-shortest-length-hardfont"><font color='red'> 471. Encode String with Shortest Length （Hard）</font></h1>
<p>Given a string s, encode the string such that its encoded length is the shortest.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. k should be a positive integer.<br>
If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    @lru_cache(None)
    def encode(self, s: str) -&gt; str:
        i=(s+s).find(s,1)
        encoded=str(len(s)//i)+'['+self.encode(s[:i])+']' if i&lt;len(s) else s
        splitEncoded=[self.encode(s[:i])+self.encode(s[i:]) for i in range(1,len(s))]
        return min(splitEncoded+[encoded],key=len)
</code></pre>
<p>答案绝了。。。<br>
For any s, you can either<br>
Do not encode it<br>
Or encode it to one string if possible<br>
Or, split it into two, encode the two substring to their shortest possible length, and combine them<br>
Pick up the shortest result from 1~3.<br>
During this process, you should remember the best encoding result for all substrings so that it can be reused.<br>
For #2, you can use LeetCode 459: Repeated Substring Pattern to find out whether the &quot;s&quot; is repeated or not, and how many times it is repeated:<br>
&quot;i=(s+s).find(s,1)&quot;<br>
&quot;i&quot; is the length of repeating pattern. If i&gt;=len(s), then s is not repeated.</p>
<h1 id="font-colorred-472-concatenated-words-hardfont"><font color='red'> 472. Concatenated Words （Hard）</font></h1>
<p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.<br>
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<pre><code class="language-python">class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -&gt; List[str]:
        d = set(words)
        @lru_cache(None)
        def dfs(word):
            for i in range(1, len(word)):
                prefix = word[:i]
                suffix = word[i:]
                
                if prefix in d and suffix in d:
                    return True
                if prefix in d and dfs(suffix):
                    return True
                if suffix in d and dfs(prefix):
                    return True
            
            return False
        
        res = []
        for word in words:
            if dfs(word):
                res.append(word)
        
        return res

</code></pre>
<p>看答案捐膝盖。。</p>
<h1 id="font-colorred-473-matchsticks-to-square-medium-font"><font color='red'> 473. Matchsticks to Square (Medium) </font></h1>
<p>You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.<br>
Return true if you can make this square and false otherwise.</p>
<pre><code class="language-python">#TLE
class Solution:
    def makesquare(self, matchsticks: List[int]) -&gt; bool:
        length = sum(matchsticks)//4
        if length*4!= sum(matchsticks): return False
        
        holds=[[],[],[],[]]
        self.result=False
        def bt(i):
            if i&gt;=len(matchsticks): return
            for hold in holds:
                val=matchsticks[i]
                hold.append(val)
                if len(set(map(sum,holds)))==1 and i==len(matchsticks)-1:
                    self.result=True
                    return 
                bt(i+1)
                hold.pop()
        
        bt(0)
        
        return self.result

#ANSWER
class Solution:
    def makesquare(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # If there are no matchsticks, then we can't form any square
        if not nums:
            return False

        # Number of matchsticks we have
        L = len(nums)

        # Perimeter of our square (if one can be formed)
        perimeter = sum(nums)

        # Possible side of our square.
        possible_side =  perimeter // 4

        # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).
        if possible_side * 4 != perimeter:
            return False

        # Reverse sort the matchsticks because we want to consider the biggest one first.
        nums.sort(reverse=True)

        # This array represents the 4 sides and their current lengths
        sums = [0 for _ in range(4)]

        # Our recursive dfs function.
        def dfs(index):

            # If we reach the end of matchsticks array, we check if the square was formed or not
            if index == L:
                # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.
                return sums[0] == sums[1] == sums[2] == possible_side

            # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are &gt;= the size of the current matchstick)
            for i in range(4):
                # If this matchstick can fir in the space left for the current side
                if sums[i] + nums[index] &lt;= possible_side:
                    # Recurse
                    sums[i] += nums[index]
                    if dfs(index + 1):
                        return True
                    # Revert the effects of recursion because we no longer need them for other recursions.
                    sums[i] -= nums[index]
            return False        
        return dfs(0)
</code></pre>
<p>初次尝试backtracking TLE。。。答案same idea with trick can pass， reverse sorting and early stopping。</p>
<h1 id="font-colorred-474-ones-and-zeroes-mediumfont"><font color='red'> 474. Ones and Zeroes （Medium）</font></h1>
<p>You are given an array of binary strings strs and two integers m and n.<br>
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.<br>
A set x is a subset of a set y if all elements of x are also elements of y.</p>
<pre><code class="language-python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        
        dp=[[0 for _ in range(n+1)] for __ in range(m+1)]
        for s in strs:
            c0=s.count('0')
            c1=s.count('1')
            for zeros in range(m,c0-1,-1):
                for ones in range(n,c1-1,-1):
                    dp[zeros][ones] = max(1+dp[zeros-c0][ones-c1],dp[zeros][ones])
        
        return dp[m][n]
#ANSWER
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        @lru_cache(None)
        def calculate(i,zeroes,ones):
            if i==len(strs): return 0
            c1=strs[i].count('1')
            c0=strs[i].count('0')        
            taken=-1
            if zeroes-c0&gt;=0 and ones-c1&gt;=0:
                taken = calculate(i+1,zeroes-c0,ones-c1) +1
            not_taken=calculate(  i + 1, zeroes, ones )
            return max(taken, not_taken)
        return calculate(0, m, n) 
    
</code></pre>
<p>greedy failed....   DP? Should have got this one.   dp[i][j] denotes the maximum number of strings that can be included in the subset given only i 0's and j 1's are available. 从后向前因为不能覆盖之前的结果。</p>
<h1 id="font-colorred-475-heaters-mediumfont"><font color='red'> 475. Heaters （Medium）</font></h1>
<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.<br>
Every house can be warmed, as long as the house is within the heater's warm radius range.<br>
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.</p>
<pre><code class="language-python">
#TLE
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        #bfs
        visited=set()
        houses=set(houses)-set(heaters)
        dis=0
        while visited!=houses:
            #print(visited,houses)
            dis+=1
            for cur in heaters: 
                if cur+dis in houses and cur+dis not in visited:
                    visited.add(cur+dis)    
                if cur-dis in houses  and cur-dis not in visited:
                    visited.add(cur-dis)
        return dis
            
#ANSWER
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        
         
               
        def binsearch(nums, target) :
            l, r = 0, len(nums)
            while l &lt; r:
                m = (l + r) // 2
                if nums[m] &lt; target :
                    l = m + 1
                else:
                    r = m
            return l
            
        heaters.sort()
        
        result = float('-inf')
        
        for house in houses :
            index = binsearch(heaters, house)
            leftHeaterDistance = house - heaters[index - 1] if index &gt; 0 else float('inf')
            rightHeaterDistance = heaters[index] - house if index &lt; len(heaters) else float('inf')
            result = max(result , min(leftHeaterDistance, rightHeaterDistance))
        
        return result
        
</code></pre>
<p>变种FBS 每次增加1 distance，TLE。看答案。max min + binary search</p>
<h1 id="476-number-complement-easy">476. Number Complement (Easy)</h1>
<p>The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.<br>
For example, The integer 5 is &quot;101&quot; in binary and its complement is &quot;010&quot; which is the integer 2.<br>
Given an integer num, return its complement.</p>
<pre><code class="language-python">class Solution:
    def findComplement(self, num: int) -&gt; int:
        mask= 2**len(bin(num)[2:])-1
        print(bin(mask),bin(num))
        return mask^num
#ANSWER
from math import log2
class Solution:
    def findComplement(self, num):
        # n is a length of num in binary representation
        n = floor(log2(num)) + 1        
        # bitmask has the same length as num and contains only ones 1...1
        bitmask = (1 &lt;&lt; n) - 1
        # flip all bits
        return bitmask ^ num
#ANSWER
class Solution:
    def findComplement(self, num):
        todo, bit = num, 1
        while todo:
            # flip current bit
            num = num ^ bit
            # prepare for the next run
            bit = bit &lt;&lt; 1
            todo = todo &gt;&gt; 1
        return num
</code></pre>
<h1 id="font-colorred477-total-hamming-distance-medium-font"><font color='red'>477. Total Hamming Distance (Medium) </font></h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.</p>
<pre><code class="language-python">#TLE
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:
        nums.sort()
        @lru_cache(None)
        def cal(a,b):
            val=a^b
            c=0
            while val:
                if val%2==1:
                    c+=1
                val&gt;&gt;=1
            return c
        res=0
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                res+=cal(nums[i],nums[j])
        return res


#ANSWER
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:
        if not nums: return 0
        res=0
        n=len(nums)
        count = [0]*32
        
        for num in nums:
            i=0
            while num:
                count[i]+= num &amp; 1
                num &gt;&gt;=1
                i+=1
        
        for k in count:
            res+=k*(n-k)
        
        return res
        
         
</code></pre>
<p>初次尝试 TLE,应该按照bit loop。Say for any particular bit position, count the number of elements with this bit ON (i.e. this particular bit is 1). Let this count be k. Hence the number of elements with this bit OFF (i.e. 0) is (n−k)(n - k) (in an n element array).<br>
Certainly unique pairs of elements exists where one element has this particular bit ON while the other element has this OFF (i.e. this particular bit differs for the two elements of this pair).</p>
<h1 id="478-generate-random-point-in-a-circle-medium">478. Generate Random Point in a Circle （Medium）</h1>
<p>Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.<br>
Implement the Solution class:<br>
Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).<br>
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].</p>
<pre><code class="language-python">from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r
        x=r*(random()-0.5)*2
        y=r*(random()-0.5)*2
        while x*x+y*y&gt;r*r:
            x=r*(random()-0.5)*2
            y=r*(random()-0.5)*2
            
        
        return [self.x+x,self.y+y]
#ANSWER hard
from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r*math.sqrt(random())
        theta = 2*math.pi*random()
        x=r*math.cos(theta)
        y=r*math.sin(theta)
     
        return [self.x+x,self.y+y]
#ANSWER
import math
import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x = x_center
        self.y = y_center
        self.area = math.pi * radius ** 2

    def randPoint(self) -&gt; List[float]:
        theta = 2 * math.pi * random.random()
        R = math.sqrt(random.uniform(0, self.area) / math.pi)
        return [self.x + R * math.cos(theta), self.y + R * math.sin(theta)]
</code></pre>
<p>The area under any probability density function curve must be 1 . Therefore, the equation must be f(x)=2x Using our probability density function f , we can compute the cumulative distribution function F , where F(x) is the probability of sampling a point within a distance of x from the origin.F(x)=∫f(x)=∫2x=x2<br>
Lastly, we can use our cumulative distribution function F  to compute the inverse cumulative distribution function  F^{-1} , which accepts uniform random value between 0  and 1  and returns a random distance from origin in accordance with f</p>
<h1 id="font-colorred-479-largest-palindrome-product-hard-font"><font color='red'> 479. Largest Palindrome Product (Hard) </font></h1>
<p>Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.</p>
<pre><code class="language-python">class Solution:
    def largestPalindrome(self, n: int) -&gt; int:
        max_=10**n-1
        min_=max_//10
        for h in range(max_,min_,-1):
            left=h
            right=0
            #// construct the palindrome
            i=h
            while i:
                right=right*10+i%10
                left*=10
                i//=10
            
            palindrom=left+right
            #print(palindrom)
            for i in range(max_,min_,-1):
                j=palindrom//i
                #// terminate if the other number is greater than current number
                if j&gt;i: break
                if  palindrom%i==0: return palindrom%1337
        #// account for case n = 1
        return 9
</code></pre>
<p>没思路。。。</p>
<h1 id="480-sliding-window-median-hard">480. Sliding Window Median （Hard）</h1>
<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.<br>
For examples, if arr = [2,3,4], the median is 3.<br>
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.<br>
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.<br>
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.</p>
<pre><code class="language-python">class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        odd=False
        pos1=0
        pos2=0
        if k%2==1:
            odd=True
            pos1=k//2
        else:
            pos1=k//2-1
            pos2=k//2
        
        res = []
        for i in range(k,len(nums)+1):
            tmp = sorted(nums[i-k:i])
            if odd: 
                res.append(tmp[pos1])
            else:
                res.append( (tmp[pos1]+tmp[pos2])/2)
        return res

#ANSWER O(nk)
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        window = sorted(nums[:k])
        medians = []
        for a, b in zip(nums, nums[k:] + [0]):
            if k&amp;1:
                medians.append( window[k//2])
            else:
                medians.append( (window[k//2]+window[k//2-1])/2.0)
            window.remove(a)
            bisect.insort(window, b)
        return medians

#ANSWER O(nlogk)
import heapq
from collections import defaultdict
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        if not nums or not k:
            return []
        #lo  hi
        lo = [] # max heap   
        hi = [] # min heap
        for i in range(k):
            if len(lo) == len(hi):
                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))
            else:
                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))
        ans = [float(hi[0])] if k &amp; 1 else [(hi[0] - lo[0]) / 2.0]
        to_remove = defaultdict(int)
        for i in range(k, len(nums)): # right bound of window
            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo
            out_num = nums[i-k]
            #out_num恰巧在lo的边界上，所以要更新边界
            if out_num &gt; -lo[0]:
                heapq.heappush(hi, -heapq.heappop(lo))
            to_remove[out_num] += 1

            #在lo边界上可以直接去掉
            while lo and to_remove[-lo[0]]:
                to_remove[-lo[0]] -= 1
                heapq.heappop(lo)
            #在hi边界上可以直接去掉
            while to_remove[hi[0]]:
                to_remove[hi[0]] -= 1
                heapq.heappop(hi)
            if k % 2:
                ans.append(float(hi[0]))
            else:
                ans.append((hi[0] - lo[0]) / 2.0)
        return ans
</code></pre>
<p>思路：维持small ，large 连个queue， 所有samll中元素都小于large， 所以median是 （max（small）+min（large））除以2，如果small ，large等长， 如果large长，则返回min（large）<br>
所以用heap， small用的是maxheap， large用的是minheap。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022-03-07 Leetcode]]></title>
        <id>https://headhuanglan.github.io/post/2022-03-07-leetcode/</id>
        <link href="https://headhuanglan.github.io/post/2022-03-07-leetcode/">
        </link>
        <updated>2022-03-07T07:06:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="461-hamming-distance-easy">461. Hamming Distance (Easy)</h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given two integers x and y, return the Hamming distance between them.</p>
<pre><code class="language-python">class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        res=x^y
        c=0
        for i in range(32):
            if res &gt;&gt;i &amp; 1:
                c+=1
        return c
#
class Solution(object):
    def hammingDistance(self, x, y):
        &quot;&quot;&quot;
        :type x: int
        :type y: int
        :rtype: int
        &quot;&quot;&quot;
        xor = x ^ y
        distance = 0
        while xor:
            # mask out the rest bits
            if xor &amp; 1:
                distance += 1
            xor = xor &gt;&gt; 1
        return distance

#
class Solution:
    def hammingDistance(self, x, y):
        xor = x ^ y
        distance = 0
        while xor:
            distance += 1
            # remove the rightmost bit of '1'
            xor = xor &amp; (xor - 1)
        return distance
</code></pre>
<h1 id="462-minimum-moves-to-equal-array-elements-ii-medium">462. Minimum Moves to Equal Array Elements II (Medium)</h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment or decrement an element of the array by 1.<br>
Test cases are designed so that the answer will fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def minMoves2(self, nums: List[int]) -&gt; int:
        # nums[i]-mid
        nums.sort()
        mid= nums[len(nums)//2]
        return sum([abs(val-mid) for val in nums])
#JAVA ANSWER good to know
public class Solution {
    public int minMoves2(int[] nums) {
        int l = 0, r = nums.length - 1, sum = 0;
        Arrays.sort(nums);
        while (l &lt; r) {
            sum += nums[r] - nums[l];
            l++;
            r--;
        }
        return sum;
    }
}
</code></pre>
<h1 id="463-island-perimeter-easy">463. Island Perimeter (Easy)</h1>
<p>You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.<br>
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).<br>
The island doesn't have &quot;lakes&quot;, meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>
<pre><code class="language-python">class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:
        # find a neighor + neighbor4 but contact need to -contact number.
        visited=set()
        def nei(i,j):
            neis=[]
            for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if ii&lt;0 or ii&gt;=len(grid) or jj&lt;0 or jj&gt;=len(grid[0]) or grid[ii][jj]==0: 
                        continue
                neis.append((ii,jj))
            return neis
        
        res = [0]
        
        def dfs(i,j):
            if (i,j) in visited: return
            res[0]+=4
            neis = nei(i,j)
            res[0]-=len(neis)
            visited.add((i,j))
            for ne in neis:
                if ne not in visited:
                    dfs(*ne)
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    dfs(i,j)
                    break
        return res[0]
            
</code></pre>
<h1 id="font-colorred-464-can-i-win-medium-font"><font color='red'> 464. Can I Win (Medium) </font></h1>
<p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.<br>
What if we change the game so that players cannot re-use integers?<br>
For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.<br>
Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.</p>
<pre><code class="language-python">class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool:
        @lru_cache(None)
        def check(nums, t):
            if nums[-1] &gt;= t: return True
            res = any(not check(tuple(nums[:i]+nums[i+1:]),t-nums[i]) for i in range(len(nums)))
            return res
            
        if maxChoosableInteger * (1 + maxChoosableInteger) // 2 &lt; desiredTotal: return False
        nums = tuple(range(1, maxChoosableInteger + 1))
        return check(nums, desiredTotal)

#ANSWER 2 TLE
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool:
        dic = dict()
        used = [False]*(maxChoosableInteger+1)
        
        sum_=(1+maxChoosableInteger)*maxChoosableInteger//2
        if sum_&lt;desiredTotal: return False
        if desiredTotal&lt;=0: return True
        
        def formatkey(used):
            n=0
            for bl in used:
                n&lt;&lt;=1
                if bl:
                    n |=1
            return n
            
        def helper(desiredTotal):
            if desiredTotal&lt;=0: return False
            key = formatkey(used)
            if key not in dic:
                for i in range(1,len(used)):
                    if not used[i]:
                        used[i]=True
                        #check whether this lead to a win (i.e. the other player lose)
                        if not helper(desiredTotal-i):
                            dic[key]=True
                            used[i]=False
                            return True
                        used[i]=False
                dic[key]=False
            
            return dic[key]
        
        return helper(desiredTotal)
</code></pre>
<p>can not reuse integer， 答案 pythonic写法。</p>
<h1 id="font-colorred-465-optimal-account-balancing-hardfont"><font color='red'> 465. Optimal Account Balancing （Hard）</font></h1>
<p>You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.<br>
Return the minimum number of transactions required to settle the debt.</p>
<pre><code class="language-python">    def minTransfers(self, transactions):
        &quot;&quot;&quot;
        :type transactions: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        m = collections.defaultdict(int)
        
        for t in transactions:
            m[t[0]]-=t[2]
            m[t[1]]+=t[2]
        
        debt = m.values()
        
        def dfs(s):
            while(s&lt;len(debt) and debt[s]==0):
                s+=1
            if s==len(debt): return 0
            
            r = float('inf')
            for i in range(s+1,len(debt)):
                if debt[i]*debt[s]&lt;0:
                    # settle s with i
                    debt[i]+=debt[s]
                    r=min(r,1+dfs(s+1))
                    # backtrack
                    debt[i]-=debt[s]
            return r
        
        return dfs(0)



</code></pre>
<p>idea is tricky...  person index s have debt[s] for other person from s+1, if other person have neg sign then person s. update debt[i] with debt[s] (so person i will take full responsiblity of person s). r=min(r,1+dfs(s+1))</p>
<h1 id="font-colorred-466-count-the-repetitions-hard-font"><font color='red'> 466. Count The Repetitions (Hard) </font></h1>
<p>We define str = [s, n] as the string str which consists of the string s concatenated n times.<br>
For example, str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;.<br>
We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.<br>
For example, s1 = &quot;abc&quot; can be obtained from s2 = &quot;abdbec&quot; based on our definition by removing the bolded underlined characters.<br>
You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].<br>
Return the maximum integer m such that str = [str2, m] can be obtained from str1.</p>
<pre><code class="language-python">
class Solution:
    def getMaxRepetitions(self, s1, n1, s2, n2):
        d, l1, l2, i1, i2 = {}, len(s1), len(s2), 0, 0
        tot = l1 * n1

        while i1 &lt; tot:
            if s1[i1 % l1] == s2[i2 % l2]:
                if (i1 % l1, i2 % l2) in d:
                    prev1, prev2 = d[(i1 % l1, i2 % l2)]
                    cir1, cir2 = i1 - prev1, i2 - prev2
                    count_cir1 = (tot - i1) // cir1
                    i1 += count_cir1 * cir1
                    i2 += count_cir1 * cir2
                    if i1 &gt;= tot: break
                else:
                    d[(i1 % l1, i2 % l2)] = (i1, i2)
                i2 += 1
            i1 += 1
        return i2 // l2 // n2

</code></pre>
<p>直接数出现的次数算重复不行，因为还有字母出现次序问题。。。 得找重复pattern。 答案厉害。</p>
<h1 id="font-colorred-467-unique-substrings-in-wraparound-string-medium-font"><font color='red'> 467. Unique Substrings in Wraparound String (Medium) </font></h1>
<p>We define the string s to be the infinite wraparound string of &quot;abcdefghijklmnopqrstuvwxyz&quot;, so s will look like this:<br>
&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;.<br>
Given a string p, return the number of unique non-empty substrings of p are present in s.</p>
<pre><code class="language-python">def findSubstringInWraproundString(self, p):
        res = {i: 1 for i in p}
        l = 1
        for i, j in zip(p, p[1:]):
            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
            res[j] = max(res[j], l)
        return sum(res.values())
#
class Solution:
    def findSubstringInWraproundString(self, p: str) -&gt; int:
        if not p: return 0
        count = [0]*26
        #initally, count is 1 for each unique char
        for char in p:
            count[ord(char)-ord('a')]=1
        
        res=1
        #for each sub sequence ending in char2, if it is connected, res+=1 else res=1
        for char1,char2 in zip(p,p[1:]):
            if (ord(char2)-ord(char1))%26==1:
                res+=1
            else:
                res=1
            #prevent duplicate char2
            count[ord(char2)-ord('a')] = max(count[ord(char2)-ord('a')], res)
                
        return sum(count)

#ANSWER DP 思路：若字符连续，当前可形成的substring个数+1，若不连续substring个数=1，更新count 为防止重复字符overwrite，更新时候取max。 
class Solution:
    def findSubstringInWraproundString(self, p: str) -&gt; int:
        count=[0]*26
        cur_maxlen=0
        for i in range(len(p)):
            if i&gt;0 and (ord(p[i])-ord(p[i-1]))%26==1:
                cur_maxlen+=1
            else:
                cur_maxlen=1
            
            index=ord(p[i])-ord('a')
            count[index]=max(count[index],cur_maxlen)
        
        return sum(count)
</code></pre>
<p>看答案了。。。<br>
Each single charecter contribution is initialized to 1<br>
if the order is continued, the contribution is increased by 1 from previous character contribution</p>
<p>example string zabce</p>
<p>Values got incremented in the following way</p>
<pre><code>z -&gt; 1
a -&gt; 1 + 1 (or) z + 1 -&gt; 2
b -&gt; 1 + 1 + 1 (or) a + 1 -&gt; 3
c -&gt; 1 + 1 + 1 + 1 (or) b + 1 -&gt; 4
e -&gt; 1 (ord(j) - ord(i)) % 26 != 1 here
</code></pre>
<p>So the final answer is contribution from z + a + b + c + e (1 + 2 + 3 + 4 + 1 = 11)</p>
<pre><code>max(res[j], l) is required to handle cases where the character is repeated.
</code></pre>
<p>For example in zaba, since each each unique character is assigned as key to res, the 2nd a contribution should not replace the 1st a contribution until it exceeds the 1st a contribution</p>
<h1 id="468-validate-ip-address-medium">468. Validate IP Address （Medium）</h1>
<p>Given a string queryIP, return &quot;IPv4&quot; if IP is a valid IPv4 address, &quot;IPv6&quot; if IP is a valid IPv6 address or &quot;Neither&quot; if IP is not a correct IP of any type.<br>
A valid IPv4 address is an IP in the form &quot;x1.x2.x3.x4&quot; where 0 &lt;= xi &lt;= 255 and xi cannot contain leading zeros. For example, &quot;192.168.1.1&quot; and &quot;192.168.1.0&quot; are valid IPv4 addresses but &quot;192.168.01.1&quot;, while &quot;192.168.1.00&quot; and &quot;192.168@1.1&quot; are invalid IPv4 addresses.<br>
A valid IPv6 address is an IP in the form &quot;x1:x2:x3:x4:x5:x6:x7:x8&quot; where:<br>
1 &lt;= xi.length &lt;= 4<br>
xi is a hexadecimal string which may contain digits, lower-case English letter ('a' to 'f') and upper-case English letters ('A' to 'F').<br>
Leading zeros are allowed in xi.<br>
For example, &quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; and &quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot; are valid IPv6 addresses, while &quot;2001:0db8:85a3::8A2E:037j:7334&quot; and &quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; are invalid IPv6 addresses.</p>
<pre><code class="language-python">class Solution:
    def validIPAddress(self, queryIP: str) -&gt; str:
        
        def convert4(string):
            # in range 0~255
            # cannot leading zeros
            # number only
            if not string: return False
            if len(string)&gt;1 and string[0]=='0': return False
            val=0
            for s in string:
                if s not in '0123456789':
                    return False
                val=val*10+int(s)
            
            #return True if success, else False
            if val&gt;=0 and val&lt;=255:
                return True
            return False
        
        def convert6(string):
            if not string: return False
            #length 1~4
            # hexadecial string 0~9 a~f A~F
            if len(string)&gt;4: return False
            for s in string:
                if s not in '0123456789abcdefABCDEF':
                    return False
            return True
        
        if '.' in queryIP:
            data = queryIP.split('.')
            if len(data)==4 and all([convert4(string) for string in data]):
                return 'IPv4'        
            
        elif ':' in queryIP:
            data = queryIP.split(':')
            if len(data)==8 and all([convert6(string) for string in data]):
                return 'IPv6'
        
        return 'Neither'

</code></pre>
<p>只需要细心的题目</p>
<h1 id="font-colorred-469-convex-polygon-mediumfont"><font color='red'> 469. Convex Polygon （Medium）</font></h1>
<p>You are given an array of points on the X-Y plane points where points[i] = [xi, yi]. The points form a polygon when joined sequentially.<br>
Return true if this polygon is convex and false otherwise.<br>
You may assume the polygon formed by given points is always a simple polygon. In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don't intersect each other.</p>
<pre><code class="language-python">def isConvex(self, p: List[List[int]]) -&gt; bool:
    def ccw(a, b, c):
        # (b-a) X (c-a)
        return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) 
    res = [ccw(p[i-2], p[i-1], p[i]) for i in range(len(p))]
    return abs(sum(res)) == sum(abs(i) for i in res)
</code></pre>
<p>convex...beyond my knowledge  CCW算法。。。Note: |Σxi| = Σ|xi| is only true when all xi are the same sign.</p>
<h1 id="470-implement-rand10-using-rand7-medium">470. Implement Rand10() Using Rand7() (Medium)</h1>
<p>Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.<br>
Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<pre><code class="language-python"># The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        # rand1  1~7   取1~6  奇偶决定生成左区间1~5 还是右区间6~10
        # rand2        取1~5  
        rand1=rand7()
        while rand1==7:
            rand1=rand7()
        flag = rand1%2==1
        rand2=rand7()
        while rand2&gt;5:
            rand2=rand7()
        return 5+rand2 if flag else rand2

#ANSWER
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        n1=rand7()
        n2=rand7()
        while n1+(n2-1)*7 &gt;40:
            n1=rand7()
            n2=rand7()
        return (n1+(n2-1)*7)%10 +1
</code></pre>
<p>(n2-1)乘7+n1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-06/">
        </link>
        <updated>2022-03-06T11:20:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="451-sort-characters-by-frequency-medium">451. Sort Characters By Frequency （Medium）</h1>
<p>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.<br>
Return the sorted string. If there are multiple answers, return any of them</p>
<pre><code class="language-python">class Solution:
    def frequencySort(self, s: str) -&gt; str:
        d=Counter(s)
        res=''
        for k in sorted(d,key=lambda x: d[x],reverse=True):
            res+=k*d[k]
        return res
#O(n) bucket sort
class Solution:
    def frequencySort(self, s: str) -&gt; str:
        if not s: return s
        counts=collections.Counter(s)
        max_freq=max(counts.values())
        
        buckets=[[] for _ in range(max_freq+1)]
        for c,i in counts.items():
            buckets[i].append(c)
        
        string_builder=[]
        for i in range(len(buckets)-1,0,-1):
            for c in buckets[i]:
                string_builder.append(c*i)
        return ''.join(string_builder)
        
</code></pre>
<p>答案的On解法好。bucketsort</p>
<h1 id="452-minimum-number-of-arrows-to-burst-balloons-medium">452. Minimum Number of Arrows to Burst Balloons (Medium)</h1>
<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.<br>
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.<br>
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</p>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        #merge points by &amp; return how many distinct points
        
        points=sorted(points,key=lambda x:x[0])
        res=[]
        for p in points:
            if res:
                # 1    1
                #    2   2 
                if res[-1][1]&gt;=p[0]:
                    res[-1][0]=max(res[-1][0],p[0])
                    res[-1][1]=min(res[-1][1],p[1])
                    
                else:
                    res.append(p)
            else:
                res.append(p)
        #print(res)
        return len(res)
                
#ANSWER WAY OF WRITTING
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        if not points:
            return 0
        
        # sort by x_end
        points.sort(key = lambda x : x[1])
        
        arrows = 1
        first_end = points[0][1]
        for x_start, x_end in points:
            # if the current balloon starts after the end of another one,
            # one needs one more arrow
            if first_end &lt; x_start:
                arrows += 1
                first_end = x_end
        
        return arrows
</code></pre>
<p>我的思路是找到相交的区间，看总共多少个就行。。。答案思路是track球右边位置，让碰到新气球左边大于cur end位置+1，更新end位置的greedy算法。</p>
<h1 id="font-colorred-453-minimum-moves-to-equal-array-elements-mediumfont"><font color='red'> 453. Minimum Moves to Equal Array Elements （Medium）</font></h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment n - 1 elements of the array by 1.</p>
<pre><code class="language-python">#TLE naive solution
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        c=0
        while len(set(nums))!=1:
            ind = nums.index(max(nums))
            for i in range(len(nums)):
                if i!=ind:
                    nums[i]+=1
            #print(nums)
            c+=1
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        nums.sort()
        c=0
        for i in range(len(nums)-1,0,-1):
            c+=nums[i]-nums[0]
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int: 
        moves=0
        min_=float('inf')
        for i in range(len(nums)):
            moves+=nums[i]
            min_=min(min_,nums[i])
        return moves-min_*len(nums)
</code></pre>
<p>答案很巧妙，如果是答案1） 思路先sort，那么每次需要move是nums【i】-nums【0】，这样move后nums【i】和nums【0】相等，然后其余数字都加上了move次，再次move时候，求nums【i-1】-nums【0】，这样nums【0】就和nums【i-1】相等，自然也和nums【i】相等。 以此类推，可求出总共move数目。 如果是答案2）所有加1除了1个不加，和只有一个减去1是等效的。 所以就是减多少次能使所有数平衡，sum（all）-min（all）乘n。</p>
<h1 id="454-4sum-ii-medium">454. 4Sum II （Medium）</h1>
<p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:<br>
0 &lt;= i, j, k, l &lt; n<br>
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
<pre><code class="language-python">class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:
        dic2sum=collections.defaultdict(int)
        for i in nums1:
            for j in nums2:
                dic2sum[i+j]+=1
        
        res=0
        for k in nums3:
            for l in nums4:
                if -k-l in dic2sum:
                    res+=dic2sum[-k-l]
        return res



#ANSWER GENERALIZED 
class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int:
        m = collections.defaultdict(int)
        lists = [A, B, C, D]

        def nSumCount() -&gt; int:
            addToHash(0, 0)
            return countComplements(len(lists) // 2, 0)

        def addToHash(i: int, total: int) -&gt; None:
            if i == len(lists) // 2:
                m[total] = m[total] + 1
            else:
                for a in lists[i]:
                    addToHash(i + 1, total + a)

        def countComplements(i: int, complement: int) -&gt; int:
            if i == len(lists):
                return m[complement]
            cnt = 0
            for a in lists[i]:
                cnt += countComplements(i + 1, complement - a)
            return cnt

        return nSumCount()
</code></pre>
<h1 id="455-assign-cookies-easy">455. Assign Cookies (Easy)</h1>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.<br>
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<pre><code class="language-python">class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:
        g.sort()
        s.sort()
        c=0
        while g:
            cur=g.pop(0)
            while s and s[0]&lt;cur:
                s.pop(0)
            if s:
                s.pop(0)
                c+=1
        return c
#
# 先对g, s两个数组进行排序
# 贪心算法
# 贪心思想1 优先满足需求因子较小的孩子。因为如果较小需求的孩子无法被满足，则之后的较大的需求更不可能能被满足了。
#贪心思想2 尽量用较小的糖果去优先满足孩子。

class Solution:
    def findContentChildren(self, g, s):
        &quot;&quot;&quot;
        :type g: List[int]
        :type s: List[int]
        :rtype: int
        &quot;&quot;&quot;
        g.sort()    # 对需求因子进行排序，从小到大
        s.sort()    # 对糖果数组进行排序，从小到大
        child  = 0  # 记录可以被满足孩子数
        cookie = 0  # 记录可以满足的糖果数
        while  child &lt;len(g) and cookie &lt; len(s):
            if g[child] &lt;= s[cookie]: 
                child += 1
            cookie += 1
        return child
</code></pre>
<h1 id="font-colorred-456-132-pattern-mediumfont"><font color='red'> 456. 132 Pattern （Medium）</font></h1>
<p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].<br>
Return true if there is a 132 pattern in nums, otherwise, return false.</p>
<pre><code class="language-python">class Solution:
    def find132pattern(self, nums: List[int]) -&gt; bool:
        if len(nums) &lt; 3:
            return False
        stack=[]
        min_array = [-1] * len(nums)
        min_array[0] = nums[0]
        for i in range(1, len(nums)):
            min_array[i] = min(min_array[i - 1], nums[i])
        
        
        for j in range(len(nums) - 1, -1, -1):
            if nums[j] &lt;= min_array[j]:
                continue
            while stack and stack[-1] &lt;= min_array[j]:
                stack.pop()
            if stack and stack[-1] &lt; nums[j]:
                return True
            stack.append(nums[j])
        return False

</code></pre>
<p>估计是用stack但是。。。看答案思路：从前往后算minarry，从后往前用stack。</p>
<h1 id="font-colorred-457-circular-array-loop-mediumfont"><font color='red'> 457. Circular Array Loop （Medium）</font></h1>
<p>You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:<br>
If nums[i] is positive, move nums[i] steps forward, and<br>
If nums[i] is negative, move nums[i] steps backward.<br>
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.<br>
A cycle in the array consists of a sequence of indices seq of length k where:<br>
Following the movement rules above results in the repeating index sequence seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...<br>
Every nums[seq[j]] is either all positive or all negative.<br>
k &gt; 1<br>
Return true if there is a cycle in nums, or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
        #two pointer
        n=len(nums)
        #check every start location
        for start in range(n):
            if nums[start]==0: continue
                
            slow=start
            fast=(slow+nums[slow])%n
            
            #if sign of fast and fast.next is the same we do the while loop
            while nums[start]*nums[fast]&gt;0 and  nums[start] * nums[(fast+nums[fast])%n] &gt; 0:
                if slow == fast:
                    if slow == (slow+nums[slow])%n:  
                        break #  1-element loop
                    return True 


                slow = (slow+nums[slow])%n
                fast = (fast+nums[fast])%n
                fast = (fast+nums[fast])%n
            
            #we are here know start from start have no loop so mark visited as 0
            slow = start 
            sgn = nums[start] 
            while sgn * nums[slow] &gt; 0:
                nxt = (slow+nums[slow])%n
                nums[slow] = 0 
                slow = nxt 

        return False
        

</code></pre>
<p>two pointer, but tricky ....if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.</p>
<h1 id="458-poor-pigs-hard">458. Poor Pigs (Hard)</h1>
<p>There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.<br>
You can feed the pigs according to these steps:<br>
Choose some live pigs to feed.<br>
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.<br>
Wait for minutesToDie minutes. You may not feed any other pigs during this time.<br>
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.<br>
Repeat this process until you run out of time.<br>
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.</p>
<pre><code class="language-python">class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
        return int(math.ceil(math.log(buckets, 2) / math.log(minutesToTest / minutesToDie + 1, 2)))
</code></pre>
<p>good to knwo but not algorithm..</p>
<h1 id="459-repeated-substring-pattern-easy">459. Repeated Substring Pattern （Easy）</h1>
<p>Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        for i in range(1,len(s)//2+1):
            if s[:i]*(len(s)//i)==s:
                return True
        return False
#ANSWER
def repeatedSubstringPattern(self, str):

        &quot;&quot;&quot;
        :type str: str
        :rtype: bool
        &quot;&quot;&quot;
        if not str:
            return False
            
        ss = (str + str)[1:-1]
        return ss.find(str) != -1
#ANSWER
def repeatedSubstringPattern(self, str):
    return s in (s+s)[1:-1]
    

</code></pre>
<p>答案思路很好， If the string S has repeated block, it could be described in terms of pattern.<br>
S = SpSp (For example, S has two repeatable block at most)<br>
If we repeat the string, then SS=SpSpSpSp.<br>
Destroying first and the last pattern by removing each character, we generate a new S2=SxSpSpSy.</p>
<h1 id="font-colorred-460-lfu-cache-hardfont"><font color='red'> 460. LFU Cache （Hard）</font></h1>
<p>Design and implement a data structure for a Least Frequently Used (LFU) cache.<br>
Implement the LFUCache class:<br>
LFUCache(int capacity) Initializes the object with the capacity of the data structure.<br>
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.<br>
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.<br>
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.<br>
When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.<br>
The functions get and put must each run in O(1) average time complexity.</p>
<pre><code class="language-python">import collections

class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.freq = 1
        self.prev = self.next = None

class DLinkedList:
    &quot;&quot;&quot; An implementation of doubly linked list.
	
	Two APIs provided:
    
    append(node): append the node to the head of the linked list.
    pop(node=None): remove the referenced node. 
                    If None is given, remove the one from tail, which is the least recently used.
                    
    Both operation, apparently, are in O(1) complexity.
    &quot;&quot;&quot;
    def __init__(self):
        self._sentinel = Node(None, None) # dummy node
        self._sentinel.next = self._sentinel.prev = self._sentinel
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def append(self, node):
        node.next = self._sentinel.next
        node.prev = self._sentinel
        node.next.prev = node
        self._sentinel.next = node
        self._size += 1
    
    def pop(self, node=None):
        if self._size == 0:
            return
        
        if not node:
            node = self._sentinel.prev

        node.prev.next = node.next
        node.next.prev = node.prev
        self._size -= 1
        
        return node
        
class LFUCache:
    def __init__(self, capacity):
        &quot;&quot;&quot;
        :type capacity: int
        
        Three things to maintain:
        
        1. a dict, named as `self._node`, for the reference of all nodes given key.
           That is, O(1) time to retrieve node given a key.
           
        2. Each frequency has a doubly linked list, store in `self._freq`, where key
           is the frequency, and value is an object of `DLinkedList`
        
        3. The min frequency through all nodes. We can maintain this in O(1) time, taking
           advantage of the fact that the frequency can only increment by 1. Use the following
		   two rules:
           
           Rule 1: Whenever we see the size of the DLinkedList of current min frequency is 0,
                   the min frequency must increment by 1.
           
           Rule 2: Whenever put in a new (key, value), the min frequency must 1 (the new node)
           
        &quot;&quot;&quot;
        self._size = 0
        self._capacity = capacity
        
        self._node = dict() # key: Node
        self._freq = collections.defaultdict(DLinkedList)
        self._minfreq = 0
        
        
    def _update(self, node):
        &quot;&quot;&quot; 
        This is a helper function that used in the following two cases:
        
            1. when `get(key)` is called; and
            2. when `put(key, value)` is called and the key exists.
         
        The common point of these two cases is that:
        
            1. no new node comes in, and
            2. the node is visited one more times -&gt; node.freq changed -&gt; 
               thus the place of this node will change
        
        The logic of this function is:
        
            1. pop the node from the old DLinkedList (with freq `f`)
            2. append the node to new DLinkedList (with freq `f+1`)
            3. if old DlinkedList has size 0 and self._minfreq is `f`,
               update self._minfreq to `f+1`
        
        All of the above opeartions took O(1) time.
        &quot;&quot;&quot;
        freq = node.freq
        
        self._freq[freq].pop(node)
        if self._minfreq == freq and not self._freq[freq]:
            self._minfreq += 1
        
        node.freq += 1
        freq = node.freq
        self._freq[freq].append(node)
    
    def get(self, key):
        &quot;&quot;&quot;
        Through checking self._node[key], we can get the node in O(1) time.
        Just performs self._update, then we can return the value of node.
        
        :type key: int
        :rtype: int
        &quot;&quot;&quot;
        if key not in self._node:
            return -1
        
        node = self._node[key]
        self._update(node)
        return node.val

    def put(self, key, value):
        &quot;&quot;&quot;
        If `key` already exists in self._node, we do the same operations as `get`, except
        updating the node.val to new value.
        
        Otherwise, the following logic will be performed
        
        1. if the cache reaches its capacity, pop the least frequently used item. (*)
        2. add new node to self._node
        3. add new node to the DLinkedList with frequency 1
        4. reset self._minfreq to 1
        
        (*) How to pop the least frequently used item? Two facts:
        
        1. we maintain the self._minfreq, the minimum possible frequency in cache.
        2. All cache with the same frequency are stored as a DLinkedList, with
           recently used order (Always append at head)
          
        Consequence? ==&gt; The tail of the DLinkedList with self._minfreq is the least
                         recently used one, pop it...
        
        :type key: int
        :type value: int
        :rtype: void
        &quot;&quot;&quot;
        if self._capacity == 0:
            return
        
        if key in self._node:
            node = self._node[key]
            self._update(node)
            node.val = value
        else:
            if self._size == self._capacity:
                node = self._freq[self._minfreq].pop()
                del self._node[node.key]
                self._size -= 1
                
            node = Node(key, value)
            self._node[key] = node
            self._freq[1].append(node)
            self._minfreq = 1
            self._size += 1


</code></pre>
<p>Each key is mapping to the corresponding node (self._node), where we can retrieve the node in O(1) time.</p>
<p>Each frequency freq is mapped to a Doubly Linked List (self._freq), where all nodes in the DLinkedList have the same frequency, freq. Moreover, each node will be always inserted in the head (indicating most recently used).</p>
<p>A minimum frequency self._minfreq is maintained to keep track of the minimum frequency of across all nodes in this cache, such that the DLinkedList with the min frequency can always be retrieved in O(1) time.</p>
<p>Here is how the algorithm works</p>
<p>get(key)</p>
<pre><code>query the node by calling self._node[key]
find the frequency by checking node.freq, assigned as f, and query the DLinkedList that this node is in, through calling self._freq[f]
pop this node
update node's frequence, append the node to the new DLinkedList with frequency f+1
if the DLinkedList is empty and self._minfreq == f, update self._minfreq to f+1.
return node.val
</code></pre>
<p>put(key, value)</p>
<pre><code>If key is already in cache, do the same thing as get(key), and update node.val as value
Otherwise:
    if the cache is full, pop the least frequenly used element (*)
    add new node to self._node
    add new node to self._freq[1]
    reset self._minfreq to 1
</code></pre>
<p>(*) The least frequently used element is the tail element in the DLinkedList with frequency self._minfreq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-05/">
        </link>
        <updated>2022-03-05T11:11:11.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="441-arranging-coins-easy">441. Arranging Coins （Easy）</h1>
<p>You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.<br>
Given the integer n, return the number of complete rows of the staircase you will build.</p>
<pre><code class="language-python">class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        r=0
        while n&gt;0:
            r+=1
            n-=r
        return r-1 if n&lt;0 else r

class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        
        # (1+ x) x /2 &lt;= n
        #      (1+x)x &lt;= 2n
        # max x which (1+x)x &lt;=2n
        
        l, r = 0, n
        
        while l &lt;= r:
            
            m = (l + r) // 2
            
            if (m+1)*m &lt;= 2*n and (m+2)*(m+1) &gt; 2*n:
                return m
            
            if (m+1)*m &lt; 2*n:
                l = m + 1
            else:
                r = m - 1
                
</code></pre>
<p>答案是binary  search啊。。</p>
<h1 id="442-find-all-duplicates-in-an-array-medium">442. Find All Duplicates in an Array （Medium）</h1>
<p>Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.<br>
You must write an algorithm that runs in O(n) time and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        # 0 1 2 3 4 5 6 7
        # 4 3 2 7 8 2 3 1
        
        # -4 3 2-7    -3-1 
        
        n=len(nums)
        
        for i in range(n):
            ind=(abs(nums[i])%n-1)
            nums[ind] =   abs(nums[ind])+n if nums[ind]&lt;0 else -abs(nums[ind])-n
        
        #print(nums)
        res=[]
        for i in range(n):
            if nums[i]&gt;n:
                res.append(i+1)
        return res

#ANSWER
class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        res=[]
        for n in nums:
            if nums[abs(n)-1]&lt;0: #seen before
                res.append(abs(n))
            
            nums[abs(n)-1]*=-1
        
        return res
</code></pre>
<p>特殊的bookkeeping。 答案写的更好</p>
<h1 id="font-colorblue-443-string-compression-medium-font"><font color='blue'> 443. String Compression （Medium） </font></h1>
<p>Given an array of characters chars, compress it using the following algorithm:<br>
Begin with an empty string s. For each group of consecutive repeating characters in chars:<br>
If the group's length is 1, append the character to s.<br>
Otherwise, append the character followed by the group's length.<br>
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.<br>
After you are done modifying the input array, return the new length of the array.<br>
You must write an algorithm that uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def compress(self, chars: List[str]) -&gt; int:
        #two pointer
        l=0
        lchar=0
        r=0
        while r&lt;len(chars):
            c=0
            while r&lt;len(chars) and chars[r]==chars[l]:
                c+=1
                r+=1
            
            if c&gt;0:r-=1
            
            if c==1:
                chars[lchar]=chars[l]
                l+=1
                lchar=lchar+1
            elif c&gt;1 and c&lt;10:
                chars[lchar]=chars[l]
                chars[lchar+1]=str(c)
                l=l+c
                lchar=lchar+2
            elif c&gt;=10:
                chars[lchar]=chars[l]
                l=l+c
                for j,cc in enumerate(str(c)):
                    chars[lchar+1+j]=cc
                 
                lchar=lchar+len(str(c))+1
            r+=1    
            
        return lchar 
#ANSWER 更简单
 
class Solution:
    def compress(self, chars: List[str]) -&gt; int:
        walker, runner = 0, 0
        while runner &lt; len(chars):
		
            chars[walker] = chars[runner]
            count = 1
			
            while runner + 1 &lt; len(chars) and chars[runner] == chars[runner+1]:
                runner += 1
                count += 1
			
            if count &gt; 1:
                for c in str(count):
                    chars[walker+1] = c
                    walker += 1
            
            runner += 1
            walker += 1
        
        return walker

</code></pre>
<p>two pointer 写出来了，但是cornercase很多边test边写的。。。。答案很简单。。。。</p>
<h1 id="font-colorred-444-sequence-reconstruction-medium-font"><font color='red'> 444. Sequence Reconstruction (Medium) </font></h1>
<p>You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.<br>
Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.<br>
For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].<br>
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.<br>
Return true if nums is the only shortest supersequence for sequences, or false otherwise.<br>
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<pre><code class="language-python">class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -&gt; bool:
        values = {x for seq in sequences for x in seq}
        graph = {x: [] for x in values}
        indegrees = {x: 0 for x in values}
        for seq in sequences:
            for i in range(len(seq) - 1):
                s = seq[i]
                t = seq[i+1]
                graph[s].append(t)
                indegrees[t] += 1
        queue = collections.deque()
        for node, count in indegrees.items():
            if count == 0:
                queue.append(node)
        res = []
        while queue:
            if len(queue) != 1:
                return False
            source = queue.popleft()
            res.append(source)
            for target in graph[source]:
                indegrees[target] -= 1
                if indegrees[target] == 0:
                    queue.append(target)
        return len(res) == len(values) and res == nums


</code></pre>
<p>感觉题就没读懂。。。。topological sort... 第一步建立dependency graph， 第二部toposort，每一步检查是否只有一个node的可能性，如果比一个多，return False。 第三步，在得到toposortlist 后，检查长度是否和sequence中所有unique 元素个数一样而且 是input nums。<br>
解释：<br>
TopSort order exists<br>
Whether the TopSort order is the only one (Uniqueness of Topological sort, Hamilton path, see https://en.wikipedia.org/wiki/Topological_sorting#Uniqueness).如果不是，那么说明有些pair只有偏序关系，没有全序关系，这样不能完全确定元素之间的顺序<br>
the only top sort order constructed should be equal to the org.</p>
<p>index == org.length (check condition 3) &amp;&amp; index == map.size() (check all the vertex in the graph has been visited, so the top sort order exists, check condition 1)</p>
<p>How to check only one order? queue.size() should always be one, then only one element at a time has indegree to be 0, so you only have one choice (check condition 2)</p>
<h1 id="font-colorblue-445-add-two-numbers-ii-medium-font"><font color='blue'> 445. Add Two Numbers II （Medium） </font></h1>
<p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.<br>
You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        l1=rev(l1)
        l2=rev(l2)
        
        carry=0
        head=ListNode(val=None)
        savehead=head
        while l1 or l2:
            v1= l1.val if l1 else 0
            v2= l2.val if l2 else 0
            val=(v1+v2+carry)%10
            carry=(v1+v2+carry)//10
            head.next=ListNode(val)
            head=head.next
            
            l1=l1.next if l1 else None
            l2=l2.next if l2 else None
            
        if carry:
            head.next=ListNode(carry)
            head=head.next
        
        return rev(savehead.next)

#
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
        
 #####
 class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
               
</code></pre>
<p>followup 是不revlist能否。。。</p>
<h1 id="font-colorred-446-arithmetic-slices-ii-subsequence-hard-font"><font color='red'> 446. Arithmetic Slices II - Subsequence (Hard) </font></h1>
<p>Given an integer array nums, return the number of all the arithmetic subsequences of nums.<br>
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.<br>
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.<br>
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.<br>
For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].<br>
The test cases are generated so that the answer fits in 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        
        #f[i][d] denotes the number of weak arithmetic subsequences that ends with A[i] and its common difference is d.
        #Now the state transitions are quite straightforward:

        # for all j &lt; i, f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1).
        # The 1 appears here because we can form a new weak arithmetic subsequence for the pair (i, j)
        
        #when we are appending new elements to existing weak arithmetic subsequences, we are forming arithmetic subsequences. So the first part, f[j][A[i] - A[j]] is the number of new formed arithmetic subsequences, and can be added to the answer.

        
        n=len(nums)
        res=0
        cnt=dict()
        for i in range(n):
            cnt[i]=dict()
            for j in range(i):
                delta=nums[i]-nums[j]
                
                diff=delta
                sum_=cnt[j].get(diff,0)
                origin=cnt[i].get(diff,0)
                cnt[i][diff]=origin+sum_+1
                res+=sum_
        return res
</code></pre>
<p>是应该用DP但看答案。。。答案这个DP解法不是一般的DP。。。先dp【i】【diff】是以ith nums为最终位置的weak arithmetic subsequences的个数，这个weak值2个元素也能形成subsequence。 要想得到真正的3个元素的arithmetic subsequences个数，每次可以把nums【i】添加到dp【j】【diff】时候这个dp【j】【diff】个数就是arithmetic subsequences个数。很难想到这个方法啊。。。<br>
backtracking 方法超时</p>
<pre><code class="language-java">class Solution {
    private int n;
    private int ans;
    private void dfs(int dep, int[] A, List&lt;Long&gt; cur) {
        if (dep == n) {
            if (cur.size() &lt; 3) {
                return;
            }
            long diff = cur.get(1) - cur.get(0);
            for (int i = 1; i &lt; cur.size(); i++) {                
                if (cur.get(i) - cur.get(i - 1) != diff) {
                    return;
                }
            }
            ans ++;
            return;
        }
        dfs(dep + 1, A, cur);
        cur.add((long)A[dep]);
        dfs(dep + 1, A, cur);
        cur.remove((long)A[dep]);
    }
    public int numberOfArithmeticSlices(int[] A) {
        n = A.length;
        ans = 0;
        List&lt;Long&gt; cur = new ArrayList&lt;Long&gt;();
        dfs(0, A, cur);
        return (int)ans;        
    }
}
</code></pre>
<h1 id="font-colorblue-447-number-of-boomerangs-medium-font"><font color='blue'> 447. Number of Boomerangs (Medium) </font></h1>
<p>You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).<br>
Return the number of boomerangs.</p>
<pre><code class="language-python">class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        
        def dis(p1,p2):
            return (p1[0]-p2[0])**2+(p1[1]-p2[1])**2
        
        
        dic=collections.defaultdict(set)
        
        for i,p1 in enumerate(points):
            for j,p2 in enumerate(points):
                if i!=j:
                    dic[dis(p1,p2)].add((i,j))
                    dic[dis(p1,p2)].add((j,i))
        #print(dic)
        res=0
        for k, s in dic.items():
            #find i,j i,k
            d=dict()
            for t in s:
                d[t[0]]=d.get(t[0],0)+1
            
            #print(d)
            
            for key,val in d.items():
                res+= val*(val-1) if val&gt;1 else 0
        
        return res
#ANSWER 同样思路但超级简单
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        res = 0
        for p in points:
            cmap = {}
            for q in points:
                f = p[0]-q[0]
                s = p[1]-q[1]
                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)
            for k in cmap:
                res += cmap[k] * (cmap[k] -1)
        return res
</code></pre>
<p>pass了 hashmap先按照距离分类， 然后每个距离下按照起始点分类，比如距离为1下 其实点为0的edge总共有n个，那么组成三角形能组成n*n-1个。</p>
<h1 id="448-find-all-numbers-disappeared-in-an-array-easy">448. Find All Numbers Disappeared in an Array (Easy)</h1>
<pre><code class="language-python">class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]:
        #
        n=len(nums)
        
        for i in range(n):
            ind = abs(nums[i])-1
            nums[ind]=-abs(nums[ind])
        
        res=[]
        for i in range(n):
            if nums[i]&gt;0:
                res.append(i+1)
        return res

</code></pre>
<h1 id="449-serialize-and-deserialize-bst-medium">449. Serialize and Deserialize BST (Medium)</h1>
<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.<br>
The encoded string should be as compact as possible.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: Optional[TreeNode]) -&gt; str:
        &quot;&quot;&quot;Encodes a tree to a single string.
        &quot;&quot;&quot;
        res=[]
        def pre(root):
            if not root: 
                res.append('#')
                return
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
        return ','.join(res)
        

    def deserialize(self, data: str) -&gt; Optional[TreeNode]:
        &quot;&quot;&quot;Decodes your encoded data to tree.
        &quot;&quot;&quot;
        data=data.split(',')
        def pre(data):
            if not data: return None
            cur=data.pop(0) 
            root=None
            if cur!='#':
                root=TreeNode(int(cur))
            
            if root and data:
                root.left=pre(data)
            if root and data:
                root.right=pre(data)
            return root
        return pre(data)
            
#答案用postorder compressed string 更好
class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;
        Encodes a tree to a single string.
        &quot;&quot;&quot;
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        &quot;&quot;&quot;
        Decodes your encoded data to tree.
        &quot;&quot;&quot;
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] &lt; lower or data[-1] &gt; upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()
</code></pre>
<p>用的pre order encode没想到写出来了。。。</p>
<h1 id="font-colorred-450-delete-node-in-a-bst-mediumfont"><font color='red'> 450. Delete Node in a BST （Medium）</font></h1>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.<br>
Basically, the deletion can be divided into two stages:<br>
Search for a node to remove.<br>
If the node is found, delete the node.</p>
<pre><code class="language-python">class Solution:
    def successor(self, root):
        &quot;&quot;&quot;
        One step right and then always left
        &quot;&quot;&quot;
        root = root.right
        while root.left:
            root = root.left
        return root.val
    
    def predecessor(self, root):
        &quot;&quot;&quot;
        One step left and then always right
        &quot;&quot;&quot;
        root = root.left
        while root.right:
            root = root.right
        return root.val
        
    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:
        if not root:
            return None
        
        # delete from the right subtree
        if key &gt; root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key &lt; root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # the node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root

</code></pre>
<p>这个是很经典的一个题目。recursion方法很经典。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-04]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-04/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-04/">
        </link>
        <updated>2022-03-04T14:13:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="431-encode-n-ary-tree-to-binary-tree-hard">431. Encode N-ary Tree to Binary Tree （Hard）</h1>
<p>Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
&quot;&quot;&quot;

class Codec:
    # Encodes an n-ary tree to a binary tree.
    def encode(self, root: 'Optional[Node]') -&gt; Optional[TreeNode]:
        if not root: return []
        rootnode = TreeNode(root.val)
        return_rootnode=rootnode
       
        first=True
        for node in root.children:
            if first:
                first=False
                rootnode.left=self.encode(node)
                rootnode=rootnode.left
            else:
                rootnode.right=self.encode(node)
                rootnode=rootnode.right
        
        return return_rootnode
	
	# Decodes your binary tree to an n-ary tree.
    def decode(self, data: Optional[TreeNode]) -&gt; 'Optional[Node]':
        if not data: return None
        #print(data)
        #print('#'*20)
        root=data
        root_node=Node(root.val,[])
        if root.left:
            root_node.children.append(self.decode(root.left))
            root=root.left
            while root.right:
                root_node.children.append(self.decode(root.right))
                root=root.right
        
        return root_node
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(root))


#ANSWER 
class Codec:

    def encode(self, root):
        if not root:
            return None

        binary = TreeNode(root.val)                 # create a binary root
        if not root.children:
            return binary
        #Python - left child for children, right child for siblings
        
        binary.left = self.encode(root.children[0]) # left child of binary is the encoding of all n-ary children,
        node = binary.left                          #     starting with the first child.
        for child in root.children[1:]:             # other children of n-ary root are right child of previous child
            node.right = self.encode(child)
            node = node.right

        return binary

    def decode(self, data):
        if not data:
            return None

        nary = Node(data.val, [])                   # create n-ary root
        node = data.left                            # move to first child of n-ary root
        while node:                                 # while more children of n-ary root
            nary.children.append(self.decode(node)) # append to list
            node = node.right                       # and move to next child
            
        return nary
        
</code></pre>
<p>我得方法，把所有孩子都包含在下一层，  root的left通向下一层，root.left.right和之后所有的right都是同一层的保存孩子。</p>
<h1 id="font-colorred-432-all-oone-data-structure-hardfont"><font color='red'> 432. All O`one Data Structure （Hard）</font></h1>
<p>Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.<br>
Implement the AllOne class:<br>
AllOne() Initializes the object of the data structure.<br>
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.<br>
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.<br>
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string &quot;&quot;.<br>
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">from collections import defaultdict
class Node(object):
    def __init__(self):
        self.key_set = set([])
        self.prev, self.nxt = None, None 

    def add_key(self, key):
        self.key_set.add(key)

    def remove_key(self, key):
        self.key_set.remove(key)        

    def get_any_key(self):
        if self.key_set:
            result = self.key_set.pop()
            self.add_key(result)
            return result
        else:
            return None
    
    def count(self):
        return len(self.key_set)

    def is_empty(self):
        return len(self.key_set) == 0


class DoubleLinkedList(object):
    def __init__(self):
        self.head_node, self.tail_node = Node(), Node()
        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node
        return

    def insert_after(self, x):
        node, temp = Node(), x.nxt
        x.nxt, node.prev = node, x
        node.nxt, temp.prev = temp, node
        return node
    
    def insert_before(self, x):
        return self.insert_after(x.prev)

    def remove(self, x):
        prev_node = x.prev
        prev_node.nxt, x.nxt.prev = x.nxt, prev_node
        return

    def get_head(self):
        return self.head_node.nxt
    
    def get_tail(self):
        return self.tail_node.prev

    def get_sentinel_head(self):
        return self.head_node

    def get_sentinel_tail(self):
        return self.tail_node
    
class AllOne(object):
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)
        self.node_freq = {0:self.dll.get_sentinel_head()}

    def _rmv_key_pf_node(self, pf, key):
        node = self.node_freq[pf]
        node.remove_key(key)
        if node.is_empty():
            self.dll.remove(node)
            self.node_freq.pop(pf)
        return

    def inc(self, key):
        &quot;&quot;&quot;
        Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        self.key_counter[key] += 1
        cf, pf = self.key_counter[key], self.key_counter[key]-1
        if cf not in self.node_freq:
            # No need to test if pf = 0 since frequency zero points to sentinel node
            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])
        self.node_freq[cf].add_key(key)
        if pf &gt; 0:
            self._rmv_key_pf_node(pf, key)

    def dec(self, key):
        &quot;&quot;&quot;
        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        if key in self.key_counter:
            self.key_counter[key] -= 1
            cf, pf = self.key_counter[key], self.key_counter[key]+1
            if self.key_counter[key] == 0:
                self.key_counter.pop(key)
            if cf != 0:
                if cf not in self.node_freq:
                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])
                self.node_freq[cf].add_key(key)
            self._rmv_key_pf_node(pf, key)

    def getMaxKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with maximal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;

    def getMinKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with Minimal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;




</code></pre>
<p>感觉是个maxheap minheap。。。但不是all o（1）。。。 看答案了。。。答案果然完美</p>
<h1 id="433-minimum-genetic-mutation-medium">433. Minimum Genetic Mutation (Medium)</h1>
<p>A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.<br>
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.<br>
For example, &quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; is one mutation.<br>
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.<br>
Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.<br>
Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<pre><code class="language-python">class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        #BFS search neighbor
        # neighor is 1 char off current also in bank
        if   end not in bank: return -1
        if not bank and start!=end: return -1
        bank=set(bank)
        bank.add(end)
        q=[]
        visited=set()
        def nei(me):
            neighbors=[]
            for other in bank:
                if other not in visited:
                    valid=0
                    for a,b in zip(me,other):
                        valid+=bool(ord(a)^ord(b))
                    if valid==1:
                        neighbors.append(other)
            return neighbors
        
        
        q.append(start)
        visited.add(start)
        level=0
        while q:
            level+=1
            for _ in range(len(q)):
                cur=q.pop(0)
                print(cur,nei(cur))
                for ne in nei(cur):
                    if ne==end: return level
                    visited.add(ne)
                    q.append(ne)
        
        return  -1
        
#ANSWER
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        &quot;&quot;&quot;
        :type start: str
        :type end: str
        :type bank: List[str]
        :rtype: int
        &quot;&quot;&quot;
        queue = []
        queue.append((start,0))
        bankSet = set(bank)
        
        while queue:
            curr, step = queue.pop(0)
            if curr == end:
                return step
            for i in range(len(curr)):
                for c in &quot;AGCT&quot;:
                    mutation = curr[:i] + c + curr[i+1:]
                    if mutation in bankSet:
                        bankSet.remove(mutation)
                        queue.append((mutation,step+1))
                        
        return -1
        
</code></pre>
<p>bfs注意corner case，end必须in bank。 答案用remove mutaton方式避免用visited set，而且mutaion是直接算的，不是从bank中找的。</p>
<h1 id="434-number-of-segments-in-a-string-easy">434. Number of Segments in a String （Easy）</h1>
<p>Given a string s, return the number of segments in the string.<br>
A segment is defined to be a contiguous sequence of non-space characters.</p>
<pre><code class="language-python">class Solution:
    def countSegments(self, s: str) -&gt; int:
        beforeisspace=True
        c=0
        while s:
            if s[0]==' ':
                s=s[1:]
                beforeisspace=True
            else:
                if beforeisspace:
                    c+=1
                    beforeisspace=False
                
                s=s[1:]
        return c

class Solution:
    def countSegments(self, s: str) -&gt; int:
        return len(s.split())

class Solution:
    def countSegments(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':
                segment_count += 1

        return segment_count
</code></pre>
<h1 id="font-colorred-435-non-overlapping-intervals-medium-font"><font color='red'> 435. Non-overlapping Intervals (Medium) </font></h1>
<p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<pre><code class="language-python">class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        #sort by start
        # [1,2] [1,3] [2,3],[3,4]
        #sort by end
        # 找最小删除相当于找最大不overlap有多少个interval
        #变成dp问题 dp[i]是最大的interval个数 用到ith interval
        # dp【i】= max（dp【j】）+1 j&lt;i  interval i，j不overlap
        intervals=sorted(intervals,key=lambda x:x[0])
        dp = [0]*len(intervals)
        dp[0]=1
        ans=1
        for i in range(1,len(dp)):
            max_=0
            for j in range(i):
                if intervals[j][1]&lt;=intervals[i][0]:
                    max_=max(dp[j],max_)
            
            dp[i]=max_+1
            ans=max(ans,dp[i])
        return len(intervals)-ans

#PASS ANSWER
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
 
        intervals=sorted(intervals,key=lambda x:x[0])
        end=intervals[0][1]
        prev=0
        c=0
        for i in range(1,len(intervals)):
            if intervals[prev][1]&gt;intervals[i][0]:
                #overlap
                if intervals[prev][1]&gt;intervals[i][1]:
                    #include,bust del prev so c+=1 prev renew to i
                    prev=i
                
                #if pure overlap do greedy, prev still the same, del i, c+=1
                c+=1
            else:
                #case 1 two interval non overlapping
                prev=i
                
        return c
</code></pre>
<p>没想出来如何处理~~ DP可以n^2， greedy也可以，Greedy nlogn</p>
<h1 id="font-colorred-436-find-right-interval-medium-font"><font color='red'> 436. Find Right Interval (Medium) </font></h1>
<p>You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.<br>
The right interval for an interval i is an interval j such that startj &gt;= endi and startj is minimized. Note that i may equal j.<br>
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        maps=dict()
        for i,interval in enumerate(intervals):
            maps[tuple(interval)]=i
        
        ans=[-1]*len(intervals)
        intervals=sorted(intervals,key=lambda x:x[0])
        for i in range(len(intervals)-1):
            #i's right
            j=i+1
            while j&lt;len(intervals) and intervals[j][0]&lt;intervals[i][1]:
                j+=1
            if j&lt;len(intervals):
                ans[maps[tuple(intervals[i])]]=maps[tuple(intervals[j])]
        return ans


#ANSWER BINARY SERACH 

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        
        l = sorted((e[0], i) for i, e in enumerate(intervals))
        res = []
        for e in intervals:
            r = bisect.bisect_left(l, (e[1],))
            res.append(l[r][1] if r &lt; len(l) else -1)
        return res

#Heap法
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        heap, result = [], [-1] * len(intervals)
        for idx, interval in sorted(enumerate(intervals), key=lambda enum: enum[1][0]):
            while heap and heap[0][0] &lt;= interval[0]:
                _, i = heapq.heappop(heap)
                if intervals[i][0]!=intervals[i][1]:
                    result[i] = idx
                else:
                    result[i] = i
            heapq.heappush(heap, (interval[1], idx))
        return result
</code></pre>
<p>初次尝试 time limit exceeded 答案的bianry search法太厉害。</p>
<h1 id="font-colorblue-437-path-sum-iii-medium-font"><font color='blue'> 437. Path Sum III （Medium） </font></h1>
<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.<br>
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:
        #post order  botoom up save node val
        
        c=[0]
        def post(root):
            if not root: return 
            post(root.left)
            post(root.right)
            root.vals=defaultdict(int)
            if root.left:
                for v in root.left.vals:
                    root.vals[v+root.val]+=root.left.vals[v]
            if root.right:
                for v in root.right.vals:
                    root.vals[v+root.val]+=root.right.vals[v]
            root.vals[root.val]+=1
            if targetSum in root.vals:
                #print(root.val,root.vals)
                c[0]+=root.vals[targetSum]
       
        post(root)
        return c[0]  
#ANSWER PREFIX SUM in tree
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; int:
        def preorder(node: TreeNode, curr_sum) -&gt; None:
            nonlocal count
            if not node:
                return 
            
            # current prefix sum
            curr_sum += node.val
            
            # here is the sum we're looking for
            if curr_sum == k:
                count += 1
            
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a path with sum k 
            # has occurred up to the current node
            count += h[curr_sum - k]
            
            # add the current sum into hashmap
            # to use it during the child nodes processing
            h[curr_sum] += 1
            
            # process left subtree
            preorder(node.left, curr_sum)
            # process right subtree
            preorder(node.right, curr_sum)
            
            # remove the current sum from the hashmap
            # in order not to use it during 
            # the parallel subtree processing
            h[curr_sum] -= 1
            
        count, k = 0, sum
        h = defaultdict(int)
        preorder(root, 0)
        return count       

#上面这个解决方法基于
class Solution:
    def subarraySum(self, nums, k):
        count = curr_sum = 0
        h = defaultdict(int)
        
        for num in nums:
            # current prefix sum
            curr_sum += num
            
            # situation 1:
            # continuous subarray starts 
            # from the beginning of the array
            if curr_sum == k:
                count += 1
            
            # situation 2:
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a subarray with sum k 
            # has occurred up to the current index
            count += h[curr_sum - k]
            
            # add the current sum
            h[curr_sum] += 1
                
        return count
</code></pre>
<p>我的解决方案是post order bottom up 扫，每个node存可以生成的pathsum值。答案是prefixsum。。</p>
<h1 id="438-find-all-anagrams-in-a-string-medium">438. Find All Anagrams in a String （Medium）</h1>
<p>Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.<br>
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br>
Input: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;<br>
Output: [0,6]<br>
Explanation:<br>
The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.<br>
The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</p>
<pre><code class="language-python">class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        if len(s)&lt;len(p): return []
        dicp=collections.Counter(p)
        lp=len(p)
        dic=dict()
        for i in range(lp):
            dic[s[i]]=dic.get(s[i],0)+1
        res=[]
        if dic==dicp: res.append(0)
        for i in range(lp,len(s)):
            #remove first
            dic[s[i-lp]]-=1
            if dic[s[i-lp]]==0:
                del  dic[s[i-lp]]
            #add last
            dic[s[i]]=dic.get(s[i],0)+1
            #
            if dic==dicp:
                res.append(i-lp+1)
        return res
            
#ANSWER 写的更简单
from collections import Counter
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count = Counter(p)
        s_count = Counter()
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[s[i]] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                if s_count[s[i - np]] == 1:
                    del s_count[s[i - np]]
                else:
                    s_count[s[i - np]] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output

#ANSWER
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count, s_count = [0] * 26, [0] * 26
        # build reference array using string p
        for ch in p:
            p_count[ord(ch) - ord('a')] += 1
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[ord(s[i]) - ord('a')] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                s_count[ord(s[i - np]) - ord('a')] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output
</code></pre>
<p>sliding window保持counter dict和p一样就可以。。。</p>
<h1 id="font-colorred-439-ternary-expression-parser-medium-font"><font color='red'> 439. Ternary Expression Parser （Medium） </font></h1>
<p>Given a string expression representing arbitrarily nested ternary expressions, evaluate the expression, and return the result of it.<br>
You can always assume that the given expression is valid and only contains digits, '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers in the expression are one-digit numbers (i.e., in the range [0, 9]).<br>
The conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, 'T' or 'F'.</p>
<pre><code class="language-python">class Solution:
    def parseTernary(self, expression: str) -&gt; str:
        #思路用stack，而且从后向前iterate
        #T?a:b
        if not expression: return expression
        stack=[]
        for char in expression[::-1]:
            if stack and stack[-1]=='?':
                stack.pop() #?
                first=stack.pop()
                stack.pop() #:
                second=stack.pop()
                
                if char=='T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(char)
        #print(stack)
        return stack[-1]
</code></pre>
<p>T？（a）：（b） 形式，但a，b可以包含再包含。。。很难分辨哪个冒号是分界线。 用stack应该，看答案。关键是从后向前。</p>
<h1 id="font-colorred-440-k-th-smallest-in-lexicographical-order-hardfont"><font color='red'> 440. K-th Smallest in Lexicographical Order （Hard）</font></h1>
<p>Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].<br>
Example 1:<br>
Input: n = 13, k = 2<br>
Output: 10<br>
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.</p>
<pre><code class="language-python">class Solution:
    def findKthNumber(self, n: int, k: int) -&gt; int:
        class Trie:
            def __init__(self):
                self.children=collections.defaultdict(Trie)
                self.val=0
        trie=Trie()
        
        def insert(i):
            i=str(i)
            root=trie
            while i:
                cur=i[0]
                root=root.children[cur]
                root.val+=1
                i=i[1:]
        for i in range(1,n+1):
            insert(i)
        
        path=[]
        def search(k):
            current_rank=0
            children=trie.children
            i=0
            while current_rank&lt;k:
                key=sorted(children)[i]
                if children[key].val+current_rank&lt;k:
                    current_rank+=children[key].val
                    i+=1
                else:
                    path.append(key)
                    current_rank+=1
                    children=children[key].children
                    i=0
                
                
                 
                
                        
        search(k)
        return int(''.join(path))
        
        
        
        
#ANSWER
'''
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.
'''
def findKthNumber(self, n, k):
        cur = 1
        k = k - 1
        while k &gt; 0:
            steps = self.calSteps(n, cur)
            if steps &lt;= k:
                cur += 1
                k -= steps
            else:
                cur *= 10
                k -= 1
        return cur

    def calSteps(self, n, cur):
        steps = 0
        n1, n2 = cur, cur + 1
        while n1 &lt;= n:
            steps += min(n + 1, n2) - n1
            n1 *= 10
            n2 *= 10
        return steps
</code></pre>
<p>根据提示用了trie，思路是对的，但是写seasrch func时候卡住了，given k，what is the node positon of kth node。就算写出来也是TLE。。。看答案。</p>
<p>Main function<br>
Firstly, calculate how many steps curr need to move to curr + 1.</p>
<pre><code>if the steps &lt;= k, we know we can move to curr + 1, and narrow down k to k - steps.

else if the steps &gt; k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.
</code></pre>
<p>calSteps function</p>
<pre><code>how to calculate the steps between curr and curr + 1?
Here we come up a idea to calculate by level.
Let n1 = curr, n2 = curr + 1.
n2 is always the next right node beside n1's right most node (who shares the same ancestor &quot;curr&quot;)
(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).

so, if n2 &lt;= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.

else if n2 &gt; n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to steps.

organize this flow to &quot;steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;&quot;
</code></pre>
<p>Here is the code snippet:</p>
<p>public int findKthNumber(int n, int k) {<br>
int curr = 1;<br>
k = k - 1;<br>
while (k &gt; 0) {<br>
int steps = calSteps(n, curr, curr + 1);<br>
if (steps &lt;= k) {<br>
curr += 1;<br>
k -= steps;<br>
} else {<br>
curr *= 10;<br>
k -= 1;<br>
}<br>
}<br>
return curr;<br>
}<br>
//use long in case of overflow<br>
public int calSteps(int n, long n1, long n2) {<br>
int steps = 0;<br>
while (n1 &lt;= n) {<br>
steps += Math.min(n + 1, n2) - n1;<br>
n1 *= 10;<br>
n2 *= 10;<br>
}<br>
return steps;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-03/">
        </link>
        <updated>2022-03-02T16:44:15.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-421-maximum-xor-of-two-numbers-in-an-array-mediumfont"><font color='red'> 421. Maximum XOR of Two Numbers in an Array （Medium）</font></h1>
<p>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.</p>
<pre><code class="language-python"> class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        res=0
        L=len(bin(max(nums)))-2
        for i in range(L-1,-1,-1):
            res &lt;&lt;=1
            cur_xor = res | 1
            prefixes = {n &gt;&gt; i  for n in nums}
            res |= any(cur_xor^p in prefixes for p in prefixes)
        return res
        
class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        L = len(bin(max(nums))) - 2
        max_xor = 0
        
        for i in reversed(range(L)):
            max_xor &lt;&lt;= 1
            # Set comprehension is used for speed purposes
            # List comprehension is what most pythonic users are used too imo
            prefixes = {num &gt;&gt; i for num in nums}
            curr_xor = max_xor | 1
            
            for p in prefixes:
                # if p1 ^ p2 == curr_xor then
                # p1 ^ curr_xor == p2 ( p2 is in prefixes)
                if p ^ curr_xor in prefixes:
                    # Set the last bit to 1
                    max_xor |= 1
                    
            
        return max_xor
</code></pre>
<p>没思路，看答案。</p>
<h1 id="422-valid-word-square-easy">422. Valid Word Square (Easy)</h1>
<p>Given an array of strings words, return true if it forms a valid word square.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).</p>
<pre><code class="language-python">class Solution:
    def validWordSquare(self, words: List[str]) -&gt; bool:
        rows=len(words)
        cols=max(map(len,words))
        for i,w in enumerate(words):
            if len(w)!=cols:
                words[i]=w+'#'*(cols-len(w))
        if rows!=cols: return False   
        
        for row in range(rows):
            for col in range(cols):
                if row&gt;col:
                    if words[row][col]!=words[col][row]:
                        return False
        return True


public class Solution {
    public boolean validWordSquare(List&lt;String&gt; words) {
        if(words == null || words.size() == 0){
            return true;
        }
        int n = words.size();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;words.get(i).length(); j++){
                if(j &gt;= n || words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j))
                    return false;
            }
        }
        return true;
    }
}
</code></pre>
<p>有corner case。。。Java 答案更正确</p>
<h1 id="font-colorred-423-reconstruct-original-digits-from-english-medium-font"><font color='red'> 423. Reconstruct Original Digits from English （Medium) </font></h1>
<p>Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.</p>
<pre><code class="language-python">class Solution:
    def originalDigits(self, s: 'str') -&gt; 'str':
        # building hashmap letter -&gt; its frequency
        count = collections.Counter(s)
        
        # building hashmap digit -&gt; its frequency 
        out = {}
        # letter &quot;z&quot; is present only in &quot;zero&quot;
        out[&quot;0&quot;] = count[&quot;z&quot;]
        # letter &quot;w&quot; is present only in &quot;two&quot;
        out[&quot;2&quot;] = count[&quot;w&quot;]
        # letter &quot;u&quot; is present only in &quot;four&quot;
        out[&quot;4&quot;] = count[&quot;u&quot;]
        # letter &quot;x&quot; is present only in &quot;six&quot;
        out[&quot;6&quot;] = count[&quot;x&quot;]
        # letter &quot;g&quot; is present only in &quot;eight&quot;
        out[&quot;8&quot;] = count[&quot;g&quot;]
        # letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;
        out[&quot;3&quot;] = count[&quot;h&quot;] - out[&quot;8&quot;]
        # letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;
        out[&quot;5&quot;] = count[&quot;f&quot;] - out[&quot;4&quot;]
        # letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;
        out[&quot;7&quot;] = count[&quot;s&quot;] - out[&quot;6&quot;]
        # letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;
        out[&quot;9&quot;] = count[&quot;i&quot;] - out[&quot;5&quot;] - out[&quot;6&quot;] - out[&quot;8&quot;]
        # letter &quot;n&quot; is present in &quot;one&quot;, &quot;nine&quot;, and &quot;seven&quot;
        out[&quot;1&quot;] = count[&quot;n&quot;] - out[&quot;7&quot;] - 2 * out[&quot;9&quot;]

        # building output string
        output = [key * out[key] for key in sorted(out.keys())]
        return &quot;&quot;.join(output)
</code></pre>
<p>直接做会出现是否要再次使用当前数字然后继续，或者直接使用下个数字，当前数字不重复使用的问题。<br>
解决方法。。。醉了</p>
<pre><code>Letter &quot;z&quot; is present only in &quot;zero&quot;.
Letter &quot;w&quot; is present only in &quot;two&quot;.
Letter &quot;u&quot; is present only in &quot;four&quot;.
Letter &quot;x&quot; is present only in &quot;six&quot;.
Letter &quot;g&quot; is present only in &quot;eight&quot;.

Hence there is a good way to count even numbers.
</code></pre>
<p>That is actually the key how to count 3s, 5s and 7s since some letters are present only in one odd and one even number (and all even numbers has already been counted) :</p>
<pre><code>Letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;.
Letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;.
Letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;.
</code></pre>
<p>Now one needs to count 9s and 1s only, and the logic is basically the same :</p>
<pre><code>Letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;.
Letter &quot;n&quot; is present in &quot;one&quot;, &quot;seven&quot;, and &quot;nine&quot;.
</code></pre>
<h1 id="font-colorred-424-longest-repeating-character-replacement-mediumfont"><font color='red'> 424. Longest Repeating Character Replacement （Medium）</font></h1>
<p>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.<br>
Return the length of the longest substring containing the same letter you can get after performing the above operations.</p>
<pre><code class="language-python">class Solution:
    def characterReplacement(self, s: str, k: int) -&gt; int:
        #   p
        # AABCBBA  k=2
        #       p
        #
        l = len(s)
        count = [0]*26
        start = 0
        maxCount = 0
        maxLength = 0
        for end in range(l):
            count[ord(s[end]) - ord('A')]+=1
            maxCount = max(maxCount, count[ord(s[end]) - ord('A')])
            while end - start + 1 - maxCount &gt; k:
                count[ord(s[start]) - ord('A')]-=1
                start+=1
            
            maxLength = max(maxLength, end - start + 1);
        
        return maxLength
</code></pre>
<p>感觉用dp的。。 感觉不对好像，提示是用two pointer sliding window， 不死磕看答案。<br>
end-start+1 = size of the current window<br>
maxCount = largest count of a single, unique character in the current window<br>
The main equation is: end-start+1-maxCount</p>
<h1 id="font-colorblue-425-word-squares-hard-font"><font  color='blue'> 425. Word Squares (Hard) </font></h1>
<p>Given an array of unique strings words, return all the word squares you can build from words. The same word from words can be used multiple times. You can return the answer in any order.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).<br>
For example, the word sequence [&quot;ball&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;] forms a word square because each word reads the same both horizontally and vertically.</p>
<pre><code class="language-python">class Solution:
    def wordSquares(self, words: List[str]) -&gt; List[List[str]]:
        # a b c d
        # b d e f
        # c e g h 
        # d f h k
        
        # select abcd
        # next must select b
        # select abcd
        #        bdef
        # next must select ce
        # select abcd
        #        bdef
        #        cegh
        # next must selct dfh
        # select abcd
        #        bdef
        #        cegh
        #        dfhk
        #
        # need a trie tree to find prefix is valid or not
        # if valid prefix, for childern path, need to explore all possible combinations using bt
        
        class Trie:
            def __init__(self):
                self.children=dict()
                self.words=set()
                
            def search(self,string):
                if not string: return True
                if string[0] not in self.children:
                    return False
                return self.children[string[0]].search(string[1:])
            
            def getwords(self,string):
                if string is False: return True
                if len(string)==1:
                    return self.children[string].words
                
                return self.children[string[0]].getwords(string[1:])
                
                
        trie=Trie()
        #insert words to trie
        for word in words:
            cur=trie
            for w in word:
                if w not in cur.children:
                    cur.children[w] = Trie()
                cur.words.add(word)
                cur=cur.children[w]
            
        
        res=[]
        size=len(words[0])
        
        def bt(tmp,words):
            #backtracking to generate all possible word squares
            if len(tmp)==size:
                res.append(tmp[:])
                return
            if not words: return
            
            for word in words:
                tmp.append(word)
                level=len(tmp)
                searchkey=''.join([e[level] for e in tmp]) if level&lt;size else False
                if trie.search(searchkey):
                    validwords=trie.getwords(searchkey)
                    bt(tmp,validwords)
                tmp.pop()
        
        bt([],set(words))
        
        return res

#ANSWER is faster...
class Solution:
    def wordSquares(self, words: 'List[str]') -&gt; 'List[List[str]]':
        
        dic= collections.defaultdict(list)
        n=len(words[0])
        for word in words:
            for i in range(1,n):
                key=word[:i]
                dic[key].append(word)
        
        res=[]        
        def build(squre):
            #print(len(squre))
            if len(squre)==n:
                res.append(squre)
                return
            #print(n,len(squre),squre)
            for word in dic[''.join(list(zip(*squre))[len(squre)])]:
                new=squre[:]
                new.append(word)
                build(new)
        
        for word in words:
            build([word])
        
        return res
</code></pre>
<p>很明显backtracking问题。。。unbelievable 做出来了。。。</p>
<h1 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list-medium">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium)</h1>
<p>Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.<br>
You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br>
We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
&quot;&quot;&quot;

class Solution:
    def treeToDoublyList(self, root: 'Optional[Node]') -&gt; 'Optional[Node]':
        if not root: return root
        stack=[]
        head=None
        pre=None
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            cur=stack.pop()
            if head is None: head=cur
            cur.left=pre
            if pre:
                pre.right=cur 
            pre=cur
            
            root=cur.right
        
        
        #print(head.val, pre.val)
        
        head.left=pre
        pre.right=head
        
        return head


#ANSER RECURSION METHOD
class Solution:
    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':
        def helper(node):
            &quot;&quot;&quot;
            Performs standard inorder traversal:
            left -&gt; node -&gt; right
            and links all nodes into DLL
            &quot;&quot;&quot;
            nonlocal last, first
            if node:
                # left
                helper(node.left)
                # node 
                if last:
                    # link the previous node (last)
                    # with the current one (node)
                    last.right = node
                    node.left = last
                else:
                    # keep the smallest node
                    # to close DLL later on
                    first = node        
                last = node
                # right
                helper(node.right)
        
        if not root:
            return None
        
        # the smallest (first) and the largest (last) nodes
        first, last = None, None
        helper(root)
        # close DLL
        last.right = first
        first.left = last
        return first
</code></pre>
<p>corner case 要想清楚。。 而且node要call right left时候node必须存在。</p>
<h1 id="427-construct-quad-tree-medium">427. Construct Quad Tree （Medium）</h1>
<p>Given a n * n matrix grid of 0's and 1's only. We want to represent the grid with a Quad-Tree.<br>
Return the root of the Quad-Tree representing the grid.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
&quot;&quot;&quot;

class Solution:
    def construct(self, grid: List[List[int]]) -&gt; 'Node':
        size=len(grid)
        if len({e for row in grid for e in row})==1:
            val=grid[0][0]==1
            isLeaf=True
            topLeft=None
            topRight=None
            bottomLeft=None
            bottomRight=None
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)
        else:
            isLeaf=False
            val=True
            topLeft=self.construct([row[:size//2] for row in grid[:size//2]])
            topRight=self.construct([row[size//2:] for row in grid[:size//2]])
            bottomLeft=self.construct([row[:size//2] for row in grid[size//2:]])
            bottomRight=self.construct([row[size//2:] for row in grid[size//2:]])
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)

</code></pre>
<h1 id="font-colorred-428-serialize-and-deserialize-n-ary-tree-hard-font"><font color='red'> 428. Serialize and Deserialize N-ary Tree (Hard) </font></h1>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        &quot;&quot;&quot;
        r=[]
        if not root: return r
        q=[root]
        while q:
            node=q.pop(0)
            if node !=',':
                r.append(str(node.val))
                for child in node.children:
                    q.append(child)
                q.append(',')
            else:
                r.append(',')
                
        return '#'.join(r)
        
 
    
    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        &quot;&quot;&quot;
        if not data: return None
        pieces=data.split('#')
        root = Node(int(pieces[0]), [])
        idx = 1
        q=[root]
        while q:
            node=q.pop(0)
            while pieces[idx] != ',':
                child=Node(int(pieces[idx]), [])
                node.children.append(child)
                q.append(child)
                idx += 1
            idx += 1
        return root
# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
</code></pre>
<p>first try failed， 若val可以重复，以val为key找parent的方法不再适用。 看答案。</p>
<h1 id="429-n-ary-tree-level-order-traversal-medium">429. N-ary Tree Level Order Traversal (Medium)</h1>
<p>Given an n-ary tree, return the level order traversal of its nodes' values.<br>
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:
        if not root: return []
        q=[root]
        res=[]
        while q:
            l=len(q)
            level=[]
            for _ in range(l):
                cur=q.pop(0)
                level.append(cur.val)
                for child in cur.children:
                    q.append(child)
            res.append(level)
        return res

#RECURSION ANSWER
class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:

        def traverse_node(node, level):
            if len(result) == level:
                result.append([])
            result[level].append(node.val)
            for child in node.children:
                traverse_node(child, level + 1)

        result = []

        if root is not None:
            traverse_node(root, 0)
        return result
</code></pre>
<p>BFS</p>
<h1 id="430-flatten-a-multilevel-doubly-linked-list-medium">430. Flatten a Multilevel Doubly Linked List (Medium)</h1>
<p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.<br>
Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.<br>
Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;

class Solution:
    def flatten(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':
        
        stack=[]
        cur=head
        pre=None
        while cur or stack:
            if not cur:
                cur=stack.pop()
                cur.prev=pre
                pre.next=cur
                
            while cur.child:
                if cur.next:
                    stack.append(cur.next)
                curnext=cur.child
                curchild=cur.child
                cur.child=None
                curchild.prev=cur
                cur.next=curnext
                cur=curnext
               
            if not cur.child:
                pre=cur
                cur=cur.next
                
            
        return head


#

class Solution:
    def flatten(self, head: 'Node') -&gt; 'Node':
        
        #DFS...
        curr=head
        tempStack = []
        while curr:
            if curr.child:
                if curr.next:
                    tempStack.append(curr.next);
                curr.next, curr.child.prev, curr.child = curr.child, curr, None;
            if not curr.next and len(tempStack):
                temp = tempStack.pop();
                temp.prev, curr.next = curr, temp
            curr = curr.next
        return head


 #ANSWER PREORDER   child is left tree next is right tree
 &quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;
class Solution(object):

    def flatten(self, head):
        if not head:
            return head

        # pseudo head to ensure the `prev` pointer is never none
        pseudoHead = Node(None, None, head, None)
        self.flatten_dfs(pseudoHead, head)

        # detach the pseudo head from the real head
        pseudoHead.next.prev = None
        return pseudoHead.next


    def flatten_dfs(self, prev, curr):
        &quot;&quot;&quot; return the tail of the flatten list &quot;&quot;&quot;
        if not curr:
            return prev

        curr.prev = prev
        prev.next = curr

        # the curr.next would be tempered in the recursive function
        tempNext = curr.next
        tail = self.flatten_dfs(curr, curr.child)
        curr.child = None
        return self.flatten_dfs(tail, tempNext)        

#preorder interative 
class Solution(object):
    def flatten(self, head):
        if not head:
            return

        pseudoHead = Node(0,None,head,None)
        prev = pseudoHead

        stack = []
        stack.append(head)

        while stack:
            curr = stack.pop()

            prev.next = curr
            curr.prev = prev

            if curr.next:
                stack.append(curr.next)
 
            if curr.child:
                stack.append(curr.child)
                # don't forget to remove all child pointers.
                curr.child = None

            prev = curr
        # detach the pseudo head node from the result.
        pseudoHead.next.prev = None
        return pseudoHead.next
</code></pre>
<p>差点没做出来 写的比答案复杂</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-02/">
        </link>
        <updated>2022-03-02T09:50:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-411-minimum-unique-word-abbreviation-hardfont"><font color='red'> 411. Minimum Unique Word Abbreviation （Hard）</font></h1>
<p>A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
Note that &quot;s55n&quot; (&quot;s ubsti tutio n&quot;) is not a valid abbreviation of &quot;substitution&quot; because the replaced substrings are adjacent.<br>
The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation &quot;s10n&quot; has a length of 3 (2 letters + 1 substring) and &quot;su3i1u2on&quot; has a length of 9 (6 letters + 3 substrings).<br>
Given a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.</p>
<pre><code class="language-python">class Solution:
    def minAbbreviation(self, target: str, dictionary: List[str]) -&gt; str:

        def abbr(target, num):
            word, count = '', 0
            for w in target:
                if num &amp; 1 == 1:
                    if count:
                        word += str(count)
                        count = 0
                    word += w
                else:
                    count += 1

                num &gt;&gt;= 1
            if count:
                word += str(count)
            return word

        m = len(target)

        # Figure out the different bits for a same length word in the dictionary
        diffs = []
        for word in dictionary:
            if len(word) != m:
                continue

            # The encoding is opposite
            bits = 0
            for i, char in enumerate(word):
                if char != target[i]:
                    bits += 2 ** i
            diffs.append(bits)

        # No word in dictionary has same length, return the shortest
        if not diffs:
            return str(m)        

        abbrs = []
        for i in range(2 ** m):
            # This abbreviation at least has one word different to every words in the dictionary
            if all(d &amp; i for d in diffs):
                abbrs.append(abbr(target, i))

        return min(abbrs, key=lambda x: len(x))
</code></pre>
<p>思路是bit manipulation。 1）找出在字典里同长度但字符和target不同的bit。 然后所有的encoding是0到2^m， 所以  all（encoding&amp;dif for dif in diffs）  encoding的bit能和所有dif bits有交集则是个可能的候选，把 encoding bit转换为string然后加入到abbrs中，最后找出长度最小的abbrs就可以了。</p>
<h1 id="412-fizz-buzz-easy">412. Fizz Buzz （Easy）</h1>
<p>Given an integer n, return a string array answer (1-indexed) where:<br>
answer[i] == &quot;FizzBuzz&quot; if i is divisible by 3 and 5.<br>
answer[i] == &quot;Fizz&quot; if i is divisible by 3.<br>
answer[i] == &quot;Buzz&quot; if i is divisible by 5.<br>
answer[i] == i (as a string) if none of the above conditions are true.</p>
<pre><code class="language-python">class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        def helper(n):
            if n%3==0 and n%5==0:
                return 'FizzBuzz'
            elif n%3==0:
                return 'Fizz'
            elif n%5==0:
                return 'Buzz'
            else:
                return str(n)
        
        return [helper(i) for i in range(1,n+1)]
</code></pre>
<h1 id="413-arithmetic-slices-medium">413. Arithmetic Slices (Medium)</h1>
<p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.<br>
Given an integer array nums, return the number of arithmetic subarrays of nums.<br>
A subarray is a contiguous subsequence of the array.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        #   [1,3,5,7,9]
        # dp 0 0 1 
        #          2
        #            3  
        # dp is the number of subarays ending in ith
        if len(nums)&lt;3: return 0
        dp=[0]*len(nums)
        if nums[0]-nums[1]==nums[1]-nums[2]:
            dp[2]=1
        
        if len(nums)==3: return dp[2]
        for i in range(3,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp[i]=1+dp[i-1]
        return sum(dp)
#ANSWER
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        dp=0
        res=0
        for i in range(2,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp=1+dp
                res+=dp
            else:
                dp=0
        return res        
</code></pre>
<p>思路和答案一致，DP解决。</p>
<h1 id="414-third-maximum-number-easy">414. Third Maximum Number （Easy）</h1>
<p>Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.</p>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        if len(set(nums))&lt;3: return max(nums)
        if len(set(nums))==3: return sorted(set(nums))[0]
        res=[]
        for n in set(nums):
            heapq.heappush(res,-n)
        heapq.heappop(res)
        heapq.heappop(res)
        return -heapq.heappop(res)

#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        maximums = set()
        for num in nums:
            maximums.add(num)
            if len(maximums) &gt; 3:
                maximums.remove(min(maximums))
        if len(maximums) == 3:
            return min(maximums)
        return max(maximums)
#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        min_heap = []
        for num in nums:
            if num in min_heap:
                continue
            if len(min_heap) &lt; 3:
                heapq.heappush(min_heap, num)
            elif len(min_heap) == 3:
                heapq.heappushpop(min_heap, num)        
        
        if len(min_heap) == 3:
            return heapq.heappop(min_heap)
        else:
            while min_heap:
                result = heapq.heappop(min_heap)
            return result

#3pointer...
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        max=float('-inf')
        max2=float('-inf')
        max3=float('-inf')
        s=set()
        for n in nums:
            if n in s: continue
            if n&gt;max:
                max3=max2
                max2=max
                max=n
            elif n&gt;max2:
                max3=max2
                max2=n
            elif n&gt;max3:
                max3=n
                
            s.add(n)
         
        return max3 if len(s)&gt;=3 else max
</code></pre>
<h1 id="415-add-strings-easy">415. Add Strings (Easy)</h1>
<p>Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.<br>
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.</p>
<pre><code class="language-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        
        n1=[int(e) for e in num1]
        n2=[int(e) for e in num2]
        res=[]
        carry=0
        while n1 or n2:
            a=n1.pop() if n1 else 0
            b=n2.pop() if n2 else 0
            val=(a+b+carry)%10
            carry=(a+b+carry)//10
            res.append(val)
        if carry:
            res.append(carry)
        
        return ''.join(map(str,res[::-1]))

</code></pre>
<h1 id="font-colorred-416-partition-equal-subset-sum-medium-font"><font color='red'> 416. Partition Equal Subset Sum (Medium) </font></h1>
<p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<pre><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        @lru_cache(None)
        def dfs(n,subset_sum):
            if subset_sum==0:
                return True
            if n==0 or subset_sum&lt;0:
                return False
            result = dfs(n-1,subset_sum-nums[n-1]) or dfs(n-1,subset_sum)
            return result
        
        total_sum=sum(nums)
        if total_sum%2==1: return False
        subset_sum=total_sum//2
        n=len(nums)
        return dfs(n,subset_sum)
###DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2
        n = len(nums)

        # construct a dp table of size (n+1) x (subset_sum + 1)
        # dp[n][subsetsum] up to nth num can sum to subsetsum
        dp = [[False] * (subset_sum + 1) for _ in range(n + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            curr = nums[i - 1]
            for j in range(subset_sum + 1):
                if j &lt; curr:
                    # subset_sum&lt; nums[i-1]   so, subsetsum not include nums[i-1]
                    dp[i][j] = dp[i - 1][j]
                else:
                    # could not include or include nums[i-1] 
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - curr]
        return dp[n][subset_sum]

#DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2

        # construct a dp table of size (subset_sum + 1)
        dp = [False] * (subset_sum + 1)
        dp[0] = True
        for curr in nums:
            for j in range(subset_sum,curr-1,-1):
                dp[j] = dp[j] or dp[j - curr]

        return dp[subset_sum]
</code></pre>
<p>没思路。。。 有两种情况，1) num in subset_sum  2) num not in subset_sum 所以dfs</p>
<h1 id="417-pacific-atlantic-water-flow-medium">417. Pacific Atlantic Water Flow （Medium）</h1>
<pre><code class="language-python">class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -&gt; List[List[int]]:
        
        #two bfs from boundy if hight is higher..
        
        visited=set()
        q=[]
        m=len(heights)
        n=len(heights[0])
        for row in range(m):
            visited.add((row,0))
            q.append((row,0))
        for col in range(1,n):
            visited.add((0,col))
            q.append((0,col))
        
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited and heights[row][col]&gt;=heights[r][c]:
                    visited.add((row,col))
                    q.append((row,col))
        
        
        visited2=set()
        q=[]
        for row in range(m):
            visited2.add((row,n-1))
            q.append((row,n-1))
        for col in range(n-1):
            visited2.add((m-1,col))
            q.append((m-1,col))
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited2 and heights[row][col]&gt;=heights[r][c]:
                    visited2.add((row,col))
                    q.append((row,col))
        
        return visited&amp;visited2

</code></pre>
<p>思路，从边界处做两次BFS，相交地方就是结果。</p>
<h1 id="font-colorred-418-sentence-screen-fitting-medium-font"><font color='red'> 418. Sentence Screen Fitting （Medium） </font></h1>
<p>Given a rows x cols screen and a sentence represented as a list of strings, return the number of times the given sentence can be fitted on the screen.<br>
The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.</p>
<pre><code class="language-python">#TIME LIMIT EXCEEDED
class Solution:
    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        sentence=[len(w) for w in sentence]
        r=0
        c_row=0
        res=0
        i=0
        while r&lt;rows:
            
            l=sentence[i]
            #print(r,c_row,l)
            if c_row+l&lt;cols:
                c_row = c_row+l+1
                if c_row==cols:
                    c_row=0
                    r+=1
                    if r&gt;=rows:
                        if i==len(sentence)-1: res+=1
                        break
            elif c_row+l==cols:
                c_row=0
                r+=1
            elif c_row+l&gt;cols:
                c_row=l+1
                r+=1
                if r&gt;=rows:
                    break
                #print('#',c_row,r)
            if i==len(sentence)-1: res+=1
            i=(i+1)%len(sentence)
        return res

#ANSWER
#case 1: sentence_ptr at the end of the screen falls on space in the sentence. Go to the next letter sentence_ptr+1 in the next row of the screen.
#case 2: sentence_ptr at the end of the screen falls on the last letter of a word. We skip the space in the sentence as the last letter coincides with the screen end: sentence_ptr+2
#case 3: sentence_ptr points in the middle of a word at the end of the screen: roll back sentence_ptr till there's a space in the sentence. his corresponds to starting to fill the word in the next row, as it does not fit into the current. sentence_ptr &gt; 0 is needed for the case when a word is longer than cols; sentence_ptr will be &lt; len(s)

#Code with the comments and the variable change:

    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        s = ' '.join(sentence) + ' '
        sentence_ptr = 0
        for i in range(rows):
            sentence_ptr += cols - 1
            # case 1: sentence_ptr at the end of screen falls exactly on the space
            if s[sentence_ptr % len(s)] == ' ':
                sentence_ptr += 1
            # case 2: sentence_ptr at the end of screen coincides with the last letter of a word (next is space)
            elif s[(sentence_ptr + 1) % len(s)] == ' ':
                sentence_ptr += 2
            else:
                # case 3: sentence_ptr at the end of screen falls in the middle of a word; roll back
                while sentence_ptr &gt; 0 and s[(sentence_ptr - 1) % len(s)] != ' ':
                    sentence_ptr -= 1
        return sentence_ptr // len(s)

</code></pre>
<p>初次尝试是TLE。。。 直接暴力解即使考虑全了cornercase也还是过不了。<br>
答案思路，先组成一个句子 s=‘ ‘.join（sentence）+’‘。  定义sentence_ptr 每过一行，sentence_ptr+= cols-1 这时候分3种情况， 1） 如果恰巧sentence_ptr落的位置是空格，senternce_ptr+1 2)如果 sentence_ptr+1位置是空格，sentence_ptr+=2 3)sentence_ptr落在字符上，那么sentence_ptr得往回缩直到遇到空格。</p>
<h1 id="419-battleships-in-a-board-medium">419. Battleships in a Board （Medium）</h1>
<p>Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.<br>
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p>
<pre><code class="language-python">class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
        
        m=len(board)
        n=len(board[0])
        
        visited=set()
        
        
        def dfs(row,col):
            #print(row,col)
            if row&lt;0 or col&lt;0 or row&gt;=m or col&gt;=n or (row,col) in visited: return
            visited.add((row,col))
            if board[row][col]=='X':
                board[row][col]='.'
                dfs(row+1,col)
                dfs(row-1,col)
                dfs(row,col+1)
                dfs(row,col-1)

        res=0
        for i in range(m):
            for j in range(n):
                if board[i][j]=='X':
                    res+=1
                    dfs(i,j)
                    
        
        return res
#ANSWER
class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
 
        total = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X':
                    flag = 1
                    if j &gt; 0 and board[i][j-1] == 'X': flag = 0
                    if i &gt; 0 and board[i-1][j] == 'X': flag = 0
                    total += flag
        return total
</code></pre>
<p>答案没用DFS or BFS 但是很完美的解决了，因为只有横的竖的是叫做Battleships，所以如果不是左上角的X就不是一个qualified battlesships。</p>
<h1 id="font-colorred-420-strong-password-checker-hardfont"><font color='red'> 420. Strong Password Checker （Hard）</font></h1>
<p>A password is considered strong if the below conditions are all met:<br>
It has at least 6 characters and at most 20 characters.<br>
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.<br>
It does not contain three repeating characters in a row (i.e., &quot;...aaa...&quot; is weak, but &quot;...aa...a...&quot; is strong, assuming other conditions are met).<br>
Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.<br>
In one step, you can:<br>
Insert one character to password,<br>
Delete one character from password, or<br>
Replace one character of password with another character.</p>
<pre><code class="language-python">class Solution:
    def strongPasswordChecker(self,s: str) -&gt; int:
        
        missing_type = 3
        if any('a' &lt;= c &lt;= 'z' for c in s): missing_type -= 1
        if any('A' &lt;= c &lt;= 'Z' for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p &lt; len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p &lt; len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) &lt; 6:
            return max(missing_type, 6 - len(s))
        elif len(s) &lt;= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return delete + max(missing_type, change)
</code></pre>
<p>看到这题就头疼~，直接看答案了。<br>
当有20+chars，必须delete=len（s）-20.但是我们能用这些delete中的一部分来处理3char rule violation。<br>
1） aaa ... 这种violation可以del最后一个a。所以， 需要从change里减去这些del。change -= min(delete, one)<br>
2）aaaa ... 这种violation可以del最后2个a。因为已经用了1）中的deletions，所以需要调整,   min(max(delete - one, 0), two * 2) // 2  意思是，如果残留 max(delete - one, 0) 个dels，那么，用这些dels来处理case2的violation。 因为必须del 2 chars  to resolve each violation, 所以只能用 dels // 2<br>
3）aaaaa ...这种 violation可以del最后3个a。   max(delete - one - 2 * two, 0) // 3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-01/">
        </link>
        <updated>2022-03-01T14:53:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>中间搞laser project浪费了不少时间~~~ 争取3月刷300到700. system design 也该看了。</p>
<h1 id="font-colorred-401-binary-watch-easy-font"><font color='red'> 401. Binary Watch (Easy) </font></h1>
<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.<br>
Given an integer turnedOn which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        return ['{}:{}'.format(h, str(m).zfill(2))  for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == turnedOn]

#Backtracking way of answer it
class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        res=set()
        nums1=[8,4,2,1]
        nums2=[32,16,8,4,2,1]
        
        
        def generateDigs(nums,count):
            res=set()
            def helper(c,pos,sum_):
                if c==0:
                    res.add(sum_)
                    return
                for i in range(pos,len(nums)):
                    helper(c-1,i+1,sum_+nums[i])
            helper(count,0,0)
            return res
        
        for i in range(turnedOn+1):
            list1=generateDigs(nums1,i)
            list2=generateDigs(nums2,turnedOn-i)
            for num1 in list1:
                if num1&gt;=12: continue
                for num2 in list2:
                    if num2&gt;=60: continue
                    res.add('{}:{}'.format(num1,str(num2).zfill(2)))
        return res
</code></pre>
<p>是一个backtracking问题， 写起来难度很大，然而是一个easy问题。。。直接暴力解即可。<br>
但用backtracking就是一个比较难的问题了。</p>
<h1 id="font-colorred-402-remove-k-digits-mediumfont"><font color='red'> 402. Remove K Digits （Medium）</font></h1>
<p>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</p>
<pre><code class="language-python">class Solution:
    def removeKdigits(self, num: str, k: int) -&gt; str:
        #
        # 2     1    4
        # left  cur
        # if cur&lt;left, we know left must be removed
        
        stack=[]
        for n in num:
            while k and stack and n&lt;stack[-1]:
                stack.pop()
                k-=1
            stack.append(n)
        
        #truncate remaining k digits at the end
        # if k==0 return entire list
        final_stack=stack[:-k] if k else stack
        
        return ''.join(final_stack).lstrip('0') or '0'
</code></pre>
<p>greedy+stack 这个方法第一次比较难想到，需要考虑corner case。</p>
<h1 id="403-frog-jump-hard">403. Frog Jump （Hard）</h1>
<p>A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.<br>
Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.<br>
If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.</p>
<pre><code class="language-python">class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
       
        dp=[False]*len(stones)
        dic={s:i for i,s in enumerate(stones)}
        
        @lru_cache(None)
        def can(ith,k):
            if k&lt;=0: return
            if ith==0:
                dp[0]=True
                if stones[0]+1 in dic:
                    jth=dic[stones[0]+1] 
                    can(jth,1)
            else:
                for i,step in enumerate([k+1,k,k-1]):
                    if stones[ith]+step in dic:
                        stone_ind=dic[stones[ith]+step]
                        dp[stone_ind]=True
                        can(stone_ind,[k+1,k,k-1][i])
            
        can(0,1)
        return dp[-1]

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        dic=dict()
        for s in stones:
            dic[s]=set()
        dic[0].add(0)
        
        for i in range(len(stones)):
            for k in dic[stones[i]]:
                for step in range(k-1,k+2):
                    if step&gt;0 and stones[i]+step in dic:
                        dic[stones[i]+step].add(step)
                        
        return len(dic[stones[-1]])&gt;0

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        seen = set()
        stoneSet = set(stones)
        end = stones[-1]
        stack = [(0, 0)]
        while len(stack) &gt; 0:
            loc, steps = stack.pop()
            if (loc, steps) in seen:
                continue
            seen.add((loc, steps))
            if loc == end:
                return True
            elif loc &lt; end:
                for i in range(steps-1, steps+2):
                    if i &lt;= 0:
                        continue
                    if loc + i in stoneSet:
                        stack.append((loc+i, i))
        return False
</code></pre>
<p>没想到做出来了。。。。。dp  with mem。。。<br>
答案更好。答案3思路： each node has 3 children. The goal is to check if we can reach to the end along the edges. We can do it with a Depth First Search with a Hashtable(to avoid redundant calculation)</p>
<h1 id="404-sum-of-left-leaves-easy">404. Sum of Left Leaves （Easy）</h1>
<p>Given the root of a binary tree, return the sum of all left leaves.</p>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:
        if not root: return 0
        if root.left and root.left.left is None and root.left.right is None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        return  self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)
</code></pre>
<h1 id="405-convert-a-number-to-hexadecimal-easy">405. Convert a Number to Hexadecimal (Easy)</h1>
<p>Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.<br>
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>
<pre><code class="language-python">class Solution:
    def toHex(self, num: int) -&gt; str:
        if num&lt;0:
            num=4294967295 +num+1
        map=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']
        res=''
        while num:
            ind=num%16
            res+=map[ind]
            num=num//16
        #26=1a  16 11
        return res[::-1]   if res else '0'  
</code></pre>
<h1 id="font-colorred-406-queue-reconstruction-by-height-medium-font"><font color='red'> 406. Queue Reconstruction by Height (Medium) </font></h1>
<p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.<br>
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p>
<pre><code class="language-python">class Solution:
    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        output = []
        for p in people:
            output.insert(p[1], p)
        return output

</code></pre>
<p>思路：最高的sort完了，插入次高的，插入位置？</p>
<h1 id="font-colorred-407-trapping-rain-water-ii-hardfont"><font color='red'> 407. Trapping Rain Water II （Hard）</font></h1>
<p>Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.</p>
<pre><code class="language-python">class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -&gt; int:
        
        class Cell:
            def __init__(self,row,col,h):
                self.row=row
                self.col=col
                self.h=h
            
            def __lt__(self,other):
                return self.h&lt;other.h
            
        
        if not heightMap or len(heightMap)==0 or len(heightMap[0])==0:
            return 0
        
        q=[]
        m=len(heightMap)
        n=len(heightMap[0])
        visited=[[False]*n for _ in range(m)]
        #Initially, add all the Cells which are on borders to the queue.
        for i in range(m):
            visited[i][0]=True
            visited[i][n-1]=True
            heapq.heappush(q, Cell(i,0,heightMap[i][0]))
            heapq.heappush(q, Cell(i,n-1,heightMap[i][n-1]))
        for j in range(n):
            visited[0][j]=True
            visited[m-1][j]=True
            heapq.heappush(q, Cell(0,j,heightMap[0][j]))
            heapq.heappush(q, Cell(m-1,j,heightMap[m-1][j]))
        #from the borders, pick the shortest cell visited and check its neighbors: if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped add all its neighbors to the queue.
        dirs = [[-1,0],[1,0],[0,-1],[0,1]]
        res=0
        while q:
            cur_cell=heapq.heappop(q)
            for dir in dirs:
                row=cur_cell.row+dir[0]
                col=cur_cell.col+dir[1]
                if row&gt;=0 and row&lt;m and col&gt;=0 and col&lt;n and not visited[row][col]:
                    visited[row][col]=True
                    res+=max(0,cur_cell.h-heightMap[row][col])
                    heapq.heappush(q,Cell(row,col,max(cur_cell.h,heightMap[row][col])))
                    
        
        return res
                    
#ANSWER
class Solution(object):
    def trapRainWater(self, heightMap):
        if not heightMap or not heightMap[0]:
            return 0
        
        import heapq    
        m, n = len(heightMap), len(heightMap[0])
        heap = []
        visited = [[0]*n for _ in xrange(m)]

        # Push all the block on the border into heap
        for i in xrange(m):
            for j in xrange(n):
                if i == 0 or j == 0 or i == m-1 or j == n-1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = 1
        
        result = 0
        while heap:
            height, i, j = heapq.heappop(heap)    
            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and not visited[x][y]:
                    result += max(0, height-heightMap[x][y])
                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))
                    visited[x][y] = 1
        return result      
        
</code></pre>
<p>思路：边界最低的板子是开始点，BFS，如果邻居低说明能存水，做计算，然后埋土。</p>
<h1 id="408-valid-word-abbreviation-easy">408. Valid Word Abbreviation （Easy）</h1>
<p>A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.<br>
For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
The following are not valid abbreviations:<br>
&quot;s55n&quot; (&quot;s ubsti tutio n&quot;, the replaced substrings are adjacent)<br>
&quot;s010n&quot; (has leading zeros)<br>
&quot;s0ubstitution&quot; (replaces an empty substring)<br>
Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation.<br>
A substring is a contiguous non-empty sequence of characters within a string.</p>
<pre><code class="language-python">class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -&gt; bool:
        
        dig=0
        while abbr:
            
            if abbr[0].isdigit():
                if dig==0 and abbr[0]=='0': return False
                dig=dig*10+int(abbr[0])
                abbr=abbr[1:]
            else:
                if dig!=0:
                    if len(word)&lt;dig: return False
                    word=word[dig:]
                    dig=0
                else:
                    if not word: return False
                    if abbr[0]!=word[0]: return False
                    abbr=abbr[1:]
                    word=word[1:]
        if dig:
            if len(word)&lt;dig: return False
            if not word: return False
            word=word[dig:]
         
        return not abbr and not word


</code></pre>
<h1 id="font-colorred-409-longest-palindrome-easy-font"><font color='red'> 409. Longest Palindrome (Easy) </font></h1>
<p>Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.<br>
Letters are case sensitive, for example, &quot;Aa&quot; is not considered a palindrome here.</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; int:
        dic=Counter(s)
        res=0
        for k,v in dic.items():
            res+=v//2*2
            if res%2==0 and v%2==1:
                res+=1
        return res
</code></pre>
<p>找到能组成palindrom的最长组合方式，如果是奇数个，可以变成偶数个，比如bbb只用bb。 但当res%2==0时候，遇到奇数情况可以加1.</p>
<h1 id="font-colorred-410-split-array-largest-sum-hard-font"><font color='red'> 410. Split Array Largest Sum （Hard） </font></h1>
<p>Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.<br>
Write an algorithm to minimize the largest sum among these m subarrays.</p>
<pre><code class="language-python">class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        # F[currIndex, subarrayCount] = 
        #  min(max(sum[currIndex, i], F[i + 1, subarrayCount - 1]))
        #        For all i in range [currIndex, n - subarrayCount]
        
        n=len(nums)
        prefix_sum=nums[:]
        for i in range(1,len(prefix_sum)):
            prefix_sum[i]+=prefix_sum[i-1]
        prefix_sum=[0]+prefix_sum
        
        @lru_cache(None)
        def get_min_largest_split_sum(cur_ind, m):
            if m==1:
                return prefix_sum[n]-prefix_sum[cur_ind]
            
            minimum_largest_split_sum=prefix_sum[n]
            for i in range(cur_ind,n-m+1):
                # Store the sum of the first subarray.
                first_split_sum=prefix_sum[i+1]-prefix_sum[cur_ind]
                # find the maxinum subaray sum ffor current frist split
                largest_split_sum=max(first_split_sum,get_min_largest_split_sum(i+1,m-1))
                #find the minum among all possible combinations
                minimum_largest_split_sum=min(minimum_largest_split_sum,largest_split_sum)
                
                if first_split_sum &gt;= minimum_largest_split_sum: break
            
            return minimum_largest_split_sum
        
        return get_min_largest_split_sum(0,m)


#。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        n = len(nums)
        memo = [[0] * (m + 1) for _ in range(n)]
        
        # Create a prefix sum array of nums.
        prefix_sum = [0] + list(itertools.accumulate(nums))
        
        for subarray_count in range(1, m + 1):
            for curr_index in range(n):
                # Base Case: If there is only one subarray left, then all of the remaining numbers
                # must go in the current subarray. So return the sum of the remaining numbers.
                if subarray_count == 1:
                    memo[curr_index][subarray_count] = prefix_sum[n] - prefix_sum[curr_index]
                    continue

                # Otherwise, use the recurrence relation to determine the minimum largest subarray sum
                # between curr_index and the end of the array with subarray_count subarrays remaining.
                minimum_largest_split_sum = prefix_sum[n]
                for i in range(curr_index, n - subarray_count + 1):
                    # Store the sum of the first subarray.
                    first_split_sum = prefix_sum[i + 1] - prefix_sum[curr_index]

                    # Find the maximum subarray sum for the current first split.
                    largest_split_sum = max(first_split_sum, memo[i + 1][subarray_count - 1])

                    # Find the minimum among all possible combinations.
                    minimum_largest_split_sum = min(minimum_largest_split_sum, largest_split_sum)

                    if first_split_sum &gt;= minimum_largest_split_sum:
                        break
            
                memo[curr_index][subarray_count] = minimum_largest_split_sum
        
        return memo[0][m]

#。。。。。。。。。。。。。。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        
        def min_subarrays_required(max_sum_allowed: int) -&gt; int:
            current_sum = 0
            splits_required = 0
            
            for element in nums:
                # Add element only if the sum doesn't exceed max_sum_allowed
                if current_sum + element &lt;= max_sum_allowed:
                    current_sum += element
                else:
                    # If the element addition makes sum more than max_sum_allowed
                    # Increment the splits required and reset sum
                    current_sum = element
                    splits_required += 1

            # Return the number of subarrays, which is the number of splits + 1
            return splits_required + 1
        
        # Define the left and right boundary of binary search
        left = max(nums)
        right = sum(nums)
        while left &lt;= right:
            # Find the mid value
            max_sum_allowed = (left + right) // 2
            
            # Find the minimum splits. If splits_required is less than
            # or equal to m move towards left i.e., smaller values
            if min_subarrays_required(max_sum_allowed) &lt;= m:
                right = max_sum_allowed - 1
                minimum_largest_split_sum = max_sum_allowed
            else:
                # Move towards right if splits_required is more than m
                left = max_sum_allowed + 1
        
        return minimum_largest_split_sum
###Binary Seasrch


class Solution(object):
    def splitArray(self, nums, m):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type m: int
        :rtype: int
        https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1042/discuss/89817/Clear-Explanation:-8ms-Binary-Search-Java?page=1
        &quot;&quot;&quot;
 
        max_ = sum=0
        for  num in nums:
            max_ = max(num, max_);
            sum += num
            
            
        def valid(target, nums, m):
            count = 1
            total = 0
            for num in nums:
                total += num
                if total &gt; target: 
                    total = num
                    count+=1
                    if count &gt; m:
                        return False
                    
            return True
        
        if m == 1: return sum
        #binary search
        l = max_ 
        r = sum
        while l &lt;= r:
            mid = (l + r)// 2;
            if  valid(mid, nums, m): 
                r = mid - 1 
            else: 
                l = mid + 1
            
        return l
</code></pre>
<p>无思路。。。m=2时候很容易，sort然后找到左右平衡点。m=3，4？<br>
DP很好， bianry search是最优解法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-12]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-12/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-12/">
        </link>
        <updated>2021-12-12T14:58:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred391-perfect-rectangle-hardfont"><font color='red'>391. Perfect Rectangle （Hard）</font></h1>
<p>Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).<br>
Return true if all the rectangles together form an exact cover of a rectangular region.</p>
<pre><code class="language-python">class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -&gt; bool:
        x1 = float('inf')
        y1 = float('inf')
        x2 = float('-inf')
        y2 = float('-inf')
        _set = set()
        
        area = 0
        for rect in rectangles:
            x1 = min(x1, rect[0])
            y1 = min(y1, rect[1])
            x2 = max(x2, rect[2])
            y2 = max(y2, rect[3])
            
            area += (rect[2] - rect[0]) * (rect[3] - rect[1])
            
            for x, y in [(rect[0],rect[1]),(rect[0],rect[3]),(rect[2],rect[3]),(rect[2],rect[1])]:
                if (x, y) in _set:
                    _set.remove((x, y))
                else:
                    _set.add((x, y))
        return all((x, y) in _set for x, y in [(x1,y1),(x2,y2),(x1,y2),(x2,y1)]) and len(_set) == 4 and area == (x2 - x1) * (y2 - y1)

</code></pre>
<p>没啥思路。。。答案思路:<br>
要是exact cover of rectangular region 1）大的rectangle面积是所有小rectangle面积和 2） 所有的图中的点应该是偶数个，除了边界的4个点。</p>
<h1 id="392-is-subsequence-easy">392. Is Subsequence (Easy)</h1>
<p>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.<br>
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).</p>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s):
            
            while p2&lt;len(t) and s[p1]!=t[p2]:
                p2+=1
            
            if p2==len(t): return False
            
            if s[p1]==t[p2]:
                p1+=1
                p2+=1
            
            if p1==len(s):return True
 #ANSWER           
class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s) and p2&lt;len(t):
            if s[p1]==t[p2]:
                p1+=1
            p2+=1
        if p1==len(s):
            return True
        return False
                     
</code></pre>
<p>这题竟然卡了，用了two pointer。。 答案写的更好。 只有相等时候s的pointer才跳，t的pointer一直跳，判断s的pointer到头就可以了。</p>
<h1 id="font-colorred393-utf-8-validation-mediumfont"><font color='red'>393. UTF-8 Validation （Medium）</font></h1>
<p>Given an integer array data representing the data, return whether it is a valid UTF-8 encoding.<br>
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:<br>
For a 1-byte character, the first bit is a 0, followed by its Unicode code.<br>
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.</p>
<p>This is how the UTF-8 encoding would work:</p>
<p>Char. number range  |        UTF-8 octet sequence<br>
(hexadecimal)    |              (binary)<br>
--------------------+---------------------------------------------<br>
0000 0000-0000 007F | 0xxxxxxx<br>
0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>
<pre><code class="language-python">class Solution:
    def validUtf8(self, data: List[int]) -&gt; bool:
        
        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # For each integer in the data array.
        for num in data:

            # Get the binary representation. We only need the least significant 8 bits
            # for any given number.
            bin_rep = format(num, '#010b')[-8:]

            # If this is the case then we are to start processing a new UTF-8 character.
            if n_bytes == 0:

                # Get the number of 1s in the beginning of the string.
                for bit in bin_rep:
                    if bit == '0': break
                    n_bytes += 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:
                # Else, we are processing integers which represent bytes which are a part of
                # a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.
                if not (bin_rep[0] == '1' and bin_rep[1] == '0'):
                    return False

            # We reduce the number of bytes to process by 1 after each integer.
            n_bytes -= 1

        # This is for the case where we might not have the complete data for
        # a particular UTF-8 character.
        return n_bytes == 0  



#ANSWER BIT 
class Solution:
    def validUtf8(self, data):
        &quot;&quot;&quot;
        :type data: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # Mask to check if the most significant bit (8th bit from the left) is set or not
        mask1 = 1 &lt;&lt; 7

        # Mask to check if the second most significant bit is set or not
        mask2 = 1 &lt;&lt; 6
        for num in data:

            # Get the number of set most significant bits in the byte if
            # this is the starting byte of an UTF-8 character.
            mask = 1 &lt;&lt; 7
            if n_bytes == 0:
                while mask &amp; num:
                    n_bytes += 1
                    mask = mask &gt;&gt; 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:

                # If this byte is a part of an existing UTF-8 character, then we
                # simply have to look at the two most significant bits and we make
                # use of the masks we defined before.
                if not (num &amp; mask1 and not (num &amp; mask2)):
                    return False
            n_bytes -= 1
        return n_bytes == 0     
</code></pre>
<p>看答案了，down vote比较多不是什么好题</p>
<h1 id="394-decode-string-medium">394. Decode String （Medium）</h1>
<p>Given an encoded string, return its decoded string.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.<br>
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.<br>
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].</p>
<pre><code class="language-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        # 3[a2[c]]
        #
        # stack=[]
        #       [3]
        #       [3 [ a 2 [ c   ] 
        # 
        
        dig=''
        stack=[]
        for char in s:
            if char.isdigit():
                dig+=char
            elif char=='[':
                if dig:
                    stack.append(int(dig))
                stack.append('[')
                dig=''
            elif char==']':
                string=[]
                while stack[-1]!='[':
                    string.append(stack.pop())
                string=''.join(string[::-1])
                stack.pop() #pop掉【
                if type(stack[-1])==int:
                    string=stack.pop()*string
                stack.append(string)
                
                
            else:
                stack.append(char)
        
        return ''.join(stack)



 #3年前的答案估计是看的别人的一样的思路
 class Solution(object):
    def decodeString(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        num='0123456789'
        s=[e for e in s]
        
        stack=[]
        
        while s:
            
            cur=s.pop(0)
            if cur in num:
                stack.append(int(cur))
            elif cur=='[':
                stack.append(cur)
            elif cur==']':
                temp=[]
                while stack and stack[-1]!='[':
                    me=stack.pop()
                    temp.append(me)
                stack.pop()
                temp=''.join(temp[::-1])
                number=0
                time=1
                while stack and type(stack[-1])==int:
                    number+=stack.pop()*time
                    time*=10
                stack.append(temp*number)
            else:
                stack.append(cur)
        return ''.join(stack)           
</code></pre>
<p>感觉是用stack的确写出来了~~</p>
<h1 id="font-colorred-395-longest-substring-with-at-least-k-repeating-characters-mediumfont"><font color='red'> 395. Longest Substring with At Least K Repeating Characters （Medium）</font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.</p>
<pre><code class="language-python">class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        def helper(start,end):
            if end&lt;k:return 0
            countMap=[0]*26
            for i in range(start,end):
                countMap[ord(s[i])-ord('a')]+=1
            for mid in range(start,end):
                if countMap[ord(s[mid])-ord('a')]&gt;=k: continue
                midnext=mid+1
                while midnext&lt;end and countMap[ord(s[midnext])-ord('a')]&lt;k:
                    midnext+=1
                return max(helper(start,mid),helper(midnext,end))
            return end-start
        
        return helper(0,len(s))
            
#Perfect ANSWER
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        for c in set(s):
            if s.count(c) &lt; k:
                return max(self.longestSubstring(t, k) for t in s.split(c))
        return len(s)

#Sliding WIndow
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        maxunique=len(set(s))
        res=0
        for cur_unique in range(1,maxunique+1):
            countmap=[0]*26
            start=end=unique=idx=countAtLeasetK=0
            while end &lt;len(s):
                #expanding sliding window
                if unique&lt;=cur_unique:
                    idx=ord(s[end])-ord('a')
                    if countmap[idx]==0:
                        unique+=1
                    countmap[idx]+=1
                    if countmap[idx]==k:
                        countAtLeasetK+=1
                    end+=1
                else:
                    #shrink sliding window
                    idx=ord(s[start])-ord('a')
                    if countmap[idx]==k:
                        countAtLeasetK-=1
                    countmap[idx]-=1
                    if countmap[idx]==0:
                        unique-=1
                    start+=1
                
                if unique==cur_unique and unique==countAtLeasetK:
                    res=max(res,end-start)
        return res

</code></pre>
<p>答案的分治法很好，<br>
的确是tow pointer啊，但写不出来。。。思路：第一层for loop 用来扫 cur_unique 。 while  end 小于len(s)； 当unique小于cur_unique而且不到s末尾时， expand。记录unique he countAtLeastK大小，否则当unique大于cur_unique就收缩， 更新countAtLeastK和unique。 如果unique等于cur_unique 而且unique等于countAtLeastK，更新结果。<br>
最简单的是方法2解法，如果count（char)小于K就用char作为分界char，recursive call function。</p>
<h1 id="396-rotate-function-medium">396. Rotate Function （Medium）</h1>
<p>You are given an integer array nums of length n.<br>
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:<br>
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].<br>
Return the maximum value of F(0), F(1), ..., F(n-1).</p>
<pre><code class="language-python">class Solution:
    def maxRotateFunction(self, nums: List[int]) -&gt; int:
        #nums = [4,3,2,6]
        #F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
        #F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
        #     = F[0]+sum-4*6
        #F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
        #     = F[1]+sum-4*2
        #F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
        #     = F[2]+sum-4*3
        
        f0=0
        sum_=0
        for i,n in enumerate(nums):
            f0+=i*n
            sum_+=n
        res=f0
        for j in range(len(nums)-1,0,-1):
            f1=f0+sum_-len(nums)*nums[j]
            res=max(res,f1)
            f0=f1
        return res
</code></pre>
<h1 id="397-integer-replacement-medium">397. Integer Replacement (Medium)</h1>
<p>Given a positive integer n, you can apply one of the following operations:<br>
If n is even, replace n with n / 2.<br>
If n is odd, replace n with either n + 1 or n - 1.<br>
Return the minimum number of operations needed for n to become 1.</p>
<pre><code class="language-python">class Solution:
    def integerReplacement(self, n: int) -&gt; int:
        def helper(n):
            if n==1:
                return 0
            step=0
            if n%2==0:
                n=n//2
                step=1+helper(n)
            else:
                step=1+min(helper(n+1),helper(n-1))
            return step
        
        return helper(n)
        
</code></pre>
<p>能加个@lru_cache(None)去优化下。。。不过已经pass autograder了</p>
<h1 id="398-random-pick-index-medium">398. Random Pick Index （Medium）</h1>
<p>Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.<br>
Implement the Solution class:<br>
Solution(int[] nums) Initializes the object with the array nums.<br>
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, nums: List[int]):
        self.dic=collections.defaultdict(list)
        for i,n in enumerate(nums):
            self.dic[n].append(i)
        

    def pick(self, target: int) -&gt; int:
        return random.choice(self.dic[target])
    
</code></pre>
<h1 id="font-colorred-399-evaluate-division-medium-font"><font color='red'> 399. Evaluate Division (Medium) </font></h1>
<p>ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.<br>
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.<br>
Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<pre><code class="language-python">class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        
        # a-val-&gt;b--val-&gt;c
        

        graph = defaultdict(defaultdict)

        def backtrack_evaluate(curr_node, target_node, acc_product, visited):
            visited.add(curr_node)
            ret = -1.0
            neighbors = graph[curr_node]
            if target_node in neighbors:
                ret = acc_product * neighbors[target_node]
            else:
                for neighbor, value in neighbors.items():
                    if neighbor in visited:
                        continue
                    ret = backtrack_evaluate(
                        neighbor, target_node, acc_product * value, visited)
                    if ret != -1.0:
                        break
            visited.remove(curr_node)
            return ret

        # Step 1). build the graph from the equations
        for (dividend, divisor), value in zip(equations, values):
            # add nodes and two edges into the graph
            graph[dividend][divisor] = value
            graph[divisor][dividend] = 1 / value

        # Step 2). Evaluate each query via backtracking (DFS)
        #  by verifying if there exists a path from dividend to divisor
        results = []
        for dividend, divisor in queries:
            if dividend not in graph or divisor not in graph:
                # case 1): either node does not exist
                ret = -1.0
            elif dividend == divisor:
                # case 2): origin and destination are the same node
                ret = 1.0
            else:
                visited = set()
                ret = backtrack_evaluate(dividend, divisor, 1, visited)
            results.append(ret)

        return results


###UNIONFIND 变种
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:

        gid_weight = {}

        def find(node_id):
            if node_id not in gid_weight:
                gid_weight[node_id] = (node_id, 1)
            group_id, node_weight = gid_weight[node_id]
            # The above statements are equivalent to the following one
            #group_id, node_weight = gid_weight.setdefault(node_id, (node_id, 1))

            if group_id != node_id:
                # found inconsistency, trigger chain update
                new_group_id, group_weight = find(group_id)
                gid_weight[node_id] =  (new_group_id, node_weight * group_weight)
            return gid_weight[node_id]

        def union(dividend, divisor, value):
            dividend_gid, dividend_weight = find(dividend)
            divisor_gid, divisor_weight = find(divisor)
            if dividend_gid != divisor_gid:
                # merge the two groups together,
                # by attaching the dividend group to the one of divisor
                gid_weight[dividend_gid] =  (divisor_gid, divisor_weight * value / dividend_weight)

        # Step 1). build the union groups
        for (dividend, divisor), value in zip(equations, values):
            union(dividend, divisor, value)

        results = []
        # Step 2). run the evaluation, with &quot;lazy&quot; updates in find() function
        for (dividend, divisor) in queries:
            if dividend not in gid_weight or divisor not in gid_weight:
                # case 1). at least one variable did not appear before
                results.append(-1.0)
            else:
                dividend_gid, dividend_weight = find(dividend)
                divisor_gid, divisor_weight = find(divisor)
                if dividend_gid != divisor_gid:
                    # case 2). the variables do not belong to the same chain/group
                    results.append(-1.0)
                else:
                    # case 3). there is a chain/path between the variables
                    results.append(dividend_weight / divisor_weight)
        return results
</code></pre>
<p>看提示，是graph问题， 一开始就偏了。。。若是graph问题，则a-val-》b-val-》c，<br>
那么a-》c就是val1*val2，如果是c-》a找不到，就找a-c然后1/结果. 如果node不在里面就return -1，如果是自己-》自己return1<br>
还是第一种方法graph比较标准用DFS。</p>
<h1 id="font-colorred400-nth-digit-mediumfont"><font color='red'>400. Nth Digit （Medium）</font></h1>
<p>Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].</p>
<pre><code class="language-python">class Solution:
    def findNthDigit(self, n: int) -&gt; int:
        #1 ~ 9 include 9 one digit number;
        #10 ~ 99 include 90 two digits number;
        #100 ~ 999 include 900 three digits number;
        #1000 ~ 9999 include 9000 four digits number;
        #...
        #length is how many digits:1 or 2 or 3 ..., range is 9 or 90 or 900 ...
        
        length = 1
        num = 1 
        range_ = 9
        while n &gt; length * range_:
            n -= length * range_
            length+=1
            range_ *= 10
            num *= 10
        num += (n - 1) // length
        return str(num)[ (n-1)%length]
		 

</code></pre>
<p>知道思路，写时候卡。。。</p>
]]></content>
    </entry>
</feed>