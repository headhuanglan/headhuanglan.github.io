<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-09-18T18:54:30.845Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[RandomText]]></title>
        <id>https://headhuanglan.github.io/post/randomtext/</id>
        <link href="https://headhuanglan.github.io/post/randomtext/">
        </link>
        <updated>2022-09-18T06:39:53.000Z</updated>
        <summary type="html"><![CDATA[<p>自己也算轴的人~</p>
]]></summary>
        <content type="html"><![CDATA[<p>自己也算轴的人~</p>
<!-- more -->
<p>所以，无论发生什么情况，都不会放弃， 上天派我来拯救你。现在只能默默在一旁希望你没事。 无论up or down 有我默默陪你。依旧24h通信畅通。<br>
试着focus在自己的事情上，刷刷题，申请个专利，锻炼下身体。日程排满。<br>
爱是共同的信念，死亡也是。还能爱就不会死亡。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自装KIDD-10/22不同品牌子弹Group分析 ]]></title>
        <id>https://headhuanglan.github.io/post/zi-zhuang-kidd-1022-bu-tong-pin-pai-zi-dan-group-fen-xi/</id>
        <link href="https://headhuanglan.github.io/post/zi-zhuang-kidd-1022-bu-tong-pin-pai-zi-dan-group-fen-xi/">
        </link>
        <updated>2022-08-17T14:24:39.000Z</updated>
        <summary type="html"><![CDATA[<p>找到适合首把22LR定制枪的最佳子弹</p>
]]></summary>
        <content type="html"><![CDATA[<p>找到适合首把22LR定制枪的最佳子弹</p>
<!-- more -->
<h1 id="器材">器材</h1>
<h2 id="枪">枪</h2>
<ul>
<li>KIDD Bolt</li>
<li>KIDD Two Stage Trigger （Pull Weight: 8oz/8oz=1lb ）</li>
<li>KIDD Bolt Handle Charging Assembly With Guide Rod &amp; Springs</li>
<li>KIDD Aftermarket .22LR Receiver Classic Slip Fit Model</li>
<li>KIDD 22LR Match Stainless Steel Rifle Bull Barrel 20'' Bead Blasted</li>
<li>Boyds At-One Applejack Stock</li>
<li>Vortex Optics Diamondback Tactical 6-24x50 First Focal Plane Riflescopes - EBR-2C</li>
</ul>
<h2 id="脚架及支撑">脚架及支撑</h2>
<ul>
<li>Harris Engineering S-BRM Hinged Base 6 - 9-Inch BiPod</li>
<li>Caldwell Deadshot Filled, Rear Shooting Bag</li>
<li>MIM Mfg S Lock for S Series Harris Bipod</li>
</ul>
<h2 id="弹药">弹药</h2>
<blockquote>
<p>Speed of Sound (30 Celsius) = 1145 fps</p>
</blockquote>
<ul>
<li>CCI Standard Velocity  （1070fps）</li>
<li>Eley Semi-Auto Benchrest Precision （1060 fps）</li>
<li>Norma TAC-22  （1083 fps）</li>
<li>Eley Match（1085 fps）</li>
<li>SK Pistol Match Special（955 fps）</li>
<li>SK Rifle Match（955 fps）</li>
<li>Blazer Ammunition 22 Long Rifle 40 Grain Lead Round Nose （1235 fps）</li>
<li>Lapua Pistol King （950 fps）</li>
<li>Aguila Super Maximum （1750 fps）</li>
<li>CCI MiniMag (1235 fps)</li>
<li>Federal AutoMatch 325 (1200 fps)</li>
</ul>
<h1 id="实验">实验</h1>
<h2 id="气温">气温</h2>
<ul>
<li>30度</li>
</ul>
<h2 id="风力风向">风力风向</h2>
<ul>
<li>微风</li>
</ul>
<h2 id="射击距离">射击距离</h2>
<ul>
<li>55码</li>
</ul>
<h2 id="实验方式">实验方式</h2>
<ul>
<li>最左边的标定靶纸调整瞄准镜的高度和风向，20发。</li>
<li>每5发一个group射击5次</li>
<li>每完成一种子弹射击用枪绳清理枪管2次，清理bolt和breechface 。等待枪管冷却。</li>
</ul>
<blockquote>
<p>所有的射击实验的 Takedown Screw 10 inch lbs 遵照KIDD给出的推荐值.</p>
</blockquote>
<h2 id="分析软件">分析软件</h2>
<ul>
<li>（Android） Range Buddy</li>
</ul>
<h1 id="结果">结果</h1>
<ul>
<li>day1 shooting<br>
<img src="https://headhuanglan.github.io/post-images/KIDD.JPG" alt="" loading="lazy"></li>
<li>day2 shooting<br>
<img src="https://headhuanglan.github.io/post-images/KIDD2.JPG" alt="" loading="lazy"></li>
</ul>
<h2 id="分析-moa">分析 （MOA）</h2>
<table>
<thead>
<tr>
<th>弹药</th>
<th>50发价格</th>
<th>Group1</th>
<th>Group2</th>
<th>Group3</th>
<th>Group4</th>
<th>Group5</th>
<th>Min</th>
<th>Max</th>
<th>Avg</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SK Pistol Match Special</strong></td>
<td>$11.99</td>
<td>0.62</td>
<td>0.62</td>
<td>0.79</td>
<td>0.91</td>
<td>0.74</td>
<td>0.62</td>
<td>0.79</td>
<td><strong>0.736</strong></td>
</tr>
<tr>
<td>Eley Match</td>
<td>$21.99</td>
<td>0.34</td>
<td>0.68</td>
<td>0.57</td>
<td>0.74</td>
<td>1.59</td>
<td>0.34</td>
<td>1.59</td>
<td>0.784</td>
</tr>
<tr>
<td>Lapua Pistol King</td>
<td>$14.72</td>
<td>1.09</td>
<td>0.54</td>
<td>0.6</td>
<td>0.76</td>
<td>0.98</td>
<td>0.54</td>
<td>1.09</td>
<td>0.794</td>
</tr>
<tr>
<td>Eley Semi-Auto Benchrest Precision</td>
<td>$15.99</td>
<td>0.53</td>
<td>0.79</td>
<td>0.74</td>
<td>0.95</td>
<td>1.0</td>
<td>0.53</td>
<td>1.0</td>
<td>0.802</td>
</tr>
<tr>
<td>SK Rifle Match</td>
<td>$12.99</td>
<td>0.68</td>
<td>0.68</td>
<td>1.19</td>
<td>0.91</td>
<td>0.96</td>
<td>0.68</td>
<td>1.19</td>
<td>0.884</td>
</tr>
<tr>
<td>CCI Standard Velocity</td>
<td>$4.99</td>
<td>0.89</td>
<td>1.05</td>
<td>1.05</td>
<td>1.32</td>
<td>0.95</td>
<td>0.89</td>
<td>1.32</td>
<td>1.052</td>
</tr>
<tr>
<td>Blazer</td>
<td>$3.99</td>
<td>1.24</td>
<td>1.01</td>
<td>2.07</td>
<td>1.01</td>
<td>0.83</td>
<td>0.83</td>
<td>2.07</td>
<td>1.232</td>
</tr>
<tr>
<td>Norma TAC-22</td>
<td>$4.29</td>
<td>0.74</td>
<td>1.79</td>
<td>1.63</td>
<td>1.21</td>
<td>1.26</td>
<td>0.74</td>
<td>1.79</td>
<td>1.326</td>
</tr>
<tr>
<td>CCI MiniMag</td>
<td>$6.0</td>
<td>1.07</td>
<td>1.28</td>
<td>2.39</td>
<td>1.24</td>
<td>1.67</td>
<td>1.07</td>
<td>2.39</td>
<td>1.53</td>
</tr>
<tr>
<td>Federal AutoMatch 325</td>
<td>$3.23</td>
<td>1.54</td>
<td>1.58</td>
<td>2.91</td>
<td>2.27</td>
<td>2.1</td>
<td>1.54</td>
<td>2.91</td>
<td>2.08</td>
</tr>
<tr>
<td>Aguila Super Maximum</td>
<td>$8.06</td>
<td>5.48</td>
<td>3.64</td>
<td>6.84</td>
<td>3.96</td>
<td>6.3</td>
<td>3.64</td>
<td>6.84</td>
<td>5.244</td>
</tr>
</tbody>
</table>
<h1 id="结论">结论</h1>
<ul>
<li>枪的精度在1MOA以下</li>
<li>fps不能超过声速Group大到没法看, impact target 时候存在超声速-声速转换区。</li>
<li>SK Pistol Match Special 最好结果</li>
<li>Eley Match应该是操作问题导致outlier比较大，除去outlier Eley Match结果最好。</li>
<li>性价比最高的CCI Standard Velocity</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统设计]]></title>
        <id>https://headhuanglan.github.io/post/system-design/</id>
        <link href="https://headhuanglan.github.io/post/system-design/">
        </link>
        <updated>2022-03-27T23:23:07.000Z</updated>
        <summary type="html"><![CDATA[<p>System Design 资源汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>System Design 资源汇总</p>
<!-- more -->
<p><a href="https://www.youtube.com/watch?v=PdtlXdse7pw&amp;list=PL4KdJM8LzAMecwInbBK5GJ3Anz-ts75RQ">DDIA书视频总结</a></p>
<p><a href="https://www.interviewbit.com/courses/system-design/">InterviewBit系统设计题汇总</a></p>
<p><a href="https://github.com/donnemartin/system-design-primer">system design primer github repo</a></p>
<p><a href="https://www.hiredintech.com/classrooms/system-design/lesson/52">system design class</a></p>
<p><a href="https://www.educative.io/courses/grokking-the-system-design-interview">付费 grokking system design interview</a></p>
<p><a href="https://luanjunyi.medium.com/the-table-of-contents-416d2240fa8e">大佬的medium文章</a></p>
<p><a href="http://blog.gainlo.co/index.php/category/system-design-interview-questions/">已经解决的系统设计问题合集</a></p>
<p><a href="http://highscalability.com/blog/2022/1/25/designing-uber.html/">Design Uber</a></p>
<p><a href="http://highscalability.com/blog/2022/1/17/designing-tinder.html">Design Tinder</a></p>
<p><a href="http://highscalability.com/blog/2022/1/11/designing-instagram.html">Design Instagram</a></p>
<p><a href="http://highscalability.com/blog/2022/1/3/designing-whatsapp.html">Design Whatsapp</a></p>
<p><a href="http://highscalability.com/blog/2021/12/13/designing-netflix.html">Design Netflix</a></p>
<p>https://leetcode.com/company/facebook/discuss/229177/My-System-Design-Template<br>
(1) FEATURE EXPECTATIONS [5 min]</p>
<pre><code>    (1) Use cases
    (2) Scenarios that will not be covered
    (3) Who will use
    (4) How many will use
    (5) Usage patterns
</code></pre>
<p>(2) ESTIMATIONS [5 min]</p>
<pre><code>    (1) Throughput (QPS for read and write queries)
    (2) Latency expected from the system (for read and write queries)
    (3) Read/Write ratio
    (4) Traffic estimates
            - Write (QPS, Volume of data)
            - Read  (QPS, Volume of data)
    (5) Storage estimates
    (6) Memory estimates
            - If we are using a cache, what is the kind of data we want to store in cache
            - How much RAM and how many machines do we need for us to achieve this ?
            - Amount of data you want to store in disk/ssd
</code></pre>
<p>(3) DESIGN GOALS [5 min]</p>
<pre><code>    (1) Latency and Throughput requirements
    (2) Consistency vs Availability  [Weak/strong/eventual =&gt; consistency | Failover/replication =&gt; availability]
</code></pre>
<p>(4) HIGH LEVEL DESIGN [5-10 min]</p>
<pre><code>    (1) APIs for Read/Write scenarios for crucial components
    (2) Database schema
    (3) Basic algorithm
    (4) High level design for Read/Write scenario
</code></pre>
<p>(5) DEEP DIVE [15-20 min]</p>
<pre><code>    (1) Scaling the algorithm
    (2) Scaling individual components: 
            -&gt; Availability, Consistency and Scale story for each component
            -&gt; Consistency and availability patterns
    (3) Think about the following components, how they would fit in and how it would help
            a) DNS
            b) CDN [Push vs Pull]
            c) Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
            d) Reverse Proxy
            e) Application layer scaling [Microservices, Service Discovery]
            f) DB [RDBMS, NoSQL]
                    &gt; RDBMS 
                        &gt;&gt; Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
                    &gt; NoSQL
                        &gt;&gt; Key-Value, Wide-Column, Graph, Document
                            Fast-lookups:
                            -------------
                                &gt;&gt;&gt; RAM  [Bounded size] =&gt; Redis, Memcached
                                &gt;&gt;&gt; AP [Unbounded size] =&gt; Cassandra, RIAK, Voldemort
                                &gt;&gt;&gt; CP [Unbounded size] =&gt; HBase, MongoDB, Couchbase, DynamoDB
            g) Caches
                    &gt; Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
                    &gt; Eviction policies:
                            &gt;&gt; Cache aside
                            &gt;&gt; Write through
                            &gt;&gt; Write behind
                            &gt;&gt; Refresh ahead
            h) Asynchronism
                    &gt; Message queues
                    &gt; Task queues
                    &gt; Back pressure
            i) Communication
                    &gt; TCP
                    &gt; UDP
                    &gt; REST
                    &gt; RPC
</code></pre>
<p>(6) JUSTIFY [5 min]</p>
<pre><code>    (1) Throughput of each layer
    (2) Latency caused between each layer
    (3) Overall latency justification
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-09]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-09/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-09/">
        </link>
        <updated>2022-03-09T06:05:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="481-magical-string-medium">481. Magical String （Medium）</h1>
<p>A magical string s consists of only '1' and '2' and obeys the following rules:<br>
The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.<br>
The first few elements of s is s = &quot;1221121221221121122……&quot;. If we group the consecutive 1's and 2's in s, it will be &quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot; and the occurrences of 1's or 2's in each group are &quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;. You can see that the occurrence sequence is s itself.<br>
Given an integer n, return the number of 1's in the first n number in the magical string s.</p>
<pre><code class="language-python">

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022-03-08 Leetcode]]></title>
        <id>https://headhuanglan.github.io/post/2022-03-08-leetcode/</id>
        <link href="https://headhuanglan.github.io/post/2022-03-08-leetcode/">
        </link>
        <updated>2022-03-07T23:50:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-471-encode-string-with-shortest-length-hardfont"><font color='red'> 471. Encode String with Shortest Length （Hard）</font></h1>
<p>Given a string s, encode the string such that its encoded length is the shortest.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. k should be a positive integer.<br>
If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    @lru_cache(None)
    def encode(self, s: str) -&gt; str:
        i=(s+s).find(s,1)
        encoded=str(len(s)//i)+'['+self.encode(s[:i])+']' if i&lt;len(s) else s
        splitEncoded=[self.encode(s[:i])+self.encode(s[i:]) for i in range(1,len(s))]
        return min(splitEncoded+[encoded],key=len)
</code></pre>
<p>答案绝了。。。<br>
For any s, you can either<br>
Do not encode it<br>
Or encode it to one string if possible<br>
Or, split it into two, encode the two substring to their shortest possible length, and combine them<br>
Pick up the shortest result from 1~3.<br>
During this process, you should remember the best encoding result for all substrings so that it can be reused.<br>
For #2, you can use LeetCode 459: Repeated Substring Pattern to find out whether the &quot;s&quot; is repeated or not, and how many times it is repeated:<br>
&quot;i=(s+s).find(s,1)&quot;<br>
&quot;i&quot; is the length of repeating pattern. If i&gt;=len(s), then s is not repeated.</p>
<h1 id="font-colorred-472-concatenated-words-hardfont"><font color='red'> 472. Concatenated Words （Hard）</font></h1>
<p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.<br>
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<pre><code class="language-python">class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -&gt; List[str]:
        d = set(words)
        @lru_cache(None)
        def dfs(word):
            for i in range(1, len(word)):
                prefix = word[:i]
                suffix = word[i:]
                
                if prefix in d and suffix in d:
                    return True
                if prefix in d and dfs(suffix):
                    return True
                if suffix in d and dfs(prefix):
                    return True
            
            return False
        
        res = []
        for word in words:
            if dfs(word):
                res.append(word)
        
        return res

</code></pre>
<p>看答案捐膝盖。。</p>
<h1 id="font-colorred-473-matchsticks-to-square-medium-font"><font color='red'> 473. Matchsticks to Square (Medium) </font></h1>
<p>You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.<br>
Return true if you can make this square and false otherwise.</p>
<pre><code class="language-python">#TLE
class Solution:
    def makesquare(self, matchsticks: List[int]) -&gt; bool:
        length = sum(matchsticks)//4
        if length*4!= sum(matchsticks): return False
        
        holds=[[],[],[],[]]
        self.result=False
        def bt(i):
            if i&gt;=len(matchsticks): return
            for hold in holds:
                val=matchsticks[i]
                hold.append(val)
                if len(set(map(sum,holds)))==1 and i==len(matchsticks)-1:
                    self.result=True
                    return 
                bt(i+1)
                hold.pop()
        
        bt(0)
        
        return self.result

#ANSWER
class Solution:
    def makesquare(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # If there are no matchsticks, then we can't form any square
        if not nums:
            return False

        # Number of matchsticks we have
        L = len(nums)

        # Perimeter of our square (if one can be formed)
        perimeter = sum(nums)

        # Possible side of our square.
        possible_side =  perimeter // 4

        # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).
        if possible_side * 4 != perimeter:
            return False

        # Reverse sort the matchsticks because we want to consider the biggest one first.
        nums.sort(reverse=True)

        # This array represents the 4 sides and their current lengths
        sums = [0 for _ in range(4)]

        # Our recursive dfs function.
        def dfs(index):

            # If we reach the end of matchsticks array, we check if the square was formed or not
            if index == L:
                # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.
                return sums[0] == sums[1] == sums[2] == possible_side

            # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are &gt;= the size of the current matchstick)
            for i in range(4):
                # If this matchstick can fir in the space left for the current side
                if sums[i] + nums[index] &lt;= possible_side:
                    # Recurse
                    sums[i] += nums[index]
                    if dfs(index + 1):
                        return True
                    # Revert the effects of recursion because we no longer need them for other recursions.
                    sums[i] -= nums[index]
            return False        
        return dfs(0)
</code></pre>
<p>初次尝试backtracking TLE。。。答案same idea with trick can pass， reverse sorting and early stopping。</p>
<h1 id="font-colorred-474-ones-and-zeroes-mediumfont"><font color='red'> 474. Ones and Zeroes （Medium）</font></h1>
<p>You are given an array of binary strings strs and two integers m and n.<br>
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.<br>
A set x is a subset of a set y if all elements of x are also elements of y.</p>
<pre><code class="language-python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        
        dp=[[0 for _ in range(n+1)] for __ in range(m+1)]
        for s in strs:
            c0=s.count('0')
            c1=s.count('1')
            for zeros in range(m,c0-1,-1):
                for ones in range(n,c1-1,-1):
                    dp[zeros][ones] = max(1+dp[zeros-c0][ones-c1],dp[zeros][ones])
        
        return dp[m][n]
#ANSWER
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        @lru_cache(None)
        def calculate(i,zeroes,ones):
            if i==len(strs): return 0
            c1=strs[i].count('1')
            c0=strs[i].count('0')        
            taken=-1
            if zeroes-c0&gt;=0 and ones-c1&gt;=0:
                taken = calculate(i+1,zeroes-c0,ones-c1) +1
            not_taken=calculate(  i + 1, zeroes, ones )
            return max(taken, not_taken)
        return calculate(0, m, n) 
    
</code></pre>
<p>greedy failed....   DP? Should have got this one.   dp[i][j] denotes the maximum number of strings that can be included in the subset given only i 0's and j 1's are available. 从后向前因为不能覆盖之前的结果。</p>
<h1 id="font-colorred-475-heaters-mediumfont"><font color='red'> 475. Heaters （Medium）</font></h1>
<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.<br>
Every house can be warmed, as long as the house is within the heater's warm radius range.<br>
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.</p>
<pre><code class="language-python">
#TLE
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        #bfs
        visited=set()
        houses=set(houses)-set(heaters)
        dis=0
        while visited!=houses:
            #print(visited,houses)
            dis+=1
            for cur in heaters: 
                if cur+dis in houses and cur+dis not in visited:
                    visited.add(cur+dis)    
                if cur-dis in houses  and cur-dis not in visited:
                    visited.add(cur-dis)
        return dis
            
#ANSWER
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int:
        
         
               
        def binsearch(nums, target) :
            l, r = 0, len(nums)
            while l &lt; r:
                m = (l + r) // 2
                if nums[m] &lt; target :
                    l = m + 1
                else:
                    r = m
            return l
            
        heaters.sort()
        
        result = float('-inf')
        
        for house in houses :
            index = binsearch(heaters, house)
            leftHeaterDistance = house - heaters[index - 1] if index &gt; 0 else float('inf')
            rightHeaterDistance = heaters[index] - house if index &lt; len(heaters) else float('inf')
            result = max(result , min(leftHeaterDistance, rightHeaterDistance))
        
        return result
        
</code></pre>
<p>变种FBS 每次增加1 distance，TLE。看答案。max min + binary search</p>
<h1 id="476-number-complement-easy">476. Number Complement (Easy)</h1>
<p>The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.<br>
For example, The integer 5 is &quot;101&quot; in binary and its complement is &quot;010&quot; which is the integer 2.<br>
Given an integer num, return its complement.</p>
<pre><code class="language-python">class Solution:
    def findComplement(self, num: int) -&gt; int:
        mask= 2**len(bin(num)[2:])-1
        print(bin(mask),bin(num))
        return mask^num
#ANSWER
from math import log2
class Solution:
    def findComplement(self, num):
        # n is a length of num in binary representation
        n = floor(log2(num)) + 1        
        # bitmask has the same length as num and contains only ones 1...1
        bitmask = (1 &lt;&lt; n) - 1
        # flip all bits
        return bitmask ^ num
#ANSWER
class Solution:
    def findComplement(self, num):
        todo, bit = num, 1
        while todo:
            # flip current bit
            num = num ^ bit
            # prepare for the next run
            bit = bit &lt;&lt; 1
            todo = todo &gt;&gt; 1
        return num
</code></pre>
<h1 id="font-colorred477-total-hamming-distance-medium-font"><font color='red'>477. Total Hamming Distance (Medium) </font></h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.</p>
<pre><code class="language-python">#TLE
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:
        nums.sort()
        @lru_cache(None)
        def cal(a,b):
            val=a^b
            c=0
            while val:
                if val%2==1:
                    c+=1
                val&gt;&gt;=1
            return c
        res=0
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                res+=cal(nums[i],nums[j])
        return res


#ANSWER
class Solution:
    def totalHammingDistance(self, nums: List[int]) -&gt; int:
        if not nums: return 0
        res=0
        n=len(nums)
        count = [0]*32
        
        for num in nums:
            i=0
            while num:
                count[i]+= num &amp; 1
                num &gt;&gt;=1
                i+=1
        
        for k in count:
            res+=k*(n-k)
        
        return res
        
         
</code></pre>
<p>初次尝试 TLE,应该按照bit loop。Say for any particular bit position, count the number of elements with this bit ON (i.e. this particular bit is 1). Let this count be k. Hence the number of elements with this bit OFF (i.e. 0) is (n−k)(n - k) (in an n element array).<br>
Certainly unique pairs of elements exists where one element has this particular bit ON while the other element has this OFF (i.e. this particular bit differs for the two elements of this pair).</p>
<h1 id="478-generate-random-point-in-a-circle-medium">478. Generate Random Point in a Circle （Medium）</h1>
<p>Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.<br>
Implement the Solution class:<br>
Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).<br>
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].</p>
<pre><code class="language-python">from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r
        x=r*(random()-0.5)*2
        y=r*(random()-0.5)*2
        while x*x+y*y&gt;r*r:
            x=r*(random()-0.5)*2
            y=r*(random()-0.5)*2
            
        
        return [self.x+x,self.y+y]
#ANSWER hard
from random import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x=x_center
        self.y=y_center
        

    def randPoint(self) -&gt; List[float]:
        r=self.r*math.sqrt(random())
        theta = 2*math.pi*random()
        x=r*math.cos(theta)
        y=r*math.sin(theta)
     
        return [self.x+x,self.y+y]
#ANSWER
import math
import random
class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.r = radius
        self.x = x_center
        self.y = y_center
        self.area = math.pi * radius ** 2

    def randPoint(self) -&gt; List[float]:
        theta = 2 * math.pi * random.random()
        R = math.sqrt(random.uniform(0, self.area) / math.pi)
        return [self.x + R * math.cos(theta), self.y + R * math.sin(theta)]
</code></pre>
<p>The area under any probability density function curve must be 1 . Therefore, the equation must be f(x)=2x Using our probability density function f , we can compute the cumulative distribution function F , where F(x) is the probability of sampling a point within a distance of x from the origin.F(x)=∫f(x)=∫2x=x2<br>
Lastly, we can use our cumulative distribution function F  to compute the inverse cumulative distribution function  F^{-1} , which accepts uniform random value between 0  and 1  and returns a random distance from origin in accordance with f</p>
<h1 id="font-colorred-479-largest-palindrome-product-hard-font"><font color='red'> 479. Largest Palindrome Product (Hard) </font></h1>
<p>Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.</p>
<pre><code class="language-python">class Solution:
    def largestPalindrome(self, n: int) -&gt; int:
        max_=10**n-1
        min_=max_//10
        for h in range(max_,min_,-1):
            left=h
            right=0
            #// construct the palindrome
            i=h
            while i:
                right=right*10+i%10
                left*=10
                i//=10
            
            palindrom=left+right
            #print(palindrom)
            for i in range(max_,min_,-1):
                j=palindrom//i
                #// terminate if the other number is greater than current number
                if j&gt;i: break
                if  palindrom%i==0: return palindrom%1337
        #// account for case n = 1
        return 9
</code></pre>
<p>没思路。。。</p>
<h1 id="480-sliding-window-median-hard">480. Sliding Window Median （Hard）</h1>
<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.<br>
For examples, if arr = [2,3,4], the median is 3.<br>
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.<br>
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.<br>
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.</p>
<pre><code class="language-python">class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        odd=False
        pos1=0
        pos2=0
        if k%2==1:
            odd=True
            pos1=k//2
        else:
            pos1=k//2-1
            pos2=k//2
        
        res = []
        for i in range(k,len(nums)+1):
            tmp = sorted(nums[i-k:i])
            if odd: 
                res.append(tmp[pos1])
            else:
                res.append( (tmp[pos1]+tmp[pos2])/2)
        return res

#ANSWER O(nk)
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        window = sorted(nums[:k])
        medians = []
        for a, b in zip(nums, nums[k:] + [0]):
            if k&amp;1:
                medians.append( window[k//2])
            else:
                medians.append( (window[k//2]+window[k//2-1])/2.0)
            window.remove(a)
            bisect.insort(window, b)
        return medians

#ANSWER O(nlogk)
import heapq
from collections import defaultdict
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -&gt; List[float]:
        if not nums or not k:
            return []
        #lo  hi
        lo = [] # max heap   
        hi = [] # min heap
        for i in range(k):
            if len(lo) == len(hi):
                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))
            else:
                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))
        ans = [float(hi[0])] if k &amp; 1 else [(hi[0] - lo[0]) / 2.0]
        to_remove = defaultdict(int)
        for i in range(k, len(nums)): # right bound of window
            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo
            out_num = nums[i-k]
            #out_num恰巧在lo的边界上，所以要更新边界
            if out_num &gt; -lo[0]:
                heapq.heappush(hi, -heapq.heappop(lo))
            to_remove[out_num] += 1

            #在lo边界上可以直接去掉
            while lo and to_remove[-lo[0]]:
                to_remove[-lo[0]] -= 1
                heapq.heappop(lo)
            #在hi边界上可以直接去掉
            while to_remove[hi[0]]:
                to_remove[hi[0]] -= 1
                heapq.heappop(hi)
            if k % 2:
                ans.append(float(hi[0]))
            else:
                ans.append((hi[0] - lo[0]) / 2.0)
        return ans
</code></pre>
<p>思路：维持small ，large 连个queue， 所有samll中元素都小于large， 所以median是 （max（small）+min（large））除以2，如果small ，large等长， 如果large长，则返回min（large）<br>
所以用heap， small用的是maxheap， large用的是minheap。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022-03-07 Leetcode]]></title>
        <id>https://headhuanglan.github.io/post/2022-03-07-leetcode/</id>
        <link href="https://headhuanglan.github.io/post/2022-03-07-leetcode/">
        </link>
        <updated>2022-03-07T07:06:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="461-hamming-distance-easy">461. Hamming Distance (Easy)</h1>
<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>
Given two integers x and y, return the Hamming distance between them.</p>
<pre><code class="language-python">class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        res=x^y
        c=0
        for i in range(32):
            if res &gt;&gt;i &amp; 1:
                c+=1
        return c
#
class Solution(object):
    def hammingDistance(self, x, y):
        &quot;&quot;&quot;
        :type x: int
        :type y: int
        :rtype: int
        &quot;&quot;&quot;
        xor = x ^ y
        distance = 0
        while xor:
            # mask out the rest bits
            if xor &amp; 1:
                distance += 1
            xor = xor &gt;&gt; 1
        return distance

#
class Solution:
    def hammingDistance(self, x, y):
        xor = x ^ y
        distance = 0
        while xor:
            distance += 1
            # remove the rightmost bit of '1'
            xor = xor &amp; (xor - 1)
        return distance
</code></pre>
<h1 id="462-minimum-moves-to-equal-array-elements-ii-medium">462. Minimum Moves to Equal Array Elements II (Medium)</h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment or decrement an element of the array by 1.<br>
Test cases are designed so that the answer will fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def minMoves2(self, nums: List[int]) -&gt; int:
        # nums[i]-mid
        nums.sort()
        mid= nums[len(nums)//2]
        return sum([abs(val-mid) for val in nums])
#JAVA ANSWER good to know
public class Solution {
    public int minMoves2(int[] nums) {
        int l = 0, r = nums.length - 1, sum = 0;
        Arrays.sort(nums);
        while (l &lt; r) {
            sum += nums[r] - nums[l];
            l++;
            r--;
        }
        return sum;
    }
}
</code></pre>
<h1 id="463-island-perimeter-easy">463. Island Perimeter (Easy)</h1>
<p>You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.<br>
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).<br>
The island doesn't have &quot;lakes&quot;, meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>
<pre><code class="language-python">class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:
        # find a neighor + neighbor4 but contact need to -contact number.
        visited=set()
        def nei(i,j):
            neis=[]
            for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if ii&lt;0 or ii&gt;=len(grid) or jj&lt;0 or jj&gt;=len(grid[0]) or grid[ii][jj]==0: 
                        continue
                neis.append((ii,jj))
            return neis
        
        res = [0]
        
        def dfs(i,j):
            if (i,j) in visited: return
            res[0]+=4
            neis = nei(i,j)
            res[0]-=len(neis)
            visited.add((i,j))
            for ne in neis:
                if ne not in visited:
                    dfs(*ne)
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    dfs(i,j)
                    break
        return res[0]
            
</code></pre>
<h1 id="font-colorred-464-can-i-win-medium-font"><font color='red'> 464. Can I Win (Medium) </font></h1>
<p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.<br>
What if we change the game so that players cannot re-use integers?<br>
For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.<br>
Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.</p>
<pre><code class="language-python">class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool:
        @lru_cache(None)
        def check(nums, t):
            if nums[-1] &gt;= t: return True
            res = any(not check(tuple(nums[:i]+nums[i+1:]),t-nums[i]) for i in range(len(nums)))
            return res
            
        if maxChoosableInteger * (1 + maxChoosableInteger) // 2 &lt; desiredTotal: return False
        nums = tuple(range(1, maxChoosableInteger + 1))
        return check(nums, desiredTotal)

#ANSWER 2 TLE
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool:
        dic = dict()
        used = [False]*(maxChoosableInteger+1)
        
        sum_=(1+maxChoosableInteger)*maxChoosableInteger//2
        if sum_&lt;desiredTotal: return False
        if desiredTotal&lt;=0: return True
        
        def formatkey(used):
            n=0
            for bl in used:
                n&lt;&lt;=1
                if bl:
                    n |=1
            return n
            
        def helper(desiredTotal):
            if desiredTotal&lt;=0: return False
            key = formatkey(used)
            if key not in dic:
                for i in range(1,len(used)):
                    if not used[i]:
                        used[i]=True
                        #check whether this lead to a win (i.e. the other player lose)
                        if not helper(desiredTotal-i):
                            dic[key]=True
                            used[i]=False
                            return True
                        used[i]=False
                dic[key]=False
            
            return dic[key]
        
        return helper(desiredTotal)
</code></pre>
<p>can not reuse integer， 答案 pythonic写法。</p>
<h1 id="font-colorred-465-optimal-account-balancing-hardfont"><font color='red'> 465. Optimal Account Balancing （Hard）</font></h1>
<p>You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.<br>
Return the minimum number of transactions required to settle the debt.</p>
<pre><code class="language-python">    def minTransfers(self, transactions):
        &quot;&quot;&quot;
        :type transactions: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        m = collections.defaultdict(int)
        
        for t in transactions:
            m[t[0]]-=t[2]
            m[t[1]]+=t[2]
        
        debt = m.values()
        
        def dfs(s):
            while(s&lt;len(debt) and debt[s]==0):
                s+=1
            if s==len(debt): return 0
            
            r = float('inf')
            for i in range(s+1,len(debt)):
                if debt[i]*debt[s]&lt;0:
                    # settle s with i
                    debt[i]+=debt[s]
                    r=min(r,1+dfs(s+1))
                    # backtrack
                    debt[i]-=debt[s]
            return r
        
        return dfs(0)



</code></pre>
<p>idea is tricky...  person index s have debt[s] for other person from s+1, if other person have neg sign then person s. update debt[i] with debt[s] (so person i will take full responsiblity of person s). r=min(r,1+dfs(s+1))</p>
<h1 id="font-colorred-466-count-the-repetitions-hard-font"><font color='red'> 466. Count The Repetitions (Hard) </font></h1>
<p>We define str = [s, n] as the string str which consists of the string s concatenated n times.<br>
For example, str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;.<br>
We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.<br>
For example, s1 = &quot;abc&quot; can be obtained from s2 = &quot;abdbec&quot; based on our definition by removing the bolded underlined characters.<br>
You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].<br>
Return the maximum integer m such that str = [str2, m] can be obtained from str1.</p>
<pre><code class="language-python">
class Solution:
    def getMaxRepetitions(self, s1, n1, s2, n2):
        d, l1, l2, i1, i2 = {}, len(s1), len(s2), 0, 0
        tot = l1 * n1

        while i1 &lt; tot:
            if s1[i1 % l1] == s2[i2 % l2]:
                if (i1 % l1, i2 % l2) in d:
                    prev1, prev2 = d[(i1 % l1, i2 % l2)]
                    cir1, cir2 = i1 - prev1, i2 - prev2
                    count_cir1 = (tot - i1) // cir1
                    i1 += count_cir1 * cir1
                    i2 += count_cir1 * cir2
                    if i1 &gt;= tot: break
                else:
                    d[(i1 % l1, i2 % l2)] = (i1, i2)
                i2 += 1
            i1 += 1
        return i2 // l2 // n2

</code></pre>
<p>直接数出现的次数算重复不行，因为还有字母出现次序问题。。。 得找重复pattern。 答案厉害。</p>
<h1 id="font-colorred-467-unique-substrings-in-wraparound-string-medium-font"><font color='red'> 467. Unique Substrings in Wraparound String (Medium) </font></h1>
<p>We define the string s to be the infinite wraparound string of &quot;abcdefghijklmnopqrstuvwxyz&quot;, so s will look like this:<br>
&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;.<br>
Given a string p, return the number of unique non-empty substrings of p are present in s.</p>
<pre><code class="language-python">def findSubstringInWraproundString(self, p):
        res = {i: 1 for i in p}
        l = 1
        for i, j in zip(p, p[1:]):
            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
            res[j] = max(res[j], l)
        return sum(res.values())
#
class Solution:
    def findSubstringInWraproundString(self, p: str) -&gt; int:
        if not p: return 0
        count = [0]*26
        #initally, count is 1 for each unique char
        for char in p:
            count[ord(char)-ord('a')]=1
        
        res=1
        #for each sub sequence ending in char2, if it is connected, res+=1 else res=1
        for char1,char2 in zip(p,p[1:]):
            if (ord(char2)-ord(char1))%26==1:
                res+=1
            else:
                res=1
            #prevent duplicate char2
            count[ord(char2)-ord('a')] = max(count[ord(char2)-ord('a')], res)
                
        return sum(count)

#ANSWER DP 思路：若字符连续，当前可形成的substring个数+1，若不连续substring个数=1，更新count 为防止重复字符overwrite，更新时候取max。 
class Solution:
    def findSubstringInWraproundString(self, p: str) -&gt; int:
        count=[0]*26
        cur_maxlen=0
        for i in range(len(p)):
            if i&gt;0 and (ord(p[i])-ord(p[i-1]))%26==1:
                cur_maxlen+=1
            else:
                cur_maxlen=1
            
            index=ord(p[i])-ord('a')
            count[index]=max(count[index],cur_maxlen)
        
        return sum(count)
</code></pre>
<p>看答案了。。。<br>
Each single charecter contribution is initialized to 1<br>
if the order is continued, the contribution is increased by 1 from previous character contribution</p>
<p>example string zabce</p>
<p>Values got incremented in the following way</p>
<pre><code>z -&gt; 1
a -&gt; 1 + 1 (or) z + 1 -&gt; 2
b -&gt; 1 + 1 + 1 (or) a + 1 -&gt; 3
c -&gt; 1 + 1 + 1 + 1 (or) b + 1 -&gt; 4
e -&gt; 1 (ord(j) - ord(i)) % 26 != 1 here
</code></pre>
<p>So the final answer is contribution from z + a + b + c + e (1 + 2 + 3 + 4 + 1 = 11)</p>
<pre><code>max(res[j], l) is required to handle cases where the character is repeated.
</code></pre>
<p>For example in zaba, since each each unique character is assigned as key to res, the 2nd a contribution should not replace the 1st a contribution until it exceeds the 1st a contribution</p>
<h1 id="468-validate-ip-address-medium">468. Validate IP Address （Medium）</h1>
<p>Given a string queryIP, return &quot;IPv4&quot; if IP is a valid IPv4 address, &quot;IPv6&quot; if IP is a valid IPv6 address or &quot;Neither&quot; if IP is not a correct IP of any type.<br>
A valid IPv4 address is an IP in the form &quot;x1.x2.x3.x4&quot; where 0 &lt;= xi &lt;= 255 and xi cannot contain leading zeros. For example, &quot;192.168.1.1&quot; and &quot;192.168.1.0&quot; are valid IPv4 addresses but &quot;192.168.01.1&quot;, while &quot;192.168.1.00&quot; and &quot;192.168@1.1&quot; are invalid IPv4 addresses.<br>
A valid IPv6 address is an IP in the form &quot;x1:x2:x3:x4:x5:x6:x7:x8&quot; where:<br>
1 &lt;= xi.length &lt;= 4<br>
xi is a hexadecimal string which may contain digits, lower-case English letter ('a' to 'f') and upper-case English letters ('A' to 'F').<br>
Leading zeros are allowed in xi.<br>
For example, &quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; and &quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot; are valid IPv6 addresses, while &quot;2001:0db8:85a3::8A2E:037j:7334&quot; and &quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot; are invalid IPv6 addresses.</p>
<pre><code class="language-python">class Solution:
    def validIPAddress(self, queryIP: str) -&gt; str:
        
        def convert4(string):
            # in range 0~255
            # cannot leading zeros
            # number only
            if not string: return False
            if len(string)&gt;1 and string[0]=='0': return False
            val=0
            for s in string:
                if s not in '0123456789':
                    return False
                val=val*10+int(s)
            
            #return True if success, else False
            if val&gt;=0 and val&lt;=255:
                return True
            return False
        
        def convert6(string):
            if not string: return False
            #length 1~4
            # hexadecial string 0~9 a~f A~F
            if len(string)&gt;4: return False
            for s in string:
                if s not in '0123456789abcdefABCDEF':
                    return False
            return True
        
        if '.' in queryIP:
            data = queryIP.split('.')
            if len(data)==4 and all([convert4(string) for string in data]):
                return 'IPv4'        
            
        elif ':' in queryIP:
            data = queryIP.split(':')
            if len(data)==8 and all([convert6(string) for string in data]):
                return 'IPv6'
        
        return 'Neither'

</code></pre>
<p>只需要细心的题目</p>
<h1 id="font-colorred-469-convex-polygon-mediumfont"><font color='red'> 469. Convex Polygon （Medium）</font></h1>
<p>You are given an array of points on the X-Y plane points where points[i] = [xi, yi]. The points form a polygon when joined sequentially.<br>
Return true if this polygon is convex and false otherwise.<br>
You may assume the polygon formed by given points is always a simple polygon. In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don't intersect each other.</p>
<pre><code class="language-python">def isConvex(self, p: List[List[int]]) -&gt; bool:
    def ccw(a, b, c):
        # (b-a) X (c-a)
        return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) 
    res = [ccw(p[i-2], p[i-1], p[i]) for i in range(len(p))]
    return abs(sum(res)) == sum(abs(i) for i in res)
</code></pre>
<p>convex...beyond my knowledge  CCW算法。。。Note: |Σxi| = Σ|xi| is only true when all xi are the same sign.</p>
<h1 id="470-implement-rand10-using-rand7-medium">470. Implement Rand10() Using Rand7() (Medium)</h1>
<p>Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.<br>
Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<pre><code class="language-python"># The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        # rand1  1~7   取1~6  奇偶决定生成左区间1~5 还是右区间6~10
        # rand2        取1~5  
        rand1=rand7()
        while rand1==7:
            rand1=rand7()
        flag = rand1%2==1
        rand2=rand7()
        while rand2&gt;5:
            rand2=rand7()
        return 5+rand2 if flag else rand2

#ANSWER
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        n1=rand7()
        n2=rand7()
        while n1+(n2-1)*7 &gt;40:
            n1=rand7()
            n2=rand7()
        return (n1+(n2-1)*7)%10 +1
</code></pre>
<p>(n2-1)乘7+n1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-06/">
        </link>
        <updated>2022-03-06T11:20:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="451-sort-characters-by-frequency-medium">451. Sort Characters By Frequency （Medium）</h1>
<p>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.<br>
Return the sorted string. If there are multiple answers, return any of them</p>
<pre><code class="language-python">class Solution:
    def frequencySort(self, s: str) -&gt; str:
        d=Counter(s)
        res=''
        for k in sorted(d,key=lambda x: d[x],reverse=True):
            res+=k*d[k]
        return res
#O(n) bucket sort
class Solution:
    def frequencySort(self, s: str) -&gt; str:
        if not s: return s
        counts=collections.Counter(s)
        max_freq=max(counts.values())
        
        buckets=[[] for _ in range(max_freq+1)]
        for c,i in counts.items():
            buckets[i].append(c)
        
        string_builder=[]
        for i in range(len(buckets)-1,0,-1):
            for c in buckets[i]:
                string_builder.append(c*i)
        return ''.join(string_builder)
        
</code></pre>
<p>答案的On解法好。bucketsort</p>
<h1 id="452-minimum-number-of-arrows-to-burst-balloons-medium">452. Minimum Number of Arrows to Burst Balloons (Medium)</h1>
<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.<br>
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.<br>
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</p>
<pre><code class="language-python">class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        #merge points by &amp; return how many distinct points
        
        points=sorted(points,key=lambda x:x[0])
        res=[]
        for p in points:
            if res:
                # 1    1
                #    2   2 
                if res[-1][1]&gt;=p[0]:
                    res[-1][0]=max(res[-1][0],p[0])
                    res[-1][1]=min(res[-1][1],p[1])
                    
                else:
                    res.append(p)
            else:
                res.append(p)
        #print(res)
        return len(res)
                
#ANSWER WAY OF WRITTING
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        if not points:
            return 0
        
        # sort by x_end
        points.sort(key = lambda x : x[1])
        
        arrows = 1
        first_end = points[0][1]
        for x_start, x_end in points:
            # if the current balloon starts after the end of another one,
            # one needs one more arrow
            if first_end &lt; x_start:
                arrows += 1
                first_end = x_end
        
        return arrows
</code></pre>
<p>我的思路是找到相交的区间，看总共多少个就行。。。答案思路是track球右边位置，让碰到新气球左边大于cur end位置+1，更新end位置的greedy算法。</p>
<h1 id="font-colorred-453-minimum-moves-to-equal-array-elements-mediumfont"><font color='red'> 453. Minimum Moves to Equal Array Elements （Medium）</font></h1>
<p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.<br>
In one move, you can increment n - 1 elements of the array by 1.</p>
<pre><code class="language-python">#TLE naive solution
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        c=0
        while len(set(nums))!=1:
            ind = nums.index(max(nums))
            for i in range(len(nums)):
                if i!=ind:
                    nums[i]+=1
            #print(nums)
            c+=1
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int:
        nums.sort()
        c=0
        for i in range(len(nums)-1,0,-1):
            c+=nums[i]-nums[0]
        return c
#ANSWER
class Solution:
    def minMoves(self, nums: List[int]) -&gt; int: 
        moves=0
        min_=float('inf')
        for i in range(len(nums)):
            moves+=nums[i]
            min_=min(min_,nums[i])
        return moves-min_*len(nums)
</code></pre>
<p>答案很巧妙，如果是答案1） 思路先sort，那么每次需要move是nums【i】-nums【0】，这样move后nums【i】和nums【0】相等，然后其余数字都加上了move次，再次move时候，求nums【i-1】-nums【0】，这样nums【0】就和nums【i-1】相等，自然也和nums【i】相等。 以此类推，可求出总共move数目。 如果是答案2）所有加1除了1个不加，和只有一个减去1是等效的。 所以就是减多少次能使所有数平衡，sum（all）-min（all）乘n。</p>
<h1 id="454-4sum-ii-medium">454. 4Sum II （Medium）</h1>
<p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:<br>
0 &lt;= i, j, k, l &lt; n<br>
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
<pre><code class="language-python">class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:
        dic2sum=collections.defaultdict(int)
        for i in nums1:
            for j in nums2:
                dic2sum[i+j]+=1
        
        res=0
        for k in nums3:
            for l in nums4:
                if -k-l in dic2sum:
                    res+=dic2sum[-k-l]
        return res



#ANSWER GENERALIZED 
class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int:
        m = collections.defaultdict(int)
        lists = [A, B, C, D]

        def nSumCount() -&gt; int:
            addToHash(0, 0)
            return countComplements(len(lists) // 2, 0)

        def addToHash(i: int, total: int) -&gt; None:
            if i == len(lists) // 2:
                m[total] = m[total] + 1
            else:
                for a in lists[i]:
                    addToHash(i + 1, total + a)

        def countComplements(i: int, complement: int) -&gt; int:
            if i == len(lists):
                return m[complement]
            cnt = 0
            for a in lists[i]:
                cnt += countComplements(i + 1, complement - a)
            return cnt

        return nSumCount()
</code></pre>
<h1 id="455-assign-cookies-easy">455. Assign Cookies (Easy)</h1>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.<br>
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<pre><code class="language-python">class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:
        g.sort()
        s.sort()
        c=0
        while g:
            cur=g.pop(0)
            while s and s[0]&lt;cur:
                s.pop(0)
            if s:
                s.pop(0)
                c+=1
        return c
#
# 先对g, s两个数组进行排序
# 贪心算法
# 贪心思想1 优先满足需求因子较小的孩子。因为如果较小需求的孩子无法被满足，则之后的较大的需求更不可能能被满足了。
#贪心思想2 尽量用较小的糖果去优先满足孩子。

class Solution:
    def findContentChildren(self, g, s):
        &quot;&quot;&quot;
        :type g: List[int]
        :type s: List[int]
        :rtype: int
        &quot;&quot;&quot;
        g.sort()    # 对需求因子进行排序，从小到大
        s.sort()    # 对糖果数组进行排序，从小到大
        child  = 0  # 记录可以被满足孩子数
        cookie = 0  # 记录可以满足的糖果数
        while  child &lt;len(g) and cookie &lt; len(s):
            if g[child] &lt;= s[cookie]: 
                child += 1
            cookie += 1
        return child
</code></pre>
<h1 id="font-colorred-456-132-pattern-mediumfont"><font color='red'> 456. 132 Pattern （Medium）</font></h1>
<p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].<br>
Return true if there is a 132 pattern in nums, otherwise, return false.</p>
<pre><code class="language-python">class Solution:
    def find132pattern(self, nums: List[int]) -&gt; bool:
        if len(nums) &lt; 3:
            return False
        stack=[]
        min_array = [-1] * len(nums)
        min_array[0] = nums[0]
        for i in range(1, len(nums)):
            min_array[i] = min(min_array[i - 1], nums[i])
        
        
        for j in range(len(nums) - 1, -1, -1):
            if nums[j] &lt;= min_array[j]:
                continue
            while stack and stack[-1] &lt;= min_array[j]:
                stack.pop()
            if stack and stack[-1] &lt; nums[j]:
                return True
            stack.append(nums[j])
        return False

</code></pre>
<p>估计是用stack但是。。。看答案思路：从前往后算minarry，从后往前用stack。</p>
<h1 id="font-colorred-457-circular-array-loop-mediumfont"><font color='red'> 457. Circular Array Loop （Medium）</font></h1>
<p>You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:<br>
If nums[i] is positive, move nums[i] steps forward, and<br>
If nums[i] is negative, move nums[i] steps backward.<br>
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.<br>
A cycle in the array consists of a sequence of indices seq of length k where:<br>
Following the movement rules above results in the repeating index sequence seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...<br>
Every nums[seq[j]] is either all positive or all negative.<br>
k &gt; 1<br>
Return true if there is a cycle in nums, or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
        #two pointer
        n=len(nums)
        #check every start location
        for start in range(n):
            if nums[start]==0: continue
                
            slow=start
            fast=(slow+nums[slow])%n
            
            #if sign of fast and fast.next is the same we do the while loop
            while nums[start]*nums[fast]&gt;0 and  nums[start] * nums[(fast+nums[fast])%n] &gt; 0:
                if slow == fast:
                    if slow == (slow+nums[slow])%n:  
                        break #  1-element loop
                    return True 


                slow = (slow+nums[slow])%n
                fast = (fast+nums[fast])%n
                fast = (fast+nums[fast])%n
            
            #we are here know start from start have no loop so mark visited as 0
            slow = start 
            sgn = nums[start] 
            while sgn * nums[slow] &gt; 0:
                nxt = (slow+nums[slow])%n
                nums[slow] = 0 
                slow = nxt 

        return False
        

</code></pre>
<p>two pointer, but tricky ....if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.</p>
<h1 id="458-poor-pigs-hard">458. Poor Pigs (Hard)</h1>
<p>There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.<br>
You can feed the pigs according to these steps:<br>
Choose some live pigs to feed.<br>
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.<br>
Wait for minutesToDie minutes. You may not feed any other pigs during this time.<br>
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.<br>
Repeat this process until you run out of time.<br>
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.</p>
<pre><code class="language-python">class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
        return int(math.ceil(math.log(buckets, 2) / math.log(minutesToTest / minutesToDie + 1, 2)))
</code></pre>
<p>good to knwo but not algorithm..</p>
<h1 id="459-repeated-substring-pattern-easy">459. Repeated Substring Pattern （Easy）</h1>
<p>Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<pre><code class="language-python">class Solution:
    def repeatedSubstringPattern(self, s: str) -&gt; bool:
        for i in range(1,len(s)//2+1):
            if s[:i]*(len(s)//i)==s:
                return True
        return False
#ANSWER
def repeatedSubstringPattern(self, str):

        &quot;&quot;&quot;
        :type str: str
        :rtype: bool
        &quot;&quot;&quot;
        if not str:
            return False
            
        ss = (str + str)[1:-1]
        return ss.find(str) != -1
#ANSWER
def repeatedSubstringPattern(self, str):
    return s in (s+s)[1:-1]
    

</code></pre>
<p>答案思路很好， If the string S has repeated block, it could be described in terms of pattern.<br>
S = SpSp (For example, S has two repeatable block at most)<br>
If we repeat the string, then SS=SpSpSpSp.<br>
Destroying first and the last pattern by removing each character, we generate a new S2=SxSpSpSy.</p>
<h1 id="font-colorred-460-lfu-cache-hardfont"><font color='red'> 460. LFU Cache （Hard）</font></h1>
<p>Design and implement a data structure for a Least Frequently Used (LFU) cache.<br>
Implement the LFUCache class:<br>
LFUCache(int capacity) Initializes the object with the capacity of the data structure.<br>
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.<br>
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.<br>
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.<br>
When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.<br>
The functions get and put must each run in O(1) average time complexity.</p>
<pre><code class="language-python">import collections

class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.freq = 1
        self.prev = self.next = None

class DLinkedList:
    &quot;&quot;&quot; An implementation of doubly linked list.
	
	Two APIs provided:
    
    append(node): append the node to the head of the linked list.
    pop(node=None): remove the referenced node. 
                    If None is given, remove the one from tail, which is the least recently used.
                    
    Both operation, apparently, are in O(1) complexity.
    &quot;&quot;&quot;
    def __init__(self):
        self._sentinel = Node(None, None) # dummy node
        self._sentinel.next = self._sentinel.prev = self._sentinel
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def append(self, node):
        node.next = self._sentinel.next
        node.prev = self._sentinel
        node.next.prev = node
        self._sentinel.next = node
        self._size += 1
    
    def pop(self, node=None):
        if self._size == 0:
            return
        
        if not node:
            node = self._sentinel.prev

        node.prev.next = node.next
        node.next.prev = node.prev
        self._size -= 1
        
        return node
        
class LFUCache:
    def __init__(self, capacity):
        &quot;&quot;&quot;
        :type capacity: int
        
        Three things to maintain:
        
        1. a dict, named as `self._node`, for the reference of all nodes given key.
           That is, O(1) time to retrieve node given a key.
           
        2. Each frequency has a doubly linked list, store in `self._freq`, where key
           is the frequency, and value is an object of `DLinkedList`
        
        3. The min frequency through all nodes. We can maintain this in O(1) time, taking
           advantage of the fact that the frequency can only increment by 1. Use the following
		   two rules:
           
           Rule 1: Whenever we see the size of the DLinkedList of current min frequency is 0,
                   the min frequency must increment by 1.
           
           Rule 2: Whenever put in a new (key, value), the min frequency must 1 (the new node)
           
        &quot;&quot;&quot;
        self._size = 0
        self._capacity = capacity
        
        self._node = dict() # key: Node
        self._freq = collections.defaultdict(DLinkedList)
        self._minfreq = 0
        
        
    def _update(self, node):
        &quot;&quot;&quot; 
        This is a helper function that used in the following two cases:
        
            1. when `get(key)` is called; and
            2. when `put(key, value)` is called and the key exists.
         
        The common point of these two cases is that:
        
            1. no new node comes in, and
            2. the node is visited one more times -&gt; node.freq changed -&gt; 
               thus the place of this node will change
        
        The logic of this function is:
        
            1. pop the node from the old DLinkedList (with freq `f`)
            2. append the node to new DLinkedList (with freq `f+1`)
            3. if old DlinkedList has size 0 and self._minfreq is `f`,
               update self._minfreq to `f+1`
        
        All of the above opeartions took O(1) time.
        &quot;&quot;&quot;
        freq = node.freq
        
        self._freq[freq].pop(node)
        if self._minfreq == freq and not self._freq[freq]:
            self._minfreq += 1
        
        node.freq += 1
        freq = node.freq
        self._freq[freq].append(node)
    
    def get(self, key):
        &quot;&quot;&quot;
        Through checking self._node[key], we can get the node in O(1) time.
        Just performs self._update, then we can return the value of node.
        
        :type key: int
        :rtype: int
        &quot;&quot;&quot;
        if key not in self._node:
            return -1
        
        node = self._node[key]
        self._update(node)
        return node.val

    def put(self, key, value):
        &quot;&quot;&quot;
        If `key` already exists in self._node, we do the same operations as `get`, except
        updating the node.val to new value.
        
        Otherwise, the following logic will be performed
        
        1. if the cache reaches its capacity, pop the least frequently used item. (*)
        2. add new node to self._node
        3. add new node to the DLinkedList with frequency 1
        4. reset self._minfreq to 1
        
        (*) How to pop the least frequently used item? Two facts:
        
        1. we maintain the self._minfreq, the minimum possible frequency in cache.
        2. All cache with the same frequency are stored as a DLinkedList, with
           recently used order (Always append at head)
          
        Consequence? ==&gt; The tail of the DLinkedList with self._minfreq is the least
                         recently used one, pop it...
        
        :type key: int
        :type value: int
        :rtype: void
        &quot;&quot;&quot;
        if self._capacity == 0:
            return
        
        if key in self._node:
            node = self._node[key]
            self._update(node)
            node.val = value
        else:
            if self._size == self._capacity:
                node = self._freq[self._minfreq].pop()
                del self._node[node.key]
                self._size -= 1
                
            node = Node(key, value)
            self._node[key] = node
            self._freq[1].append(node)
            self._minfreq = 1
            self._size += 1


</code></pre>
<p>Each key is mapping to the corresponding node (self._node), where we can retrieve the node in O(1) time.</p>
<p>Each frequency freq is mapped to a Doubly Linked List (self._freq), where all nodes in the DLinkedList have the same frequency, freq. Moreover, each node will be always inserted in the head (indicating most recently used).</p>
<p>A minimum frequency self._minfreq is maintained to keep track of the minimum frequency of across all nodes in this cache, such that the DLinkedList with the min frequency can always be retrieved in O(1) time.</p>
<p>Here is how the algorithm works</p>
<p>get(key)</p>
<pre><code>query the node by calling self._node[key]
find the frequency by checking node.freq, assigned as f, and query the DLinkedList that this node is in, through calling self._freq[f]
pop this node
update node's frequence, append the node to the new DLinkedList with frequency f+1
if the DLinkedList is empty and self._minfreq == f, update self._minfreq to f+1.
return node.val
</code></pre>
<p>put(key, value)</p>
<pre><code>If key is already in cache, do the same thing as get(key), and update node.val as value
Otherwise:
    if the cache is full, pop the least frequenly used element (*)
    add new node to self._node
    add new node to self._freq[1]
    reset self._minfreq to 1
</code></pre>
<p>(*) The least frequently used element is the tail element in the DLinkedList with frequency self._minfreq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-05/">
        </link>
        <updated>2022-03-05T11:11:11.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="441-arranging-coins-easy">441. Arranging Coins （Easy）</h1>
<p>You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.<br>
Given the integer n, return the number of complete rows of the staircase you will build.</p>
<pre><code class="language-python">class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        r=0
        while n&gt;0:
            r+=1
            n-=r
        return r-1 if n&lt;0 else r

class Solution:
    def arrangeCoins(self, n: int) -&gt; int:
        
        # (1+ x) x /2 &lt;= n
        #      (1+x)x &lt;= 2n
        # max x which (1+x)x &lt;=2n
        
        l, r = 0, n
        
        while l &lt;= r:
            
            m = (l + r) // 2
            
            if (m+1)*m &lt;= 2*n and (m+2)*(m+1) &gt; 2*n:
                return m
            
            if (m+1)*m &lt; 2*n:
                l = m + 1
            else:
                r = m - 1
                
</code></pre>
<p>答案是binary  search啊。。</p>
<h1 id="442-find-all-duplicates-in-an-array-medium">442. Find All Duplicates in an Array （Medium）</h1>
<p>Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.<br>
You must write an algorithm that runs in O(n) time and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        # 0 1 2 3 4 5 6 7
        # 4 3 2 7 8 2 3 1
        
        # -4 3 2-7    -3-1 
        
        n=len(nums)
        
        for i in range(n):
            ind=(abs(nums[i])%n-1)
            nums[ind] =   abs(nums[ind])+n if nums[ind]&lt;0 else -abs(nums[ind])-n
        
        #print(nums)
        res=[]
        for i in range(n):
            if nums[i]&gt;n:
                res.append(i+1)
        return res

#ANSWER
class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        res=[]
        for n in nums:
            if nums[abs(n)-1]&lt;0: #seen before
                res.append(abs(n))
            
            nums[abs(n)-1]*=-1
        
        return res
</code></pre>
<p>特殊的bookkeeping。 答案写的更好</p>
<h1 id="font-colorblue-443-string-compression-medium-font"><font color='blue'> 443. String Compression （Medium） </font></h1>
<p>Given an array of characters chars, compress it using the following algorithm:<br>
Begin with an empty string s. For each group of consecutive repeating characters in chars:<br>
If the group's length is 1, append the character to s.<br>
Otherwise, append the character followed by the group's length.<br>
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.<br>
After you are done modifying the input array, return the new length of the array.<br>
You must write an algorithm that uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def compress(self, chars: List[str]) -&gt; int:
        #two pointer
        l=0
        lchar=0
        r=0
        while r&lt;len(chars):
            c=0
            while r&lt;len(chars) and chars[r]==chars[l]:
                c+=1
                r+=1
            
            if c&gt;0:r-=1
            
            if c==1:
                chars[lchar]=chars[l]
                l+=1
                lchar=lchar+1
            elif c&gt;1 and c&lt;10:
                chars[lchar]=chars[l]
                chars[lchar+1]=str(c)
                l=l+c
                lchar=lchar+2
            elif c&gt;=10:
                chars[lchar]=chars[l]
                l=l+c
                for j,cc in enumerate(str(c)):
                    chars[lchar+1+j]=cc
                 
                lchar=lchar+len(str(c))+1
            r+=1    
            
        return lchar 
#ANSWER 更简单
 
class Solution:
    def compress(self, chars: List[str]) -&gt; int:
        walker, runner = 0, 0
        while runner &lt; len(chars):
		
            chars[walker] = chars[runner]
            count = 1
			
            while runner + 1 &lt; len(chars) and chars[runner] == chars[runner+1]:
                runner += 1
                count += 1
			
            if count &gt; 1:
                for c in str(count):
                    chars[walker+1] = c
                    walker += 1
            
            runner += 1
            walker += 1
        
        return walker

</code></pre>
<p>two pointer 写出来了，但是cornercase很多边test边写的。。。。答案很简单。。。。</p>
<h1 id="font-colorred-444-sequence-reconstruction-medium-font"><font color='red'> 444. Sequence Reconstruction (Medium) </font></h1>
<p>You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.<br>
Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.<br>
For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].<br>
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.<br>
Return true if nums is the only shortest supersequence for sequences, or false otherwise.<br>
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<pre><code class="language-python">class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -&gt; bool:
        values = {x for seq in sequences for x in seq}
        graph = {x: [] for x in values}
        indegrees = {x: 0 for x in values}
        for seq in sequences:
            for i in range(len(seq) - 1):
                s = seq[i]
                t = seq[i+1]
                graph[s].append(t)
                indegrees[t] += 1
        queue = collections.deque()
        for node, count in indegrees.items():
            if count == 0:
                queue.append(node)
        res = []
        while queue:
            if len(queue) != 1:
                return False
            source = queue.popleft()
            res.append(source)
            for target in graph[source]:
                indegrees[target] -= 1
                if indegrees[target] == 0:
                    queue.append(target)
        return len(res) == len(values) and res == nums


</code></pre>
<p>感觉题就没读懂。。。。topological sort... 第一步建立dependency graph， 第二部toposort，每一步检查是否只有一个node的可能性，如果比一个多，return False。 第三步，在得到toposortlist 后，检查长度是否和sequence中所有unique 元素个数一样而且 是input nums。<br>
解释：<br>
TopSort order exists<br>
Whether the TopSort order is the only one (Uniqueness of Topological sort, Hamilton path, see https://en.wikipedia.org/wiki/Topological_sorting#Uniqueness).如果不是，那么说明有些pair只有偏序关系，没有全序关系，这样不能完全确定元素之间的顺序<br>
the only top sort order constructed should be equal to the org.</p>
<p>index == org.length (check condition 3) &amp;&amp; index == map.size() (check all the vertex in the graph has been visited, so the top sort order exists, check condition 1)</p>
<p>How to check only one order? queue.size() should always be one, then only one element at a time has indegree to be 0, so you only have one choice (check condition 2)</p>
<h1 id="font-colorblue-445-add-two-numbers-ii-medium-font"><font color='blue'> 445. Add Two Numbers II （Medium） </font></h1>
<p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.<br>
You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        def rev(node):
            pre=None
            while node:
                nodenext=node.next
                node.next=pre
                pre=node
                node=nodenext
            return pre
        
        l1=rev(l1)
        l2=rev(l2)
        
        carry=0
        head=ListNode(val=None)
        savehead=head
        while l1 or l2:
            v1= l1.val if l1 else 0
            v2= l2.val if l2 else 0
            val=(v1+v2+carry)%10
            carry=(v1+v2+carry)//10
            head.next=ListNode(val)
            head=head.next
            
            l1=l1.next if l1 else None
            l2=l2.next if l2 else None
            
        if carry:
            head.next=ListNode(carry)
            head=head.next
        
        return rev(savehead.next)

#
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
        
 #####
 class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1: return l2
        if not l2: return l1
        
        s1=[]
        s2=[]
        
        cur=l1
        while cur:
            s1.append(cur.val)
            cur=cur.next
            
        cur=l2
        while cur:
            s2.append(cur.val)
            cur=cur.next
            
        
        head=None
        carry=0
        while s1 or s2:
            x = s1.pop() if s1 else 0
            y = s2.pop() if s2 else 0
            sum_=x+y+carry
            cur=ListNode(sum_%10)
            cur.next=head
            head=cur
            carry=sum_//10
        
        if carry:
            cur=ListNode(carry)
            cur.next=head
            head=cur
        return head
               
</code></pre>
<p>followup 是不revlist能否。。。</p>
<h1 id="font-colorred-446-arithmetic-slices-ii-subsequence-hard-font"><font color='red'> 446. Arithmetic Slices II - Subsequence (Hard) </font></h1>
<p>Given an integer array nums, return the number of all the arithmetic subsequences of nums.<br>
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.<br>
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.<br>
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.<br>
For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].<br>
The test cases are generated so that the answer fits in 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        
        #f[i][d] denotes the number of weak arithmetic subsequences that ends with A[i] and its common difference is d.
        #Now the state transitions are quite straightforward:

        # for all j &lt; i, f[i][A[i] - A[j]] += (f[j][A[i] - A[j]] + 1).
        # The 1 appears here because we can form a new weak arithmetic subsequence for the pair (i, j)
        
        #when we are appending new elements to existing weak arithmetic subsequences, we are forming arithmetic subsequences. So the first part, f[j][A[i] - A[j]] is the number of new formed arithmetic subsequences, and can be added to the answer.

        
        n=len(nums)
        res=0
        cnt=dict()
        for i in range(n):
            cnt[i]=dict()
            for j in range(i):
                delta=nums[i]-nums[j]
                
                diff=delta
                sum_=cnt[j].get(diff,0)
                origin=cnt[i].get(diff,0)
                cnt[i][diff]=origin+sum_+1
                res+=sum_
        return res
</code></pre>
<p>是应该用DP但看答案。。。答案这个DP解法不是一般的DP。。。先dp【i】【diff】是以ith nums为最终位置的weak arithmetic subsequences的个数，这个weak值2个元素也能形成subsequence。 要想得到真正的3个元素的arithmetic subsequences个数，每次可以把nums【i】添加到dp【j】【diff】时候这个dp【j】【diff】个数就是arithmetic subsequences个数。很难想到这个方法啊。。。<br>
backtracking 方法超时</p>
<pre><code class="language-java">class Solution {
    private int n;
    private int ans;
    private void dfs(int dep, int[] A, List&lt;Long&gt; cur) {
        if (dep == n) {
            if (cur.size() &lt; 3) {
                return;
            }
            long diff = cur.get(1) - cur.get(0);
            for (int i = 1; i &lt; cur.size(); i++) {                
                if (cur.get(i) - cur.get(i - 1) != diff) {
                    return;
                }
            }
            ans ++;
            return;
        }
        dfs(dep + 1, A, cur);
        cur.add((long)A[dep]);
        dfs(dep + 1, A, cur);
        cur.remove((long)A[dep]);
    }
    public int numberOfArithmeticSlices(int[] A) {
        n = A.length;
        ans = 0;
        List&lt;Long&gt; cur = new ArrayList&lt;Long&gt;();
        dfs(0, A, cur);
        return (int)ans;        
    }
}
</code></pre>
<h1 id="font-colorblue-447-number-of-boomerangs-medium-font"><font color='blue'> 447. Number of Boomerangs (Medium) </font></h1>
<p>You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).<br>
Return the number of boomerangs.</p>
<pre><code class="language-python">class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        
        def dis(p1,p2):
            return (p1[0]-p2[0])**2+(p1[1]-p2[1])**2
        
        
        dic=collections.defaultdict(set)
        
        for i,p1 in enumerate(points):
            for j,p2 in enumerate(points):
                if i!=j:
                    dic[dis(p1,p2)].add((i,j))
                    dic[dis(p1,p2)].add((j,i))
        #print(dic)
        res=0
        for k, s in dic.items():
            #find i,j i,k
            d=dict()
            for t in s:
                d[t[0]]=d.get(t[0],0)+1
            
            #print(d)
            
            for key,val in d.items():
                res+= val*(val-1) if val&gt;1 else 0
        
        return res
#ANSWER 同样思路但超级简单
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        res = 0
        for p in points:
            cmap = {}
            for q in points:
                f = p[0]-q[0]
                s = p[1]-q[1]
                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)
            for k in cmap:
                res += cmap[k] * (cmap[k] -1)
        return res
</code></pre>
<p>pass了 hashmap先按照距离分类， 然后每个距离下按照起始点分类，比如距离为1下 其实点为0的edge总共有n个，那么组成三角形能组成n*n-1个。</p>
<h1 id="448-find-all-numbers-disappeared-in-an-array-easy">448. Find All Numbers Disappeared in an Array (Easy)</h1>
<pre><code class="language-python">class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]:
        #
        n=len(nums)
        
        for i in range(n):
            ind = abs(nums[i])-1
            nums[ind]=-abs(nums[ind])
        
        res=[]
        for i in range(n):
            if nums[i]&gt;0:
                res.append(i+1)
        return res

</code></pre>
<h1 id="449-serialize-and-deserialize-bst-medium">449. Serialize and Deserialize BST (Medium)</h1>
<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.<br>
The encoded string should be as compact as possible.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: Optional[TreeNode]) -&gt; str:
        &quot;&quot;&quot;Encodes a tree to a single string.
        &quot;&quot;&quot;
        res=[]
        def pre(root):
            if not root: 
                res.append('#')
                return
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
        return ','.join(res)
        

    def deserialize(self, data: str) -&gt; Optional[TreeNode]:
        &quot;&quot;&quot;Decodes your encoded data to tree.
        &quot;&quot;&quot;
        data=data.split(',')
        def pre(data):
            if not data: return None
            cur=data.pop(0) 
            root=None
            if cur!='#':
                root=TreeNode(int(cur))
            
            if root and data:
                root.left=pre(data)
            if root and data:
                root.right=pre(data)
            return root
        return pre(data)
            
#答案用postorder compressed string 更好
class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;
        Encodes a tree to a single string.
        &quot;&quot;&quot;
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        &quot;&quot;&quot;
        Decodes your encoded data to tree.
        &quot;&quot;&quot;
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] &lt; lower or data[-1] &gt; upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()
</code></pre>
<p>用的pre order encode没想到写出来了。。。</p>
<h1 id="font-colorred-450-delete-node-in-a-bst-mediumfont"><font color='red'> 450. Delete Node in a BST （Medium）</font></h1>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.<br>
Basically, the deletion can be divided into two stages:<br>
Search for a node to remove.<br>
If the node is found, delete the node.</p>
<pre><code class="language-python">class Solution:
    def successor(self, root):
        &quot;&quot;&quot;
        One step right and then always left
        &quot;&quot;&quot;
        root = root.right
        while root.left:
            root = root.left
        return root.val
    
    def predecessor(self, root):
        &quot;&quot;&quot;
        One step left and then always right
        &quot;&quot;&quot;
        root = root.left
        while root.right:
            root = root.right
        return root.val
        
    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:
        if not root:
            return None
        
        # delete from the right subtree
        if key &gt; root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key &lt; root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # the node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root

</code></pre>
<p>这个是很经典的一个题目。recursion方法很经典。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-04]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-04/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-04/">
        </link>
        <updated>2022-03-04T14:13:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="431-encode-n-ary-tree-to-binary-tree-hard">431. Encode N-ary Tree to Binary Tree （Hard）</h1>
<p>Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
&quot;&quot;&quot;

class Codec:
    # Encodes an n-ary tree to a binary tree.
    def encode(self, root: 'Optional[Node]') -&gt; Optional[TreeNode]:
        if not root: return []
        rootnode = TreeNode(root.val)
        return_rootnode=rootnode
       
        first=True
        for node in root.children:
            if first:
                first=False
                rootnode.left=self.encode(node)
                rootnode=rootnode.left
            else:
                rootnode.right=self.encode(node)
                rootnode=rootnode.right
        
        return return_rootnode
	
	# Decodes your binary tree to an n-ary tree.
    def decode(self, data: Optional[TreeNode]) -&gt; 'Optional[Node]':
        if not data: return None
        #print(data)
        #print('#'*20)
        root=data
        root_node=Node(root.val,[])
        if root.left:
            root_node.children.append(self.decode(root.left))
            root=root.left
            while root.right:
                root_node.children.append(self.decode(root.right))
                root=root.right
        
        return root_node
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(root))


#ANSWER 
class Codec:

    def encode(self, root):
        if not root:
            return None

        binary = TreeNode(root.val)                 # create a binary root
        if not root.children:
            return binary
        #Python - left child for children, right child for siblings
        
        binary.left = self.encode(root.children[0]) # left child of binary is the encoding of all n-ary children,
        node = binary.left                          #     starting with the first child.
        for child in root.children[1:]:             # other children of n-ary root are right child of previous child
            node.right = self.encode(child)
            node = node.right

        return binary

    def decode(self, data):
        if not data:
            return None

        nary = Node(data.val, [])                   # create n-ary root
        node = data.left                            # move to first child of n-ary root
        while node:                                 # while more children of n-ary root
            nary.children.append(self.decode(node)) # append to list
            node = node.right                       # and move to next child
            
        return nary
        
</code></pre>
<p>我得方法，把所有孩子都包含在下一层，  root的left通向下一层，root.left.right和之后所有的right都是同一层的保存孩子。</p>
<h1 id="font-colorred-432-all-oone-data-structure-hardfont"><font color='red'> 432. All O`one Data Structure （Hard）</font></h1>
<p>Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.<br>
Implement the AllOne class:<br>
AllOne() Initializes the object of the data structure.<br>
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.<br>
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.<br>
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string &quot;&quot;.<br>
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">from collections import defaultdict
class Node(object):
    def __init__(self):
        self.key_set = set([])
        self.prev, self.nxt = None, None 

    def add_key(self, key):
        self.key_set.add(key)

    def remove_key(self, key):
        self.key_set.remove(key)        

    def get_any_key(self):
        if self.key_set:
            result = self.key_set.pop()
            self.add_key(result)
            return result
        else:
            return None
    
    def count(self):
        return len(self.key_set)

    def is_empty(self):
        return len(self.key_set) == 0


class DoubleLinkedList(object):
    def __init__(self):
        self.head_node, self.tail_node = Node(), Node()
        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node
        return

    def insert_after(self, x):
        node, temp = Node(), x.nxt
        x.nxt, node.prev = node, x
        node.nxt, temp.prev = temp, node
        return node
    
    def insert_before(self, x):
        return self.insert_after(x.prev)

    def remove(self, x):
        prev_node = x.prev
        prev_node.nxt, x.nxt.prev = x.nxt, prev_node
        return

    def get_head(self):
        return self.head_node.nxt
    
    def get_tail(self):
        return self.tail_node.prev

    def get_sentinel_head(self):
        return self.head_node

    def get_sentinel_tail(self):
        return self.tail_node
    
class AllOne(object):
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)
        self.node_freq = {0:self.dll.get_sentinel_head()}

    def _rmv_key_pf_node(self, pf, key):
        node = self.node_freq[pf]
        node.remove_key(key)
        if node.is_empty():
            self.dll.remove(node)
            self.node_freq.pop(pf)
        return

    def inc(self, key):
        &quot;&quot;&quot;
        Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        self.key_counter[key] += 1
        cf, pf = self.key_counter[key], self.key_counter[key]-1
        if cf not in self.node_freq:
            # No need to test if pf = 0 since frequency zero points to sentinel node
            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])
        self.node_freq[cf].add_key(key)
        if pf &gt; 0:
            self._rmv_key_pf_node(pf, key)

    def dec(self, key):
        &quot;&quot;&quot;
        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        if key in self.key_counter:
            self.key_counter[key] -= 1
            cf, pf = self.key_counter[key], self.key_counter[key]+1
            if self.key_counter[key] == 0:
                self.key_counter.pop(key)
            if cf != 0:
                if cf not in self.node_freq:
                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])
                self.node_freq[cf].add_key(key)
            self._rmv_key_pf_node(pf, key)

    def getMaxKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with maximal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;

    def getMinKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with Minimal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;




</code></pre>
<p>感觉是个maxheap minheap。。。但不是all o（1）。。。 看答案了。。。答案果然完美</p>
<h1 id="433-minimum-genetic-mutation-medium">433. Minimum Genetic Mutation (Medium)</h1>
<p>A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.<br>
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.<br>
For example, &quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; is one mutation.<br>
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.<br>
Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.<br>
Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<pre><code class="language-python">class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        #BFS search neighbor
        # neighor is 1 char off current also in bank
        if   end not in bank: return -1
        if not bank and start!=end: return -1
        bank=set(bank)
        bank.add(end)
        q=[]
        visited=set()
        def nei(me):
            neighbors=[]
            for other in bank:
                if other not in visited:
                    valid=0
                    for a,b in zip(me,other):
                        valid+=bool(ord(a)^ord(b))
                    if valid==1:
                        neighbors.append(other)
            return neighbors
        
        
        q.append(start)
        visited.add(start)
        level=0
        while q:
            level+=1
            for _ in range(len(q)):
                cur=q.pop(0)
                print(cur,nei(cur))
                for ne in nei(cur):
                    if ne==end: return level
                    visited.add(ne)
                    q.append(ne)
        
        return  -1
        
#ANSWER
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        &quot;&quot;&quot;
        :type start: str
        :type end: str
        :type bank: List[str]
        :rtype: int
        &quot;&quot;&quot;
        queue = []
        queue.append((start,0))
        bankSet = set(bank)
        
        while queue:
            curr, step = queue.pop(0)
            if curr == end:
                return step
            for i in range(len(curr)):
                for c in &quot;AGCT&quot;:
                    mutation = curr[:i] + c + curr[i+1:]
                    if mutation in bankSet:
                        bankSet.remove(mutation)
                        queue.append((mutation,step+1))
                        
        return -1
        
</code></pre>
<p>bfs注意corner case，end必须in bank。 答案用remove mutaton方式避免用visited set，而且mutaion是直接算的，不是从bank中找的。</p>
<h1 id="434-number-of-segments-in-a-string-easy">434. Number of Segments in a String （Easy）</h1>
<p>Given a string s, return the number of segments in the string.<br>
A segment is defined to be a contiguous sequence of non-space characters.</p>
<pre><code class="language-python">class Solution:
    def countSegments(self, s: str) -&gt; int:
        beforeisspace=True
        c=0
        while s:
            if s[0]==' ':
                s=s[1:]
                beforeisspace=True
            else:
                if beforeisspace:
                    c+=1
                    beforeisspace=False
                
                s=s[1:]
        return c

class Solution:
    def countSegments(self, s: str) -&gt; int:
        return len(s.split())

class Solution:
    def countSegments(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':
                segment_count += 1

        return segment_count
</code></pre>
<h1 id="font-colorred-435-non-overlapping-intervals-medium-font"><font color='red'> 435. Non-overlapping Intervals (Medium) </font></h1>
<p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<pre><code class="language-python">class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        #sort by start
        # [1,2] [1,3] [2,3],[3,4]
        #sort by end
        # 找最小删除相当于找最大不overlap有多少个interval
        #变成dp问题 dp[i]是最大的interval个数 用到ith interval
        # dp【i】= max（dp【j】）+1 j&lt;i  interval i，j不overlap
        intervals=sorted(intervals,key=lambda x:x[0])
        dp = [0]*len(intervals)
        dp[0]=1
        ans=1
        for i in range(1,len(dp)):
            max_=0
            for j in range(i):
                if intervals[j][1]&lt;=intervals[i][0]:
                    max_=max(dp[j],max_)
            
            dp[i]=max_+1
            ans=max(ans,dp[i])
        return len(intervals)-ans

#PASS ANSWER
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
 
        intervals=sorted(intervals,key=lambda x:x[0])
        end=intervals[0][1]
        prev=0
        c=0
        for i in range(1,len(intervals)):
            if intervals[prev][1]&gt;intervals[i][0]:
                #overlap
                if intervals[prev][1]&gt;intervals[i][1]:
                    #include,bust del prev so c+=1 prev renew to i
                    prev=i
                
                #if pure overlap do greedy, prev still the same, del i, c+=1
                c+=1
            else:
                #case 1 two interval non overlapping
                prev=i
                
        return c
</code></pre>
<p>没想出来如何处理~~ DP可以n^2， greedy也可以，Greedy nlogn</p>
<h1 id="font-colorred-436-find-right-interval-medium-font"><font color='red'> 436. Find Right Interval (Medium) </font></h1>
<p>You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.<br>
The right interval for an interval i is an interval j such that startj &gt;= endi and startj is minimized. Note that i may equal j.<br>
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        maps=dict()
        for i,interval in enumerate(intervals):
            maps[tuple(interval)]=i
        
        ans=[-1]*len(intervals)
        intervals=sorted(intervals,key=lambda x:x[0])
        for i in range(len(intervals)-1):
            #i's right
            j=i+1
            while j&lt;len(intervals) and intervals[j][0]&lt;intervals[i][1]:
                j+=1
            if j&lt;len(intervals):
                ans[maps[tuple(intervals[i])]]=maps[tuple(intervals[j])]
        return ans


#ANSWER BINARY SERACH 

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        
        l = sorted((e[0], i) for i, e in enumerate(intervals))
        res = []
        for e in intervals:
            r = bisect.bisect_left(l, (e[1],))
            res.append(l[r][1] if r &lt; len(l) else -1)
        return res

#Heap法
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        heap, result = [], [-1] * len(intervals)
        for idx, interval in sorted(enumerate(intervals), key=lambda enum: enum[1][0]):
            while heap and heap[0][0] &lt;= interval[0]:
                _, i = heapq.heappop(heap)
                if intervals[i][0]!=intervals[i][1]:
                    result[i] = idx
                else:
                    result[i] = i
            heapq.heappush(heap, (interval[1], idx))
        return result
</code></pre>
<p>初次尝试 time limit exceeded 答案的bianry search法太厉害。</p>
<h1 id="font-colorblue-437-path-sum-iii-medium-font"><font color='blue'> 437. Path Sum III （Medium） </font></h1>
<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.<br>
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:
        #post order  botoom up save node val
        
        c=[0]
        def post(root):
            if not root: return 
            post(root.left)
            post(root.right)
            root.vals=defaultdict(int)
            if root.left:
                for v in root.left.vals:
                    root.vals[v+root.val]+=root.left.vals[v]
            if root.right:
                for v in root.right.vals:
                    root.vals[v+root.val]+=root.right.vals[v]
            root.vals[root.val]+=1
            if targetSum in root.vals:
                #print(root.val,root.vals)
                c[0]+=root.vals[targetSum]
       
        post(root)
        return c[0]  
#ANSWER PREFIX SUM in tree
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; int:
        def preorder(node: TreeNode, curr_sum) -&gt; None:
            nonlocal count
            if not node:
                return 
            
            # current prefix sum
            curr_sum += node.val
            
            # here is the sum we're looking for
            if curr_sum == k:
                count += 1
            
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a path with sum k 
            # has occurred up to the current node
            count += h[curr_sum - k]
            
            # add the current sum into hashmap
            # to use it during the child nodes processing
            h[curr_sum] += 1
            
            # process left subtree
            preorder(node.left, curr_sum)
            # process right subtree
            preorder(node.right, curr_sum)
            
            # remove the current sum from the hashmap
            # in order not to use it during 
            # the parallel subtree processing
            h[curr_sum] -= 1
            
        count, k = 0, sum
        h = defaultdict(int)
        preorder(root, 0)
        return count       

#上面这个解决方法基于
class Solution:
    def subarraySum(self, nums, k):
        count = curr_sum = 0
        h = defaultdict(int)
        
        for num in nums:
            # current prefix sum
            curr_sum += num
            
            # situation 1:
            # continuous subarray starts 
            # from the beginning of the array
            if curr_sum == k:
                count += 1
            
            # situation 2:
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a subarray with sum k 
            # has occurred up to the current index
            count += h[curr_sum - k]
            
            # add the current sum
            h[curr_sum] += 1
                
        return count
</code></pre>
<p>我的解决方案是post order bottom up 扫，每个node存可以生成的pathsum值。答案是prefixsum。。</p>
<h1 id="438-find-all-anagrams-in-a-string-medium">438. Find All Anagrams in a String （Medium）</h1>
<p>Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.<br>
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br>
Input: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;<br>
Output: [0,6]<br>
Explanation:<br>
The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.<br>
The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</p>
<pre><code class="language-python">class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        if len(s)&lt;len(p): return []
        dicp=collections.Counter(p)
        lp=len(p)
        dic=dict()
        for i in range(lp):
            dic[s[i]]=dic.get(s[i],0)+1
        res=[]
        if dic==dicp: res.append(0)
        for i in range(lp,len(s)):
            #remove first
            dic[s[i-lp]]-=1
            if dic[s[i-lp]]==0:
                del  dic[s[i-lp]]
            #add last
            dic[s[i]]=dic.get(s[i],0)+1
            #
            if dic==dicp:
                res.append(i-lp+1)
        return res
            
#ANSWER 写的更简单
from collections import Counter
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count = Counter(p)
        s_count = Counter()
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[s[i]] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                if s_count[s[i - np]] == 1:
                    del s_count[s[i - np]]
                else:
                    s_count[s[i - np]] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output

#ANSWER
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count, s_count = [0] * 26, [0] * 26
        # build reference array using string p
        for ch in p:
            p_count[ord(ch) - ord('a')] += 1
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[ord(s[i]) - ord('a')] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                s_count[ord(s[i - np]) - ord('a')] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output
</code></pre>
<p>sliding window保持counter dict和p一样就可以。。。</p>
<h1 id="font-colorred-439-ternary-expression-parser-medium-font"><font color='red'> 439. Ternary Expression Parser （Medium） </font></h1>
<p>Given a string expression representing arbitrarily nested ternary expressions, evaluate the expression, and return the result of it.<br>
You can always assume that the given expression is valid and only contains digits, '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers in the expression are one-digit numbers (i.e., in the range [0, 9]).<br>
The conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, 'T' or 'F'.</p>
<pre><code class="language-python">class Solution:
    def parseTernary(self, expression: str) -&gt; str:
        #思路用stack，而且从后向前iterate
        #T?a:b
        if not expression: return expression
        stack=[]
        for char in expression[::-1]:
            if stack and stack[-1]=='?':
                stack.pop() #?
                first=stack.pop()
                stack.pop() #:
                second=stack.pop()
                
                if char=='T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(char)
        #print(stack)
        return stack[-1]
</code></pre>
<p>T？（a）：（b） 形式，但a，b可以包含再包含。。。很难分辨哪个冒号是分界线。 用stack应该，看答案。关键是从后向前。</p>
<h1 id="font-colorred-440-k-th-smallest-in-lexicographical-order-hardfont"><font color='red'> 440. K-th Smallest in Lexicographical Order （Hard）</font></h1>
<p>Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].<br>
Example 1:<br>
Input: n = 13, k = 2<br>
Output: 10<br>
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.</p>
<pre><code class="language-python">class Solution:
    def findKthNumber(self, n: int, k: int) -&gt; int:
        class Trie:
            def __init__(self):
                self.children=collections.defaultdict(Trie)
                self.val=0
        trie=Trie()
        
        def insert(i):
            i=str(i)
            root=trie
            while i:
                cur=i[0]
                root=root.children[cur]
                root.val+=1
                i=i[1:]
        for i in range(1,n+1):
            insert(i)
        
        path=[]
        def search(k):
            current_rank=0
            children=trie.children
            i=0
            while current_rank&lt;k:
                key=sorted(children)[i]
                if children[key].val+current_rank&lt;k:
                    current_rank+=children[key].val
                    i+=1
                else:
                    path.append(key)
                    current_rank+=1
                    children=children[key].children
                    i=0
                
                
                 
                
                        
        search(k)
        return int(''.join(path))
        
        
        
        
#ANSWER
'''
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.
'''
def findKthNumber(self, n, k):
        cur = 1
        k = k - 1
        while k &gt; 0:
            steps = self.calSteps(n, cur)
            if steps &lt;= k:
                cur += 1
                k -= steps
            else:
                cur *= 10
                k -= 1
        return cur

    def calSteps(self, n, cur):
        steps = 0
        n1, n2 = cur, cur + 1
        while n1 &lt;= n:
            steps += min(n + 1, n2) - n1
            n1 *= 10
            n2 *= 10
        return steps
</code></pre>
<p>根据提示用了trie，思路是对的，但是写seasrch func时候卡住了，given k，what is the node positon of kth node。就算写出来也是TLE。。。看答案。</p>
<p>Main function<br>
Firstly, calculate how many steps curr need to move to curr + 1.</p>
<pre><code>if the steps &lt;= k, we know we can move to curr + 1, and narrow down k to k - steps.

else if the steps &gt; k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.
</code></pre>
<p>calSteps function</p>
<pre><code>how to calculate the steps between curr and curr + 1?
Here we come up a idea to calculate by level.
Let n1 = curr, n2 = curr + 1.
n2 is always the next right node beside n1's right most node (who shares the same ancestor &quot;curr&quot;)
(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).

so, if n2 &lt;= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.

else if n2 &gt; n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to steps.

organize this flow to &quot;steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;&quot;
</code></pre>
<p>Here is the code snippet:</p>
<p>public int findKthNumber(int n, int k) {<br>
int curr = 1;<br>
k = k - 1;<br>
while (k &gt; 0) {<br>
int steps = calSteps(n, curr, curr + 1);<br>
if (steps &lt;= k) {<br>
curr += 1;<br>
k -= steps;<br>
} else {<br>
curr *= 10;<br>
k -= 1;<br>
}<br>
}<br>
return curr;<br>
}<br>
//use long in case of overflow<br>
public int calSteps(int n, long n1, long n2) {<br>
int steps = 0;<br>
while (n1 &lt;= n) {<br>
steps += Math.min(n + 1, n2) - n1;<br>
n1 *= 10;<br>
n2 *= 10;<br>
}<br>
return steps;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-03/">
        </link>
        <updated>2022-03-02T16:44:15.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-421-maximum-xor-of-two-numbers-in-an-array-mediumfont"><font color='red'> 421. Maximum XOR of Two Numbers in an Array （Medium）</font></h1>
<p>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.</p>
<pre><code class="language-python"> class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        res=0
        L=len(bin(max(nums)))-2
        for i in range(L-1,-1,-1):
            res &lt;&lt;=1
            cur_xor = res | 1
            prefixes = {n &gt;&gt; i  for n in nums}
            res |= any(cur_xor^p in prefixes for p in prefixes)
        return res
        
class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        L = len(bin(max(nums))) - 2
        max_xor = 0
        
        for i in reversed(range(L)):
            max_xor &lt;&lt;= 1
            # Set comprehension is used for speed purposes
            # List comprehension is what most pythonic users are used too imo
            prefixes = {num &gt;&gt; i for num in nums}
            curr_xor = max_xor | 1
            
            for p in prefixes:
                # if p1 ^ p2 == curr_xor then
                # p1 ^ curr_xor == p2 ( p2 is in prefixes)
                if p ^ curr_xor in prefixes:
                    # Set the last bit to 1
                    max_xor |= 1
                    
            
        return max_xor
</code></pre>
<p>没思路，看答案。</p>
<h1 id="422-valid-word-square-easy">422. Valid Word Square (Easy)</h1>
<p>Given an array of strings words, return true if it forms a valid word square.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).</p>
<pre><code class="language-python">class Solution:
    def validWordSquare(self, words: List[str]) -&gt; bool:
        rows=len(words)
        cols=max(map(len,words))
        for i,w in enumerate(words):
            if len(w)!=cols:
                words[i]=w+'#'*(cols-len(w))
        if rows!=cols: return False   
        
        for row in range(rows):
            for col in range(cols):
                if row&gt;col:
                    if words[row][col]!=words[col][row]:
                        return False
        return True


public class Solution {
    public boolean validWordSquare(List&lt;String&gt; words) {
        if(words == null || words.size() == 0){
            return true;
        }
        int n = words.size();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;words.get(i).length(); j++){
                if(j &gt;= n || words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j))
                    return false;
            }
        }
        return true;
    }
}
</code></pre>
<p>有corner case。。。Java 答案更正确</p>
<h1 id="font-colorred-423-reconstruct-original-digits-from-english-medium-font"><font color='red'> 423. Reconstruct Original Digits from English （Medium) </font></h1>
<p>Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.</p>
<pre><code class="language-python">class Solution:
    def originalDigits(self, s: 'str') -&gt; 'str':
        # building hashmap letter -&gt; its frequency
        count = collections.Counter(s)
        
        # building hashmap digit -&gt; its frequency 
        out = {}
        # letter &quot;z&quot; is present only in &quot;zero&quot;
        out[&quot;0&quot;] = count[&quot;z&quot;]
        # letter &quot;w&quot; is present only in &quot;two&quot;
        out[&quot;2&quot;] = count[&quot;w&quot;]
        # letter &quot;u&quot; is present only in &quot;four&quot;
        out[&quot;4&quot;] = count[&quot;u&quot;]
        # letter &quot;x&quot; is present only in &quot;six&quot;
        out[&quot;6&quot;] = count[&quot;x&quot;]
        # letter &quot;g&quot; is present only in &quot;eight&quot;
        out[&quot;8&quot;] = count[&quot;g&quot;]
        # letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;
        out[&quot;3&quot;] = count[&quot;h&quot;] - out[&quot;8&quot;]
        # letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;
        out[&quot;5&quot;] = count[&quot;f&quot;] - out[&quot;4&quot;]
        # letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;
        out[&quot;7&quot;] = count[&quot;s&quot;] - out[&quot;6&quot;]
        # letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;
        out[&quot;9&quot;] = count[&quot;i&quot;] - out[&quot;5&quot;] - out[&quot;6&quot;] - out[&quot;8&quot;]
        # letter &quot;n&quot; is present in &quot;one&quot;, &quot;nine&quot;, and &quot;seven&quot;
        out[&quot;1&quot;] = count[&quot;n&quot;] - out[&quot;7&quot;] - 2 * out[&quot;9&quot;]

        # building output string
        output = [key * out[key] for key in sorted(out.keys())]
        return &quot;&quot;.join(output)
</code></pre>
<p>直接做会出现是否要再次使用当前数字然后继续，或者直接使用下个数字，当前数字不重复使用的问题。<br>
解决方法。。。醉了</p>
<pre><code>Letter &quot;z&quot; is present only in &quot;zero&quot;.
Letter &quot;w&quot; is present only in &quot;two&quot;.
Letter &quot;u&quot; is present only in &quot;four&quot;.
Letter &quot;x&quot; is present only in &quot;six&quot;.
Letter &quot;g&quot; is present only in &quot;eight&quot;.

Hence there is a good way to count even numbers.
</code></pre>
<p>That is actually the key how to count 3s, 5s and 7s since some letters are present only in one odd and one even number (and all even numbers has already been counted) :</p>
<pre><code>Letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;.
Letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;.
Letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;.
</code></pre>
<p>Now one needs to count 9s and 1s only, and the logic is basically the same :</p>
<pre><code>Letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;.
Letter &quot;n&quot; is present in &quot;one&quot;, &quot;seven&quot;, and &quot;nine&quot;.
</code></pre>
<h1 id="font-colorred-424-longest-repeating-character-replacement-mediumfont"><font color='red'> 424. Longest Repeating Character Replacement （Medium）</font></h1>
<p>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.<br>
Return the length of the longest substring containing the same letter you can get after performing the above operations.</p>
<pre><code class="language-python">class Solution:
    def characterReplacement(self, s: str, k: int) -&gt; int:
        #   p
        # AABCBBA  k=2
        #       p
        #
        l = len(s)
        count = [0]*26
        start = 0
        maxCount = 0
        maxLength = 0
        for end in range(l):
            count[ord(s[end]) - ord('A')]+=1
            maxCount = max(maxCount, count[ord(s[end]) - ord('A')])
            while end - start + 1 - maxCount &gt; k:
                count[ord(s[start]) - ord('A')]-=1
                start+=1
            
            maxLength = max(maxLength, end - start + 1);
        
        return maxLength
</code></pre>
<p>感觉用dp的。。 感觉不对好像，提示是用two pointer sliding window， 不死磕看答案。<br>
end-start+1 = size of the current window<br>
maxCount = largest count of a single, unique character in the current window<br>
The main equation is: end-start+1-maxCount</p>
<h1 id="font-colorblue-425-word-squares-hard-font"><font  color='blue'> 425. Word Squares (Hard) </font></h1>
<p>Given an array of unique strings words, return all the word squares you can build from words. The same word from words can be used multiple times. You can return the answer in any order.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).<br>
For example, the word sequence [&quot;ball&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;] forms a word square because each word reads the same both horizontally and vertically.</p>
<pre><code class="language-python">class Solution:
    def wordSquares(self, words: List[str]) -&gt; List[List[str]]:
        # a b c d
        # b d e f
        # c e g h 
        # d f h k
        
        # select abcd
        # next must select b
        # select abcd
        #        bdef
        # next must select ce
        # select abcd
        #        bdef
        #        cegh
        # next must selct dfh
        # select abcd
        #        bdef
        #        cegh
        #        dfhk
        #
        # need a trie tree to find prefix is valid or not
        # if valid prefix, for childern path, need to explore all possible combinations using bt
        
        class Trie:
            def __init__(self):
                self.children=dict()
                self.words=set()
                
            def search(self,string):
                if not string: return True
                if string[0] not in self.children:
                    return False
                return self.children[string[0]].search(string[1:])
            
            def getwords(self,string):
                if string is False: return True
                if len(string)==1:
                    return self.children[string].words
                
                return self.children[string[0]].getwords(string[1:])
                
                
        trie=Trie()
        #insert words to trie
        for word in words:
            cur=trie
            for w in word:
                if w not in cur.children:
                    cur.children[w] = Trie()
                cur.words.add(word)
                cur=cur.children[w]
            
        
        res=[]
        size=len(words[0])
        
        def bt(tmp,words):
            #backtracking to generate all possible word squares
            if len(tmp)==size:
                res.append(tmp[:])
                return
            if not words: return
            
            for word in words:
                tmp.append(word)
                level=len(tmp)
                searchkey=''.join([e[level] for e in tmp]) if level&lt;size else False
                if trie.search(searchkey):
                    validwords=trie.getwords(searchkey)
                    bt(tmp,validwords)
                tmp.pop()
        
        bt([],set(words))
        
        return res

#ANSWER is faster...
class Solution:
    def wordSquares(self, words: 'List[str]') -&gt; 'List[List[str]]':
        
        dic= collections.defaultdict(list)
        n=len(words[0])
        for word in words:
            for i in range(1,n):
                key=word[:i]
                dic[key].append(word)
        
        res=[]        
        def build(squre):
            #print(len(squre))
            if len(squre)==n:
                res.append(squre)
                return
            #print(n,len(squre),squre)
            for word in dic[''.join(list(zip(*squre))[len(squre)])]:
                new=squre[:]
                new.append(word)
                build(new)
        
        for word in words:
            build([word])
        
        return res
</code></pre>
<p>很明显backtracking问题。。。unbelievable 做出来了。。。</p>
<h1 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list-medium">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium)</h1>
<p>Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.<br>
You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br>
We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
&quot;&quot;&quot;

class Solution:
    def treeToDoublyList(self, root: 'Optional[Node]') -&gt; 'Optional[Node]':
        if not root: return root
        stack=[]
        head=None
        pre=None
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            cur=stack.pop()
            if head is None: head=cur
            cur.left=pre
            if pre:
                pre.right=cur 
            pre=cur
            
            root=cur.right
        
        
        #print(head.val, pre.val)
        
        head.left=pre
        pre.right=head
        
        return head


#ANSER RECURSION METHOD
class Solution:
    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':
        def helper(node):
            &quot;&quot;&quot;
            Performs standard inorder traversal:
            left -&gt; node -&gt; right
            and links all nodes into DLL
            &quot;&quot;&quot;
            nonlocal last, first
            if node:
                # left
                helper(node.left)
                # node 
                if last:
                    # link the previous node (last)
                    # with the current one (node)
                    last.right = node
                    node.left = last
                else:
                    # keep the smallest node
                    # to close DLL later on
                    first = node        
                last = node
                # right
                helper(node.right)
        
        if not root:
            return None
        
        # the smallest (first) and the largest (last) nodes
        first, last = None, None
        helper(root)
        # close DLL
        last.right = first
        first.left = last
        return first
</code></pre>
<p>corner case 要想清楚。。 而且node要call right left时候node必须存在。</p>
<h1 id="427-construct-quad-tree-medium">427. Construct Quad Tree （Medium）</h1>
<p>Given a n * n matrix grid of 0's and 1's only. We want to represent the grid with a Quad-Tree.<br>
Return the root of the Quad-Tree representing the grid.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
&quot;&quot;&quot;

class Solution:
    def construct(self, grid: List[List[int]]) -&gt; 'Node':
        size=len(grid)
        if len({e for row in grid for e in row})==1:
            val=grid[0][0]==1
            isLeaf=True
            topLeft=None
            topRight=None
            bottomLeft=None
            bottomRight=None
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)
        else:
            isLeaf=False
            val=True
            topLeft=self.construct([row[:size//2] for row in grid[:size//2]])
            topRight=self.construct([row[size//2:] for row in grid[:size//2]])
            bottomLeft=self.construct([row[:size//2] for row in grid[size//2:]])
            bottomRight=self.construct([row[size//2:] for row in grid[size//2:]])
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)

</code></pre>
<h1 id="font-colorred-428-serialize-and-deserialize-n-ary-tree-hard-font"><font color='red'> 428. Serialize and Deserialize N-ary Tree (Hard) </font></h1>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        &quot;&quot;&quot;
        r=[]
        if not root: return r
        q=[root]
        while q:
            node=q.pop(0)
            if node !=',':
                r.append(str(node.val))
                for child in node.children:
                    q.append(child)
                q.append(',')
            else:
                r.append(',')
                
        return '#'.join(r)
        
 
    
    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        &quot;&quot;&quot;
        if not data: return None
        pieces=data.split('#')
        root = Node(int(pieces[0]), [])
        idx = 1
        q=[root]
        while q:
            node=q.pop(0)
            while pieces[idx] != ',':
                child=Node(int(pieces[idx]), [])
                node.children.append(child)
                q.append(child)
                idx += 1
            idx += 1
        return root
# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
</code></pre>
<p>first try failed， 若val可以重复，以val为key找parent的方法不再适用。 看答案。</p>
<h1 id="429-n-ary-tree-level-order-traversal-medium">429. N-ary Tree Level Order Traversal (Medium)</h1>
<p>Given an n-ary tree, return the level order traversal of its nodes' values.<br>
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:
        if not root: return []
        q=[root]
        res=[]
        while q:
            l=len(q)
            level=[]
            for _ in range(l):
                cur=q.pop(0)
                level.append(cur.val)
                for child in cur.children:
                    q.append(child)
            res.append(level)
        return res

#RECURSION ANSWER
class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:

        def traverse_node(node, level):
            if len(result) == level:
                result.append([])
            result[level].append(node.val)
            for child in node.children:
                traverse_node(child, level + 1)

        result = []

        if root is not None:
            traverse_node(root, 0)
        return result
</code></pre>
<p>BFS</p>
<h1 id="430-flatten-a-multilevel-doubly-linked-list-medium">430. Flatten a Multilevel Doubly Linked List (Medium)</h1>
<p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.<br>
Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.<br>
Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;

class Solution:
    def flatten(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':
        
        stack=[]
        cur=head
        pre=None
        while cur or stack:
            if not cur:
                cur=stack.pop()
                cur.prev=pre
                pre.next=cur
                
            while cur.child:
                if cur.next:
                    stack.append(cur.next)
                curnext=cur.child
                curchild=cur.child
                cur.child=None
                curchild.prev=cur
                cur.next=curnext
                cur=curnext
               
            if not cur.child:
                pre=cur
                cur=cur.next
                
            
        return head


#

class Solution:
    def flatten(self, head: 'Node') -&gt; 'Node':
        
        #DFS...
        curr=head
        tempStack = []
        while curr:
            if curr.child:
                if curr.next:
                    tempStack.append(curr.next);
                curr.next, curr.child.prev, curr.child = curr.child, curr, None;
            if not curr.next and len(tempStack):
                temp = tempStack.pop();
                temp.prev, curr.next = curr, temp
            curr = curr.next
        return head


 #ANSWER PREORDER   child is left tree next is right tree
 &quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;
class Solution(object):

    def flatten(self, head):
        if not head:
            return head

        # pseudo head to ensure the `prev` pointer is never none
        pseudoHead = Node(None, None, head, None)
        self.flatten_dfs(pseudoHead, head)

        # detach the pseudo head from the real head
        pseudoHead.next.prev = None
        return pseudoHead.next


    def flatten_dfs(self, prev, curr):
        &quot;&quot;&quot; return the tail of the flatten list &quot;&quot;&quot;
        if not curr:
            return prev

        curr.prev = prev
        prev.next = curr

        # the curr.next would be tempered in the recursive function
        tempNext = curr.next
        tail = self.flatten_dfs(curr, curr.child)
        curr.child = None
        return self.flatten_dfs(tail, tempNext)        

#preorder interative 
class Solution(object):
    def flatten(self, head):
        if not head:
            return

        pseudoHead = Node(0,None,head,None)
        prev = pseudoHead

        stack = []
        stack.append(head)

        while stack:
            curr = stack.pop()

            prev.next = curr
            curr.prev = prev

            if curr.next:
                stack.append(curr.next)
 
            if curr.child:
                stack.append(curr.child)
                # don't forget to remove all child pointers.
                curr.child = None

            prev = curr
        # detach the pseudo head node from the result.
        pseudoHead.next.prev = None
        return pseudoHead.next
</code></pre>
<p>差点没做出来 写的比答案复杂</p>
]]></content>
    </entry>
</feed>