<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-02-27T09:37:27.747Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-10]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-10/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-10/">
        </link>
        <updated>2021-12-09T17:33:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-371-sum-of-two-integers-medium-font"><font color='red'> 371. Sum of Two Integers （Medium） </font></h1>
<p>Given two integers a and b, return the sum of the two integers without using the operators + and -.</p>
<pre><code class="language-python">class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        x, y = abs(a), abs(b)
        # ensure that abs(a) &gt;= abs(b)
        if x &lt; y:
            return self.getSum(b, a)
        
        # abs(a) &gt;= abs(b) --&gt; 
        # a determines the sign
        sign = 1 if a &gt; 0 else -1
        
        if a * b &gt;= 0:
            # sum of two positive integers x + y
            # where x &gt; y
            while y:
                answer = x ^ y
                carry = (x &amp; y) &lt;&lt; 1
                x, y = answer, carry
        else:
            # difference of two integers x - y
            # where x &gt; y
            while y:
                answer = x ^ y
                borrow = ((~x) &amp; y) &lt;&lt; 1
                x, y = answer, borrow
        
        return x * sign
#ANSWER
class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        mask = 0xFFFFFFFF
        
        while b != 0:
            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask
        
        max_int = 0x7FFFFFFF
        return a if a &lt; max_int else ~(a ^ mask)
</code></pre>
<p>bit manipulation 初见感觉是。 但不知道怎么处理。思路，borrow 是 x&amp;y《《1， 没borrow的sum是x^y.</p>
<h1 id="font-colorred-372-super-pow-medium-font"><font color='red'> 372. Super Pow (Medium) </font></h1>
<p>Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<pre><code class="language-python">class Solution:
    def superPow(self, a: int, b: List[int]) -&gt; int:
        base=1337
        def f(a,b):
            res=1
            for i in range(b):
                res*=(a%base)
                res%=base
            return res
        if not b: return 1
        last_digit=b.pop()
        return f(self.superPow(a, b), 10) * f(a, last_digit) % base;
</code></pre>
<p>mod 有结合律交换律吗？。。不太清楚。。。 答案用了1） ab % k = (a%k)(b%k)%k<br>
2）a<sup>b%k=(a%k)</sup>b%k<br>
推到递推关系：<br>
a^1234567 % k = (a^1234560 a^7)%k= ((a^1234560)%k )  ((a^7)%k ) %k<br>
= ((a<sup>123456)</sup>10)%k )  ((a^7)%k ) %k<br>
= ((((a<sup>123456)%k)</sup>10 )% k)  ((a^7)%k ) %k<br>
设 a^b%k=f(a,b)<br>
f(a,1234567)=  f(f(a,123456),10) f(a,7)%k</p>
<h1 id="font-colorred-373-find-k-pairs-with-smallest-sums-medium-font"><font color='red'> 373. Find K Pairs with Smallest Sums （Medium） </font></h1>
<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.<br>
Define a pair (u, v) which consists of one element from the first array and one element from the second array.<br>
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.</p>
<pre><code class="language-python">class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:
        res = []
        if not nums1 or not nums2 or not k:
            return res
        
        heap = []
        visited = set()
        
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        
        visited.add((0, 0))
        
        while len(res) &lt; k and heap:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            
            if i+1 &lt; len(nums1) and (i+1, j) not in visited:
                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))
                visited.add((i+1, j))
            
            if j+1 &lt; len(nums2) and (i, j+1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
                visited.add((i, j+1))
        return res
        
           

</code></pre>
<p>暴力解肯定TLE。。。也想到了是k-way merge sort 但怎么写出来？直接抄答案了，用到了heapq.heappush, heapq.heappop, visited.  先从（0，0）开始push，然后是（1，0）（0，1）， i.e.   (i,j) then (i+1,j),(i,j+1)... 通过visited 去重。</p>
<h1 id="374-guess-number-higher-or-lower-easy">374. Guess Number Higher or Lower （Easy）</h1>
<p>We are playing the Guess Game. The game is as follows:<br>
I pick a number from 1 to n. You have to guess which number I picked.<br>
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.<br>
You call a pre-defined API int guess(int num), which returns three possible results:<br>
-1: Your guess is higher than the number I picked (i.e. num &gt; pick).<br>
1: Your guess is lower than the number I picked (i.e. num &lt; pick).<br>
0: your guess is equal to the number I picked (i.e. num == pick).</p>
<pre><code class="language-python"># The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if guess(m)==0:
                return m
            elif guess(m)==1:
                l=m+1
            else:
                r=m-1
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m1=l+(r-l)//3
            m2=r-(r-l)//3
            res1=guess(m1)
            res2=guess(m2)
            if res1==0:
                return m1
            if res2==0:
                return m2
            elif res1&lt;0:
                r=m1-1
            elif res2&gt;0:
                l=m2+1
            else:
                l=m1+1
                r=m2-1
</code></pre>
<p>二分法，三分法。。。</p>
<h1 id="font-colorred375-guess-number-higher-or-lower-ii-mediumfont"><font color='red'>375. Guess Number Higher or Lower II （Medium）</font></h1>
<p>We are playing the Guessing Game. The game will work as follows:<br>
I pick a number between 1 and n.<br>
You guess a number.<br>
If you guess the right number, you win the game.<br>
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.<br>
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.</p>
<pre><code class="language-python">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        #dp[i][j] will save the min cost guessing from i to j
        dp=[[0]*(n+1) for _ in range(n+1)]
         
        def helper(start,end):
            if start&gt;=end: return 0
            if dp[start][end]!=0: return dp[start][end]
            res=float('inf')
            for x in range(start,end+1):
                #try select x,the cost will be
                tmp=x+max(helper(start,x-1),helper(x+1,end))
                res=min(res,tmp)
            dp[start][end]=res
            return res
            
        return helper( 1, n)
    
</code></pre>
<p>没思路。。。看答案，用了DP 关键是DP【i】【j】定义为从i猜到j，花费的最小cost。 那么如果X在i，j之间，选定了X，则cost为 X+max（dp【start】【x-1】，dp【x+1】【end】）因为dp这时候还没值，所以用helper（start，x-1），helper（x+1，end）代替，用max是因为不确定是左面还是右面，只能按照最坏情况准备钱。扫描所有X，然后最小的作为dp【i】【j】cost结果。</p>
<h1 id="font-colorblue376-wiggle-subsequence-mediumfont"><font color='blue'>376. Wiggle Subsequence （Medium）</font></h1>
<p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.<br>
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.<br>
Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<pre><code class="language-python">class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        #dp[i]   the max length of wiggle including nums[i]
        # 1 17 5 10 13 15 10 5 16 8
        # 0 +  - +  +   +  - - +  -
        # 1 2  3 4  4   4  5 5 6  7   
        
        # 1 7 4 9 2 5
        # 0 + - + - +
        #sign[i] the sign of max length of nums[i-1] to nums[i] if increasing 1 decresasing -1
        if len(nums)&lt;2: return len(nums)
        if len(nums)==2 and nums[0]!=nums[1]:return 2
        if len(nums)==2 and nums[0]==nums[1]:return 1
        
        
        count_plus=0
        count_minus=0
        presign=None
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]: continue
            sign= nums[i]-nums[i-1]&gt;0
            if sign:
                #positive
                if presign is None:
                    count_minus=1
                
                if presign!=sign:
                    
                    count_plus=count_minus+1
            else:
                #negtive
                if presign is None:
                    count_plus=1
                if presign!=sign:
                    count_minus=count_plus+1 
            
            presign=sign
        
        return max([1,count_plus,count_minus])

#ANSWER DP O（n*n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[1]*len(nums)
        down=[1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]&gt;nums[j]:
                    up[i]=max(up[i],down[j]+1)
                elif nums[i]&lt;nums[j]:
                    down[i]=max(down[i],up[j]+1)
        return max(up[-1],down[-1])

#ANSWER DP O（n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[0]*len(nums)
        down=[0]*len(nums)
        up[0]=1
        down[0]=1
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up[i]=down[i-1]+1
                down[i]=down[i-1]
            elif nums[i]&lt;nums[i-1]:
                down[i]=up[i-1]+1
                up[i]=up[i-1]
            else:
                down[i]=down[i-1]
                up[i]=up[i-1]
        return max(up[-1],down[-1])

#ANSWER DP O（n） space O（1）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=1
        down=1
       
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up =down +1
           
            elif nums[i]&lt;nums[i-1]:
                down =up +1
              
        return max(up ,down )

#Greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        maxLen=1
        sign=0
        for i in range(1,len(nums)):
            if nums[i]&lt;nums[i-1] and sign!=-1:
                # find a peak nums[i-1] is peak, now it is a decreasing sequence sign=-1
                sign=-1
                maxLen+=1
           
            elif nums[i]&gt;nums[i-1] and sign!=1:
                #valley
                sign=1
                maxLen+=1
              
        return maxLen
         
</code></pre>
<p>本来想用DP做，但发现只用保持 count+ 和 count- 两个计数器就够了。  如果发现增加2元序列，count-加1. 如果发现减小2元序列，count+加1，最后返回count+,count-中最大的就可以了，注意corner case。答案用了多种方法，贴上来开阔思路。第三个方法和我的一样但是写的更简单</p>
<h1 id="font-colorred-377-combination-sum-iv-mediumfont"><font color='red'> 377. Combination Sum IV （Medium）</font></h1>
<p>Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.<br>
The test cases are generated so that the answer can fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        @lru_cache(None)
        def dp(remain):
            if remain==0:
                return 1
            res=0
            for n in nums:
                if remain-n&gt;=0:
                    res+=dp(remain-n)
            return res
        return dp(target)
    
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):

            for num in nums:
                if comb_sum - num &gt;= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
</code></pre>
<p>知道是DP，而且知道DP【i】是能sum到i的组合个数，那么dp【i】=dp【i-n】+dp【n】为啥不对？？ n是添加的最后一个数。而且扫的是所有n in nums。 如果再拆分n，那么会有重复。<br>
思路卡了， 应该是dp【i】+=dp【i-n】   要往组合里加n能到i，那么多出来的组合数就是dp【i-n】。应该求的是和。。。</p>
<h1 id="379-design-phone-directory-medium">379. Design Phone Directory （Medium）</h1>
<p>Design a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.<br>
Implement the PhoneDirectory class:<br>
PhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.<br>
int get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.<br>
bool check(int number) Returns true if the slot number is available and false otherwise.<br>
void release(int number) Recycles or releases the slot number.</p>
<pre><code class="language-python">class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n=maxNumbers
        self.avaliable=set([i for i in range(self.n)])
        self.used=set()
        self.current=-1
        

    def get(self) -&gt; int:
        if not self.avaliable: return -1
        while not self.check(self.current):
            self.current= (self.current+1)%self.n
        
        #current in self.avaliable
        # remove from self.avaliable
        self.avaliable.remove(self.current)
        self.used.add(self.current)
        
        res = self.current
        self.current= (self.current+1)%self.n
        return res

    def check(self, number: int) -&gt; bool:
        return  number in self.avaliable 

    def release(self, number: int) -&gt; None:
        self.avaliable.add(number)
        if number in self.used:
            self.used.remove(number)
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)

   def __init__(self, maxNumbers):
        self.available = set(range(maxNumbers))

    def get(self):
        return self.available.pop() if self.available else -1

    def check(self, number):
        return number in self.available

    def release(self, number):
        self.available.add(number)

#ANSWER PERFECT
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.pos=0
        self.next=[0]*maxNumbers
        for i in range(maxNumbers):
            self.next[i]=(i+1)%maxNumbers
        

    def get(self) -&gt; int:
        if self.next[self.pos]==-1: return -1
        res=self.pos
        self.pos=self.next[self.pos]
        self.next[res]=-1
        return res
        

    def check(self, number: int) -&gt; bool:
        return self.next[number]!=-1

    def release(self, number: int) -&gt; None:
        if self.next[number]!=-1: return
        self.next[number]=self.pos
        self.pos=number
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number) int[] next;
   
  


</code></pre>
<p>答案很完美的写法：Use a linked list to track available numbers, and a pointer to head. If head is still available, get() would return it and move to the next available number. Release would re-add a node to the beginning of the linked list and update head</p>
<h1 id="font-colorred-380-insert-delete-getrandom-o1-mediumfont"><font color='red'> 380. Insert Delete GetRandom O(1) （Medium）</font></h1>
<p>Implement the RandomizedSet class:</p>
<pre><code>RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
</code></pre>
<p>You must implement the functions of the class such that each function works in average O(1) time complexity.</p>
<pre><code class="language-python">from random import choice
class RandomizedSet():
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -&gt; int:
        &quot;&quot;&quot;
        Get a random element from the set.
        &quot;&quot;&quot;
        return choice(self.list)

</code></pre>
<p>这个思路好，用dic保存插入元素位置方便找出index， 删除时候找出index，然后和list中最后一个元素交换位置，然后pop list del dict【val】</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-09]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-09/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-09/">
        </link>
        <updated>2021-12-09T05:25:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="361-bomb-enemy-medium">361. Bomb Enemy （Medium）</h1>
<p>Given an m x n matrix grid where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.</p>
<p>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.</p>
<pre><code class="language-python">class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        m=len(grid)
        n=len(grid[0])
        dp=[[0]*n for _ in range(m) ]
        #look from left for each row
        for i in range(m):
            c=0
            for j in range(n):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from right for each row
        for i in range(m):
            c=0
            for j in range(n-1,-1,-1):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from up for each col
        for i in range(n):
            c=0
            for j in range(m):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
        #look from bottom for each col
        for i in range(n):
            c=0
            for j in range(m-1,-1,-1):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
         
        res=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]=='0':
                    res=max(res,dp[i][j])
        return res
                
 #ANSWER
 class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        if len(grid) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        max_count = 0
        row_hits = 0
        col_hits = [0] * cols

        for row in range(0, rows):
            for col in range(0, cols):
                # reset the hits on the row, if necessary.
                if col == 0 or grid[row][col - 1] == 'W':
                    row_hits = 0
                    for k in range(col, cols):
                        if grid[row][k] == 'W':
                            # stop the scan when we hit the wall.
                            break
                        elif grid[row][k] == 'E':
                            row_hits += 1

                # reset the hits on the col, if necessary.
                if row == 0 or grid[row - 1][col] == 'W':
                    col_hits[col] = 0
                    for k in range(row, rows):
                        if grid[k][col] == 'W':
                            break
                        elif grid[k][col] == 'E':
                            col_hits[col] += 1

                # count the hits for each empty cell.
                if grid[row][col] == '0':
                    total_hits = row_hits + col_hits[col]
                    max_count = max(max_count, total_hits)

        return max_count       
</code></pre>
<p>和答案思路是一致的，写的更简洁些。</p>
<h1 id="362-design-hit-counter-medium">362. Design Hit Counter （Medium）</h1>
<p>Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).<br>
Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). Several hits may arrive roughly at the same time.<br>
Implement the HitCounter class:<br>
HitCounter() Initializes the object of the hit counter system.<br>
void hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.<br>
int getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).</p>
<pre><code class="language-python">#NOT WORKING DUE TO timestamp range up to 2*10^9
class HitCounter:
    class BIT:
        def __init__(self,size):
            self.size=size
            self.tree=[0]*size
            
        def update(self,ind):
            #index in BIT is 1 more than original index
            while ind&lt;self.size:
                self.tree[ind]+=1
                ind+= ind&amp;-ind
        def query(self,ind):
            #index in BIT is 1 more than original index
            res=0
            while ind&gt;0:
                res+=self.tree[ind]
                ind-= ind&amp;-ind
            return res


    def __init__(self):
        self.tree=self.BIT(2000)
    def hit(self, timestamp: int) -&gt; None:
        self.tree.update(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return self.tree.query(timestamp)-self.tree.query(timestamp-300 if timestamp-300&gt;0 else 0)
        
#ANOTHER WAY...
class HitCounter:

    def __init__(self):
        self.data=[]
        
        

    def hit(self, timestamp: int) -&gt; None:
        self.data.append(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return bisect.bisect_right(self.data,timestamp)-bisect.bisect_left(self.data,timestamp-299)


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)

class HitCounter(object):

def __init__(self):
    &quot;&quot;&quot;
    Initialize your data structure here.
    &quot;&quot;&quot;
    self.deque = collections.deque()

def hit(self, timestamp):
    &quot;&quot;&quot;
    Record a hit.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: None
    &quot;&quot;&quot;
    self.deque.append(timestamp)
    

def getHits(self, timestamp):
    &quot;&quot;&quot;
    Return the number of hits in the past 5 minutes.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: int
    &quot;&quot;&quot;

    while self.deque and timestamp - self.deque[0] &gt;= 300:
        self.deque.popleft()
    return len(self.deque)

</code></pre>
<p>感觉用Seg Tree 或者Binary Indexed Tree 但忘记怎么写。。。遇到memory out of bond 问题，因为timestamp 范围太大。。。换思路。。。直接用binary search。。。或者用queue</p>
<h1 id="font-colorred-363-max-sum-of-rectangle-no-larger-than-k-hardfont"><font color='red'> 363. Max Sum of Rectangle No Larger Than K （Hard）</font></h1>
<p>Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        m=len(matrix)
        n=len(matrix[0])
        res=[]
        for i in range(m):
            for j in range(n):
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
                if i==0 and j==0:continue
                if j&gt;0 and i==0 :
                    matrix[i][j]+=matrix[i][j-1]
                elif i&gt;0 and j==0:
                    matrix[i][j]+=matrix[i-1][j]
                else:
                    matrix[i][j]+=matrix[i][j-1]+matrix[i-1][j]-matrix[i-1][j-1]
                
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
        
        #for row in matrix:
        #    print(row)
        #print(res)
   
        for row in range(m):
            for col in range(n):
                for row_p in range(row):
                    area=matrix[row][col]-matrix[row_p][col]
                    if area&lt;=k:
                            heapq.heappush(res,-area)
                    for col_p in range(col):
                        area=matrix[row][col]-matrix[row][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)
                        area=matrix[row][col]-matrix[row_p][col]-matrix[row][col_p]+matrix[row_p][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)

        return -heapq.heappop(res)

#ANSWER
import sortedcontainers
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        def updateresult(nums,k):
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result

#ANSWER 
import sortedcontainers
class Solution:
    
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        
        def getmaxkadane(nums):
            maxkadane=float('-inf')
            currentmaxsum=0
            for num in nums:
                currentmaxsum=max(currentmaxsum+num,num)
                maxkadane=max(maxkadane,currentmaxsum)
            return maxkadane
        def updateresult(nums,k):
            kadanesum=getmaxkadane(nums)
            if kadanesum&lt;=k:
                self.result=max(self.result,kadanesum)
                return
            
            
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result
                      
</code></pre>
<p>初次尝试heapq+cumsum time limit exceeded，因为还是属于暴力解法。。。看答案。答案用python去解也是TLE， 答案思路，先考虑1D问题，要寻找加和小于等于K的，相当于找当前的runningsum-X小于等于K，所以要寻找X大于等于runningsum-K，这样用orderedset和binary seasrch可以从runningsum中找到这个X，runningsum-X就是要求的小于等于K的累加和。 再还原成2d问题，对于每一个起始点为ith row的数据，初始化一个rowsum。然后每添加一个row就update一下答案。 Time complexity: O(m2nlog⁡n)<br>
另一种方法增加改进用Kadane's algorithm gets the max possible sum of a sub-array in O(n) time，</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        # Initialize our variables using the first element.
        current_subarray = max_subarray = nums[0]
        # Start with the 2nd element since we already used the first one.
        for num in nums[1:]:
            # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
            current_subarray = max(num, current_subarray + num)
            max_subarray = max(max_subarray, current_subarray)
        return max_subarray
</code></pre>
<p>一种DP的方法求maxsubarray。。。因为一个row如果maxsumarry已经小于等于K了就没必要用nlogn方法的updateresult再去求了，算一步时间复杂度上的小优化。这样写出来能pass。</p>
<h1 id="364-nested-list-weight-sum-ii-medium">364. Nested List Weight Sum II （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth. Let maxDepth be the maximum depth of any integer.<br>
The weight of an integer is maxDepth - (the depth of the integer) + 1.<br>
Return the sum of each integer in nestedList multiplied by its weight.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &quot;&quot;&quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &quot;&quot;&quot;
#
#    def isInteger(self):
#        &quot;&quot;&quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def add(self, elem):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def setInteger(self, value):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def getInteger(self):
#        &quot;&quot;&quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &quot;&quot;&quot;
#
#    def getList(self):
#        &quot;&quot;&quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &quot;&quot;&quot;

class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -&gt; int:
        #[[1,1],2,[1,1]]
        
        def depth(nestedList):
            d=1
            for li in nestedList:
                if not li.isInteger():
                    d=max(d,1+depth(li.getList()))
            return d
                    
                    
                
        maxd=depth(nestedList)    
        #print(maxd)
    
        
        def helper(nestedList,depth):
            res=0
            for li in nestedList:
                if li.isInteger():
                    #print(li.getInteger(),(maxd-depth+1))
                    res+=li.getInteger()*(maxd-depth+1)
                else:
                    
                    res+=helper(li.getList(),depth+1)
                   
            return res
        
        return helper(nestedList,1)

            
        
</code></pre>
<p>算maxdepth时候卡壳了。。。。写出的算法同答案1，double DFS。 算法2，3用了math+BFS。</p>
<h1 id="font-colorred365-water-and-jug-problem-mediumfont"><font color='red'>365. Water and Jug Problem （Medium）</font></h1>
<p>ou are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.</p>
<p>If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<pre><code>Fill any of the jugs with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.
</code></pre>
<pre><code class="language-python">class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
     
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
        if x + y &lt; z: return False
        if  x == z or y == z or x + y == z : return True
        
        def GCD(a,b):
            while b:
                a,b=b,a%b
            return a
        return z%GCD(x, y) == 0 

#ANSWER BFS
class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
     
        if x&gt;y:
            #make sure x&lt;y
            x,y=y,x
            
        if z &gt; x + y: return False
        
        # set the initial state will empty jars;
        queue = [(0, 0)]
        visited = set((0, 0))
        while queue:
            a, b = queue.pop(0);
            if a + b == z:
                return True;
            
            states = set()
            
            states.add((x, b)) # fill jar x;
            states.add((a, y)) # fill jar y;
            states.add((0, b)) # empty jar x;
            states.add((a, 0)) # empty jar y;
            states.add((min(x, b + a), 0 if b &lt; x - a else b - (x - a))) # pour jar y to x;
            states.add((0 if a + b &lt; y else a - (y - b), min(b + a, y))) # pour jar x to y;

            for state in states:
                if state in visited:
                    continue;
                queue.append(state)
                visited.add(state);
                
        return False

</code></pre>
<p>一眼看上去好像是个dp问题。但提示是DFS，BFS, MATH。 答案用了 Bézout's identity and check if z is a multiple of GCD(x, y)<br>
Bézout's identity (also called Bézout's lemma) is a theorem in the elementary theory of numbers:<br>
let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x and y such that ax+by=d，In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by every integer of the form ax + by is a multiple of the greatest common divisor d.<br>
BFS解法也很经典</p>
<h1 id="366-find-leaves-of-binary-tree-medium">366. Find Leaves of Binary Tree （Medium）</h1>
<p>Given the root of a binary tree, collect a tree's nodes as if you were doing this:<br>
Collect all the leaf nodes.<br>
Remove all the leaf nodes.<br>
Repeat until the tree is empty.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        self.maxd=0
        def depth(root):
            if not root: return
            if not root.left and not root.right:
                root.d=0
                return
        
            depth(root.left)
            depth(root.right)
            
            if root.left and root.right:
                root.d=max(root.left.d,root.right.d)+1
            elif root.left:
                root.d=root.left.d+1
            else:
                root.d=root.right.d+1
            
            self.maxd=max(self.maxd,root.d)
                
                    
        depth(root)
        res=[[] for _ in range(self.maxd+1)]
        
        def pre(root):
            if not root: return 
            res[root.d].append(root.val)
            pre(root.left)
            pre(root.right)
        
        pre(root)
        return res 


#ANSWER
def findLeaves(self, root: TreeNode) -&gt; List[List[int]]:
    output = collections.defaultdict(list)
    
    def dfs(node, layer):
        if not node: 
            return layer 
        left = dfs(node.left, layer)
        right = dfs(node.right, layer)
        layer = max(left, right)
        output[layer].append(node.val)
        return layer + 1
    
    dfs(root, 0)
    return output.values() 
</code></pre>
<p>先后序遍历给node标号，同时知道最大深度，然后初始化res，再前序遍历把val放到应该放的res位置。答案把所有的都放在后序遍历里了。</p>
<h1 id="367-valid-perfect-square-easy">367. Valid Perfect Square （Easy）</h1>
<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<pre><code class="language-python">class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        l=1
        r=num//2+1
        while l&lt;=r:
            m= (l+r)//2
            if m*m==num:
                return True
            elif m*m&gt;num:
                r=m-1
            else:
                l=m+1
        return False
#ANSWER
class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        if num &lt; 2:
            return True
        
        x = num // 2
        while x * x &gt; num:
            x = (x + num // x) // 2
        return x * x == num
</code></pre>
<p>答案用了牛顿法，更快收敛比二分法。找出f（x）= x^2-num=0的根。 设一个猜测值Xk  ，f（Xk）是y值，f‘（Xk）是对比底，所以底= f（Xk）/f'(Xk)  新的猜测Xk+1= Xk- f（Xk）/f'(Xk) 所以 xk+1​=0.5*(xk​+num/xk​​)<br>
牛顿法也是O(log⁡N)</p>
<h1 id="font-colorred368-largest-divisible-subset-mediumfont"><font color='red'>368. Largest Divisible Subset （Medium）</font></h1>
<p>Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:<br>
answer[i] % answer[j] == 0, or<br>
answer[j] % answer[i] == 0<br>
If there are multiple solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:
        #dp[i]= maxsubset include nums[i] from 0 to i
        # dp[i]=      nums[0] to nums[i] are divisible by nums[i] find max(dp)+1
        nums.sort()
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i]%nums[j]==0 or nums[j]%nums[i]==0:
                    dp[i]=max(dp[i],dp[j]+1)
               
        ind=dp.index(max(dp))
        while ind+1&lt;len(dp) and dp[ind+1]==max(dp):
            ind+=1
        #print(nums)
        #print(dp)
        #reconstruct res
        res=[]
        cursize=max(dp)
        curtail=nums[ind]
        for i in range(ind,-1,-1):
            if cursize==dp[i] and curtail%nums[i]==0:
                res.append(nums[i])
                cursize-=1
                curtail=nums[i]
        return res[::-1]

 #ANSWER WAY OF WRITING        
class Solution(object):
    def largestDivisibleSubset(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # The container that holds all intermediate solutions.
        # key: the largest element in a valid subset.
        subsets = {-1: set()}
        
        for num in sorted(nums):
            subsets[num] = max([subsets[k] for k in subsets if num % k == 0], key=len) | {num}
        
        return list(max(subsets.values(), key=len))
</code></pre>
<p>用dp可以算出长度，但没法正确给出一个result。问题出在了reconstruct这一步。 看了答案写出来了。<br>
答案写出算法用了2个定理。假设【E，F，G】已经是从小到大排序好的而且是divisible subset，那么1）对于h大于G， h%G等于0则【E，F，G，h】满足divisible subset  2）对于 d小于E，若 E%d==0则【d，E，F，G】满足divisible subset。</p>
<h1 id="369-plus-one-linked-list-medium">369. Plus One Linked List （Medium）</h1>
<p>Given a non-negative integer represented as a linked list of digits, plus one to the integer.<br>
The digits are stored such that the most significant digit is at the head of the list.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
        revlist_head = rev(head)
        cur=revlist_head
        first=True
        carry=0
        pre=None
        while cur:
            if first:
                val=cur.val+carry+1
                cur.val=val%10
                carry=val//10
                first=False
            else:
                val=cur.val+carry
                cur.val=val%10
                carry=val//10
            pre=cur
            cur=cur.next
        
        if carry:
            pre.next=ListNode(val=carry)
        
        return rev(revlist_head)

#ANSWER WAY OF WRITING
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        # sentinel head
        sentinel = ListNode(0)
        sentinel.next = head
        not_nine = sentinel

        # find the rightmost not-nine digit
        while head:
            if head.val != 9:
                not_nine = head
            head = head.next

        # increase this rightmost not-nine digit by 1
        not_nine.val += 1
        not_nine = not_nine.next

        # set all the following nines to zeros
        while not_nine:
            not_nine.val = 0
            not_nine = not_nine.next

        return sentinel if sentinel.val else sentinel.next

</code></pre>
<p>先rev了加1，然后再rev回去。<br>
答案做法用哨兵0node，找到最右面不是9的node+1，后面是9的一律变0.</p>
<h1 id="font-colorblue-370-range-addition-mediumfont"><font color='blue'> 370. Range Addition （Medium）</font></h1>
<p>You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].</p>
<p>You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.</p>
<p>Return arr after applying all the updates.</p>
<pre><code class="language-python">class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:
        #brute force
        res=[0]*length
        for update in updates:
            i,j,inc=update
            res[i]+=inc
            if j+1&lt;length:
                res[j+1]+=-inc 
            
        for i in range(1,length):
            res[i]+=res[i-1]
        return res
        

</code></pre>
<p>暴力解TLE。。 看了hint写出来了。。。第一个hint就是没必要用复杂数据结构，别想太多。<br>
BIT,SEGMENTTREE</p>
<pre><code class="language-python">tree=[0]*(2*size)   
#####SEGMENT TREE
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7
       
def update(ind):
    tree[ind]+=1
    
    while ind&gt;0:
        left=ind
        right=ind
        if ind%2==0:
            right+=1
        else:
            left-=1
        if ind//2&gt;0:
            tree[ind//2]=tree[left]+tree[right]
        ind//=2
#####
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7      
def query(left,right):
    res=0
    while left&lt;=right:
        if right%2==0:
            res+=tree[right]
            right-=1
        if left%2==1:
            res+=tree[left]
            left+=1

        left//=2
        right//=2

    return res

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-08]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-08/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-08/">
        </link>
        <updated>2021-12-07T16:32:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred351-android-unlock-patterns-medium-font"><font color='red'>351. Android Unlock Patterns (Medium) </font></h1>
<p>Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an &quot;unlock pattern&quot; by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true:<br>
All the dots in the sequence are distinct.<br>
If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.<br>
For example, connecting dots 2 and 9 without dots 5 or 6 appearing beforehand is valid because the line from dot 2 to dot 9 does not pass through the center of either dot 5 or 6.<br>
However, connecting dots 1 and 3 without dot 2 appearing beforehand is invalid because the line from dot 1 to dot 3 passes through the center of dot 2.<br>
Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys.</p>
<p>Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.</p>
<pre><code class="language-python">class Solution:
    def numberOfPatterns(self, m: int, n: int) -&gt; int:
        skip = [[0]*10 for _ in range(10)]
        skip[1][3] = skip[3][1] = 2 
        skip[1][7] = skip[7][1] = 4 
        skip[3][9] = skip[9][3] = 6 
        skip[7][9] = skip[9][7] = 8 
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5 
        visited = [False]*10
        res=0
        def DFS(cur,remain):
            if remain&lt;0: return 0
            if remain==0: return 1
            visited[cur]=True
            res=0
            for i in range(1,10):
                if not visited[i] and (skip[cur][i]==0 or visited[skip[cur][i]]):
                    res+=DFS(i,remain-1)
            visited[cur]=False
            return res
        
        for i in range(m,n+1):
            res+=DFS(1,i-1)*4 # 1,3,7, 9 sym 
            res+=DFS(2,i-1)*4 # 2 4 6 8  sym
            res+=DFS(5,i-1) 
            
        return res
        
</code></pre>
<p>问题是奇怪的问题，解决方法大概是DP，但递归关系不好找。思路错误， 答案用DFS+BT  简化思路是 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.</p>
<h1 id="font-colorred352-data-stream-as-disjoint-intervals-hardfont"><font color='red'>352. Data Stream as Disjoint Intervals （Hard）</font></h1>
<p>Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.<br>
Implement the SummaryRanges class:<br>
SummaryRanges() Initializes the object with an empty stream.<br>
void addNum(int val) Adds the integer val to the stream.<br>
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].</p>
<pre><code class="language-python">class SummaryRanges:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.interval = [] # record the interval
        self.s = set() # record the number we have added before
        return 

    def addNum(self, val: int) -&gt; None:
        if val in self.s:
            return 
        self.s.add(val)
        index = bisect_left(self.interval,[val,val])

        # check whether we could extend the interval on its left and right 
        if index &lt; len(self.interval) and self.interval[index][0]-1 == val:
            self.interval[index][0] = self.interval[index][0] - 1
        elif index &gt; 0 and self.interval[index-1][1]+1 == val:
            self.interval[index-1][1] = self.interval[index-1][1] + 1
        else:
            self.interval.insert(index, [val,val])

    def getIntervals(self) -&gt; List[List[int]]:
        # update the intervals in getIntervals function 
        connect = []
        for x in self.interval:
            if connect and connect[-1][1] == x[0]-1:
                connect[-1][1] = x[1]
            else:
                connect.append(x)
        self.interval = connect
        return self.interval 

</code></pre>
<p>思路： binary search for interval， interval update when getIntervals。</p>
<h1 id="353-design-snake-game-medium">353. Design Snake Game （Medium）</h1>
<pre><code class="language-python">class SnakeGame:

    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.food=food
        self.w=width
        self.h=height
        self.score=0
        self.body = [[0,0]]
        self.pos=[0,0]

    def move(self, direction: str) -&gt; int:
        #outofbound check
        if direction=='R':
            self.pos[1]+=1
        elif direction=='L':
            self.pos[1]-=1
        elif direction=='U':
            self.pos[0]-=1
        elif direction=='D':
            self.pos[0]+=1
        
        if not (self.h&gt;self.pos[0]&gt;=0): return -1
        if not (self.w&gt;self.pos[1]&gt;=0): return -1
        
        #hadle food
       
        if not (self.food and self.pos==self.food[0]):
            #no food
            self.body.pop(0)
            if self.pos in self.body: return -1
            self.body.append(self.pos[:])
        else:
            #food
            self.food.pop(0)
            self.body.append(self.pos[:])
            self.score+=1
        return self.score
            
# Your SnakeGame object will be instantiated and called as such:
# obj = SnakeGame(width, height, food)
# param_1 = obj.move(direction)

</code></pre>
<h1 id="font-colorred354-russian-doll-envelopes-hard-font"><font color='red'>354. Russian Doll Envelopes (Hard) </font></h1>
<p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.</p>
<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.</p>
<p>Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).</p>
<pre><code class="language-python">from bisect import bisect_left
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:
        arr = envelopes
        arr.sort(key=lambda x: (x[0], -x[1]))

        def lis(nums):
            dp = []
            for i in range(len(nums)):
                idx = bisect_left(dp, nums[i])
                if idx == len(dp):
                    dp.append(nums[i])
                else:
                    dp[idx] = nums[i]
            return len(dp)
        # extract the second dimension and run the LIS
        return lis([i[1] for i in arr])

</code></pre>
<p>尝试用greedy解决但失败了，感觉是个DP问题。。。思路看答案了。  2D longest increasing subsequence problem (LIS).  KEY： ''we also sort decreasing on the second dimension, so two envelopes that are equal in the first dimension can never be in the same increasing subsequence'' 关键是NlogN的 LIS 没用过。。。，需要记住写法。dp[i] 存储的是长度是i+1的LIS末尾元素。</p>
<h1 id="355-design-twitter-medium">355. Design Twitter （Medium）</h1>
<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.<br>
Implement the Twitter class:<br>
Twitter() Initializes your twitter object.<br>
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.<br>
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.<br>
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.<br>
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.</p>
<pre><code class="language-python">
class Twitter:

    def __init__(self):
        self.follows=collections.defaultdict(set)
        self.tweets=collections.defaultdict(list)
        self.time=0
   

    def postTweet(self, userId: int, tweetId: int) -&gt; None:
        self.tweets[userId].append([tweetId,self.time])
        self.time+=1
        

    def getNewsFeed(self, userId: int) -&gt; List[int]:
        res=[]
        followers=self.follows[userId]
        for f in list(followers)+[userId]:
            res.extend(self.tweets[f])
        
        return [ e[0] for e in sorted(res,key=lambda x:-x[1])][:10] 

    def follow(self, followerId: int, followeeId: int) -&gt; None:
        self.follows[followerId].add(followeeId)
    

    def unfollow(self, followerId: int, followeeId: int) -&gt; None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
        


</code></pre>
<h1 id="font-colorred356-line-reflection-medium-font"><font color='red'>356. Line Reflection (Medium) </font></h1>
<p>Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.</p>
<p>In other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.</p>
<pre><code class="language-python">class Solution:
    def isReflected(self, points: List[List[int]]) -&gt; bool:
        s=set()
        min_=float('inf')
        max_=float('-inf')
        for p in points:
            min_=min(p[0],min_)
            max_=max(p[0],max_)
            s.add(tuple(p))
        sum_=min_+max_
        for p in points:
            if s and (sum_-p[0],p[1]) not in s:
                return False
        return True
        

</code></pre>
<p>思路竟然和two sum类似， 用一个set先保存点，然后找reflect点是否在set里。 中心位置一定是min+max的中点。</p>
<h1 id="font-colorblue357-count-numbers-with-unique-digits-medium-font"><font color='blue'>357. Count Numbers with Unique Digits (Medium) </font></h1>
<p>Given an integer n, return the count of all numbers with unique digits, x, where 0 &lt;= x &lt; 10n.</p>
<pre><code class="language-python">class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        #Let f(k) = count of numbers with unique digits with length equals k.
        # f(1)=10
        # f(2)=9*9   choose 1~9, choose 0~9 except first choose
        # f(3)=9*9*8
        # f(k)=9*9*8*...(9-k+2)
        if n==0: return 1
        if n==1: return 10 
        if n==2: return 91
        f=[0]*(n+1)
        f[1]=10
        f[2]=81
        for i in range(3,n+1):
            f[i]=f[i-1]*(9-i+2)
        
         
        res=0
        for j in range(1,n+1):
            #print(j,f[j])
            res+=f[j]
        return res
</code></pre>
<p>看了提示才做出来。。。 定义f（x） ，意思是长度为x的string，有多少种不同组合方式。答案就是f1+f2+。。。+fn</p>
<h1 id="font-colorred-358-rearrange-string-k-distance-apart-hard-font"><font color='red'> 358. Rearrange String k Distance Apart (Hard) </font></h1>
<p>Given a string s and an integer k, rearrange s such that the same characters are at least distance k from each other. If it is not possible to rearrange the string, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">class Solution:
    def rearrangeString(self, s: str, k: int) -&gt; str:
     
        if k == 0:
            return s
        n = len(s)
        count = collections.Counter(s)
        max_val = max(count.values())
        max_count = sum(1 for val in count.values() if val == max_val)
        if (max_val-1)*k+max_count &gt; n:
            return &quot;&quot;
        
        buckets = [[] for _ in range(max_val)]
        cnt = 0
        for key in sorted(count, key = lambda x: -count[x]):
            divisor = max_val if count[key] == max_val else max_val-1
            for _ in range(count[key]):
                buckets[cnt% divisor].append(key)
                cnt += 1
        return &quot;&quot;.join([&quot;&quot;.join(bucket) for bucket in buckets])
</code></pre>
<p>刚开始想用bt做，看了答案用的是比较巧妙的bucket。 而且要从数目多的char到数目少的char来排。 排的位置如果是频率最大的，则能排到所有buket，否则只能排到n-1 buket。<br>
aaabbcccd  k=2<br>
count={a：3，c：3，b：2，d：1}<br>
max_val=3 所以有3个buket<br>
【】 【】 【】<br>
先排a，divisor=3<br>
【a】 【a】 【a】<br>
再排c，divisor=3<br>
【ac】【ac】【ac】<br>
再排b，divisor=2 最后一个位置排满了<br>
【acb】【acb】【ac】<br>
再排d，divisor=2<br>
【acbd】【acb】【ac】</p>
<p>这个思路比较难想出来。。。buket+变divisor。。。</p>
<h1 id="359-logger-rate-limiter-easy">359. Logger Rate Limiter （Easy）</h1>
<p>Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).<br>
All messages will come in chronological order. Several messages may arrive at the same timestamp.<br>
Implement the Logger class:<br>
Logger() Initializes the logger object.<br>
bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.</p>
<pre><code class="language-python">class Logger:

    def __init__(self):
        self.dic=dict()
        

    def shouldPrintMessage(self, timestamp: int, message: str) -&gt; bool:
        res=True
        if message in self.dic and timestamp-self.dic[message]&lt;10:
            res=False
        if res:
            self.dic[message]=timestamp
        return res
# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)


#ANSWER WAY OF WRITTING
class Logger(object):

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._msg_dict = {}
    
    def shouldPrintMessage(self, timestamp, message):
        &quot;&quot;&quot;
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        &quot;&quot;&quot;
        if message not in self._msg_dict:
            # case 1). add the message to print
            self._msg_dict[message] = timestamp
            return True

        if timestamp - self._msg_dict[message] &gt;= 10:
            # case 2). update the timestamp of the message
            self._msg_dict[message] = timestamp
            return True
        else:
            return False

</code></pre>
<h1 id="360-sort-transformed-array-medium">360. Sort Transformed Array (Medium)</h1>
<p>Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.</p>
<pre><code class="language-python">class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
        #f(x)=ax**2+bx+c
        #f(x)= a(x+b/2a)**2 -b**2/4a+c
        #Therefore, sym axis=  -b/2a  
        
        
        
        f=lambda x: a*x**2+b*x+c
        if a==0: return [f(i) for i in nums] if b&gt;0 else  [f(i) for i in nums[::-1]]
        
        axis=-b/(2*a)
        res=[]
        ind=bisect.bisect_left(nums,axis)
        l=ind-1
        r=ind
        while l&gt;=0 and r&lt;len(nums):
            
            if a&gt;0: #fill left to right find smaller
                if f(nums[l])&lt;=f(nums[r]):
                    res.append(f(nums[l]))
                    l-=1
                else:
                    res.append(f(nums[r]))
                    r+=1
            
            else:# fill right to left find larger
                if f(nums[l])&gt;=f(nums[r]):
                    res=[f(nums[l])]+res
                    l-=1
                else:
                    res= [f(nums[r])]+res
                    r+=1
        
        #print(res)
        while l&gt;=0:
            if a&gt;0:
                res.append(f(nums[l]))
            else:
                res=[f(nums[l])]+res
            l-=1
                
        while r&lt;len(nums):
            if a&gt;0:
                res.append(f(nums[r]))
            else:
                res=[f(nums[r])]+res
            r+=1
        
        return res
        
#ANSWER WAY
class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
 
        
        f=lambda x: a*x**2+b*x+c
        n=len(nums)
        res=['NULL']*n
        l=0
        r=n-1
        index= n-1 if a&gt;=0 else 0
        while l&lt;=r:
            if a&gt;=0:
                res[index]=f(nums[l]) if f(nums[l])&gt;=f(nums[r]) else f(nums[r])
                index-=1
                if f(nums[l])&gt;=f(nums[r]):
                    l+=1
                else:
                    r-=1
             
            else:
                res[index]=f(nums[r]) if f(nums[l])&gt;=f(nums[r]) else f(nums[l])
                index+=1
                if f(nums[l])&gt;=f(nums[r]):
                    r-=1
                else:
                    l+=1
        return res
      

</code></pre>
<p>考二次函数，答案更精巧 用two pointer，关键点在于如果a大于0, 最大值肯定在head tail之间的一个，如果a小于0，最小值肯定在head tail中的一个。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-07]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-07/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-07/">
        </link>
        <updated>2021-12-07T11:31:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred341-flatten-nested-list-iterator-mediumfont"><font color='red'>341. Flatten Nested List Iterator （Medium）</font></h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>
<pre><code class="language-python">
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.integers=[]
        self.position = -1
        def flaten_list(nestedList):
            for nl in nestedList:
                if nl.isInteger():
                    self.integers.append(nl.getInteger())
                else:
                    flaten_list(nl.getList())
        flaten_list(nestedList)
    
    def next(self) -&gt; int:
        self.position+=1
        return self.integers[self.position]
    
    def hasNext(self) -&gt; bool:
        return self.position+1&lt;len(self.integers)


class NestedIterator(object):

    def __init__(self, nestedList):
        &quot;&quot;&quot;
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        &quot;&quot;&quot;
        self.stack = nestedList[::-1]
        
    def next(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        return self.stack.pop().getInteger()
        
    def hasNext(self):
        &quot;&quot;&quot;
        :rtype: bool
        &quot;&quot;&quot;
        while self.stack:
            top = self.stack[-1]
            if top.isInteger():
                return True
            self.stack = self.stack[:-1] + top.getList()[::-1]
        return False

class NestedIterator:

    def __init__(self, nestedList: [NestedInteger]):
        # Get a generator object from the generator function, passing in
        # nestedList as the parameter.
        self._generator = self._int_generator(nestedList)
        # All values are placed here before being returned.
        self._peeked = None

    # This is the generator function. It can be used to create generator
    # objects.
    def _int_generator(self, nested_list) -&gt; &quot;Generator[int]&quot;:
        # This code is the same as Approach 1. It's a recursive DFS.
        for nested in nested_list:
            if nested.isInteger():
                yield nested.getInteger()
            else:
                # We always use &quot;yield from&quot; on recursive generator calls.
                yield from self._int_generator(nested.getList())
        # Will automatically raise a StopIteration.
    
    def next(self) -&gt; int:
        # Check there are integers left, and if so, then this will
        # also put one into self._peeked.
        if not self.hasNext(): return None
        # Return the value of self._peeked, also clearing it.
        next_integer, self._peeked = self._peeked, None
        return next_integer
        
    def hasNext(self) -&gt; bool:
        if self._peeked is not None: return True
        try: # Get another integer out of the generator.
            self._peeked = next(self._generator)
            return True
        except: # The generator is finished so raised StopIteration.
            return False

</code></pre>
<p>generator 解法没见过， 普通解法，要么初始化时候分解，要么用stack倒序，保证栈顶是integer。</p>
<h1 id="342-power-of-four-easy">342. Power of Four （Easy）</h1>
<p>Given an integer n, return true if it is a power of four. Otherwise, return false.<br>
An integer n is a power of four, if there exists an integer x such that n == 4^x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfFour(self, n: int) -&gt; bool:
        if n==0: return False 
        while n:
            if n==1: return True
            if n%4!=0:
                return False
            n//=4
        return True

class Solution(object):
    def isPowerOfFour(self, n):
        if n == 0:
            return False
        while n % 4 == 0:
            n /= 4
        return n == 1
</code></pre>
<h1 id="font-colorred343-integer-break-medium-font"><font color='red'>343. Integer Break (Medium) </font></h1>
<p>Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers.<br>
Return the maximum product you can get.</p>
<pre><code class="language-python">class Solution:
    def integerBreak(self, n: int) -&gt; int:
        dp = [0]*(n+1)
        dp[1]=1
        for i in range(2,n+1):
            for j in range(1,i):
                dp[i]=max(dp[i],max(dp[j],j)*max(i-j,dp[i-j]))
        return dp[n]
  
class Solution:
    def integerBreak(self, n: int) -&gt; int:
        if n==2: return 1
        if n==3: return 2
        product = 1
        while n&gt;4:
            product*=3;
            n-=3
        product*=n;
        return product

#
class Solution:
    def integerBreak(self, n: int) -&gt; int:
        if n == 2: 
            return 1 
        elif n == 3:
            return 2
        elif n%3 == 0:
            return 3**(n//3)
        elif n%3 == 1:
            return 4* 3**((n - 4) // 3)
        else: 
            #n%3==2
            return 2 * (3** (n//3))
</code></pre>
<p>没思路,答案一，dp，dp【i】保存i可以被分解的最大乘集，假设i被分解成 a和b的和， 那么a或者b可以选中集训分解dp【a/b】或者不分解保留原始值a/b. 思路2： 用3 as many as possible. 比如 6, 3 乘 3大于2 乘 2 乘 2. 因此答案不会有超过3个的2. 尽力用3.   答案3： 有了思路2 ，和容易写出答案3.但dp这种方法应该想出来。。。</p>
<h1 id="344-reverse-string-easy">344. Reverse String (Easy)</h1>
<p>Write a function that reverses a string. The input string is given as an array of characters s.<br>
You must do this by modifying the input array in-place with O(1) extra memory.</p>
<pre><code class="language-python">class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        l=0
        r=len(s)-1
        while l&lt;r:
            s[l],s[r]=s[r],s[l]
            l+=1
            r-=1
</code></pre>
<h1 id="345-reverse-vowels-of-a-string-easy">345. Reverse Vowels of a String (Easy)</h1>
<p>Given a string s, reverse only all the vowels in the string and return it.<br>
The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.</p>
<pre><code class="language-python">class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        s=[e for e in s]
        l=0
        r=len(s)-1
        vowels={'a','e','i','o','u'}
        while l&lt;r:
            while l&lt;r and s[l].lower() not in vowels:
                l+=1
            while l&lt;r and s[r].lower() not in vowels:
                r-=1
            
            s[l],s[r]=s[r],s[l]
            r-=1
            l+=1
        
        return ''.join(s)
</code></pre>
<h1 id="346-moving-average-from-data-stream-easy">346. Moving Average from Data Stream (Easy)</h1>
<p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.<br>
Implement the MovingAverage class:<br>
MovingAverage(int size) Initializes the object with the size of the window size.<br>
double next(int val) Returns the moving average of the last size values of the stream.</p>
<pre><code class="language-python">class MovingAverage:

    def __init__(self, size: int):
        self.size=size
        self.q=[]
    def next(self, val: int) -&gt; float:
        if len(self.q)&lt;self.size:
            self.q.append(val)
            return sum(self.q)/len(self.q)
        else:
            self.q.pop(0)
            self.q.append(val)
            return sum(self.q)/len(self.q)
        
from collections import deque
class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = deque()
        # number of elements seen so far
        self.window_sum = 0
        self.count = 0

    def next(self, val: int) -&gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        self.queue.append(val)
        tail = self.queue.popleft() if self.count &gt; self.size else 0

        self.window_sum = self.window_sum - tail + val

        return self.window_sum / min(self.size, self.count)

class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = [0] * self.size
        self.head = self.window_sum = 0
        # number of elements seen so far
        self.count = 0

    def next(self, val: int) -&gt; float:
        self.count += 1
        # calculate the new sum by shifting the window
        tail = (self.head + 1) % self.size
        self.window_sum = self.window_sum - self.queue[tail] + val
        # move on to the next head
        self.head = (self.head + 1) % self.size
        self.queue[self.head] = val
        return self.window_sum / min(self.size, self.count)

</code></pre>
<p>用queue 和 Circular Queue 都是好想法。</p>
<h1 id="font-colorblue347-top-k-frequent-elements-mediumfont"><font color='blue'>347. Top K Frequent Elements （Medium）</font></h1>
<p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.<br>
Your algorithm's time complexity must be better than O(n log n), where n is the array's size</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        dic_c = collections.Counter(nums)
        return sorted(dic_c.keys(),key=lambda x: dic_c[x],reverse=True)[:k]

#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        count = Counter(nums)
        unique = list(count.keys())
        
        def partition(left, right, pivot_index) -&gt; int:
            pivot_frequency = count[unique[pivot_index]]
            # 1. move pivot to end
            unique[pivot_index], unique[right] = unique[right], unique[pivot_index]  
            
            # 2. move all less frequent elements to the left
            store_index = left
            for i in range(left, right):
                if count[unique[i]] &lt; pivot_frequency:
                    unique[store_index], unique[i] = unique[i], unique[store_index]
                    store_index += 1

            # 3. move pivot to its final place
            unique[right], unique[store_index] = unique[store_index], unique[right]  
            
            return store_index
        
        def quickselect(left, right, k_smallest) -&gt; None:
            &quot;&quot;&quot;
            Sort a list within left..right till kth less frequent element
            takes its place. 
            &quot;&quot;&quot;
            # base case: the list contains only one element
            if left == right: 
                return
            
            # select a random pivot_index
            pivot_index = random.randint(left, right)     
                            
            # find the pivot position in a sorted list   
            pivot_index = partition(left, right, pivot_index)
            
            # if the pivot is in its final sorted position
            if k_smallest == pivot_index:
                 return 
            # go left
            elif k_smallest &lt; pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            # go right
            else:
                quickselect(pivot_index + 1, right, k_smallest)
         
        n = len(unique) 
        # kth top frequent element is (n - k)th less frequent.
        # Do a partial sort: from less frequent to the most frequent, till
        # (n - k)th less frequent element takes its place (n - k) in a sorted array. 
        # All element on the left are less frequent.
        # All the elements on the right are more frequent.  
        quickselect(0, n - 1, n - k)
        # Return top k frequent elements
        return unique[n - k:]

#ANSWER
from collections import Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        
        bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: 
            bucket[freq].append(num) 
        flat_list = [item for sublist in bucket for item in sublist]
        return flat_list[::-1][:k]
</code></pre>
<p>答案给出了quick selelct的解法O（n）。但bucket 方法更好。 也是O（n）。</p>
<h1 id="348-design-tic-tac-toe-medium">348. Design Tic-Tac-Toe （Medium）</h1>
<p>Assume the following rules are for the tic-tac-toe game on an n x n board between two players:<br>
A move is guaranteed to be valid and is placed on an empty block.<br>
Once a winning condition is reached, no more moves are allowed.<br>
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.<br>
Implement the TicTacToe class:<br>
TicTacToe(int n) Initializes the object the size of the board n.<br>
int move(int row, int col, int player) Indicates that the player with id player plays at the cell (row, col) of the board. The move is guaranteed to be a valid move.</p>
<pre><code class="language-python">class TicTacToe:

    def __init__(self, n: int):
        self.n=n
        self.rows_p1 = [0]*n
        self.rows_p2 = [0]*n
        self.cols_p1 = [0]*n
        self.cols_p2 = [0]*n
        self.i_plus_j_n_1_p1=0
        self.i_plus_j_n_1_p2=0
        self.i_equal_j_p1=0
        self.i_equal_j_p2=0
                
    def move(self, row: int, col: int, player: int) -&gt; int:
        if player==1:
            self.rows_p1[row]+=1
            if self.rows_p1[row]==self.n: return player
            self.cols_p1[col]+=1
            if self.cols_p1[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p1+=1
                if self.i_plus_j_n_1_p1==self.n: return player
            if row==col:
                self.i_equal_j_p1+=1
                if self.i_equal_j_p1==self.n: return player
        else:
            self.rows_p2[row]+=1
            if self.rows_p2[row]==self.n: return player
            self.cols_p2[col]+=1
            if self.cols_p2[col]==self.n: return player
            if row+col==self.n-1:
                self.i_plus_j_n_1_p2+=1
                if self.i_plus_j_n_1_p2==self.n: return player
            if row==col:
                self.i_equal_j_p2+=1
                if self.i_equal_j_p2==self.n: return player
        
        return 0


</code></pre>
<h1 id="349-intersection-of-two-arrays-easy">349. Intersection of Two Arrays (Easy)</h1>
<p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p>
<pre><code class="language-python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        return list(set(nums1)&amp;set(nums2))
</code></pre>
<p>folowup, solve in O(n) time O(1) space given nums1,nums2 are sorted.</p>
<pre><code class="language-python">def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
    # if the lists are already sorted and you're told to solve in O(n) time and O(1) space:
    nums1.sort() # assume sorted
    nums2.sort() # assume sorted

    # iterate both nums backwards till at least 1 is empty
    # if num2[j] &gt; num1[i], pop num2
    # if num2[j] &lt; num1[i], pop num1
    # if equal and num not last appended to result, append to result and pop both nums
    
    result = []
            
    while nums1 and nums2:
        if nums2[-1] &gt; nums1[-1]:
            nums2.pop()
        elif nums2[-1] &lt; nums1[-1]:
            nums1.pop()
        else:
            # to avoid duplicates
            if not result or (result and nums1[-1] != result[-1]):
                result.append(nums1[-1])
            nums1.pop()
            nums2.pop()

    return result
</code></pre>
<h1 id="350-intersection-of-two-arrays-ii-easy">350. Intersection of Two Arrays II （Easy）</h1>
<p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</p>
<pre><code class="language-python">class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        c1=collections.Counter(nums1)
        c2=collections.Counter(nums2)
        res=[]
        for k in c1:
            if k in c2:
                res.extend([k]*min(c1[k],c2[k]))
        return res

#Bad but save space answer
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1.sort()
        nums2.sort()
        result = []
    
        while nums1 and nums2:
            if nums2[-1] &gt; nums1[-1]:
                nums2.pop()
            elif nums2[-1] &lt; nums1[-1]:
                nums1.pop()
            else:
                result.append(nums1[-1])
                nums1.pop()
                nums2.pop()

        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-06]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-06/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-06/">
        </link>
        <updated>2021-12-06T05:36:37.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorblue331-verify-preorder-serialization-of-a-binary-tree-font"><font color='blue'>331. Verify Preorder Serialization of a Binary Tree </font></h1>
<p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.</p>
<pre><code class="language-python">class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        
        stack = []
        for char in preorder.split(','):
            while char=='#' and stack and stack[-1]=='#':
                if len(stack)&lt;2: return False
                stack.pop()
                stack.pop()
            
            stack.append(char)
        
        return stack==['#']
                
 #ANSWER           
 class Solution:
    def isValidSerialization(self, preorder: str) -&gt; bool:
        # number of available slots
        slots = 1

        for node in preorder.split(','):
            # one node takes one slot
            slots -= 1
            
            # no more slots available
            if slots &lt; 0:
                return False
            
            # non-empty node creates two children slots
            if node != '#':
                slots += 2
        
        # all slots should be used up
        return slots == 0
</code></pre>
<p>没思路初看， 但是用stack解决了， 如果遇到‘X,#,#’ X一定是个leave，出栈，但X本身可能是其他人的child，所以补一个#。  最后如果valid，应该stack为【#】。答案思路没用stack用了计算slot的方法。</p>
<h1 id="font-colorred332-reconstruct-itinerary-hardfont"><font color='red'>332. Reconstruct Itinerary （Hard）</font></h1>
<p>You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.<br>
All of the tickets belong to a man who departs from &quot;JFK&quot;, thus, the itinerary must begin with &quot;JFK&quot;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>
<pre><code class="language-python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
        
        self.visitBitmap=dict()
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
            self.visitBitmap[origin]=[False]*len(itinerary)
        
        self.flights=len(tickets)
        self.result=[]
        route=['JFK']
        self.backtracking('JFK',route)
        return self.result
    
    def backtracking(self,origin,route):
        if len(route)==self.flights+1:
            self.result=route
            return True
        
        for i, nextDest in enumerate(self.flightMap[origin]):
            if not self.visitBitmap[origin][i]:
                self.visitBitmap[origin][i]=True
                ret=self.backtracking(nextDest,route+[nextDest])
                self.visitBitmap[origin][i]=False
                if ret:
                    return True
        return False

#
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        self.flightMap = collections.defaultdict(list)
        for ticket in tickets:
            origin,dest=ticket[0],ticket[1]
            self.flightMap[origin].append(dest)
 
        
        for origin,itinerary in self.flightMap.items():
            itinerary.sort()
         
        self.result=[]
        self.DFS('JFK')
       
        return self.result[::-1]
    
    def DFS(self,origin):
        destList=self.flightMap[origin]
        while destList:
            nextDest=destList.pop(0)
            self.DFS(nextDest)
        self.result.append(origin)
</code></pre>
<p>这个明显是个一笔画问题，不知道答案。。。有两个问题，判断能否是一笔画，怎么能画出一笔画。一笔画算法：<br>
It starts with a random node and then follows an arbitrary unvisited edge to a neighbor. This step is repeated until one returns to the starting node. This yields a first circle in the graph.</p>
<pre><code>If this circle covers all nodes it is an Eulerian cycle and the algorithm is finished. Otherwise, one chooses another node among the cycles' nodes with unvisited edges and constructs another circle, called subtour.
By connecting all the circles in the above process, we build the Eulerian cycle at the end
</code></pre>
<p>答案1：backtracking+greedy  答案2： 在倒序添加一个机场前，必须已经visited 所有这个机场的outgoing edge。否则就是还有路径没有浏览过。 所以算法是postorder DFS</p>
<h1 id="font-colorblue333-largest-bst-subtree-medium-font"><font color='blue'>333. Largest BST Subtree （Medium） </font></h1>
<p>Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -&gt; int:
         
        self.res=0
        
        def isBST(root):
            if not root: 
                return True
            res=[]
            def inorder(root):
                if not root: return 
                inorder(root.left)
                res.append(root.val)
                inorder(root.right)
            inorder(root)
            for i in range(1,len(res)):
                if res[i-1] &gt;= res[i]:
                    return False
            root.size=len(res)
            return True
            
        
        def helper(root):
            if not root: return
            helper(root.left)
            helper(root.right)
            if isBST(root):
                self.res=max(self.res,root.size)  
     
        helper(root)
        return self.res          

</code></pre>
<p>因为要判断isBST，call很多次，自己写的时间复杂度感觉比较大。。。 isBST同时设置了 BST大小，所以call完isBST后直接更新self.res.  看答案思路：答案是preorder 和postorder 。。。 postorder优于preorder，因为没有重复判断isvalidBST. 但需要通知parent node maxleft minright是多少，感觉更繁琐，不如自己的答案。</p>
<h1 id="font-colorred334-increasing-triplet-subsequence-mediumfont"><font color='red'>334. Increasing Triplet Subsequence （Medium）</font></h1>
<p>Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.</p>
<pre><code class="language-python">class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        if len(nums)&lt;3: return False
        
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                 if nums[i]&gt;nums[j]:
                    dp[i]= max(dp[j]+1,dp[i])  
                    if dp[i]&gt;=3: return True
        
        return False


class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        first_num = float(&quot;inf&quot;)
        second_num = float(&quot;inf&quot;)
        for n in nums:
            if n &lt;= first_num:
                first_num = n
            elif n &lt;= second_num:
                second_num = n
            else:
                return True
        return False
</code></pre>
<p>初次尝试用increasing subsequence DP方法， time limit exceeded。。。直接看答案了。。。直接比较难相到这个方法，思路：scan num list。 边scan边保存看到的最小的和次小的数字，如果遇到比这两个数字都大的，那么找到了答案，如果都没有return False。</p>
<h1 id="font-colorred335-self-crossing-hard-font"><font color='red'>335. Self Crossing （Hard） </font></h1>
<p>You are given an array of integers distance.<br>
You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.<br>
Return true if your path crosses itself, and false if it does not.</p>
<pre><code class="language-python">class Solution:
    def isSelfCrossing(self, distance: List[int]) -&gt; bool:
        
        x=distance
        for i in range(3,len(x)):
            
            if i &gt;= 3 and x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]:
                return True
            
            if i &gt;= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] &gt;= x[i - 2]:
                return True
            
            if i &gt;= 5 and x[i - 2] &gt;= x[i - 4] and x[i - 5] + x[i - 1] &gt;= x[i - 3] and x[i - 1] &lt;= x[i - 3] and x[i - 4] + x[i] &gt;= x[i - 2]:
                return True
        
        return False

#GREAT ANSWER
def isSelfCrossing(self, x):
    b = c = d = e = 0
    for a in x:
        if d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c-e &gt;= 0 and f &gt;= d-b):
            return True
        b, c, d, e, f = a, b, c, d, e
    return False
</code></pre>
<p>直接看答案， 只有3种情况会crossing， 第一种包含4条线段 最后一条穿过第一条， 第二种包括5条线段，最后一条嵌入第一条。 第三种包含6条线段，最后一条与第一条十字交叉穿过。</p>
<p>第二种解法：</p>
<pre>
            b                              b
   +----------------+             +----------------+
   |                |             |                |
   |                |             |                | a
 c |                |           c |                |
   |                | a           |                |    f
   +----------->    |             |                | <----+
            d       |             |                |      | e
                    |             |                       |
                                  +-----------------------+
                                               d
</pre>
<h1 id="font-colorred336-palindrome-pairs-hard-font"><font color='red'>336. Palindrome Pairs (Hard) </font></h1>
<p>Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.</p>
<pre><code class="language-python">class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
        res= []
        def isp(w):
            res = [e for e in w]
            return res==res[::-1]
        for i in range(len(words)):
            for j in range(i+1,len(words)):
                if not words[i] or not words[j] or words[i][0]==words[j][-1]:
                    if isp(words[i]+words[j]):
                        res.append([i,j])
                if not words[i] or not words[j] or words[j][0]==words[i][-1]:
                    if isp(words[j]+words[i]):
                        res.append([j,i])
        return res
#answer                  
class Solution:
    def palindromePairs(self, words: List[str]) -&gt; List[List[int]]:
      
        def all_valid_prefixes(word):
            valid_prefixes = []
            for i in range(len(word)):
                if word[i:] == word[i:][::-1]:
                    valid_prefixes.append(word[:i])
            return valid_prefixes

        def all_valid_suffixes(word):
            valid_suffixes = []
            for i in range(len(word)):
                if word[:i+1] == word[:i+1][::-1]:
                    valid_suffixes.append(word[i + 1:])
            return valid_suffixes

        word_lookup = {word: i for i, word in enumerate(words)}
        solutions = []

        for word_index, word in enumerate(words):
            reversed_word = word[::-1]

            # Build solutions of case #1. This word will be word 1.
            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:
                solutions.append([word_index, word_lookup[reversed_word]])

            # Build solutions of case #2. This word will be word 2.
            for suffix in all_valid_suffixes(word):
                reversed_suffix = suffix[::-1]
                if reversed_suffix in word_lookup:
                    solutions.append([word_lookup[reversed_suffix], word_index])

            # Build solutions of case #3. This word will be word 1.
            for prefix in all_valid_prefixes(word):
                reversed_prefix = prefix[::-1]
                if reversed_prefix in word_lookup:
                    solutions.append([word_index, word_lookup[reversed_prefix]])

        return solutions
#ANSWER TRIE

class TrieNode:
    def __init__(self):
        self.next = collections.defaultdict(TrieNode)
        self.ending_word = -1
        self.palindrome_suffixes = []

class Solution:
    def palindromePairs(self, words):

        # Create the Trie and add the reverses of all the words.
        trie = TrieNode()
        for i, word in enumerate(words):
            word = word[::-1] # We want to insert the reverse.
            current_level = trie
            for j, c in enumerate(word):
                # Check if remainder of word is a palindrome.
                if word[j:] == word[j:][::-1]:# Is the word the same as its reverse?
                    current_level.palindrome_suffixes.append(i)
                # Move down the trie.
                current_level = current_level.next[c]
            current_level.ending_word = i

        # Look up each word in the Trie and find palindrome pairs.
        solutions = []
        for i, word in enumerate(words):
            current_level = trie
            for j, c in enumerate(word):
                # Check for case 3.
                if current_level.ending_word != -1:
                    if word[j:] == word[j:][::-1]: # Is the word the same as its reverse?
                        solutions.append([i, current_level.ending_word])
                if c not in current_level.next:
                    break
                current_level = current_level.next[c]
            else: # Case 1 and 2 only come up if whole word was iterated.
                # Check for case 1.
                if current_level.ending_word != -1 and current_level.ending_word != i:
                    solutions.append([i, current_level.ending_word])
                # Check for case 2.
                for j in current_level.palindrome_suffixes:
                    solutions.append([i, j])
        return solutions
</code></pre>
<p>初次尝试，time limit exceeded。 基本暴力解，无优化。如何优化？  感觉是用Trie。。。看答案了。思路1： 三种情况，1）word本身是palindrome，2）AB_PALINDROME     BA  找到第一个词所有满足第一个pattern的prefix，然后找prefix[::-1]  3)    BA    PALINDROM_AB,找第二个词所有满足第二个patern的suffix，然后找suffix[::-1]<br>
思路2： Trie， case1） CAT TAC     case2）  CAT   PALINDROME_TAC case3） CAT_PALINDROME  TAC.     只有在扫过所有word1字符情况都不break情况下才会再检查case1和2. 逆序在tire保存word和保存满足palindrome suffix的word ids是简化算法的关键。</p>
<h1 id="337-house-robber-iii-medium">337. House Robber III （Medium）</h1>
<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.<br>
Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.<br>
Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -&gt; int:
        # root.val =  root.left_rob+root.right.rob                         1)rob2child
        # root.val =  root.left_norob + root.right.norob + root.val        2)rob root no rob child
        # root.val = root.left/right.rob   root.right/left.norob      3) rob one of child norob root
        
    
        #postorder transversal  add two value, rob  norob
        
        def helper(root):
            if not root: return 
            helper(root.left)
            helper(root.right)
            
            #processing leaves
            if not root.left and not root.right:
                root.rob=root.val
                root.norob=0
            
            #if decide rob root:
            root_left_max = root.left.norob if root.left else 0
            root_right_max= root.right.norob if root.right else 0
            root.rob = root.val + root_left_max + root_right_max
            #if decide norob root:
            root_left_max =max([root.left.norob,root.left.rob]) if root.left else 0
            root_right_max= max([root.right.norob,root.right.rob]) if root.right else 0
            root.norob = root_left_max + root_right_max
        
        helper(root)
        return max([root.rob,root.norob])


#ANSWER
class Solution:
    def rob(self, root: TreeNode) -&gt; int:
        def helper(node):
            # return [rob this node, not rob this node]
            if not node:
                return (0, 0)
            left = helper(node.left)
            right = helper(node.right)
            # if we rob this node, we cannot rob its children
            rob = node.val + left[1] + right[1]
            # else we could choose to either rob its children or not
            not_rob = max(left) + max(right)
            return [rob, not_rob]

        return max(helper(root))
</code></pre>
<h1 id="338-counting-bits-easy">338. Counting Bits (Easy)</h1>
<p>Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1's in the binary representation of i.</p>
<pre><code class="language-python">class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        if n==0: return [0]
        if n==1: return [0,1]
        cur=[0,1]
        while len(cur)&lt;=n:
            cur = cur+[1+e for e in cur]
        return cur[:n+1]
        
#ANSWER
class Solution:
    def countBits(self, n: int) -&gt; List[int]:
        ans = [0] * (n + 1)
        for x in range(1, n + 1):
            ans[x] = ans[x &amp; (x - 1)] + 1
        return ans 

</code></pre>
<p>答案更优雅，x&amp;x-1 得到去掉最后一个significant bit的数字  X&gt; X&amp;(X-1) 然后从1遍历到n用dp。</p>
<h1 id="339-nested-list-weight-sum-medium">339. Nested List Weight Sum （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.<br>
Return the sum of each integer in nestedList multiplied by its depth.</p>
<pre><code class="language-python">
class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -&gt; int:
        def helper(nestli,level):
            res=0
            for nl in nestli:
                if nl.isInteger():
                    res+=nl.getInteger() * level
                else:
                    res+=helper(nl.getList(),level+1)
            
            return res
        return helper(nestedList,1)
</code></pre>
<h1 id="font-colorblue340-longest-substring-with-at-most-k-distinct-characters-medium-font"><font color='blue'>340. Longest Substring with At Most K Distinct Characters (Medium) </font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        #  e c e b a  a a a a a a c d a a 
        # two pointer
        #   
        dic=dict()
        start=0
        res=0
        for j,char in enumerate(s):
            #process over k case
            if dic and char not in dic and len(dic)==k:
                while len(dic)==k:
                    dic[s[start]]-=1
                    if dic[s[start]]==0:
                        del dic[s[start]]
                    start+=1
            
            elif char in dic and len(dic)&lt;=k:
                res=max(res,j-start+1)
            
            
            elif len(dic)&lt;k:
                res+=1
        
            
            dic[char]=dic.get(char,0)+1
        
        return res



#ANSWER
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        n = len(s)
        if n * k == 0:
            return 0

        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -&gt; its rightmost position
        # in the sliding window
        hashmap = defaultdict()

        max_len = 1

        while right &lt; n:
            # add new character and move right pointer
            hashmap[s[right]] = right
            right += 1

            if len(hashmap) == k + 1:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len
</code></pre>
<p>典型的two pointer 写的磕磕绊绊 但写出来了。。。dic存放window中遇到字符的个数，  case1）如果目前dic有内容而且当前char不在dic而且window已经达到容量，start得向前移动，每前进一位，dic中s【start】数目减少一个，如果减少到0需要删除key。 退出while循环现在len（dic）小于k，后续这个不在dic中的char会加入dic。 case2）char in dic and len（dic）小于等于k，直接算结果 case3） len（dic）小于k，res+1.  答案方法思路也差不多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-05]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-05/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-05/">
        </link>
        <updated>2021-12-05T10:46:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred321-create-maximum-number-hard-font"><font color='red'>321. Create Maximum Number (Hard) </font></h1>
<p>You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.<br>
Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.<br>
Return an array of the k digits representing the answer.<br>
Example<br>
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5<br>
Output: [9,8,6,5,3]</p>
<pre><code class="language-python">class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[int]:
        # 思路。。。
        # 最大需要每个位置数字最大，
        # 但选择最大的数字有顺序约束
        # 而且当可选最大数字相同时，需要程序tracking 2种不同结果。
        

        def prep(nums, k):
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] &lt; num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            return [max(a, b).pop(0) for _ in a+b]

        return max(merge(prep(nums1, i), prep(nums2, k-i))  for i in range(k+1)   if i &lt;= len(nums1) and k-i &lt;= len(nums2))

</code></pre>
<p>没思路。。。看到答案用了greedy方法。。。  prep function只是在一个数组中按照顺序找出K个最大的数。先算一下需要drop多少个数， 如果当前值大于栈顶元素，说明需要更新栈顶。  merge function这一步是按照a，b的lexcial顺序找到最大的元素，a+b总共有K个元素，所以pop k次。 最后return所有K+1个分割可能产生的结果取最大的。基本不可能现想出来解法。</p>
<h1 id="322-coin-change-medium">322. Coin Change （Medium）</h1>
<p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.<br>
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.<br>
You may assume that you have an infinite number of each kind of coin.</p>
<pre><code class="language-python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        if amount==0: return 0 if coins else -1
        dp = dict()
        for c in coins:
            dp[c]=1
        for a in range(1,amount+1):
            for c in coins:
                if a+c&lt;=amount and a in dp:
                    if a+c in dp:
                        dp[a+c]=min(dp[a+c],dp[a]+1) 
                    else:
                        dp[a+c]=dp[a]+1
        return dp[amount] if   amount in dp else -1

#ANSWER
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
</code></pre>
<p>感觉是个DP问题，递归关系？  dp【i】是需要达到amount i需要的次数。 初始coins值的dp【coins_val】=1.   对于每一个有dp值的位置，都用coints_val 更新， dp【i+val】=min（dp【i+val】，dp【i】+1）直到amount。 由于不能开过大内存，所以dp变成dict。<br>
答案写法更标准， dp【x】=min（dp【x】，dp【x-coin】+1） x大于等于coin小于等于amount。</p>
<h1 id="323-number-of-connected-components-in-an-undirected-graph-medium">323. Number of Connected Components in an Undirected Graph （Medium）</h1>
<p>You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.<br>
Return the number of connected components in the graph.</p>
<pre><code class="language-python">class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        #  BFS
        neis = collections.defaultdict(list)
        for edge in edges:
            neis[edge[0]].append(edge[1])
            neis[edge[1]].append(edge[0])
        
        
        res=0
        visited=set()
        while len(visited)!=n:
            res+=1
            for i in range(n):
                if i not in visited:
                    visited.add(i)
                    q=[i]
                    break     
            while q:
                l=len(q)
                for _ in range(l):
                    cur=q.pop(0)
                    for nei in neis[cur]:
                        if nei not in visited:
                            visited.add(nei)
                            q.append(nei)
        return res
#UNIONFIND
class Solution:
    
    class UnionFind:
        def __init__(self,n):
            self.parent=[i for i in range(n)]
            self.rank=[0]*n
            self.n=n
        def find(self,x):
            if x!=self.parent[x]:
                self.parent[x]=self.find(self.parent[x])
            return self.parent[x]
        
        def union(self,x,y):
            px=self.find(x)
            py=self.find(y)
            if px!=py:
                self.n-=1
                if self.rank[px]&lt;self.rank[py]:
                    self.parent[px]=py
                elif self.rank[px]&gt;self.rank[py]:
                    self.parent[py]=px
                else:
                    self.parent[py]=px
                    self.rank[px]+=1
                    
    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:
        uf=self.UnionFind(n)
        for edge in edges:
            uf.union(*edge)
        return uf.n

</code></pre>
<p>注意unionfind中   if x!=self.parent[x]   爸爸=找爸爸（爸爸）  self.parent[x]=self.find(self.parent[x])， union只有rank相同时候才需要+rank。</p>
<h1 id="font-colorred324-wiggle-sort-ii-mediumfont"><font color='red'>324. Wiggle Sort II （Medium）</font></h1>
<p>Given an integer array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....<br>
You may assume the input array always has a valid answer.</p>
<pre><code class="language-python">     def wiggleSort(self, nums):
        count = [0]*5001
        
        for n in nums:
            count[n]+=1
        
        odd = 1
        even = 0
        for n in range(5000,-1,-1):
            if odd &gt;= len(nums) and even &gt;= len(nums):
                break
                
            if count[n] == 0:
                continue
            
            while count[n] and (odd &lt; len(nums) or even &lt; len(nums)):
                count[n]-=1
                if odd &lt; len(nums):
                    nums[odd] = n
                    odd+=2
                else:
                    nums[even] = n
                    even+=2
        
 class Solution(object):
    def wiggleSort(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
      
        arr = sorted(nums)
        for i in range(1, len(nums), 2): nums[i] = arr.pop() 
        for i in range(0, len(nums), 2): nums[i] = arr.pop() 

class Solution:
    def wiggleSort(self, A: List[int]) -&gt; None:        
        N = len(A)                    
        count = [0] * 5001        
        self.curr_val = A[0]
        
        for v in A:
            count[v] += 1
            self.curr_val = max(self.curr_val, v)
        
        def next_val():
            while count[self.curr_val] == 0: self.curr_val -= 1            
            count[self.curr_val] -= 1
            return self.curr_val
                            
        for i in range(1, N, 2): A[i] = next_val()     
        for i in range(0, N, 2): A[i] = next_val() 
</code></pre>
<p>思路：从sorted 最大到最小，奇数位置放置，然后偶数位置放置数字。时间要降低到O（n）只能用count sort了。</p>
<h1 id="font-colorred325-maximum-size-subarray-sum-equals-k-mediumfont"><font color='red'>325. Maximum Size Subarray Sum Equals k （Medium）</font></h1>
<p>Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.</p>
<pre><code class="language-python">class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:
        
        prefix_sum = 0 
        res = 0
        indices = dict()
        
        for i,n in enumerate(nums):
            prefix_sum+=n
            
            if prefix_sum==k:
                res=i+1
            
            if prefix_sum-k in indices:
                res=max(res,i-indices[prefix_sum-k])
            
            if prefix_sum not in indices:
                indices[prefix_sum]=i
        
        return res

</code></pre>
<p>没思路，直接看答案了。看错题目了，题目是subarray。。。是连续的字符串，并不是sublist。。。。<br>
思路：用到了prefix sum和 two sum的解法。 因为是subarray，prefix【j】-prefix【i】==k 就是一个答案。  具体扫predix过程借鉴two sum，在predix-k在 dict中，更新res。 不在dict中，更新dict。 不能无条件更新dict，因为prefix在dict中与之间prefix重复，应该保留更早的index使长度更长。</p>
<h1 id="326-power-of-three-easy">326. Power of Three （Easy）</h1>
<p>Given an integer n, return true if it is a power of three. Otherwise, return false.<br>
An integer n is a power of three, if there exists an integer x such that n == 3x.</p>
<pre><code class="language-python">class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n==0: return False
        while n:
            if n==1: return True
            if n%3!=0:
                return False
            n//=3
        return True

class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n&lt;1: return False
        while n%3==0:
            n//=3
            
        return n==1
</code></pre>
<h1 id="font-colorred327-count-of-range-sum-hard-font"><font color='red'>327. Count of Range Sum (Hard) </font></h1>
<p>Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.<br>
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i &lt;= j.</p>
<pre><code class="language-python">class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        presum = [0]*(len(nums)+1)
        for i,n in enumerate(nums):
            presum[i+1]=presum[i]+n
        
        res=0
        for i in range(1,len(nums)+1):
            for j in range(i):
                if upper&gt;=presum[i]-presum[j]&gt;=lower:
                    res+=1
        return res
#ANSWER 1 PrefixSum+MergeSort
class Solution:
    def countRangeSum(self, nums, lower, upper):
        cumsum = [0]*(len(nums)+1)
        for i,num in enumerate(nums):
            cumsum[i+1]=cumsum[i]+num
        def sort(lo, hi):
            mid = (lo + hi) // 2
            if mid == lo:
                return 0
            count = sort(lo, mid) + sort(mid, hi)
            i = j = mid
            for left in cumsum[lo:mid]:
                while i &lt; hi and cumsum[i] - left &lt;  lower: i += 1
                while j &lt; hi and cumsum[j] - left &lt;= upper: j += 1
                count += j - i
            cumsum[lo:hi] = sorted(cumsum[lo:hi])
            return count
        return sort(0, len(cumsum))


#ANSER Binary Indexed Tree + Binary Search
class BinaryIndexedTree:
    
    def __init__(self, n):
        self.n = n
        self.tree = [0 for _ in range(n+1)]
    
    def update(self, idx, val):
        while idx &lt;= self.n:
            self.tree[idx] += val
            idx += idx &amp; -idx
    
    def query(self, idx):
        total = 0
        while idx &gt; 0:
            total += self.tree[idx]
            idx -= idx &amp; -idx
        return total

    
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:
        n, prefixes = len(nums), list(itertools.accumulate(nums))
        
        sortedPrefixes = sorted(set(prefixes))
        ranks = { prefix: idx + 1 for idx, prefix in enumerate(sortedPrefixes) }
        
        ds = BinaryIndexedTree(len(sortedPrefixes))
        for prefix in prefixes:
            ds.update(ranks[prefix], 1)
        
        res = 0
        processed = 0
        for prefix in prefixes:
            l = bisect.bisect_left(sortedPrefixes, lower + processed)
            r = bisect.bisect_right(sortedPrefixes, upper + processed)  
            res += ds.query(r) - ds.query(l)
            ds.update(ranks[prefix], -1)
            processed = prefix
        
        return res
</code></pre>
<p>首次尝试O（n^2）time limit exccded。  看来得低于O（n^2）才可以。。。改进方法是增加mergesort。 思路：先算cumsum。 目标找出cumsum【right】-cumsum【left】在upper lower 之间的这样的pair个数。 定义helper function merge sort。 返回值是满足条件的个数，先递归找出只在lo<sub>mid和mid</sub>hi之间的个数。若left~right横跨mid， 对于每一个left in sumsum【lo：mid】 找出满足upper lower bond的 right。其中满足lower bound的index 是i， 满足upper bound 的index 是j 所以 count+=j-i。<br>
又忘记了有segment tree 和binary indexed tree这两种数据结构。。。。</p>
<h1 id="328-odd-even-linked-list-medium">328. Odd Even Linked List (Medium)</h1>
<p>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.<br>
The first node is considered odd, and the second node is even, and so on.<br>
Note that the relative order inside both the even and odd groups should remain as it was in the input.<br>
You must solve the problem in O(1) extra space complexity and O(n) time complexity.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if not head: return head
        odd_head=head
        even_head=head.next
        
        cur=head
        odd_tail=None
        c=0
        while cur:
            curnext=cur.next
            c+=1
            if c%2==1:
                #cur is odd node
                cur.next=cur.next.next if cur.next else None
                odd_tail=cur
            else:
                #cur is even node
                cur.next=cur.next.next if cur.next else None
            
            cur=curnext
        
        if odd_tail:
            odd_tail.next=even_head
        
        return odd_head


#ANSWER 
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        
        if not head: return head
        
        odd  = head
        even = head.next
        evenhead = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        return head
</code></pre>
<h1 id="font-colorred329-longest-increasing-path-in-a-matrix-hard-font"><font color='red'>329. Longest Increasing Path in a Matrix (Hard) </font></h1>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.<br>
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<pre><code class="language-python">class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int:
        dirs = [[0,1],[1,0],[0,-1],[-1,0]]
        m=len(matrix)
        n=len(matrix[0])
        if not matrix: return 0
        cache= [[0]*n for _ in range(m)]
        res=0
        
        def dfs(i,j):
            if cache[i][j]!=0: return cache[i][j]
            for d in dirs:
                x=i+d[0]
                y=j+d[1]
                if m&gt;x&gt;=0 and n&gt;y&gt;=0 and matrix[x][y]&gt;matrix[i][j]:
                    cache[i][j]=max(cache[i][j],dfs(x,y))
            
            cache[i][j]+=1
            return cache[i][j] 
        
        
        for i in range(m):
            for j in range(n):
                res=max(res,dfs(i,j))
                
        return res
</code></pre>
<p>DFS+mem  太晚了直接看答案了。。。因为是strictly increasing path 所以是DAG，所以dfs（i，j） path length 是可以用mem记住的。 但通常的DFS是不能用mem的。</p>
<h1 id="font-colorred330-patching-array-hardfont"><font color='red'>330. Patching Array （Hard）</font></h1>
<p>Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.<br>
Return the minimum number of patches required.</p>
<pre><code class="language-python">class Solution:
    def minPatches(self, nums: List[int], n: int) -&gt; int:
        
        '''Initialize the range [1, miss) = [1, 1) = empty
        While n is not covered yet
            if the current element nums[i] is less than or equal to miss
                extends the range to [1, miss + nums[i])
                increase i by 1
            otherwise
                patch the array with miss, extends the range to [1, miss + miss)
                increase the number of patches
        Return the number of patches
        '''
        
        patches=0
        i=0
        miss=1
        while miss&lt;=n:
            if i&lt;len(nums) and nums[i]&lt;=miss:
                #miss is covered
                miss+=nums[i]
                i+=1
            else:
                #patch miss to aray
                miss+=miss
                patches+=1
        return patches

</code></pre>
<p>太晚没思路直接看答案， 答案思路：假设miss 是最小的missing number， 但我们知道【1，miss） 已经covered。 要cover miss，需要添加小于等于miss的数字。<br>
假设我们添加的数字是x，那么区间【1，miss） 【x，x+miss）都covered。由于x小于等于miss。 所以两个区间可以合并为【1，x+miss）我们想选一个range cover最大的x，显然当x=miss时候区间最大。所以算法是：<br>
初始化区间【1，miss）=【1，1）<br>
当n还没covered，如果 nums【i】小于等于miss，增加区间为【1，miss+nums【i】），i++ 否则， 数组里添加miss， 增加区间为【1，miss+miss), res+=1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-04]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-04/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-04/">
        </link>
        <updated>2021-12-04T13:17:02.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="311-sparse-matrix-multiplication-medium">311. Sparse Matrix Multiplication (Medium)</h1>
<p>Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.</p>
<pre><code class="language-python">class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -&gt; List[List[int]]:
        l=len(mat1)
        m=len(mat1[0])
        n=len(mat2[0])
        #1m*mn = ln
        res = [[0]*n for _ in range(l)]
        
        for i in range(l):
            for j in range(n):
                for k in range(m):
                    res[i][j]+=mat1[i][k]*mat2[k][j]
        return res
</code></pre>
<p>因为题目是sparse table 所以更好的做饭是把table 存成hashmap。</p>
<h1 id="font-colorred312-burst-balloons-hardfont"><font color='red'>312. Burst Balloons （Hard）</font></h1>
<p>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.<br>
If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.<br>
Return the maximum coins you can collect by bursting the balloons wisely</p>
<pre><code class="language-python">#TIME LIMIT EXCCEEDED.
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int:
        res = []
        def bt(nums,val):
            if not nums:
                res.append(val)
            for i,n in enumerate(nums):
                new_nums = nums[:i]+nums[i+1:]
                a = nums[i-1] if i-1&gt;=0 else 1
                b= n
                c= nums[i+1] if i+1&lt;len(nums) else 1
                bt(new_nums,val+a*b*c)
        
        
        bt(nums,0)
        #print(res)
        return max(res) if res else 1

#ANSWER 1
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int: 
        #ith is the last to burst
        nums = [1]+nums+[1]
        @lru_cache(None)
        def dp(left,right):
            if left&gt;right: return 0
            res=0
            for i in range(left,right+1):
                gain=nums[left-1]*nums[i]*nums[right+1]
                remaining=dp(left,i-1)+dp(i+1,right)
                res=max(res,gain+remaining)
            return res
  
        
        return dp(1,len(nums)-2)

#
class Solution:
    def maxCoins(self, nums: List[int]) -&gt; int: 
        #ith is the last to burst
        nums = [1]+nums+[1]
        n=len(nums)
        dp=[[0]*n for _ in range(n)]
        for left in range(n-2,0,-1):
            for right in range(left,n-1):
                for i in range(left,right+1):
                    gain=nums[left-1]*nums[i]*nums[right+1]
                    remaining=dp[left][i-1]+dp[i+1][right]
                    dp[left][right]=max(dp[left][right],gain+remaining)
        return dp[1][n-2]
</code></pre>
<p>初次尝试，backtraking 方法会time limit exceeded， 需要更优方法。 答案1） top down dp， ith气球是最后一个burst的，所以left到i-1，i+1到right先burst。 思路是分治法，能拆分为互相不干扰的left，right部分是因为ith定义是最后一个burst，要ith定义是先burst，就会出现left，right部分dependent关系，right部分数值取决于left最右一个气球是否burst。所以定义ith气球最后一个burst是很聪明的解决了分治法左右depenent问题。2）Bottom-Up dp 算 dp【left】【right】必须知道dp【left】【i-1】和dp【i+1】【right】 i在left right之间，所以dp更新路线是从右下角zigzag更新。</p>
<h1 id="font-colorred313-super-ugly-number-mediumfont"><font color='red'>313. Super Ugly Number （Medium）</font></h1>
<p>A super ugly number is a positive integer whose prime factors are in the array primes.<br>
Given an integer n and an array of integers primes, return the nth super ugly number.<br>
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.</p>
<pre><code class="language-python">class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:
        dp = [0]*n
        t = [0]*len(primes)
        dp[0]=1
        for i in range(1,n):
            dp[i]=min(dp[t[ii]]*primes[ii] for ii in range(len(primes)))
            for j in range(len(primes)):
                if dp[i]==dp[t[j]]*primes[j]:
                    t[j]+=1
        return dp[-1]
 
        
        # dp = [0] * n
        # t2 = t3 = t5 = 0
        # dp[0] = 1
        # for i in range(1,n):
        #     dp[i] = min(dp[t2]*2,dp[t3]*3,dp[t5]*5)
        #     if(dp[i] == dp[t2]*2): t2 += 1
        #     if(dp[i] == dp[t3]*3): t3 += 1
        #     if(dp[i] == dp[t5]*5): t5 += 1
        # return dp[-1]
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:
 
        dp=[1]
        res=1
        s=set()
        for _ in range(n):
            while res in s:
                res = heapq.heappop(dp)
            s.add(res)
            for p in primes:
                heapq.heappush(dp,res*p)
        return res
 
#ANSWER
 class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int:

        uglies = [1]
        def gen(prime):
            for ugly in uglies:
                yield ugly * prime
        merged = heapq.merge(*map(gen, primes))
        while len(uglies) &lt; n:
            ugly = next(merged)
            if ugly != uglies[-1]:
                uglies.append(ugly)
        return uglies[-1]
</code></pre>
<p>仿照ugly unmber II 写出一个dp的解但time limit excceded。   用heapq还是time limit excceded。 这个题目python不友好， 答案用了generator。</p>
<h1 id="314-binary-tree-vertical-order-traversal-medium">314. Binary Tree Vertical Order Traversal （Medium）</h1>
<p>Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column).<br>
If two nodes are in the same row and column, the order should be from left to right.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        dic = dict()
        def pre(root,level,hight):
            hight+=1
            if not root: return 
            if level not in dic:
                dic[level]=[]
            dic[level].append((root.val,hight))
            pre(root.left,level-1,hight) 
            pre(root.right,level+1,hight)
        pre(root,0,0)
        res= [ [val[0] for val in sorted(v,key=lambda x:x[1])] for k,v in  sorted(dic.items(),key=lambda x:x[0])]
        return res

</code></pre>
<p>记录左右移动同时记录上下移动。</p>
<h1 id="font-colorred-315-count-of-smaller-numbers-after-self-hardfont"><font color='red'> 315. Count of Smaller Numbers After Self （Hard）</font></h1>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].<br>
Input: nums = [5,2,6,1]<br>
Output: [2,1,1,0]<br>
Explanation:<br>
To the right of 5 there are 2 smaller elements (2 and 1).<br>
To the right of 2 there is only 1 smaller element (1).<br>
To the right of 6 there is 1 smaller element (1).<br>
To the right of 1 there is 0 smaller element.</p>
<pre><code class="language-python">class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
        #   5  2   6   1
        #
        #   0 1 2 3 4 5 6
        #     1 1     1 1
        #
        #  找出 i-1 到 -inf 的cumsum ，而且update 从右往左。
        #  -OFFSET ~0 ~ OFFSET
        
        OFFSET=10000
        size=2 * OFFSET+1  
        tree=[0]*(2*size)
        
        #####
        #   1
        # 2   3
        #4 5 6 7
        # 1 2 3 4 5 6 7
       
                    
            
        def update(ind):
            tree[ind]+=1
           
            while ind&gt;0:
                left=ind
                right=ind
                if ind%2==0:
                    right+=1
                else:
                    left-=1
                if ind//2&gt;0:
                    tree[ind//2]=tree[left]+tree[right]
                ind//=2
                
        def query(left,right):
            res=0
            while left&lt;=right:
                if right%2==0:
                    res+=tree[right]
                    right-=1
                if left%2==1:
                    res+=tree[left]
                    left+=1

                left//=2
                right//=2
    
            return res
                    
        ans = []
        for num in nums[::-1]:
            ind = num+OFFSET+size 
            ans.append(query(size,ind-1))
            update(ind)
             
            
        return ans[::-1]


#ANSWER 2
class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
 
        OFFSET=10000
        size=2 * OFFSET+1 + 1 #total possible values in nums plus one dummy 
        tree=[0]*size
        ans = []
            
        def update(ind):
            ind=ind+1   #index in BIT is 1 more than original index
            while ind&lt;size:
                tree[ind]+=1
                ind+= ind&amp;-ind
        def query(ind):
            ind=ind+ 1  #index in BIT is 1 more than original index
            res=0
            while ind&gt;0:
                res+=tree[ind]
                ind-= ind&amp;-ind
            return res
           
          
        ans = []
        for num in nums[::-1]:
            ind = num+OFFSET
            ans.append(query(ind-1))
            update(ind)
             
            
        return ans[::-1]
    
#ANSWER3
class Solution:
    def countSmaller(self, nums: List[int]) -&gt; List[int]:    
        def sort(enum):
            half = len(enum) // 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                m, n = len(left), len(right)
                i = j = 0
                while i &lt; m or j &lt; n:
                    if j == n or i &lt; m and left[i][1] &lt;= right[j][1]:
                        enum[i+j] = left[i]
                        smaller[left[i][0]] += j
                        i += 1
                    else:
                        enum[i+j] = right[j]
                        j += 1
            return enum
        smaller = [0] * len(nums)
        sort(list(enumerate(nums)))
        return smaller
 

</code></pre>
<p>错误以为用stack可以解决~~，答案方法1）Segment Tree 2）Binary index Tree 3)Merge Sort,当选取左边元素，记录 smaller[left[i][0]] += j  ；  left【i】【0】是左边元素在原始数组种的index， j是right中未被选中元素的index，恰巧是小于左边被选中元素的在右边需要变换位置元素的长度。</p>
<h1 id="font-colorred316-remove-duplicate-letters-mediumfont"><font color='red'>316. Remove Duplicate Letters （Medium）</font></h1>
<p>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.<br>
Example 1:<br>
Input: s = &quot;bcabc&quot;<br>
Output: &quot;abc&quot;<br>
Example 2:<br>
Input: s = &quot;cbacdcbc&quot;<br>
Output: &quot;acdb&quot;</p>
<pre><code class="language-python">class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        # maintain smalleset lexicographical order How?
        
        # find pos - the index of the leftmost letter in our solution
        # we create a counter and end the iteration once the suffix doesn't have each unique character
        # pos will be the index of the smallest character we encounter before the iteration ends
        c=Counter(s)
        pos=0
        for i in range(len(s)):
            if s[i]&lt;s[pos]:
                pos=i
            c[s[i]]-=1
            if c[s[i]]==0:
                break
        return s[pos]+self.removeDuplicateLetters(s[pos:].replace(s[pos],&quot;&quot;)) if s  else ''

#ANSWER
class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        stack=[]
        seen=set()
        last_occurrence = {c:i for i,c in enumerate(s)}
        for i,c in enumerate(s):
            if c not in seen:
                #只有c不在seen中才能试图在stack中加c
                while stack and c&lt;stack[-1] and i&lt;last_occurrence[stack[-1]]:  
                    # 如果当前试图加入的c&lt;stack[-1] 而且 c的位置&lt; stack[-1]最后出现位置
                    # 可以安全移除stack【-1】
                    val=stack.pop()
                    seen.discard(val)
                    
                seen.add(c)
                stack.append(c)
                
        return ''.join(stack)
</code></pre>
<p>思路1） 找到第一个qualify的pos，s【i】小于s【pos】需要更新pos成i，当counter s【i】==0时候说明s【i】是当前必须加入结果的字符，然后找下一个字符用recursive方法。<br>
思路2）  见代码 Greedy 方法的应用</p>
<h1 id="font-colorred317-shortest-distance-from-all-buildings-hard-font"><font color='red'>317. Shortest Distance from All Buildings （Hard） </font></h1>
<p>You are given an m x n grid grid of values 0, 1, or 2, where:<br>
each 0 marks an empty land that you can pass by freely,<br>
each 1 marks a building that you cannot pass through, and<br>
each 2 marks an obstacle that you cannot pass through.<br>
You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.<br>
Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.</p>
<pre><code class="language-python">#METHOD 1 BFS from Biulding
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&gt; int:
        
        
        #Use hit to record how many times a 0 grid has been reached and use distSum to record the sum of distance from all 1 grids to this 0 grid. A powerful pruning is that during the BFS we use count1 to count how many 1 grids we reached. If count1 &lt; buildings then we know not all 1 grids are connected are we can return -1 immediately, which greatly improved speed (beat 100% submissions).

 
        if not grid or not grid[0]: return -1
        M, N, buildings = len(grid), len(grid[0]), sum(val for line in grid for val in line if val == 1)
        hit, distSum = [[0] * N for i in range(M)], [[0] * N for i in range(M)]

        def BFS(start_x, start_y):
            visited = [[False] * N for k in range(M)]
            visited[start_x][start_y], count1, queue = True, 1, collections.deque([(start_x, start_y, 0)])
            while queue:
                x, y, dist = queue.popleft()
                for i, j in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if 0 &lt;= i &lt; M and 0 &lt;= j &lt; N and not visited[i][j]:
                        visited[i][j] = True
                        if not grid[i][j]:
                            queue.append((i, j, dist + 1))
                            hit[i][j] += 1
                            distSum[i][j] += dist + 1
                        elif grid[i][j] == 1:
                            count1 += 1
            return count1 == buildings  

        for x in range(M):
            for y in range(N):
                if grid[x][y] == 1:
                    if not BFS(x, y): return -1
        return min([distSum[i][j] for i in range(M) for j in range(N) if not grid[i][j] and hit[i][j] == buildings] or [-1])
    

#METHOD 2 BFS from Empty space
class Solution:
    def shortestDistance(self, grid: List[List[int]]) -&gt; int:
        M=len(grid)
        N=len(grid[0])
        totalHouses = sum([v for row in grid for v in row if v==1])
        minDistance=float('inf')
        def bfs(row,col):
            distanceSum=0
            housesReached=0
            visited =[[False]*N for _ in range(M)]
            q=collections.deque()
            q.append((row,col))
            step=0
            while q and housesReached!=totalHouses:
                l=len(q)
                for _ in range(l):
                    row,col=q.popleft()
                    
                    if grid[row][col]==1:
                        distanceSum+=step
                        housesReached+=1
                        continue
                    
                    for new_row,new_col in [(row+1,col),(row-1,col),(row,col+1),(row,col-1)]:
                        if M&gt;new_row&gt;=0 and N&gt;new_col&gt;=0:
                            if not visited[new_row][new_col] and grid[new_row][new_col]!=2:
                                visited[new_row][new_col]=True
                                q.append((new_row,new_col))
                                
                step+=1
            
            if housesReached!=totalHouses:
                for row in  range(M):
                    for col in range(N):
                        if grid[row][col]==0 and visited[row][col]:
                            grid[row][col]=2
                
                return float('inf')
            return distanceSum
        
        
        
        #main
        for row in range(M):
            for col in range(N):
                if grid[row][col]==0:
                    minDistance=min(minDistance,bfs(row,col))
        
        if minDistance==float('inf'):
            return -1
        return minDistance         

</code></pre>
<p>直接看答案了。。。。方法一更好点， 从building处做BFS，保存hits数目。BFS返回count1==#Buildings 这样可以提前截断如果存在不能完全到达所有building情况。</p>
<h1 id="318-maximum-product-of-word-lengths-medium">318. Maximum Product of Word Lengths （Medium）</h1>
<p>Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.</p>
<pre><code class="language-python">class Solution:
    def maxProduct(self, words: List[str]) -&gt; int:
        ss  = [set() for _ in range(len(words))]
        for i,word in enumerate(words):
            for w in word:
                ss[i].add(w)
        res=float('-inf')
        for i in range(len(words)-1):
            for j in range(i+1,len(words)):
                if not ss[i] &amp; ss[j]:
                    res=max(res,len(words[i])*len(words[j]))
        return res if res!=float('-inf') else 0
#ANSWER
from collections import defaultdict
class Solution:
    def maxProduct(self, words: List[str]) -&gt; int:
        hashmap = defaultdict(int)
        bit_number = lambda ch : ord(ch) - ord('a')
        
        for word in words:
            bitmask = 0
            for ch in word:
                # add bit number bit_number in bitmask
                bitmask |= 1 &lt;&lt; bit_number(ch)
            # there could be different words with the same bitmask
            # ex. ab and aabb
            hashmap[bitmask] = max(hashmap[bitmask], len(word))
        
        max_prod = 0
        for x in hashmap:
            for y in hashmap:
                if x &amp; y == 0:
                    max_prod = max(max_prod, hashmap[x] * hashmap[y])
        return max_prod
</code></pre>
<p>答案用了bitmask作为key来优化。思路很好。</p>
<h1 id="319-bulb-switcher-medium">319. Bulb Switcher （Medium）</h1>
<p>There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.<br>
On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.<br>
Return the number of bulbs that are on after n rounds.</p>
<pre><code class="language-python">class Solution:
    def bulbSwitch(self, n: int) -&gt; int:
        return int(math.sqrt(n))
        
</code></pre>
<p>这题比较tricky， 灯泡1到n， 只有灯泡被拨动奇数次才会亮， 比如第i个灯泡，i%round==0时候会被拨动一次， 这样第i个灯泡比如第12个，1，12，2，6，3，4轮时候会被拨到，但是对于完全平方数，比如36个灯泡，1，36，2，18，3，12，4，9，6轮时候会被拨到但为奇数轮。所以找到有多少个完全平方数在1到n之间就可以了。</p>
<h1 id="font-colorred320-generalized-abbreviation-mediumfont"><font color='red'>320. Generalized Abbreviation （Medium）</font></h1>
<p>A word's generalized abbreviation can be constructed by taking any number of non-overlapping and non-adjacent substrings and replacing them with their respective lengths.<br>
For example, &quot;abcde&quot; can be abbreviated into:<br>
&quot;a3e&quot; (&quot;bcd&quot; turned into &quot;3&quot;)<br>
&quot;1bcd1&quot; (&quot;a&quot; and &quot;e&quot; both turned into &quot;1&quot;)<br>
&quot;5&quot; (&quot;abcde&quot; turned into &quot;5&quot;)<br>
&quot;abcde&quot; (no substrings replaced)<br>
However, these abbreviations are invalid:<br>
&quot;23&quot; (&quot;ab&quot; turned into &quot;2&quot; and &quot;cde&quot; turned into &quot;3&quot;) is invalid as the substrings chosen are adjacent.<br>
&quot;22de&quot; (&quot;ab&quot; turned into &quot;2&quot; and &quot;bc&quot; turned into &quot;2&quot;) is invalid as the substring chosen overlap.<br>
Given a string word, return a list of all the possible generalized abbreviations of word. Return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def generateAbbreviations(self, word: str) -&gt; List[str]:
        if not word: return []
        res= set()
        res.add(str(len(word)))
        res.add(word)
        for seg_pos in range(len(word)):
            left=word[:seg_pos]
            right=word[seg_pos:]
            
            if left:
                res.add(str(len(left))+right)
            if right:
                res.add(left+str(len(right)))
            
            for left_res in self.generateAbbreviations(left):
                for right_res in self.generateAbbreviations(right):
                    if not (left_res and left_res[-1].isdigit() and right_res and right_res[0].isdigit()):
                        res.add(left_res+right_res)
        
        return sorted(list(res))
#ANSWER
class Solution:
    def generateAbbreviations(self, word: str) -&gt; List[str]:
        def rec(idx, curr_list):
            if idx == L:
                res.append(''.join(curr_list))
                return
            
            #Abbreviate
            if curr_list and curr_list[-1].isdigit():
                curr_list[-1] = str(int(curr_list[-1]) + 1)
                rec(idx + 1, curr_list)
                curr_list[-1] = str(int(curr_list[-1]) - 1)
            else:
                rec(idx + 1, curr_list + ['1'])
            
            #Not to abbreviate
            rec(idx + 1, curr_list + [word[idx]])
                
        L = len(word)
        res = []
        rec(0, [])
        return res
</code></pre>
<p>初次尝试time limit exceeded。。。但这题只能backtracking解。 time complexity应该是相同的，看答案的backtracking写的很完美。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-03/">
        </link>
        <updated>2021-12-02T07:07:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred301-remove-invalid-parentheses-hard-font"><font color='red'>301. Remove Invalid Parentheses (Hard) </font></h1>
<p>Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.<br>
Return all the possible results. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution(object):
    def removeInvalidParentheses(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: List[str]
        &quot;&quot;&quot;
        
        res=[] 
        if not s: return [s]
        visited=set()
        q=[]
        
        q.append(s)
        visited.add(s)
        
      
        
        def isValid(s):
            c=0
            for e in s:
                if e=='(':c+=1
                if e==')':c-=1
                
                if c&lt;0: return False
            return c==0

        found=False
        
        while q:
            s=q.pop(0)
            
            if isValid(s):
                res.append(s)
                found=True
            
            if found: continue
            
            for i in range(len(s)):
                if s[i]!='(' and s[i]!=')': continue
                t=s[:i]+s[i+1:]
                
                if not t in visited:
                    q.append(t)
                    visited.add(t)
        
        return res
    
#         def valid(s):
#             stack=[]
#             ss=[ i for i in s if (i in '()') ]
#             for e in ss:
#                 if e==')':
#                     if (not stack) or (not stack.pop()=='('):
#                         return False
#                 else:
#                     stack.append(e)
#             return not stack

#ANSWER
class Solution:
    
  
    
    def removeInvalidParentheses(self, s: str) -&gt; List[str]:
        #based on hint 
        #1) figure out how many misplaced left and right parenthesis
        left=0
        right=0
        for i,p in enumerate(s):
            if p=='(':
                left+=1
            elif p==')':
                if left&gt;0:
                    left-=1
                else:
                    right+=1
        
        #2)recursion process 
        res =set()
        def bt(left_rem,right_rem,left,right,tmp,index):
            #left_rem is the left error position ( remained
            #right_rem is the right error position ) remained
            #left is # of ( in current expression tmp
            #right is # of ) in current expression tmp
            #tmp is current expression
            #index is the index of char in original string s
            
            #BASE CASE
            if index==len(s):     
                #print(left_rem,right_rem,left,right,tmp)
                if left_rem==0 and right_rem==0:
                    res.add(&quot;&quot;.join(tmp))
                return
            
            #discard current
            if (s[index]=='(' and left_rem&gt;0) or (s[index]==')' and right_rem&gt;0):
                bt(left_rem-(s[index]=='('),right_rem-(s[index]==')'),left,right,tmp,index+1)

            #add current
            tmp.append(s[index])

            #if current is not in {()}
            if s[index] not in [&quot;(&quot;,&quot;)&quot;]:
                bt(left_rem,right_rem,left,right,tmp,index+1)
            elif s[index]=='(':
                #consider an opening bracket
                bt(left_rem,right_rem,left+1,right,tmp,index+1)
            elif s[index]==')' and left&gt;right:
                # consider a closing bracket
                bt(left_rem,right_rem,left,right+1,tmp,index+1)

            tmp.pop()                 

         
        bt(left,right,0,0,[],0)
        return list(res)

</code></pre>
<p>思路1 最快最吊炸天） 类似bfs，用queue 做，验证每一个可能的结果。但为了找到最少的变动就能valid的string，所以一旦找到remove后可以valid的string就不在queue中添加后续元素了。 2）backtracking，先计算错位的left right 括号个数。需要track的， left_remain,right_remain,left_counter,right_counter, tmp=[], index.  比较复杂。</p>
<h1 id="302-smallest-rectangle-enclosing-black-pixels-hard">302. Smallest Rectangle Enclosing Black Pixels （Hard）</h1>
<p>You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel.<br>
The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.<br>
Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.<br>
You must write an algorithm with less than O(mn) runtime complexity</p>
<pre><code class="language-python">class Solution:
    minx=float('inf')
    miny=float('inf')
    maxx=float('-inf')
    maxy=float('-inf')
    def minArea(self, image: List[List[str]], x: int, y: int) -&gt; int:
        
        m=len(image)
        n=len(image[0])
        def dfs(x,y):
            self.minx=min(self.minx,x)
            self.miny=min(self.miny,y)
            self.maxx=max(self.maxx,x)
            self.maxy=max(self.maxy,y)
            image[x][y]='#'
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n and image[xx][yy]=='1':
                    dfs(xx,yy)
        dfs(x,y)
        return (self.maxx-self.minx+1)*(self.maxy-self.miny+1)
</code></pre>
<p>除了bfs ，dfs外 答案给出了一种project 图片到1D，然后用binary search 找上下界，来算面积。</p>
<h1 id="303-range-sum-query-immutable-easy">303. Range Sum Query - Immutable （Easy）</h1>
<pre><code class="language-python">class NumArray:

    def __init__(self, nums: List[int]):
        
        for i,n in enumerate(nums):
            if i==0: continue
            nums[i]+=nums[i-1]
        self.cumsum=nums

    def sumRange(self, left: int, right: int) -&gt; int:
        # 1 2 3
        # 1 3 6
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)

#OR ANSWER WAY OF WRITTEN
class NumArray(object):

    def __init__(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        &quot;&quot;&quot;
        
        nums = [0] + nums
        
        for i in range(1,len(nums)):
            nums[i] +=nums[i-1]
        
        self.nums=nums
     

    def sumRange(self, i, j):
        &quot;&quot;&quot;
        :type i: int
        :type j: int
        :rtype: int
        &quot;&quot;&quot;
        return self.nums[j+1]-self.nums[i]
</code></pre>
<h1 id="304-range-sum-query-2d-immutable-medium">304. Range Sum Query 2D - Immutable (Medium)</h1>
<p>Given a 2D matrix matrix, handle multiple queries of the following type:<br>
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        # original matrix
        # 1 2 3
        # 4 5 6
        # 7 8 9
        #
        #cumsum matrix
        #             c1
        #        0 0  0    0
        #        0 1  3    6
        # row1   0 5  #12  21
        # row2   0 12 27  #45 
        #                 c2
        # do cumsum on row
        # do cumsum on col
        #
        #  row2,col2 -(row1-1)col2 - row2(col1-1) + (row1-1)(col1-1)
        self.matrix = [[0]*(len(matrix[0])+1)]
        for row in matrix:
            self.matrix.append([0]+row)
        
    
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row][col-1]
        
        for row in range(1,len(matrix)+1):
            for col in range(1,len(matrix[0])+1):
                self.matrix[row][col]+=self.matrix[row-1][col]
        
        
        
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        return self.matrix[row2+1][col2+1]-self.matrix[row1][col2+1]-self.matrix[row2+1][col1]+self.matrix[row1][col1]
        


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<h1 id="font-colorred305-number-of-islands-ii-hard-font"><font color='red'>305. Number of Islands II (Hard) </font></h1>
<p>You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0's represent water and 1's represent land. Initially, all the cells of grid are water cells (i.e., all the cells are 0's).<br>
We may perform an add land operation which turns the water at position into a land. You are given an array positions where positions[i] = [ri, ci] is the position (ri, ci) at which we should operate the ith operation.<br>
Return an array of integers answer where answer[i] is the number of islands after turning the cell (ri, ci) into a land.</p>
<pre><code class="language-python">class Solution:
    
    class unionfind:
        
        def __init__(self,m,n):
            self.m=m
            self.n=n
            self.parent=[-1]*(m*n) 
            self.rank = [0]*(m*n)
            self.counter=0
           
        def isvalid(self,row,col):
            ind=row*self.n+col
            return self.parent[ind]&gt;=0
        
        def setparent(self,row,col):
            ind=row*self.n+col
            if self.parent[ind]==-1:
                self.parent[ind]=ind
                self.counter+=1
            
        def find(self,row,col):
            ind= row*self.n+col
            if self.parent[ind]!=ind:
                new_col = self.parent[ind]%self.n
                new_row = (self.parent[ind]-new_col)//self.n
                self.parent[ind]=self.find(new_row,new_col)
            return self.parent[ind]
            
            
        def union(self,p1,p2):
            x1,y1=p1
            x2,y2=p2
            root1=self.find(x1,y1)
            root2=self.find(x2,y2)
            if root1!=root2:
                self.counter-=1
                if self.rank[root1]&gt;self.rank[root2]:
                    self.parent[root2]=root1
                elif self.rank[root1]&lt;self.rank[root2]:
                    self.parent[root1]=root2
                else:
                    self.parent[root1]=root2
                    self.rank[root2]+=1
                    
        def getcount(self):
            return self.counter
         
                    
                
            
    
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -&gt; List[int]:
        
       
        res=[]
        
        uf=self.unionfind(m,n)
    
        def get_nei(pos,uf):
            nei = []
            x,y=pos
            for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:
                if xx&gt;=0 and xx&lt;m and yy&gt;=0 and yy&lt;n:
                    if uf.isvalid(xx,yy):
                        nei.append((xx,yy))
            return nei
    
        for pos in positions:
            uf.setparent(*pos)
            for nei in get_nei(pos,uf):
                uf.union(nei,pos)
            res.append(uf.getcount())
            
        return res
            
            
   

</code></pre>
<p>试过用neighbor_list做，但是无法分辨新加入的点是否会引起2个或3个不同island合并。 思路不正确， 感觉是用UNIONFIND做。还是不能顺畅写出UNIONFIND calss。这次的unionfind class是个变种。 注意增加相同点的时候，setparent做check，必须self.parent[i]==-1 才能做self.conter+=1 。 思路： 每次增加一个点，做setparent，counter++，找这个点所有valid neighbors，然后做union。没发现以个union则counter--。</p>
<h1 id="font-colorblue-306-additive-number-mediumfont"><font color='blue'> 306. Additive Number （Medium）</font></h1>
<p>An additive number is a string whose digits can form an additive sequence.<br>
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.<br>
Given a string containing only digits, return true if it is an additive number or false otherwise.</p>
<pre><code class="language-python">class Solution:
    def isAdditiveNumber(self, num: str) -&gt; bool:
        if not num or len(num)&lt;3: 
            return False
        
        mem=dict()
        def helper(num):
            if not num: return True
            if num in mem: return mem[num]
            Found=False
            for len_a in range(1,len(num)):
                if len_a&gt;1 and num[0]=='0': continue
                for len_b in range(1,len(num)):
                    if len_b&gt;1 and num[len_a]=='0': continue
                    temp_flag=False
                    if len_a+len_b&gt;=len(num):continue
                    a = num[:len_a]
                    b = num[len_a:len_a+len_b]
                    c = str(int(a)+int(b))
                    #print(a,b,c)
                    len_c= len(c)
                    if len_a+len_b+len_c&gt;len(num):continue
                    if len_a+len_b+len_c==len(num) and num[len_a+len_b:len_a+len_b+len_c]==c:
                        return True
                    elif num[len_a+len_b:len_a+len_b+len_c]==c:
                        temp_flag = True and helper(num[len_a:])
                    Found=Found or temp_flag
            mem[num]=Found
            print(num,Found)
            return Found
        
        return helper(num)
        
#ANSWER WAY
def isAdditiveNumber(self, num):
    n = len(num)
    for i, j in itertools.combinations(range(1, n), 2):
        a, b = num[:i], num[i:j]
        if a != str(int(a)) or b != str(int(b)):
            continue
        while j &lt; n:
            c = str(int(a) + int(b))
            if not num.startswith(c, j):
                break
            j += len(c)
            a, b = b, c
        if j == n:
            return True
    return False                

</code></pre>
<p>自己通过recursion with mem解决的，头部为0问题用2个continue 判断去解决。<br>
答案大神用了itertools.combinatons i 是a的长度，j是 a+b的长度，确定了a，b可以算出来c，如果不满足条件跳出while，如果满足条件，则j+len（c），前进一位做下一次判断。 推出时候如果j==n说明找到了。</p>
<h1 id="font-colorred-307-range-sum-query-mutable-medium-font"><font color='red'> 307. Range Sum Query - Mutable (Medium) </font></h1>
<p>Given an integer array nums, handle multiple queries of the following types:<br>
Update the value of an element in nums.<br>
Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.cumsum=nums[:]
        for i in range(1,len(nums)):
            self.cumsum[i]+=self.cumsum[i-1]
 
    def update(self, index: int, val: int) -&gt; None:
        diff=val-self.nums[index]
        self.nums[index]=val
        for i in range(index,len(self.cumsum)):
            self.cumsum[i]+=diff
    def sumRange(self, left: int, right: int) -&gt; int:
        
        return self.cumsum[right]-self.cumsum[left-1] if left-1&gt;=0 else self.cumsum[right]
#METHOD 1  SQRT DECOMPOSTION
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        self.len =  len(nums)//int(math.sqrt(len(nums)))+1 
        self.b=[0]*self.len
        for i,n in enumerate(nums):
            self.b[i//self.len]+=n
         

    def update(self, index: int, val: int) -&gt; None:
        block_index = index//self.len
        self.b[block_index] = self.b[block_index] - self.nums[index]+val
        self.nums[index]=val

    def sumRange(self, left: int, right: int) -&gt; int:
        res=0
        startblock=left//self.len
        endblock=right//self.len
        if startblock==endblock:
            for ind in range(left,right+1):
                res+=self.nums[ind]
        else:
            for ind in range(left,(startblock+1)*self.len):
                res+=self.nums[ind]
            for block_ind in range(startblock+1,endblock):
                res+=self.b[block_ind]
            for ind in range(endblock*self.len,right+1):
                res+=self.nums[ind]
        return res
        
# METHOD 2 ＳＥＧＭＥＮＴ　ＴＲＥＥ
class NumArray:

    def __init__(self, nums: List[int]):
        self.n=len(nums)
        self.tree=['#']*(2*self.n)
        self.buildtree(nums)
        print(self.tree)
    
    def buildtree(self,nums):
        #populate leaves
        j=0
        for i in range(self.n,2*self.n):
            self.tree[i]=nums[j]
            j+=1
        #populate parent nodes
        for i in range(self.n-1,0,-1):
            self.tree[i]=self.tree[i*2]+self.tree[i*2+1]
        

    def update(self, index: int, val: int) -&gt; None:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        #     22 9 13 4  5  6   7
        pos = index+self.n
        self.tree[pos]=val
        while pos&gt;0:
            left=pos
            right=pos
            #这里比较巧妙，tree变成数组后可以理解。
            if pos%2==0:
                right=pos+1
            else:
                left=pos-1
            
            if left&gt;0:
                self.tree[pos//2] = self.tree[left]+self.tree[right]
            pos //=2
        

    def sumRange(self, left: int, right: int) -&gt; int:
        #    1
        # 2     3
        #4  5  6  7
        # 0  1  2  3  4  5  6   7  
        # #  22 9  13 4  5  6   7
        l = left+self.n
        r = right+self.n
        res=0
        while l&lt;=r:
            if l%2==1:
                res+=self.tree[l]
                l+=1
            if r%2==0:
                res+=self.tree[r]
                r-=1
            l//=2
            r//=2
        return res
        
　

</code></pre>
<p>第一版本用cumsum，time limit exceeded。原因在于update时候，要更新所有后续影响的cumsum值。 看答案了。思路1） Sqrt Decomposition，把nums分成 sqrt（len）个block求和。 思路2） Segment Tree。 这个没见过，是最优解。  构造方法很巧妙。可能需要记住．</p>
<h1 id="font-colorred308-range-sum-query-2d-mutable-hard-font"><font color='red'>308. Range Sum Query 2D - Mutable (Hard) </font></h1>
<p>1D to 2D of rang sum Query</p>
<pre><code class="language-python">class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.trees=[self.buildtree(nums) for nums in matrix]
        
        #for tree in self.trees:
        #    print(tree)
    
    def buildtree(self,nums):
        #   1
        #  2  3
        # 4 5 6 7
        # 1 2 3 4 5 6 7
        tree=['#']*self.n*2
        for i,n in enumerate(nums):
            ind=i+self.n
            tree[ind]=n
        
        for ind in range(self.n-1,0,-1):
            tree[ind]=tree[2*ind]+tree[2*ind+1]
        return tree
    
    def update(self, row: int, col: int, val: int) -&gt; None:
        tree=self.trees[row]
        #   1
        #  2  3
        # 4 5 6 7
        # 1   2  3  4 5 6 7
        # 22  9  13 4 5 6 7
        ind = self.n+col
        self.matrix[row][col]=val
        tree[ind]=val
        while ind&gt;0:
            left=ind
            right=ind
            if ind%2==0:
                right+=1
            else:
                left-=1
            if ind//2&gt;0:
                tree[ind//2]=tree[left]+tree[right]
            ind=ind//2
        self.trees[row]=tree
      

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        res = 0
        for row in range(row1,row2+1):
            tree=self.trees[row]
            #   1
            #  2  3
            # 4 5 6 7
            # 1   2  3  4 5 6 7
            # 22  9  13 4 5 6 7
            l=col1+self.n
            r=col2+self.n
            while l&lt;=r:
                if l%2==1:
                    res+=tree[l]
                    l+=1
                if r%2==0:
                    res+=tree[r]
                    r-=1
                l//=2
                r//=2
        return res
            
# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)

#ANSWER
class NumMatrix:
    
    def lsb(self,n):
        return n&amp;-n
    
    def updateBIT(self,r,c,val):
        i=r
        while i&lt;=self.m:
            j=c
            while j&lt;=self.n:
                self.bit[i][j]+=val
                j+=self.lsb(j)
            i+=self.lsb(i)
    
    def queryBIT(self,r,c):
        res=0
        i=r
        while i&gt;0:
            j=c
            while j&gt;0:
                res+=self.bit[i][j]
                j-=self.lsb(j)
            i-=self.lsb(i)
        return res
    def buildBIT(self,matrix):
        for i in range(1,self.m+1):
            for j in range(1,self.n+1):
                val=matrix[i-1][j-1]
                self.updateBIT(i,j,val)
    
    def __init__(self, matrix: List[List[int]]):
        self.matrix=matrix
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.bit= [[0]*(self.n+1) for _ in range(self.m+1)]
        self.buildBIT(matrix)
        
    def update(self, row: int, col: int, val: int) -&gt; None:
        old_val=self.sumRegion(row,col,row,col)
        #handling 1-based indexing
        row+=1
        col+=1
        diff=val-old_val
        self.updateBIT(row,col,diff)
        
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        #handling 1-based indexing
        row1+=1;col1+=1;row2+=1;col2+=1
        a=self.queryBIT(row2,col2)
        b=self.queryBIT(row1-1,col1-1)
        c=self.queryBIT(row2,col1-1)
        d=self.queryBIT(row1-1,col2)
        return a-c-d+b
    


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2)
</code></pre>
<p>自己套用之前的1d segment tree用在2d问题，可以pass。 但不是最优解。 答案用了 Fenwick Tree (Binary Index Tree)  https://www.youtube.com/watch?v=uSFzHCZ4E-8  没见过。而且最终还是用的2D版本的 Binary Index Tree。bit操作下，X，Y不影响，bit位置是bit，保存的值是partial sum。</p>
<h1 id="font-colorred309-best-time-to-buy-and-sell-stock-with-cooldown-mediumfont"><font color='red'>309. Best Time to Buy and Sell Stock with Cooldown （Medium）</font></h1>
<p>You are given an array prices where prices[i] is the price of a given stock on the ith day.<br>
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:<br>
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int: 
        
    
        &quot;&quot;&quot;
        state machine  
                  O held    -sell-&gt;  sold 
                    /\                |
                    |_ buy_ O reset &lt;-rest
       
       O is self loop
       
       DP:
         sold[i]=held[i-1]+price[i]
         held[i]=max(held[i-1],reset[i-1]-price[i])
         reset[i]=max(rest[i-1],sold[i-1])
         
         return max(reset[n],sold[n]
         &quot;&quot;&quot;
        sold, held, reset = float('-inf'), float('-inf'), 0
        for price in prices:
            pre_sold = sold
            sold = held + price               #sell operation
            held = max(held, reset - price)   #buy operation
            reset = max(reset, pre_sold)      # do nothing operation
            
        return max(sold, reset)
 
        #309 直接看答案了
        # profit on ith day kth transanction 0 means 0 stock at our hand after the end of ith day， 1 means 1 stock at our hand after the end of ith day
        #T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) #sell
        #T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])  # buy 
        #Base cases:
        # T[-1][k][0] = 0, T[-1][k][1] = -Infinity
        # T[i][0][0] = 0, T[i][0][1] = -Infinity
        #constain to cooldown
        
        T_ik0=0
        T_ik0_pre=0
        T_ik1=-float('inf')
        
        for p in prices:
            T_ik0_old=T_ik0
            T_ik0 = max(T_ik0, T_ik1+p)
            T_ik1 = max(T_ik1, T_ik0_pre-p)
            T_ik0_pre=T_ik0_old
        
        return T_ik0


</code></pre>
<p>这是一类问题，很多变种。。。。https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75924/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 答案的state machine 思维方法很有意思。</p>
<h1 id="310-minimum-height-trees-medium">310. Minimum Height Trees （Medium）</h1>
<p>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.</p>
<p>Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).</p>
<p>Return a list of all MHTs' root labels. You can return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]:
        #remove those leafves what left is root 
        
        
        dic={i:[] for i in range(n)}
        q = []
        for edge in edges:
            n1,n2=edge
            dic[n1].append(n2)
            dic[n2].append(n1)
        
        for i in range(n):
            if len(dic[i])==1:
                q.append(i)
                
        res=q
        while q:
            l=len(q)
            res=q[:]
            for _ in range(l):
                cur=q.pop(0)
                for nei in dic[cur]:
                    dic[nei].remove(cur)
                if len(dic[nei])==1:
                    q.append(nei)
        return res if res else [0]
    
</code></pre>
<p>看一下hint才做出来，思路topological sort，leaves 直接砍掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-02/">
        </link>
        <updated>2021-12-02T06:05:58.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="291-word-pattern-ii-medium">291. Word Pattern II （Medium）</h1>
<p>Given a pattern and a string s, return true if s matches the pattern.<br>
A string s matches a pattern if there is some bijective mapping of single characters to strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.</p>
<pre><code class="language-python">class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -&gt; bool:
        
        
        
        def helper(pattern,s,dic1,dic2):
            if not s: return not pattern
            if not pattern: return not s
            key = pattern[0]
            res=False
            for i in range(1,len(s)+1):
                dic1_copy=dic1.copy() 
                dic2_copy=dic2.copy()
                s_val = s[:i]
                
                #print(key,s_val)
                if key in dic1_copy and dic1_copy[key]!=s_val: 
                    res=res or False
                    continue
                else:
                    dic1_copy[key]=s_val
                
                if s_val in dic2_copy and dic2_copy[s_val]!=key: 
                    res=res or False
                    continue
                else:
                    dic2_copy[s_val]=key
                    
                s_rest = s[i:]
                res = res or helper(pattern[1:],s_rest,dic1_copy,dic2_copy)
            #if res:
            #    print(pattern,s)
            return res
        
        return helper(pattern,s,dict(),dict())
</code></pre>
<p>知道使用backtracking，但是得小心 dic1 dic2 copy问题，以及res = res or False， 既然当前s[:i] 已经是False了就skip，所以用cotinue。</p>
<h1 id="292-nim-game-easy">292. Nim Game （Easy）</h1>
<p>You are playing the following Nim Game with your friend:<br>
Initially, there is a heap of stones on the table.<br>
You and your friend will alternate taking turns, and you go first.<br>
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br>
The one who removes the last stone is the winner.</p>
<pre><code class="language-python">class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # dp [0]   [1]     [2]   [3]    [4]     [5]
        #    True   True   True  True   False  
        
        dp = [False] * (n+1)
        if n&lt;=3: return True
        dp[0]=True
        dp[1]=True
        dp[2]=True
        dp[3]=True
        for nn in range(2,n+1):
            for i_select in [1,2,3]:
                dp[nn] = dp[nn] or  (not dp[nn-i_select])
        
        #print(dp)
        return dp[n]
    
class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        # 只要对方等于4个 对方必然输。
        # 我先开始，如何让对方等于4个
        # n=4 我输
        # n=5 我选1
        # n=6 我选2
        # n=7 我选3
        # n=8 我选1 不行 我选2 不行 我选3 还是不行
        # n=9 选1
        # n=10 选2
        # n=11 选3
        # n=12 都不行
        
        return  not n%4==0

</code></pre>
<p>用dp写了一个答案，但time limit exceeded。 逐渐发现规律。。。就是是否被4整除。</p>
<h1 id="293-flip-game-easy">293. Flip Game （Easy）</h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].</p>
<pre><code class="language-python">class Solution:
    def generatePossibleNextMoves(self, currentState: str) -&gt; List[str]:
        res= []
        for i in range(len(currentState)-1):
            if currentState[i]=='+' and currentState[i+1]=='+':
                res.append(currentState[:i]+'--'+currentState[i+2:])
        return res
</code></pre>
<h1 id="font-colorred294-flip-game-ii-medium-font"><font color='red'>294. Flip Game II (Medium) </font></h1>
<p>You are playing a Flip Game with your friend.<br>
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive &quot;++&quot; into &quot;--&quot;. The game ends when a person can no longer make a move, and therefore the other person will be the winner.<br>
Return true if the starting player can guarantee a win, and false otherwise.</p>
<pre><code class="language-python">class Solution:
    def canWin(self, currentState: str) -&gt; bool:
            return any(currentState[i:i+2] == '++' and not self.canWin(currentState[:i] + '--' + currentState[i+2:])  for i in range(len(currentState)))
#ANSWER
class Solution(object):
    _memo = {}
    def canWin(self, s):
        memo = self._memo
        if s not in memo:
            memo[s] = any(s[i:i+2] == '++' and not self.canWin(s[:i] + '--' + s[i+2:])
                          for i in range(len(s)))
        return memo[s]

#ANSWER
class Solution(object):
    def canWin(self, s):
        memo = {}
        def can(s):
            if s not in memo:
                memo[s] = any(s[i:i+2] == '++' and not can(s[:i] + '--' + s[i+2:])
                              for i in range(len(s)))
            return memo[s]
        return can(s)

</code></pre>
<p>没思路。。 。。。backtracking with mem。。。。</p>
<h1 id="font-colorred295-find-median-from-data-stream-hardfont"><font color='red'>295. Find Median from Data Stream （Hard）</font></h1>
<pre><code class="language-python">from heapq import *


class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))
        else:
            heappush(self.small, -heappushpop(self.large, num))

    def findMedian(self):
        if len(self.small) == len(self.large):
            return float(self.large[0] - self.small[0]) / 2.0
        else:
            return float(self.large[0])

</code></pre>
<p>最简单方法的是sort， 复杂点的比如答案，用了min heap。 思路： small 保存较小的，large保存较大的， 由于需要small的最大元素，minheap头是最小元素，所以push到small要反向。  large能最多比small多存一个元素。 heappushpop同时 push一个元素取出一个元素。TimeCoplex O(logn).</p>
<h1 id="296-best-meeting-point-hard">296. Best Meeting Point （Hard）</h1>
<p>Given an m x n binary grid grid where each 1 marks the home of one friend, return the minimal total travel distance.<br>
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.<br>
The distance is calculated using Manhattan Distance</p>
<pre><code class="language-python">class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -&gt; int:
        
        m=len(grid)
        n=len(grid[0])
        rows=[]
        cols=[]
        for row in range(m):
            for col in range(n):
                if grid[row][col]==1:
                    rows.append(row)
                    cols.append(col)
        
        rows = sorted(rows)
        cols = sorted(cols)
        row=rows[len(rows)//2]
        col=cols[len(cols)//2]
        
        def mindis1d(points,origin):
            distance=0
            for point in points:
                distance += abs(point-origin)
            return distance
        
        return mindis1d(rows,row)+mindis1d(cols,col)
                    

</code></pre>
<p>第一想法多次BFS。。。一次cost mn   最差情况有mn个1， 所以最差有O（mmnn）。 不可行。 答案思路：1）分解成2个1d的问题，最小值点出现在median位置。  O(mnlog⁡mn)    2）只要不sort，时间复杂度还能降低到O(mn) 。 拉出来行和列分别遍历即可。</p>
<h1 id="font-colorred-297-serialize-and-deserialize-binary-tree-hard-font"><font color='red'> 297. Serialize and Deserialize Binary Tree （Hard） </font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;
        res = []
        def pre(root):
            if not root:
                res.append('#')
                return  
            res.append(str(root.val))
            pre(root.left)
            pre(root.right)
        pre(root)
         
        return '@'.join(res)
        

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        
        data = [ e.strip() for e in data.split('@')  ]
        
        def deser(data):
            if not data: return None
            if data[0]=='#':
                data.pop(0)
                return None
            
            root=TreeNode(int(data.pop(0))) 
            root.left=deser(data)
            root.right=deser(data)
            return root
        
        return deser(data)
        
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

</code></pre>
<p>有个什么儿子兄弟表示法，但忘记了。。。这个题目只用了preorder。 但要注意递归时候，传入data必须是list，这样随着递归list本身会变化，要是str会出错。</p>
<h1 id="font-colorred298-binary-tree-longest-consecutive-sequence-mediumfont"><font color='red'>298. Binary Tree Longest Consecutive Sequence （Medium）</font></h1>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -&gt; int:
        res=[0]
        def pre(root,parent, length):
            if not root:
                return 
            if parent and root.val==parent.val+1:
                length+=1
            else:
                length=1
            res[0]=max(res[0],length)
            pre(root.left,root,length)
            pre(root.right,root,length)
        pre(root,None,0)
        
        return res[0]
         
</code></pre>
<p>太晚了，应该能做出来，直接看答案改写。 pre order， 如果 parent+1=current ， length+=1 else length=1</p>
<h1 id="299-bulls-and-cows-medium">299. Bulls and Cows （Medium）</h1>
<pre><code class="language-python">class Solution:
    def getHint(self, secret: str, guess: str) -&gt; str:
        aaa=0
        dic1=dict()
        dic2=dict()
        for a,b in zip(secret,guess):
            if a==b:
                aaa+=1
            dic1[a]=dic1.get(a,0)+1
            dic2[b]=dic2.get(b,0)+1
        bbb=0
        for k in dic1:
            if k in dic2:
                bbb+=min(dic1[k],dic2[k])
        
        bbb=bbb-aaa
        
        return str(aaa)+'A'+str(bbb)+'B'
</code></pre>
<h1 id="font-colorblue300-longest-increasing-subsequence-medium-font"><font color='blue'>300. Longest Increasing Subsequence (Medium) </font></h1>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        # dp[i] means the LIS till ith number including i
        # dp[i] =  max(dp[i],dp[j]+1)   j&lt;i and nums[j]&lt;nums[i]
        if not nums: return 0
        if len(nums)==1: return 1
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j]&lt;nums[i]:
                    dp[i]=max(dp[i],dp[j]+1)
        
        return max(dp)
</code></pre>
<p>classical DP problem O(n^2)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-01/">
        </link>
        <updated>2021-11-30T05:36:09.000Z</updated>
        <summary type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
]]></summary>
        <content type="html"><![CDATA[<p>依然在补进度，而且没有复习之前刷的题目， 12月底补12月初进度。 立个flag，明年一月结束要刷到900. 二月全面复习二刷。</p>
<!-- more -->
<h1 id="281-zigzag-iterator-medium">281. Zigzag Iterator （Medium）</h1>
<p>Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.</p>
<pre><code class="language-python">class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        li=[v1,v2]
        self.li = [[v,len(v)] for v in li if v]
        self.select = 0
    
    def next(self) -&gt; int:
        if self.li[self.select][1]&gt;0:
            self.li[self.select][1]-=1
            val= self.li[self.select][0].pop(0)
            if self.li[self.select][1]==0:
                self.li.pop(self.select)
            self.select=(self.select+1)%len(self.li) if self.li else 0
            return val
         
    def hasNext(self) -&gt; bool:
        return sum([e[1] for e in self.li])&gt;0
        
        

# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())
</code></pre>
<h1 id="282-expression-add-operators-hard">282. Expression Add Operators (Hard)</h1>
<p>Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.Note that operands in the returned expressions should not contain leading zeros.</p>
<pre><code class="language-python">class Solution:
    def addOperators(self, num: 'str', target: 'int') -&gt; 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append(&quot;&quot;.join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand &gt; 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
</code></pre>
<p>第一眼感觉是用backtracking，写出了第一版，但是没考虑1） number 可以是1位可以是2位，3位 etc， 2）乘法的优先级高于加减，所以需要tracking operator是什么。 3）不可以backtracking到最后eval结果，太费时间。 直接看答案了。。。答案： 关键在于除了加减乘以外，增加一个不操作operator， 12--&gt;123  是 12乘以10+3     extending 当前值12 by one digit， 12乘以10。  看了答案还是懵逼。细节太多但都符合逻辑。</p>
<h1 id="283-move-zeroes-easy">283. Move Zeroes （Easy）</h1>
<p>Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.</p>
<pre><code class="language-python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos]=n
                pos+=1
        while pos&lt;len(nums):
            nums[pos]=0
            pos+=1

#SWAP is a better solution
class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
    
        pos=0
        for i,n in enumerate(nums):
            if n!=0:
                nums[pos],nums[i] = nums[i],nums[pos]
                pos+=1
     
</code></pre>
<h1 id="284-peeking-iterator-medium">284. Peeking Iterator (Medium)</h1>
<pre><code class="language-python"># Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         &quot;&quot;&quot;
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         &quot;&quot;&quot;
#
#     def hasNext(self):
#         &quot;&quot;&quot;
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         &quot;&quot;&quot;
#
#     def next(self):
#         &quot;&quot;&quot;
#         Returns the next element in the iteration.
#         :rtype: int
#         &quot;&quot;&quot;

class PeekingIterator:
    def __init__(self, iterator):
        &quot;&quot;&quot;
        Initialize your data structure here.
        :type iterator: Iterator
        &quot;&quot;&quot;
        self.iterator=iterator
        self.peekval=None

    def peek(self):
        &quot;&quot;&quot;
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval:
            return self.peekval
        else:
            self.peekval=self.iterator.next()
            return self.peekval
        

    def next(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        if self.peekval is not None:
            peekval=self.peekval
            self.peekval=None
            return peekval
        else:
            return self.iterator.next()
        

    def hasNext(self):
        &quot;&quot;&quot;
        :rtype: bool
        &quot;&quot;&quot;
        return self.iterator.hasNext() or self.peekval is not None
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].

</code></pre>
<h1 id="285-inorder-successor-in-bst-medium">285. Inorder Successor in BST (Medium)</h1>
<p>Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'Optional[TreeNode]':
        stack = []
        while root and root.val!=p.val:
            stack.append(root)
            if p.val&lt;root.val:
                root=root.left
            else:
                root=root.right
        
        if p.right:
            node=p.right
            while node.left:
                node=node.left
            return node
                
        else:
            while stack:
                node=stack.pop()
                if node.val&gt;p.val:
                    return node
            return None


#ANSWER
class Solution:
    
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -&gt; 'TreeNode':
        
        successor = None
        
        while root:
            
            if p.val &gt;= root.val:
                root = root.right
            else:
                successor = root
                root = root.left
                
        return successor

</code></pre>
<p>答案更巧妙。</p>
<h1 id="286-walls-and-gates-medium">286. Walls and Gates （Medium）</h1>
<p>You are given an m x n grid rooms initialized with these three possible values.</p>
<pre><code>-1 A wall or an obstacle.
0 A gate.
INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
</code></pre>
<p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.</p>
<pre><code class="language-python">class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        visited = set()
        while q:
            level+=1
            for _ in range(len(q)):
                i,j = q.popleft()
                visited.add((i,j))
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and (ii,jj) not in visited:
                        if rooms[ii][jj]!=0 and rooms[ii][jj]!=-1:
                            rooms[ii][jj] = level
                            q.append((ii,jj))
                            visited.add((ii,jj))

#ANSWER
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify rooms in-place instead.
        &quot;&quot;&quot;
        from collections import deque
        m=len(rooms)
        n=len(rooms[0])
        INF=2**31-1
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j]==0:
                    q.append((i,j))
        level=0
        while q:
            for _ in range(len(q)):
                i,j = q.popleft()
                for ii,jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if ii&gt;=0 and ii&lt;m and jj&gt;=0 and jj&lt;n and  rooms[ii][jj]==INF :
                        rooms[ii][jj] = rooms[i][j]+1
                        q.append((ii,jj))
                           
</code></pre>
<p>第一眼感觉用bfs做，从gates 处扫不是墙和gate的rooms距离。 差点忘了bfs 要for _ in range(len(queue))  .....   答案不用visited level 解决， 因为BFS所以只要INF 变成距离就是最短距离， 从什么地方变得距离？就是rooms[ii][jj] = rooms[i][j]+1</p>
<h1 id="font-colorred-287-find-the-duplicate-number-mediumfont"><font color='red'> 287. Find the Duplicate Number （Medium）</font></h1>
<p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.<br>
There is only one repeated number in nums, return this repeated number.<br>
You must solve the problem without modifying the array nums and uses only constant extra space.</p>
<pre><code class="language-python">class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        for num in nums:
            cur = abs(num)
            if nums[cur] &lt; 0:
                duplicate = cur
                break
            nums[cur] = -nums[cur]

        # Restore numbers
        for i in range(len(nums)):
            nums[i] = abs(nums[i])

        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        duplicate = 0
        n = len(nums)
        bits = n.bit_length()
        for bit in range(bits):
            mask = 1 &lt;&lt; bit
            base_count = 0
            nums_count = 0
            for i in range(n):
                # If bit is set in number (i) then add 1 to base_count
                if i &amp; mask:
                    base_count += 1
                    
                # If bit is set in nums[i] then add 1 to nums_count
                if nums[i] &amp; mask:
                    nums_count += 1
                    
            # If the current bit is more frequently set in nums than it is in 
            # the range [1, 2, ..., n] then it must also be set in the duplicate number.
            if nums_count - base_count &gt; 0:
                duplicate |= mask
                
        return duplicate

#ANSWER
class Solution:
    def findDuplicate(self, nums: 'List[int]') -&gt; 'int':
        
        low = 1
        high = len(nums)-1
        
        while low &lt; high:
            mid = low+(high-low)//2
            count = 0
            for i in nums:
                if i &lt;= mid:
                    count+=1
            if count &lt;= mid:
                low = mid+1
            else:
                high = mid
        return low

#ANSWER
class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        
        #who can think it as cycled two pointer problem?
        
        slow = nums[0]
        fast = nums[0]
        
        while True:
            slow =  nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        
        fast = nums[0]
        while slow!=fast:
            slow=nums[slow]
            fast=nums[fast]
        return slow
</code></pre>
<p>一堆double数中找single容易，用xor就可以， 但一堆single中找double。。。 答案思路： 思路1）标负。符号所在位置表示数出现过没。 nums[cur]小于0表示 cur这个数出现过。 2）bitmask 3）binary search 4）Cycle Detection，这个方法最妙。</p>
<h1 id="288-unique-word-abbreviation-medium">288. Unique Word Abbreviation （Medium）</h1>
<p>The abbreviation of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an abbreviation of itself.</p>
<pre><code class="language-python">class ValidWordAbbr:
    
    
    def __init__(self, dictionary: List[str]):
        import collections 
        self.dic= collections.defaultdict(set)
        for w in dictionary:
            key=self.sort(w)
            self.dic[key].add(w)
        #print(self.dic)
        
    def sort(self,w):
        if len(w)&lt;=2:
            key=w
        else:
            key=w[0]+str(len(w[1:-1])) +w[-1]
        return key
    
    def isUnique(self, word: str) -&gt; bool:
        key=self.sort(word)
        if key not in self.dic or (len(self.dic[key])==1 and list(self.dic[key])[0]==word):
            return True
        return False


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)

#Better solution
class ValidWordAbbr(object):
    
    def getkey(self,word):
        if len(word)&lt;=2: 
            return word
        else:
            return word[0]+str(len(word[1:-1]))+word[-1]
        
    
    def __init__(self, dictionary):
        &quot;&quot;&quot;
        :type dictionary: List[str]
        &quot;&quot;&quot;
         
        self.dic=dict()
        for word in dictionary:
            key=self.getkey(word)
            if key in self.dic and word!=self.dic[key]:
                self.dic[key]='#'
            else:
                self.dic[key]=word
        

    def isUnique(self, word):
        &quot;&quot;&quot;
        :type word: str
        :rtype: bool
        &quot;&quot;&quot;

        key=self.getkey(word)
        
        if key in self.dic and self.dic[key]==word:
            return True
        elif key not in self.dic:
            return True
        return False
</code></pre>
<h1 id="289-game-of-life-medium">289. Game of Life (Medium)</h1>
<pre><code class="language-python">class Solution:
    def gameOfLife(self, board: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        m=len(board)
        n=len(board[0])
        #solve it in-place
        #rule
        #  live cell =1
        #            #nei &lt;2      die
        #            #nei 2 or 3  live
        #            #nei &gt;3      die
        #  dead cell = 0
        #            #nei 3       live
        #
        #  save live die in next round with (X//10)%2   if live save as 10+old
        #                                               if die  save as 20+old
        #  when get old value   old = old%10
        
        for i in range(m):
            for j in range(n):
                live=0
                old=board[i][j]%10
                if old==1:
                    livecell=True
                else:
                    livecell=False
                    
                for nei in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    ii,jj=nei
                    if ii&lt;m and ii&gt;=0 and jj&lt;n and jj&gt;=0:
                        live+=board[ii][jj]%10
                
                if livecell:
                    if live==2 or live==3:
                        board[i][j]= 10+old
                    else:
                        board[i][j]= 20+old
                else:
                    if live==3:
                        board[i][j] = 10+old
                        
        for i in range(m):
            for j in range(n):
                board[i][j] = (board[i][j]//10)%2
        
#INF CASE
def gameOfLifeInfinite(self, live):
    ctr = collections.Counter((I, J)
                              for i, j in live
                              for I in range(i-1, i+2)
                              for J in range(j-1, j+2)
                              if I != i or J != j)
    return {ij
            for ij in ctr
            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}

def gameOfLife(self, board):
    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}
    live = self.gameOfLifeInfinite(live)
    for i, row in enumerate(board):
        for j in range(len(row)):
            row[j] = int((i, j) in live)
</code></pre>
<h1 id="290-word-pattern-easy">290. Word Pattern （Easy）</h1>
<pre><code class="language-python">class Solution:
    def wordPattern(self, pattern: str, s: str) -&gt; bool:
        
        dic1=dict()
        dic2=dict()
        if len(pattern)!=len(s.split()): return False
        for k,v in zip(s.split(),pattern):
            if k not in dic1:
                dic1[k]=v
            else:
                if dic1[k]!=v:
                    return False
            
            if v not in dic2:
                dic2[v]=k
            else:
                if dic2[v]!=k:
                    return False
        return True
</code></pre>
<p>注意是一一映射，所以需要2个dict检查， 注意corner case。</p>
]]></content>
    </entry>
</feed>