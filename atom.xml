<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://headhuanglan.github.io</id>
    <title>Lan&apos;s Blog</title>
    <updated>2022-04-01T23:33:11.352Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://headhuanglan.github.io"/>
    <link rel="self" href="https://headhuanglan.github.io/atom.xml"/>
    <subtitle>回忆未来</subtitle>
    <logo>https://headhuanglan.github.io/images/avatar.png</logo>
    <icon>https://headhuanglan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Lan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[系统设计]]></title>
        <id>https://headhuanglan.github.io/post/system-design/</id>
        <link href="https://headhuanglan.github.io/post/system-design/">
        </link>
        <updated>2022-03-29T23:23:07.000Z</updated>
        <summary type="html"><![CDATA[<p>system design</p>
]]></summary>
        <content type="html"><![CDATA[<p>system design</p>
<!-- more -->
<p><a href="https://www.youtube.com/watch?v=PdtlXdse7pw&amp;list=PL4KdJM8LzAMecwInbBK5GJ3Anz-ts75RQ">DDIA书视频总结</a></p>
<p><a href="https://github.com/donnemartin/system-design-primer">system design primer github repo</a></p>
<p><a href="https://www.hiredintech.com/classrooms/system-design/lesson/52">system design class</a></p>
<p><a href="https://www.educative.io/courses/grokking-the-system-design-interview">grokking system design interview</a></p>
<p><a href="https://luanjunyi.medium.com/the-table-of-contents-416d2240fa8e">大佬的medium文章</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-04]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-04/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-04/">
        </link>
        <updated>2022-03-04T14:13:50.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="431-encode-n-ary-tree-to-binary-tree-hard">431. Encode N-ary Tree to Binary Tree （Hard）</h1>
<p>Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
&quot;&quot;&quot;

class Codec:
    # Encodes an n-ary tree to a binary tree.
    def encode(self, root: 'Optional[Node]') -&gt; Optional[TreeNode]:
        if not root: return []
        rootnode = TreeNode(root.val)
        return_rootnode=rootnode
       
        first=True
        for node in root.children:
            if first:
                first=False
                rootnode.left=self.encode(node)
                rootnode=rootnode.left
            else:
                rootnode.right=self.encode(node)
                rootnode=rootnode.right
        
        return return_rootnode
	
	# Decodes your binary tree to an n-ary tree.
    def decode(self, data: Optional[TreeNode]) -&gt; 'Optional[Node]':
        if not data: return None
        #print(data)
        #print('#'*20)
        root=data
        root_node=Node(root.val,[])
        if root.left:
            root_node.children.append(self.decode(root.left))
            root=root.left
            while root.right:
                root_node.children.append(self.decode(root.right))
                root=root.right
        
        return root_node
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(root))


#ANSWER 
class Codec:

    def encode(self, root):
        if not root:
            return None

        binary = TreeNode(root.val)                 # create a binary root
        if not root.children:
            return binary
        #Python - left child for children, right child for siblings
        
        binary.left = self.encode(root.children[0]) # left child of binary is the encoding of all n-ary children,
        node = binary.left                          #     starting with the first child.
        for child in root.children[1:]:             # other children of n-ary root are right child of previous child
            node.right = self.encode(child)
            node = node.right

        return binary

    def decode(self, data):
        if not data:
            return None

        nary = Node(data.val, [])                   # create n-ary root
        node = data.left                            # move to first child of n-ary root
        while node:                                 # while more children of n-ary root
            nary.children.append(self.decode(node)) # append to list
            node = node.right                       # and move to next child
            
        return nary
        
</code></pre>
<p>我得方法，把所有孩子都包含在下一层，  root的left通向下一层，root.left.right和之后所有的right都是同一层的保存孩子。</p>
<h1 id="font-colorred-432-all-oone-data-structure-hardfont"><font color='red'> 432. All O`one Data Structure （Hard）</font></h1>
<p>Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.<br>
Implement the AllOne class:<br>
AllOne() Initializes the object of the data structure.<br>
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.<br>
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.<br>
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string &quot;&quot;.<br>
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">from collections import defaultdict
class Node(object):
    def __init__(self):
        self.key_set = set([])
        self.prev, self.nxt = None, None 

    def add_key(self, key):
        self.key_set.add(key)

    def remove_key(self, key):
        self.key_set.remove(key)        

    def get_any_key(self):
        if self.key_set:
            result = self.key_set.pop()
            self.add_key(result)
            return result
        else:
            return None
    
    def count(self):
        return len(self.key_set)

    def is_empty(self):
        return len(self.key_set) == 0


class DoubleLinkedList(object):
    def __init__(self):
        self.head_node, self.tail_node = Node(), Node()
        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node
        return

    def insert_after(self, x):
        node, temp = Node(), x.nxt
        x.nxt, node.prev = node, x
        node.nxt, temp.prev = temp, node
        return node
    
    def insert_before(self, x):
        return self.insert_after(x.prev)

    def remove(self, x):
        prev_node = x.prev
        prev_node.nxt, x.nxt.prev = x.nxt, prev_node
        return

    def get_head(self):
        return self.head_node.nxt
    
    def get_tail(self):
        return self.tail_node.prev

    def get_sentinel_head(self):
        return self.head_node

    def get_sentinel_tail(self):
        return self.tail_node
    
class AllOne(object):
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)
        self.node_freq = {0:self.dll.get_sentinel_head()}

    def _rmv_key_pf_node(self, pf, key):
        node = self.node_freq[pf]
        node.remove_key(key)
        if node.is_empty():
            self.dll.remove(node)
            self.node_freq.pop(pf)
        return

    def inc(self, key):
        &quot;&quot;&quot;
        Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        self.key_counter[key] += 1
        cf, pf = self.key_counter[key], self.key_counter[key]-1
        if cf not in self.node_freq:
            # No need to test if pf = 0 since frequency zero points to sentinel node
            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])
        self.node_freq[cf].add_key(key)
        if pf &gt; 0:
            self._rmv_key_pf_node(pf, key)

    def dec(self, key):
        &quot;&quot;&quot;
        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
        :type key: str
        :rtype: void
        &quot;&quot;&quot;
        if key in self.key_counter:
            self.key_counter[key] -= 1
            cf, pf = self.key_counter[key], self.key_counter[key]+1
            if self.key_counter[key] == 0:
                self.key_counter.pop(key)
            if cf != 0:
                if cf not in self.node_freq:
                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])
                self.node_freq[cf].add_key(key)
            self._rmv_key_pf_node(pf, key)

    def getMaxKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with maximal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;

    def getMinKey(self):
        &quot;&quot;&quot;
        Returns one of the keys with Minimal value.
        :rtype: str
        &quot;&quot;&quot;
        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() &gt; 0 else &quot;&quot;




</code></pre>
<p>感觉是个maxheap minheap。。。但不是all o（1）。。。 看答案了。。。答案果然完美</p>
<h1 id="433-minimum-genetic-mutation-medium">433. Minimum Genetic Mutation (Medium)</h1>
<p>A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.<br>
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.<br>
For example, &quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; is one mutation.<br>
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.<br>
Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.<br>
Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<pre><code class="language-python">class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        #BFS search neighbor
        # neighor is 1 char off current also in bank
        if   end not in bank: return -1
        if not bank and start!=end: return -1
        bank=set(bank)
        bank.add(end)
        q=[]
        visited=set()
        def nei(me):
            neighbors=[]
            for other in bank:
                if other not in visited:
                    valid=0
                    for a,b in zip(me,other):
                        valid+=bool(ord(a)^ord(b))
                    if valid==1:
                        neighbors.append(other)
            return neighbors
        
        
        q.append(start)
        visited.add(start)
        level=0
        while q:
            level+=1
            for _ in range(len(q)):
                cur=q.pop(0)
                print(cur,nei(cur))
                for ne in nei(cur):
                    if ne==end: return level
                    visited.add(ne)
                    q.append(ne)
        
        return  -1
        
#ANSWER
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int:
        &quot;&quot;&quot;
        :type start: str
        :type end: str
        :type bank: List[str]
        :rtype: int
        &quot;&quot;&quot;
        queue = []
        queue.append((start,0))
        bankSet = set(bank)
        
        while queue:
            curr, step = queue.pop(0)
            if curr == end:
                return step
            for i in range(len(curr)):
                for c in &quot;AGCT&quot;:
                    mutation = curr[:i] + c + curr[i+1:]
                    if mutation in bankSet:
                        bankSet.remove(mutation)
                        queue.append((mutation,step+1))
                        
        return -1
        
</code></pre>
<p>bfs注意corner case，end必须in bank。 答案用remove mutaton方式避免用visited set，而且mutaion是直接算的，不是从bank中找的。</p>
<h1 id="434-number-of-segments-in-a-string-easy">434. Number of Segments in a String （Easy）</h1>
<p>Given a string s, return the number of segments in the string.<br>
A segment is defined to be a contiguous sequence of non-space characters.</p>
<pre><code class="language-python">class Solution:
    def countSegments(self, s: str) -&gt; int:
        beforeisspace=True
        c=0
        while s:
            if s[0]==' ':
                s=s[1:]
                beforeisspace=True
            else:
                if beforeisspace:
                    c+=1
                    beforeisspace=False
                
                s=s[1:]
        return c

class Solution:
    def countSegments(self, s: str) -&gt; int:
        return len(s.split())

class Solution:
    def countSegments(self, s):
        segment_count = 0

        for i in range(len(s)):
            if (i == 0 or s[i-1] == ' ') and s[i] != ' ':
                segment_count += 1

        return segment_count
</code></pre>
<h1 id="font-colorred-435-non-overlapping-intervals-medium-font"><font color='red'> 435. Non-overlapping Intervals (Medium) </font></h1>
<p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<pre><code class="language-python">class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        #sort by start
        # [1,2] [1,3] [2,3],[3,4]
        #sort by end
        # 找最小删除相当于找最大不overlap有多少个interval
        #变成dp问题 dp[i]是最大的interval个数 用到ith interval
        # dp【i】= max（dp【j】）+1 j&lt;i  interval i，j不overlap
        intervals=sorted(intervals,key=lambda x:x[0])
        dp = [0]*len(intervals)
        dp[0]=1
        ans=1
        for i in range(1,len(dp)):
            max_=0
            for j in range(i):
                if intervals[j][1]&lt;=intervals[i][0]:
                    max_=max(dp[j],max_)
            
            dp[i]=max_+1
            ans=max(ans,dp[i])
        return len(intervals)-ans

#PASS ANSWER
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
 
        intervals=sorted(intervals,key=lambda x:x[0])
        end=intervals[0][1]
        prev=0
        c=0
        for i in range(1,len(intervals)):
            if intervals[prev][1]&gt;intervals[i][0]:
                #overlap
                if intervals[prev][1]&gt;intervals[i][1]:
                    #include,bust del prev so c+=1 prev renew to i
                    prev=i
                
                #if pure overlap do greedy, prev still the same, del i, c+=1
                c+=1
            else:
                #case 1 two interval non overlapping
                prev=i
                
        return c
</code></pre>
<p>没想出来如何处理~~ DP可以n^2， greedy也可以，Greedy nlogn</p>
<h1 id="font-colorred-436-find-right-interval-medium-font"><font color='red'> 436. Find Right Interval (Medium) </font></h1>
<p>You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.<br>
The right interval for an interval i is an interval j such that startj &gt;= endi and startj is minimized. Note that i may equal j.<br>
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        maps=dict()
        for i,interval in enumerate(intervals):
            maps[tuple(interval)]=i
        
        ans=[-1]*len(intervals)
        intervals=sorted(intervals,key=lambda x:x[0])
        for i in range(len(intervals)-1):
            #i's right
            j=i+1
            while j&lt;len(intervals) and intervals[j][0]&lt;intervals[i][1]:
                j+=1
            if j&lt;len(intervals):
                ans[maps[tuple(intervals[i])]]=maps[tuple(intervals[j])]
        return ans


#ANSWER BINARY SERACH 

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        
        l = sorted((e[0], i) for i, e in enumerate(intervals))
        res = []
        for e in intervals:
            r = bisect.bisect_left(l, (e[1],))
            res.append(l[r][1] if r &lt; len(l) else -1)
        return res

#Heap法
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -&gt; List[int]:
        heap, result = [], [-1] * len(intervals)
        for idx, interval in sorted(enumerate(intervals), key=lambda enum: enum[1][0]):
            while heap and heap[0][0] &lt;= interval[0]:
                _, i = heapq.heappop(heap)
                if intervals[i][0]!=intervals[i][1]:
                    result[i] = idx
                else:
                    result[i] = i
            heapq.heappush(heap, (interval[1], idx))
        return result
</code></pre>
<p>初次尝试 time limit exceeded 答案的bianry search法太厉害。</p>
<h1 id="font-colorblue-437-path-sum-iii-medium-font"><font color='blue'> 437. Path Sum III （Medium） </font></h1>
<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.<br>
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:
        #post order  botoom up save node val
        
        c=[0]
        def post(root):
            if not root: return 
            post(root.left)
            post(root.right)
            root.vals=defaultdict(int)
            if root.left:
                for v in root.left.vals:
                    root.vals[v+root.val]+=root.left.vals[v]
            if root.right:
                for v in root.right.vals:
                    root.vals[v+root.val]+=root.right.vals[v]
            root.vals[root.val]+=1
            if targetSum in root.vals:
                #print(root.val,root.vals)
                c[0]+=root.vals[targetSum]
       
        post(root)
        return c[0]  
#ANSWER PREFIX SUM in tree
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; int:
        def preorder(node: TreeNode, curr_sum) -&gt; None:
            nonlocal count
            if not node:
                return 
            
            # current prefix sum
            curr_sum += node.val
            
            # here is the sum we're looking for
            if curr_sum == k:
                count += 1
            
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a path with sum k 
            # has occurred up to the current node
            count += h[curr_sum - k]
            
            # add the current sum into hashmap
            # to use it during the child nodes processing
            h[curr_sum] += 1
            
            # process left subtree
            preorder(node.left, curr_sum)
            # process right subtree
            preorder(node.right, curr_sum)
            
            # remove the current sum from the hashmap
            # in order not to use it during 
            # the parallel subtree processing
            h[curr_sum] -= 1
            
        count, k = 0, sum
        h = defaultdict(int)
        preorder(root, 0)
        return count       

#上面这个解决方法基于
class Solution:
    def subarraySum(self, nums, k):
        count = curr_sum = 0
        h = defaultdict(int)
        
        for num in nums:
            # current prefix sum
            curr_sum += num
            
            # situation 1:
            # continuous subarray starts 
            # from the beginning of the array
            if curr_sum == k:
                count += 1
            
            # situation 2:
            # number of times the curr_sum − k has occurred already, 
            # determines the number of times a subarray with sum k 
            # has occurred up to the current index
            count += h[curr_sum - k]
            
            # add the current sum
            h[curr_sum] += 1
                
        return count
</code></pre>
<p>我的解决方案是post order bottom up 扫，每个node存可以生成的pathsum值。答案是prefixsum。。</p>
<h1 id="438-find-all-anagrams-in-a-string-medium">438. Find All Anagrams in a String （Medium）</h1>
<p>Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.<br>
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br>
Input: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;<br>
Output: [0,6]<br>
Explanation:<br>
The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.<br>
The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</p>
<pre><code class="language-python">class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        if len(s)&lt;len(p): return []
        dicp=collections.Counter(p)
        lp=len(p)
        dic=dict()
        for i in range(lp):
            dic[s[i]]=dic.get(s[i],0)+1
        res=[]
        if dic==dicp: res.append(0)
        for i in range(lp,len(s)):
            #remove first
            dic[s[i-lp]]-=1
            if dic[s[i-lp]]==0:
                del  dic[s[i-lp]]
            #add last
            dic[s[i]]=dic.get(s[i],0)+1
            #
            if dic==dicp:
                res.append(i-lp+1)
        return res
            
#ANSWER 写的更简单
from collections import Counter
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count = Counter(p)
        s_count = Counter()
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[s[i]] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                if s_count[s[i - np]] == 1:
                    del s_count[s[i - np]]
                else:
                    s_count[s[i - np]] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output

#ANSWER
class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ns, np = len(s), len(p)
        if ns &lt; np:
            return []

        p_count, s_count = [0] * 26, [0] * 26
        # build reference array using string p
        for ch in p:
            p_count[ord(ch) - ord('a')] += 1
        
        output = []
        # sliding window on the string s
        for i in range(ns):
            # add one more letter 
            # on the right side of the window
            s_count[ord(s[i]) - ord('a')] += 1
            # remove one letter 
            # from the left side of the window
            if i &gt;= np:
                s_count[ord(s[i - np]) - ord('a')] -= 1
            # compare array in the sliding window
            # with the reference array
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output
</code></pre>
<p>sliding window保持counter dict和p一样就可以。。。</p>
<h1 id="font-colorred-439-ternary-expression-parser-medium-font"><font color='red'> 439. Ternary Expression Parser （Medium） </font></h1>
<p>Given a string expression representing arbitrarily nested ternary expressions, evaluate the expression, and return the result of it.<br>
You can always assume that the given expression is valid and only contains digits, '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers in the expression are one-digit numbers (i.e., in the range [0, 9]).<br>
The conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, 'T' or 'F'.</p>
<pre><code class="language-python">class Solution:
    def parseTernary(self, expression: str) -&gt; str:
        #思路用stack，而且从后向前iterate
        #T?a:b
        if not expression: return expression
        stack=[]
        for char in expression[::-1]:
            if stack and stack[-1]=='?':
                stack.pop() #?
                first=stack.pop()
                stack.pop() #:
                second=stack.pop()
                
                if char=='T':
                    stack.append(first)
                else:
                    stack.append(second)
            else:
                stack.append(char)
        #print(stack)
        return stack[-1]
</code></pre>
<p>T？（a）：（b） 形式，但a，b可以包含再包含。。。很难分辨哪个冒号是分界线。 用stack应该，看答案。关键是从后向前。</p>
<h1 id="font-colorred-440-k-th-smallest-in-lexicographical-order-hardfont"><font color='red'> 440. K-th Smallest in Lexicographical Order （Hard）</font></h1>
<p>Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].<br>
Example 1:<br>
Input: n = 13, k = 2<br>
Output: 10<br>
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.</p>
<pre><code class="language-python">class Solution:
    def findKthNumber(self, n: int, k: int) -&gt; int:
        class Trie:
            def __init__(self):
                self.children=collections.defaultdict(Trie)
                self.val=0
        trie=Trie()
        
        def insert(i):
            i=str(i)
            root=trie
            while i:
                cur=i[0]
                root=root.children[cur]
                root.val+=1
                i=i[1:]
        for i in range(1,n+1):
            insert(i)
        
        path=[]
        def search(k):
            current_rank=0
            children=trie.children
            i=0
            while current_rank&lt;k:
                key=sorted(children)[i]
                if children[key].val+current_rank&lt;k:
                    current_rank+=children[key].val
                    i+=1
                else:
                    path.append(key)
                    current_rank+=1
                    children=children[key].children
                    i=0
                
                
                 
                
                        
        search(k)
        return int(''.join(path))
        
        
        
        
#ANSWER
'''
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.
'''
def findKthNumber(self, n, k):
        cur = 1
        k = k - 1
        while k &gt; 0:
            steps = self.calSteps(n, cur)
            if steps &lt;= k:
                cur += 1
                k -= steps
            else:
                cur *= 10
                k -= 1
        return cur

    def calSteps(self, n, cur):
        steps = 0
        n1, n2 = cur, cur + 1
        while n1 &lt;= n:
            steps += min(n + 1, n2) - n1
            n1 *= 10
            n2 *= 10
        return steps
</code></pre>
<p>根据提示用了trie，思路是对的，但是写seasrch func时候卡住了，given k，what is the node positon of kth node。就算写出来也是TLE。。。看答案。</p>
<p>Main function<br>
Firstly, calculate how many steps curr need to move to curr + 1.</p>
<pre><code>if the steps &lt;= k, we know we can move to curr + 1, and narrow down k to k - steps.

else if the steps &gt; k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.
</code></pre>
<p>calSteps function</p>
<pre><code>how to calculate the steps between curr and curr + 1?
Here we come up a idea to calculate by level.
Let n1 = curr, n2 = curr + 1.
n2 is always the next right node beside n1's right most node (who shares the same ancestor &quot;curr&quot;)
(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).

so, if n2 &lt;= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.

else if n2 &gt; n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to steps.

organize this flow to &quot;steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;&quot;
</code></pre>
<p>Here is the code snippet:</p>
<p>public int findKthNumber(int n, int k) {<br>
int curr = 1;<br>
k = k - 1;<br>
while (k &gt; 0) {<br>
int steps = calSteps(n, curr, curr + 1);<br>
if (steps &lt;= k) {<br>
curr += 1;<br>
k -= steps;<br>
} else {<br>
curr *= 10;<br>
k -= 1;<br>
}<br>
}<br>
return curr;<br>
}<br>
//use long in case of overflow<br>
public int calSteps(int n, long n1, long n2) {<br>
int steps = 0;<br>
while (n1 &lt;= n) {<br>
steps += Math.min(n + 1, n2) - n1;<br>
n1 *= 10;<br>
n2 *= 10;<br>
}<br>
return steps;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-03]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-03/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-03/">
        </link>
        <updated>2022-03-02T16:44:15.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-421-maximum-xor-of-two-numbers-in-an-array-mediumfont"><font color='red'> 421. Maximum XOR of Two Numbers in an Array （Medium）</font></h1>
<p>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.</p>
<pre><code class="language-python"> class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        res=0
        L=len(bin(max(nums)))-2
        for i in range(L-1,-1,-1):
            res &lt;&lt;=1
            cur_xor = res | 1
            prefixes = {n &gt;&gt; i  for n in nums}
            res |= any(cur_xor^p in prefixes for p in prefixes)
        return res
        
class Solution:
    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        L = len(bin(max(nums))) - 2
        max_xor = 0
        
        for i in reversed(range(L)):
            max_xor &lt;&lt;= 1
            # Set comprehension is used for speed purposes
            # List comprehension is what most pythonic users are used too imo
            prefixes = {num &gt;&gt; i for num in nums}
            curr_xor = max_xor | 1
            
            for p in prefixes:
                # if p1 ^ p2 == curr_xor then
                # p1 ^ curr_xor == p2 ( p2 is in prefixes)
                if p ^ curr_xor in prefixes:
                    # Set the last bit to 1
                    max_xor |= 1
                    
            
        return max_xor
</code></pre>
<p>没思路，看答案。</p>
<h1 id="422-valid-word-square-easy">422. Valid Word Square (Easy)</h1>
<p>Given an array of strings words, return true if it forms a valid word square.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).</p>
<pre><code class="language-python">class Solution:
    def validWordSquare(self, words: List[str]) -&gt; bool:
        rows=len(words)
        cols=max(map(len,words))
        for i,w in enumerate(words):
            if len(w)!=cols:
                words[i]=w+'#'*(cols-len(w))
        if rows!=cols: return False   
        
        for row in range(rows):
            for col in range(cols):
                if row&gt;col:
                    if words[row][col]!=words[col][row]:
                        return False
        return True


public class Solution {
    public boolean validWordSquare(List&lt;String&gt; words) {
        if(words == null || words.size() == 0){
            return true;
        }
        int n = words.size();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;words.get(i).length(); j++){
                if(j &gt;= n || words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j))
                    return false;
            }
        }
        return true;
    }
}
</code></pre>
<p>有corner case。。。Java 答案更正确</p>
<h1 id="font-colorred-423-reconstruct-original-digits-from-english-medium-font"><font color='red'> 423. Reconstruct Original Digits from English （Medium) </font></h1>
<p>Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.</p>
<pre><code class="language-python">class Solution:
    def originalDigits(self, s: 'str') -&gt; 'str':
        # building hashmap letter -&gt; its frequency
        count = collections.Counter(s)
        
        # building hashmap digit -&gt; its frequency 
        out = {}
        # letter &quot;z&quot; is present only in &quot;zero&quot;
        out[&quot;0&quot;] = count[&quot;z&quot;]
        # letter &quot;w&quot; is present only in &quot;two&quot;
        out[&quot;2&quot;] = count[&quot;w&quot;]
        # letter &quot;u&quot; is present only in &quot;four&quot;
        out[&quot;4&quot;] = count[&quot;u&quot;]
        # letter &quot;x&quot; is present only in &quot;six&quot;
        out[&quot;6&quot;] = count[&quot;x&quot;]
        # letter &quot;g&quot; is present only in &quot;eight&quot;
        out[&quot;8&quot;] = count[&quot;g&quot;]
        # letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;
        out[&quot;3&quot;] = count[&quot;h&quot;] - out[&quot;8&quot;]
        # letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;
        out[&quot;5&quot;] = count[&quot;f&quot;] - out[&quot;4&quot;]
        # letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;
        out[&quot;7&quot;] = count[&quot;s&quot;] - out[&quot;6&quot;]
        # letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;
        out[&quot;9&quot;] = count[&quot;i&quot;] - out[&quot;5&quot;] - out[&quot;6&quot;] - out[&quot;8&quot;]
        # letter &quot;n&quot; is present in &quot;one&quot;, &quot;nine&quot;, and &quot;seven&quot;
        out[&quot;1&quot;] = count[&quot;n&quot;] - out[&quot;7&quot;] - 2 * out[&quot;9&quot;]

        # building output string
        output = [key * out[key] for key in sorted(out.keys())]
        return &quot;&quot;.join(output)
</code></pre>
<p>直接做会出现是否要再次使用当前数字然后继续，或者直接使用下个数字，当前数字不重复使用的问题。<br>
解决方法。。。醉了</p>
<pre><code>Letter &quot;z&quot; is present only in &quot;zero&quot;.
Letter &quot;w&quot; is present only in &quot;two&quot;.
Letter &quot;u&quot; is present only in &quot;four&quot;.
Letter &quot;x&quot; is present only in &quot;six&quot;.
Letter &quot;g&quot; is present only in &quot;eight&quot;.

Hence there is a good way to count even numbers.
</code></pre>
<p>That is actually the key how to count 3s, 5s and 7s since some letters are present only in one odd and one even number (and all even numbers has already been counted) :</p>
<pre><code>Letter &quot;h&quot; is present only in &quot;three&quot; and &quot;eight&quot;.
Letter &quot;f&quot; is present only in &quot;five&quot; and &quot;four&quot;.
Letter &quot;s&quot; is present only in &quot;seven&quot; and &quot;six&quot;.
</code></pre>
<p>Now one needs to count 9s and 1s only, and the logic is basically the same :</p>
<pre><code>Letter &quot;i&quot; is present in &quot;nine&quot;, &quot;five&quot;, &quot;six&quot;, and &quot;eight&quot;.
Letter &quot;n&quot; is present in &quot;one&quot;, &quot;seven&quot;, and &quot;nine&quot;.
</code></pre>
<h1 id="font-colorred-424-longest-repeating-character-replacement-mediumfont"><font color='red'> 424. Longest Repeating Character Replacement （Medium）</font></h1>
<p>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.<br>
Return the length of the longest substring containing the same letter you can get after performing the above operations.</p>
<pre><code class="language-python">class Solution:
    def characterReplacement(self, s: str, k: int) -&gt; int:
        #   p
        # AABCBBA  k=2
        #       p
        #
        l = len(s)
        count = [0]*26
        start = 0
        maxCount = 0
        maxLength = 0
        for end in range(l):
            count[ord(s[end]) - ord('A')]+=1
            maxCount = max(maxCount, count[ord(s[end]) - ord('A')])
            while end - start + 1 - maxCount &gt; k:
                count[ord(s[start]) - ord('A')]-=1
                start+=1
            
            maxLength = max(maxLength, end - start + 1);
        
        return maxLength
</code></pre>
<p>感觉用dp的。。 感觉不对好像，提示是用two pointer sliding window， 不死磕看答案。<br>
end-start+1 = size of the current window<br>
maxCount = largest count of a single, unique character in the current window<br>
The main equation is: end-start+1-maxCount</p>
<h1 id="font-colorblue-425-word-squares-hard-font"><font  color='blue'> 425. Word Squares (Hard) </font></h1>
<p>Given an array of unique strings words, return all the word squares you can build from words. The same word from words can be used multiple times. You can return the answer in any order.<br>
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).<br>
For example, the word sequence [&quot;ball&quot;,&quot;area&quot;,&quot;lead&quot;,&quot;lady&quot;] forms a word square because each word reads the same both horizontally and vertically.</p>
<pre><code class="language-python">class Solution:
    def wordSquares(self, words: List[str]) -&gt; List[List[str]]:
        # a b c d
        # b d e f
        # c e g h 
        # d f h k
        
        # select abcd
        # next must select b
        # select abcd
        #        bdef
        # next must select ce
        # select abcd
        #        bdef
        #        cegh
        # next must selct dfh
        # select abcd
        #        bdef
        #        cegh
        #        dfhk
        #
        # need a trie tree to find prefix is valid or not
        # if valid prefix, for childern path, need to explore all possible combinations using bt
        
        class Trie:
            def __init__(self):
                self.children=dict()
                self.words=set()
                
            def search(self,string):
                if not string: return True
                if string[0] not in self.children:
                    return False
                return self.children[string[0]].search(string[1:])
            
            def getwords(self,string):
                if string is False: return True
                if len(string)==1:
                    return self.children[string].words
                
                return self.children[string[0]].getwords(string[1:])
                
                
        trie=Trie()
        #insert words to trie
        for word in words:
            cur=trie
            for w in word:
                if w not in cur.children:
                    cur.children[w] = Trie()
                cur.words.add(word)
                cur=cur.children[w]
            
        
        res=[]
        size=len(words[0])
        
        def bt(tmp,words):
            #backtracking to generate all possible word squares
            if len(tmp)==size:
                res.append(tmp[:])
                return
            if not words: return
            
            for word in words:
                tmp.append(word)
                level=len(tmp)
                searchkey=''.join([e[level] for e in tmp]) if level&lt;size else False
                if trie.search(searchkey):
                    validwords=trie.getwords(searchkey)
                    bt(tmp,validwords)
                tmp.pop()
        
        bt([],set(words))
        
        return res

#ANSWER is faster...
class Solution:
    def wordSquares(self, words: 'List[str]') -&gt; 'List[List[str]]':
        
        dic= collections.defaultdict(list)
        n=len(words[0])
        for word in words:
            for i in range(1,n):
                key=word[:i]
                dic[key].append(word)
        
        res=[]        
        def build(squre):
            #print(len(squre))
            if len(squre)==n:
                res.append(squre)
                return
            #print(n,len(squre),squre)
            for word in dic[''.join(list(zip(*squre))[len(squre)])]:
                new=squre[:]
                new.append(word)
                build(new)
        
        for word in words:
            build([word])
        
        return res
</code></pre>
<p>很明显backtracking问题。。。unbelievable 做出来了。。。</p>
<h1 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list-medium">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium)</h1>
<p>Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.<br>
You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br>
We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
&quot;&quot;&quot;

class Solution:
    def treeToDoublyList(self, root: 'Optional[Node]') -&gt; 'Optional[Node]':
        if not root: return root
        stack=[]
        head=None
        pre=None
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            
            cur=stack.pop()
            if head is None: head=cur
            cur.left=pre
            if pre:
                pre.right=cur 
            pre=cur
            
            root=cur.right
        
        
        #print(head.val, pre.val)
        
        head.left=pre
        pre.right=head
        
        return head


#ANSER RECURSION METHOD
class Solution:
    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':
        def helper(node):
            &quot;&quot;&quot;
            Performs standard inorder traversal:
            left -&gt; node -&gt; right
            and links all nodes into DLL
            &quot;&quot;&quot;
            nonlocal last, first
            if node:
                # left
                helper(node.left)
                # node 
                if last:
                    # link the previous node (last)
                    # with the current one (node)
                    last.right = node
                    node.left = last
                else:
                    # keep the smallest node
                    # to close DLL later on
                    first = node        
                last = node
                # right
                helper(node.right)
        
        if not root:
            return None
        
        # the smallest (first) and the largest (last) nodes
        first, last = None, None
        helper(root)
        # close DLL
        last.right = first
        first.left = last
        return first
</code></pre>
<p>corner case 要想清楚。。 而且node要call right left时候node必须存在。</p>
<h1 id="427-construct-quad-tree-medium">427. Construct Quad Tree （Medium）</h1>
<p>Given a n * n matrix grid of 0's and 1's only. We want to represent the grid with a Quad-Tree.<br>
Return the root of the Quad-Tree representing the grid.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
&quot;&quot;&quot;

class Solution:
    def construct(self, grid: List[List[int]]) -&gt; 'Node':
        size=len(grid)
        if len({e for row in grid for e in row})==1:
            val=grid[0][0]==1
            isLeaf=True
            topLeft=None
            topRight=None
            bottomLeft=None
            bottomRight=None
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)
        else:
            isLeaf=False
            val=True
            topLeft=self.construct([row[:size//2] for row in grid[:size//2]])
            topRight=self.construct([row[size//2:] for row in grid[:size//2]])
            bottomLeft=self.construct([row[:size//2] for row in grid[size//2:]])
            bottomRight=self.construct([row[size//2:] for row in grid[size//2:]])
            return Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight)

</code></pre>
<h1 id="font-colorred-428-serialize-and-deserialize-n-ary-tree-hard-font"><font color='red'> 428. Serialize and Deserialize N-ary Tree (Hard) </font></h1>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>
Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Codec:
    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        &quot;&quot;&quot;
        r=[]
        if not root: return r
        q=[root]
        while q:
            node=q.pop(0)
            if node !=',':
                r.append(str(node.val))
                for child in node.children:
                    q.append(child)
                q.append(',')
            else:
                r.append(',')
                
        return '#'.join(r)
        
 
    
    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        &quot;&quot;&quot;
        if not data: return None
        pieces=data.split('#')
        root = Node(int(pieces[0]), [])
        idx = 1
        q=[root]
        while q:
            node=q.pop(0)
            while pieces[idx] != ',':
                child=Node(int(pieces[idx]), [])
                node.children.append(child)
                q.append(child)
                idx += 1
            idx += 1
        return root
# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
</code></pre>
<p>first try failed， 若val可以重复，以val为key找parent的方法不再适用。 看答案。</p>
<h1 id="429-n-ary-tree-level-order-traversal-medium">429. N-ary Tree Level Order Traversal (Medium)</h1>
<p>Given an n-ary tree, return the level order traversal of its nodes' values.<br>
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:
        if not root: return []
        q=[root]
        res=[]
        while q:
            l=len(q)
            level=[]
            for _ in range(l):
                cur=q.pop(0)
                level.append(cur.val)
                for child in cur.children:
                    q.append(child)
            res.append(level)
        return res

#RECURSION ANSWER
class Solution:
    def levelOrder(self, root: 'Node') -&gt; List[List[int]]:

        def traverse_node(node, level):
            if len(result) == level:
                result.append([])
            result[level].append(node.val)
            for child in node.children:
                traverse_node(child, level + 1)

        result = []

        if root is not None:
            traverse_node(root, 0)
        return result
</code></pre>
<p>BFS</p>
<h1 id="430-flatten-a-multilevel-doubly-linked-list-medium">430. Flatten a Multilevel Doubly Linked List (Medium)</h1>
<p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.<br>
Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.<br>
Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;

class Solution:
    def flatten(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':
        
        stack=[]
        cur=head
        pre=None
        while cur or stack:
            if not cur:
                cur=stack.pop()
                cur.prev=pre
                pre.next=cur
                
            while cur.child:
                if cur.next:
                    stack.append(cur.next)
                curnext=cur.child
                curchild=cur.child
                cur.child=None
                curchild.prev=cur
                cur.next=curnext
                cur=curnext
               
            if not cur.child:
                pre=cur
                cur=cur.next
                
            
        return head


#

class Solution:
    def flatten(self, head: 'Node') -&gt; 'Node':
        
        #DFS...
        curr=head
        tempStack = []
        while curr:
            if curr.child:
                if curr.next:
                    tempStack.append(curr.next);
                curr.next, curr.child.prev, curr.child = curr.child, curr, None;
            if not curr.next and len(tempStack):
                temp = tempStack.pop();
                temp.prev, curr.next = curr, temp
            curr = curr.next
        return head


 #ANSWER PREORDER   child is left tree next is right tree
 &quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;
class Solution(object):

    def flatten(self, head):
        if not head:
            return head

        # pseudo head to ensure the `prev` pointer is never none
        pseudoHead = Node(None, None, head, None)
        self.flatten_dfs(pseudoHead, head)

        # detach the pseudo head from the real head
        pseudoHead.next.prev = None
        return pseudoHead.next


    def flatten_dfs(self, prev, curr):
        &quot;&quot;&quot; return the tail of the flatten list &quot;&quot;&quot;
        if not curr:
            return prev

        curr.prev = prev
        prev.next = curr

        # the curr.next would be tempered in the recursive function
        tempNext = curr.next
        tail = self.flatten_dfs(curr, curr.child)
        curr.child = None
        return self.flatten_dfs(tail, tempNext)        

#preorder interative 
class Solution(object):
    def flatten(self, head):
        if not head:
            return

        pseudoHead = Node(0,None,head,None)
        prev = pseudoHead

        stack = []
        stack.append(head)

        while stack:
            curr = stack.pop()

            prev.next = curr
            curr.prev = prev

            if curr.next:
                stack.append(curr.next)
 
            if curr.child:
                stack.append(curr.child)
                # don't forget to remove all child pointers.
                curr.child = None

            prev = curr
        # detach the pseudo head node from the result.
        pseudoHead.next.prev = None
        return pseudoHead.next
</code></pre>
<p>差点没做出来 写的比答案复杂</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-02]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-02/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-02/">
        </link>
        <updated>2022-03-02T09:50:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-411-minimum-unique-word-abbreviation-hardfont"><font color='red'> 411. Minimum Unique Word Abbreviation （Hard）</font></h1>
<p>A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
Note that &quot;s55n&quot; (&quot;s ubsti tutio n&quot;) is not a valid abbreviation of &quot;substitution&quot; because the replaced substrings are adjacent.<br>
The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation &quot;s10n&quot; has a length of 3 (2 letters + 1 substring) and &quot;su3i1u2on&quot; has a length of 9 (6 letters + 3 substrings).<br>
Given a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.</p>
<pre><code class="language-python">class Solution:
    def minAbbreviation(self, target: str, dictionary: List[str]) -&gt; str:

        def abbr(target, num):
            word, count = '', 0
            for w in target:
                if num &amp; 1 == 1:
                    if count:
                        word += str(count)
                        count = 0
                    word += w
                else:
                    count += 1

                num &gt;&gt;= 1
            if count:
                word += str(count)
            return word

        m = len(target)

        # Figure out the different bits for a same length word in the dictionary
        diffs = []
        for word in dictionary:
            if len(word) != m:
                continue

            # The encoding is opposite
            bits = 0
            for i, char in enumerate(word):
                if char != target[i]:
                    bits += 2 ** i
            diffs.append(bits)

        # No word in dictionary has same length, return the shortest
        if not diffs:
            return str(m)        

        abbrs = []
        for i in range(2 ** m):
            # This abbreviation at least has one word different to every words in the dictionary
            if all(d &amp; i for d in diffs):
                abbrs.append(abbr(target, i))

        return min(abbrs, key=lambda x: len(x))
</code></pre>
<p>思路是bit manipulation。 1）找出在字典里同长度但字符和target不同的bit。 然后所有的encoding是0到2^m， 所以  all（encoding&amp;dif for dif in diffs）  encoding的bit能和所有dif bits有交集则是个可能的候选，把 encoding bit转换为string然后加入到abbrs中，最后找出长度最小的abbrs就可以了。</p>
<h1 id="412-fizz-buzz-easy">412. Fizz Buzz （Easy）</h1>
<p>Given an integer n, return a string array answer (1-indexed) where:<br>
answer[i] == &quot;FizzBuzz&quot; if i is divisible by 3 and 5.<br>
answer[i] == &quot;Fizz&quot; if i is divisible by 3.<br>
answer[i] == &quot;Buzz&quot; if i is divisible by 5.<br>
answer[i] == i (as a string) if none of the above conditions are true.</p>
<pre><code class="language-python">class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        def helper(n):
            if n%3==0 and n%5==0:
                return 'FizzBuzz'
            elif n%3==0:
                return 'Fizz'
            elif n%5==0:
                return 'Buzz'
            else:
                return str(n)
        
        return [helper(i) for i in range(1,n+1)]
</code></pre>
<h1 id="413-arithmetic-slices-medium">413. Arithmetic Slices (Medium)</h1>
<p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.<br>
For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.<br>
Given an integer array nums, return the number of arithmetic subarrays of nums.<br>
A subarray is a contiguous subsequence of the array.</p>
<pre><code class="language-python">class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        #   [1,3,5,7,9]
        # dp 0 0 1 
        #          2
        #            3  
        # dp is the number of subarays ending in ith
        if len(nums)&lt;3: return 0
        dp=[0]*len(nums)
        if nums[0]-nums[1]==nums[1]-nums[2]:
            dp[2]=1
        
        if len(nums)==3: return dp[2]
        for i in range(3,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp[i]=1+dp[i-1]
        return sum(dp)
#ANSWER
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int:
        dp=0
        res=0
        for i in range(2,len(nums)):
            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:
                dp=1+dp
                res+=dp
            else:
                dp=0
        return res        
</code></pre>
<p>思路和答案一致，DP解决。</p>
<h1 id="414-third-maximum-number-easy">414. Third Maximum Number （Easy）</h1>
<p>Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.</p>
<pre><code class="language-python">class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        if len(set(nums))&lt;3: return max(nums)
        if len(set(nums))==3: return sorted(set(nums))[0]
        res=[]
        for n in set(nums):
            heapq.heappush(res,-n)
        heapq.heappop(res)
        heapq.heappop(res)
        return -heapq.heappop(res)

#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        maximums = set()
        for num in nums:
            maximums.add(num)
            if len(maximums) &gt; 3:
                maximums.remove(min(maximums))
        if len(maximums) == 3:
            return min(maximums)
        return max(maximums)
#
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        min_heap = []
        for num in nums:
            if num in min_heap:
                continue
            if len(min_heap) &lt; 3:
                heapq.heappush(min_heap, num)
            elif len(min_heap) == 3:
                heapq.heappushpop(min_heap, num)        
        
        if len(min_heap) == 3:
            return heapq.heappop(min_heap)
        else:
            while min_heap:
                result = heapq.heappop(min_heap)
            return result

#3pointer...
class Solution:
    def thirdMax(self, nums: List[int]) -&gt; int:
        max=float('-inf')
        max2=float('-inf')
        max3=float('-inf')
        s=set()
        for n in nums:
            if n in s: continue
            if n&gt;max:
                max3=max2
                max2=max
                max=n
            elif n&gt;max2:
                max3=max2
                max2=n
            elif n&gt;max3:
                max3=n
                
            s.add(n)
         
        return max3 if len(s)&gt;=3 else max
</code></pre>
<h1 id="415-add-strings-easy">415. Add Strings (Easy)</h1>
<p>Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.<br>
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.</p>
<pre><code class="language-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        
        n1=[int(e) for e in num1]
        n2=[int(e) for e in num2]
        res=[]
        carry=0
        while n1 or n2:
            a=n1.pop() if n1 else 0
            b=n2.pop() if n2 else 0
            val=(a+b+carry)%10
            carry=(a+b+carry)//10
            res.append(val)
        if carry:
            res.append(carry)
        
        return ''.join(map(str,res[::-1]))

</code></pre>
<h1 id="font-colorred-416-partition-equal-subset-sum-medium-font"><font color='red'> 416. Partition Equal Subset Sum (Medium) </font></h1>
<p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<pre><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        @lru_cache(None)
        def dfs(n,subset_sum):
            if subset_sum==0:
                return True
            if n==0 or subset_sum&lt;0:
                return False
            result = dfs(n-1,subset_sum-nums[n-1]) or dfs(n-1,subset_sum)
            return result
        
        total_sum=sum(nums)
        if total_sum%2==1: return False
        subset_sum=total_sum//2
        n=len(nums)
        return dfs(n,subset_sum)
###DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2
        n = len(nums)

        # construct a dp table of size (n+1) x (subset_sum + 1)
        # dp[n][subsetsum] up to nth num can sum to subsetsum
        dp = [[False] * (subset_sum + 1) for _ in range(n + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            curr = nums[i - 1]
            for j in range(subset_sum + 1):
                if j &lt; curr:
                    # subset_sum&lt; nums[i-1]   so, subsetsum not include nums[i-1]
                    dp[i][j] = dp[i - 1][j]
                else:
                    # could not include or include nums[i-1] 
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - curr]
        return dp[n][subset_sum]

#DP
class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # find sum of array elements
        total_sum = sum(nums)

        # if total_sum is odd, it cannot be partitioned into equal sum subsets
        if total_sum % 2 != 0:
            return False
        subset_sum = total_sum // 2

        # construct a dp table of size (subset_sum + 1)
        dp = [False] * (subset_sum + 1)
        dp[0] = True
        for curr in nums:
            for j in range(subset_sum,curr-1,-1):
                dp[j] = dp[j] or dp[j - curr]

        return dp[subset_sum]
</code></pre>
<p>没思路。。。 有两种情况，1) num in subset_sum  2) num not in subset_sum 所以dfs</p>
<h1 id="417-pacific-atlantic-water-flow-medium">417. Pacific Atlantic Water Flow （Medium）</h1>
<pre><code class="language-python">class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -&gt; List[List[int]]:
        
        #two bfs from boundy if hight is higher..
        
        visited=set()
        q=[]
        m=len(heights)
        n=len(heights[0])
        for row in range(m):
            visited.add((row,0))
            q.append((row,0))
        for col in range(1,n):
            visited.add((0,col))
            q.append((0,col))
        
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited and heights[row][col]&gt;=heights[r][c]:
                    visited.add((row,col))
                    q.append((row,col))
        
        
        visited2=set()
        q=[]
        for row in range(m):
            visited2.add((row,n-1))
            q.append((row,n-1))
        for col in range(n-1):
            visited2.add((m-1,col))
            q.append((m-1,col))
        while q:
            r,c = q.pop()
            for row,col in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if m&gt;row&gt;=0  and n&gt;col&gt;=0 and (row,col) not in visited2 and heights[row][col]&gt;=heights[r][c]:
                    visited2.add((row,col))
                    q.append((row,col))
        
        return visited&amp;visited2

</code></pre>
<p>思路，从边界处做两次BFS，相交地方就是结果。</p>
<h1 id="font-colorred-418-sentence-screen-fitting-medium-font"><font color='red'> 418. Sentence Screen Fitting （Medium） </font></h1>
<p>Given a rows x cols screen and a sentence represented as a list of strings, return the number of times the given sentence can be fitted on the screen.<br>
The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.</p>
<pre><code class="language-python">#TIME LIMIT EXCEEDED
class Solution:
    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        sentence=[len(w) for w in sentence]
        r=0
        c_row=0
        res=0
        i=0
        while r&lt;rows:
            
            l=sentence[i]
            #print(r,c_row,l)
            if c_row+l&lt;cols:
                c_row = c_row+l+1
                if c_row==cols:
                    c_row=0
                    r+=1
                    if r&gt;=rows:
                        if i==len(sentence)-1: res+=1
                        break
            elif c_row+l==cols:
                c_row=0
                r+=1
            elif c_row+l&gt;cols:
                c_row=l+1
                r+=1
                if r&gt;=rows:
                    break
                #print('#',c_row,r)
            if i==len(sentence)-1: res+=1
            i=(i+1)%len(sentence)
        return res

#ANSWER
#case 1: sentence_ptr at the end of the screen falls on space in the sentence. Go to the next letter sentence_ptr+1 in the next row of the screen.
#case 2: sentence_ptr at the end of the screen falls on the last letter of a word. We skip the space in the sentence as the last letter coincides with the screen end: sentence_ptr+2
#case 3: sentence_ptr points in the middle of a word at the end of the screen: roll back sentence_ptr till there's a space in the sentence. his corresponds to starting to fill the word in the next row, as it does not fit into the current. sentence_ptr &gt; 0 is needed for the case when a word is longer than cols; sentence_ptr will be &lt; len(s)

#Code with the comments and the variable change:

    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -&gt; int:
        s = ' '.join(sentence) + ' '
        sentence_ptr = 0
        for i in range(rows):
            sentence_ptr += cols - 1
            # case 1: sentence_ptr at the end of screen falls exactly on the space
            if s[sentence_ptr % len(s)] == ' ':
                sentence_ptr += 1
            # case 2: sentence_ptr at the end of screen coincides with the last letter of a word (next is space)
            elif s[(sentence_ptr + 1) % len(s)] == ' ':
                sentence_ptr += 2
            else:
                # case 3: sentence_ptr at the end of screen falls in the middle of a word; roll back
                while sentence_ptr &gt; 0 and s[(sentence_ptr - 1) % len(s)] != ' ':
                    sentence_ptr -= 1
        return sentence_ptr // len(s)

</code></pre>
<p>初次尝试是TLE。。。 直接暴力解即使考虑全了cornercase也还是过不了。<br>
答案思路，先组成一个句子 s=‘ ‘.join（sentence）+’‘。  定义sentence_ptr 每过一行，sentence_ptr+= cols-1 这时候分3种情况， 1） 如果恰巧sentence_ptr落的位置是空格，senternce_ptr+1 2)如果 sentence_ptr+1位置是空格，sentence_ptr+=2 3)sentence_ptr落在字符上，那么sentence_ptr得往回缩直到遇到空格。</p>
<h1 id="419-battleships-in-a-board-medium">419. Battleships in a Board （Medium）</h1>
<p>Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.<br>
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p>
<pre><code class="language-python">class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
        
        m=len(board)
        n=len(board[0])
        
        visited=set()
        
        
        def dfs(row,col):
            #print(row,col)
            if row&lt;0 or col&lt;0 or row&gt;=m or col&gt;=n or (row,col) in visited: return
            visited.add((row,col))
            if board[row][col]=='X':
                board[row][col]='.'
                dfs(row+1,col)
                dfs(row-1,col)
                dfs(row,col+1)
                dfs(row,col-1)

        res=0
        for i in range(m):
            for j in range(n):
                if board[i][j]=='X':
                    res+=1
                    dfs(i,j)
                    
        
        return res
#ANSWER
class Solution:
    def countBattleships(self, board: List[List[str]]) -&gt; int:
 
        total = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X':
                    flag = 1
                    if j &gt; 0 and board[i][j-1] == 'X': flag = 0
                    if i &gt; 0 and board[i-1][j] == 'X': flag = 0
                    total += flag
        return total
</code></pre>
<p>答案没用DFS or BFS 但是很完美的解决了，因为只有横的竖的是叫做Battleships，所以如果不是左上角的X就不是一个qualified battlesships。</p>
<h1 id="font-colorred-420-strong-password-checker-hardfont"><font color='red'> 420. Strong Password Checker （Hard）</font></h1>
<p>A password is considered strong if the below conditions are all met:<br>
It has at least 6 characters and at most 20 characters.<br>
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.<br>
It does not contain three repeating characters in a row (i.e., &quot;...aaa...&quot; is weak, but &quot;...aa...a...&quot; is strong, assuming other conditions are met).<br>
Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.<br>
In one step, you can:<br>
Insert one character to password,<br>
Delete one character from password, or<br>
Replace one character of password with another character.</p>
<pre><code class="language-python">class Solution:
    def strongPasswordChecker(self,s: str) -&gt; int:
        
        missing_type = 3
        if any('a' &lt;= c &lt;= 'z' for c in s): missing_type -= 1
        if any('A' &lt;= c &lt;= 'Z' for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p &lt; len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p &lt; len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) &lt; 6:
            return max(missing_type, 6 - len(s))
        elif len(s) &lt;= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return delete + max(missing_type, change)
</code></pre>
<p>看到这题就头疼~，直接看答案了。<br>
当有20+chars，必须delete=len（s）-20.但是我们能用这些delete中的一部分来处理3char rule violation。<br>
1） aaa ... 这种violation可以del最后一个a。所以， 需要从change里减去这些del。change -= min(delete, one)<br>
2）aaaa ... 这种violation可以del最后2个a。因为已经用了1）中的deletions，所以需要调整,   min(max(delete - one, 0), two * 2) // 2  意思是，如果残留 max(delete - one, 0) 个dels，那么，用这些dels来处理case2的violation。 因为必须del 2 chars  to resolve each violation, 所以只能用 dels // 2<br>
3）aaaaa ...这种 violation可以del最后3个a。   max(delete - one - 2 * two, 0) // 3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2022-03-01]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2022-03-01/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2022-03-01/">
        </link>
        <updated>2022-03-01T14:53:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>中间搞laser project浪费了不少时间~~~ 争取3月刷300到700. system design 也该看了。</p>
<h1 id="font-colorred-401-binary-watch-easy-font"><font color='red'> 401. Binary Watch (Easy) </font></h1>
<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.<br>
Given an integer turnedOn which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.</p>
<pre><code class="language-python">class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        return ['{}:{}'.format(h, str(m).zfill(2))  for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == turnedOn]

#Backtracking way of answer it
class Solution:
    def readBinaryWatch(self, turnedOn: int) -&gt; List[str]:
        res=set()
        nums1=[8,4,2,1]
        nums2=[32,16,8,4,2,1]
        
        
        def generateDigs(nums,count):
            res=set()
            def helper(c,pos,sum_):
                if c==0:
                    res.add(sum_)
                    return
                for i in range(pos,len(nums)):
                    helper(c-1,i+1,sum_+nums[i])
            helper(count,0,0)
            return res
        
        for i in range(turnedOn+1):
            list1=generateDigs(nums1,i)
            list2=generateDigs(nums2,turnedOn-i)
            for num1 in list1:
                if num1&gt;=12: continue
                for num2 in list2:
                    if num2&gt;=60: continue
                    res.add('{}:{}'.format(num1,str(num2).zfill(2)))
        return res
</code></pre>
<p>是一个backtracking问题， 写起来难度很大，然而是一个easy问题。。。直接暴力解即可。<br>
但用backtracking就是一个比较难的问题了。</p>
<h1 id="font-colorred-402-remove-k-digits-mediumfont"><font color='red'> 402. Remove K Digits （Medium）</font></h1>
<p>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</p>
<pre><code class="language-python">class Solution:
    def removeKdigits(self, num: str, k: int) -&gt; str:
        #
        # 2     1    4
        # left  cur
        # if cur&lt;left, we know left must be removed
        
        stack=[]
        for n in num:
            while k and stack and n&lt;stack[-1]:
                stack.pop()
                k-=1
            stack.append(n)
        
        #truncate remaining k digits at the end
        # if k==0 return entire list
        final_stack=stack[:-k] if k else stack
        
        return ''.join(final_stack).lstrip('0') or '0'
</code></pre>
<p>greedy+stack 这个方法第一次比较难想到，需要考虑corner case。</p>
<h1 id="403-frog-jump-hard">403. Frog Jump （Hard）</h1>
<p>A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.<br>
Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.<br>
If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.</p>
<pre><code class="language-python">class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
       
        dp=[False]*len(stones)
        dic={s:i for i,s in enumerate(stones)}
        
        @lru_cache(None)
        def can(ith,k):
            if k&lt;=0: return
            if ith==0:
                dp[0]=True
                if stones[0]+1 in dic:
                    jth=dic[stones[0]+1] 
                    can(jth,1)
            else:
                for i,step in enumerate([k+1,k,k-1]):
                    if stones[ith]+step in dic:
                        stone_ind=dic[stones[ith]+step]
                        dp[stone_ind]=True
                        can(stone_ind,[k+1,k,k-1][i])
            
        can(0,1)
        return dp[-1]

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        dic=dict()
        for s in stones:
            dic[s]=set()
        dic[0].add(0)
        
        for i in range(len(stones)):
            for k in dic[stones[i]]:
                for step in range(k-1,k+2):
                    if step&gt;0 and stones[i]+step in dic:
                        dic[stones[i]+step].add(step)
                        
        return len(dic[stones[-1]])&gt;0

#ANSWER
class Solution:
    def canCross(self, stones: List[int]) -&gt; bool:
        
        seen = set()
        stoneSet = set(stones)
        end = stones[-1]
        stack = [(0, 0)]
        while len(stack) &gt; 0:
            loc, steps = stack.pop()
            if (loc, steps) in seen:
                continue
            seen.add((loc, steps))
            if loc == end:
                return True
            elif loc &lt; end:
                for i in range(steps-1, steps+2):
                    if i &lt;= 0:
                        continue
                    if loc + i in stoneSet:
                        stack.append((loc+i, i))
        return False
</code></pre>
<p>没想到做出来了。。。。。dp  with mem。。。<br>
答案更好。答案3思路： each node has 3 children. The goal is to check if we can reach to the end along the edges. We can do it with a Depth First Search with a Hashtable(to avoid redundant calculation)</p>
<h1 id="404-sum-of-left-leaves-easy">404. Sum of Left Leaves （Easy）</h1>
<p>Given the root of a binary tree, return the sum of all left leaves.</p>
<pre><code class="language-python">class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:
        if not root: return 0
        if root.left and root.left.left is None and root.left.right is None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        return  self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)
</code></pre>
<h1 id="405-convert-a-number-to-hexadecimal-easy">405. Convert a Number to Hexadecimal (Easy)</h1>
<p>Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.<br>
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>
<pre><code class="language-python">class Solution:
    def toHex(self, num: int) -&gt; str:
        if num&lt;0:
            num=4294967295 +num+1
        map=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']
        res=''
        while num:
            ind=num%16
            res+=map[ind]
            num=num//16
        #26=1a  16 11
        return res[::-1]   if res else '0'  
</code></pre>
<h1 id="font-colorred-406-queue-reconstruction-by-height-medium-font"><font color='red'> 406. Queue Reconstruction by Height (Medium) </font></h1>
<p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.<br>
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p>
<pre><code class="language-python">class Solution:
    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        output = []
        for p in people:
            output.insert(p[1], p)
        return output

</code></pre>
<p>思路：最高的sort完了，插入次高的，插入位置？</p>
<h1 id="font-colorred-407-trapping-rain-water-ii-hardfont"><font color='red'> 407. Trapping Rain Water II （Hard）</font></h1>
<p>Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.</p>
<pre><code class="language-python">class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -&gt; int:
        
        class Cell:
            def __init__(self,row,col,h):
                self.row=row
                self.col=col
                self.h=h
            
            def __lt__(self,other):
                return self.h&lt;other.h
            
        
        if not heightMap or len(heightMap)==0 or len(heightMap[0])==0:
            return 0
        
        q=[]
        m=len(heightMap)
        n=len(heightMap[0])
        visited=[[False]*n for _ in range(m)]
        #Initially, add all the Cells which are on borders to the queue.
        for i in range(m):
            visited[i][0]=True
            visited[i][n-1]=True
            heapq.heappush(q, Cell(i,0,heightMap[i][0]))
            heapq.heappush(q, Cell(i,n-1,heightMap[i][n-1]))
        for j in range(n):
            visited[0][j]=True
            visited[m-1][j]=True
            heapq.heappush(q, Cell(0,j,heightMap[0][j]))
            heapq.heappush(q, Cell(m-1,j,heightMap[m-1][j]))
        #from the borders, pick the shortest cell visited and check its neighbors: if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped add all its neighbors to the queue.
        dirs = [[-1,0],[1,0],[0,-1],[0,1]]
        res=0
        while q:
            cur_cell=heapq.heappop(q)
            for dir in dirs:
                row=cur_cell.row+dir[0]
                col=cur_cell.col+dir[1]
                if row&gt;=0 and row&lt;m and col&gt;=0 and col&lt;n and not visited[row][col]:
                    visited[row][col]=True
                    res+=max(0,cur_cell.h-heightMap[row][col])
                    heapq.heappush(q,Cell(row,col,max(cur_cell.h,heightMap[row][col])))
                    
        
        return res
                    
#ANSWER
class Solution(object):
    def trapRainWater(self, heightMap):
        if not heightMap or not heightMap[0]:
            return 0
        
        import heapq    
        m, n = len(heightMap), len(heightMap[0])
        heap = []
        visited = [[0]*n for _ in xrange(m)]

        # Push all the block on the border into heap
        for i in xrange(m):
            for j in xrange(n):
                if i == 0 or j == 0 or i == m-1 or j == n-1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = 1
        
        result = 0
        while heap:
            height, i, j = heapq.heappop(heap)    
            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and not visited[x][y]:
                    result += max(0, height-heightMap[x][y])
                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))
                    visited[x][y] = 1
        return result      
        
</code></pre>
<p>思路：边界最低的板子是开始点，BFS，如果邻居低说明能存水，做计算，然后埋土。</p>
<h1 id="408-valid-word-abbreviation-easy">408. Valid Word Abbreviation （Easy）</h1>
<p>A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.<br>
For example, a string such as &quot;substitution&quot; could be abbreviated as (but not limited to):<br>
&quot;s10n&quot; (&quot;s ubstitutio n&quot;)<br>
&quot;sub4u4&quot; (&quot;sub stit u tion&quot;)<br>
&quot;12&quot; (&quot;substitution&quot;)<br>
&quot;su3i1u2on&quot; (&quot;su bst i t u ti on&quot;)<br>
&quot;substitution&quot; (no substrings replaced)<br>
The following are not valid abbreviations:<br>
&quot;s55n&quot; (&quot;s ubsti tutio n&quot;, the replaced substrings are adjacent)<br>
&quot;s010n&quot; (has leading zeros)<br>
&quot;s0ubstitution&quot; (replaces an empty substring)<br>
Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation.<br>
A substring is a contiguous non-empty sequence of characters within a string.</p>
<pre><code class="language-python">class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -&gt; bool:
        
        dig=0
        while abbr:
            
            if abbr[0].isdigit():
                if dig==0 and abbr[0]=='0': return False
                dig=dig*10+int(abbr[0])
                abbr=abbr[1:]
            else:
                if dig!=0:
                    if len(word)&lt;dig: return False
                    word=word[dig:]
                    dig=0
                else:
                    if not word: return False
                    if abbr[0]!=word[0]: return False
                    abbr=abbr[1:]
                    word=word[1:]
        if dig:
            if len(word)&lt;dig: return False
            if not word: return False
            word=word[dig:]
         
        return not abbr and not word


</code></pre>
<h1 id="font-colorred-409-longest-palindrome-easy-font"><font color='red'> 409. Longest Palindrome (Easy) </font></h1>
<p>Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.<br>
Letters are case sensitive, for example, &quot;Aa&quot; is not considered a palindrome here.</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; int:
        dic=Counter(s)
        res=0
        for k,v in dic.items():
            res+=v//2*2
            if res%2==0 and v%2==1:
                res+=1
        return res
</code></pre>
<p>找到能组成palindrom的最长组合方式，如果是奇数个，可以变成偶数个，比如bbb只用bb。 但当res%2==0时候，遇到奇数情况可以加1.</p>
<h1 id="font-colorred-410-split-array-largest-sum-hard-font"><font color='red'> 410. Split Array Largest Sum （Hard） </font></h1>
<p>Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.<br>
Write an algorithm to minimize the largest sum among these m subarrays.</p>
<pre><code class="language-python">class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        # F[currIndex, subarrayCount] = 
        #  min(max(sum[currIndex, i], F[i + 1, subarrayCount - 1]))
        #        For all i in range [currIndex, n - subarrayCount]
        
        n=len(nums)
        prefix_sum=nums[:]
        for i in range(1,len(prefix_sum)):
            prefix_sum[i]+=prefix_sum[i-1]
        prefix_sum=[0]+prefix_sum
        
        @lru_cache(None)
        def get_min_largest_split_sum(cur_ind, m):
            if m==1:
                return prefix_sum[n]-prefix_sum[cur_ind]
            
            minimum_largest_split_sum=prefix_sum[n]
            for i in range(cur_ind,n-m+1):
                # Store the sum of the first subarray.
                first_split_sum=prefix_sum[i+1]-prefix_sum[cur_ind]
                # find the maxinum subaray sum ffor current frist split
                largest_split_sum=max(first_split_sum,get_min_largest_split_sum(i+1,m-1))
                #find the minum among all possible combinations
                minimum_largest_split_sum=min(minimum_largest_split_sum,largest_split_sum)
                
                if first_split_sum &gt;= minimum_largest_split_sum: break
            
            return minimum_largest_split_sum
        
        return get_min_largest_split_sum(0,m)


#。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        n = len(nums)
        memo = [[0] * (m + 1) for _ in range(n)]
        
        # Create a prefix sum array of nums.
        prefix_sum = [0] + list(itertools.accumulate(nums))
        
        for subarray_count in range(1, m + 1):
            for curr_index in range(n):
                # Base Case: If there is only one subarray left, then all of the remaining numbers
                # must go in the current subarray. So return the sum of the remaining numbers.
                if subarray_count == 1:
                    memo[curr_index][subarray_count] = prefix_sum[n] - prefix_sum[curr_index]
                    continue

                # Otherwise, use the recurrence relation to determine the minimum largest subarray sum
                # between curr_index and the end of the array with subarray_count subarrays remaining.
                minimum_largest_split_sum = prefix_sum[n]
                for i in range(curr_index, n - subarray_count + 1):
                    # Store the sum of the first subarray.
                    first_split_sum = prefix_sum[i + 1] - prefix_sum[curr_index]

                    # Find the maximum subarray sum for the current first split.
                    largest_split_sum = max(first_split_sum, memo[i + 1][subarray_count - 1])

                    # Find the minimum among all possible combinations.
                    minimum_largest_split_sum = min(minimum_largest_split_sum, largest_split_sum)

                    if first_split_sum &gt;= minimum_largest_split_sum:
                        break
            
                memo[curr_index][subarray_count] = minimum_largest_split_sum
        
        return memo[0][m]

#。。。。。。。。。。。。。。。。。
class Solution:
    def splitArray(self, nums: List[int], m: int) -&gt; int:
        
        def min_subarrays_required(max_sum_allowed: int) -&gt; int:
            current_sum = 0
            splits_required = 0
            
            for element in nums:
                # Add element only if the sum doesn't exceed max_sum_allowed
                if current_sum + element &lt;= max_sum_allowed:
                    current_sum += element
                else:
                    # If the element addition makes sum more than max_sum_allowed
                    # Increment the splits required and reset sum
                    current_sum = element
                    splits_required += 1

            # Return the number of subarrays, which is the number of splits + 1
            return splits_required + 1
        
        # Define the left and right boundary of binary search
        left = max(nums)
        right = sum(nums)
        while left &lt;= right:
            # Find the mid value
            max_sum_allowed = (left + right) // 2
            
            # Find the minimum splits. If splits_required is less than
            # or equal to m move towards left i.e., smaller values
            if min_subarrays_required(max_sum_allowed) &lt;= m:
                right = max_sum_allowed - 1
                minimum_largest_split_sum = max_sum_allowed
            else:
                # Move towards right if splits_required is more than m
                left = max_sum_allowed + 1
        
        return minimum_largest_split_sum
###Binary Seasrch


class Solution(object):
    def splitArray(self, nums, m):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type m: int
        :rtype: int
        https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1042/discuss/89817/Clear-Explanation:-8ms-Binary-Search-Java?page=1
        &quot;&quot;&quot;
 
        max_ = sum=0
        for  num in nums:
            max_ = max(num, max_);
            sum += num
            
            
        def valid(target, nums, m):
            count = 1
            total = 0
            for num in nums:
                total += num
                if total &gt; target: 
                    total = num
                    count+=1
                    if count &gt; m:
                        return False
                    
            return True
        
        if m == 1: return sum
        #binary search
        l = max_ 
        r = sum
        while l &lt;= r:
            mid = (l + r)// 2;
            if  valid(mid, nums, m): 
                r = mid - 1 
            else: 
                l = mid + 1
            
        return l
</code></pre>
<p>无思路。。。m=2时候很容易，sort然后找到左右平衡点。m=3，4？<br>
DP很好， bianry search是最优解法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-12]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-12/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-12/">
        </link>
        <updated>2021-12-12T14:58:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred391-perfect-rectangle-hardfont"><font color='red'>391. Perfect Rectangle （Hard）</font></h1>
<p>Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).<br>
Return true if all the rectangles together form an exact cover of a rectangular region.</p>
<pre><code class="language-python">class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -&gt; bool:
        x1 = float('inf')
        y1 = float('inf')
        x2 = float('-inf')
        y2 = float('-inf')
        _set = set()
        
        area = 0
        for rect in rectangles:
            x1 = min(x1, rect[0])
            y1 = min(y1, rect[1])
            x2 = max(x2, rect[2])
            y2 = max(y2, rect[3])
            
            area += (rect[2] - rect[0]) * (rect[3] - rect[1])
            
            for x, y in [(rect[0],rect[1]),(rect[0],rect[3]),(rect[2],rect[3]),(rect[2],rect[1])]:
                if (x, y) in _set:
                    _set.remove((x, y))
                else:
                    _set.add((x, y))
        return all((x, y) in _set for x, y in [(x1,y1),(x2,y2),(x1,y2),(x2,y1)]) and len(_set) == 4 and area == (x2 - x1) * (y2 - y1)

</code></pre>
<p>没啥思路。。。答案思路:<br>
要是exact cover of rectangular region 1）大的rectangle面积是所有小rectangle面积和 2） 所有的图中的点应该是偶数个，除了边界的4个点。</p>
<h1 id="392-is-subsequence-easy">392. Is Subsequence (Easy)</h1>
<p>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.<br>
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).</p>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s):
            
            while p2&lt;len(t) and s[p1]!=t[p2]:
                p2+=1
            
            if p2==len(t): return False
            
            if s[p1]==t[p2]:
                p1+=1
                p2+=1
            
            if p1==len(s):return True
 #ANSWER           
class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if not s: return True
        p1=0
        p2=0
        while p1&lt;len(s) and p2&lt;len(t):
            if s[p1]==t[p2]:
                p1+=1
            p2+=1
        if p1==len(s):
            return True
        return False
                     
</code></pre>
<p>这题竟然卡了，用了two pointer。。 答案写的更好。 只有相等时候s的pointer才跳，t的pointer一直跳，判断s的pointer到头就可以了。</p>
<h1 id="font-colorred393-utf-8-validation-mediumfont"><font color='red'>393. UTF-8 Validation （Medium）</font></h1>
<p>Given an integer array data representing the data, return whether it is a valid UTF-8 encoding.<br>
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:<br>
For a 1-byte character, the first bit is a 0, followed by its Unicode code.<br>
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.</p>
<p>This is how the UTF-8 encoding would work:</p>
<p>Char. number range  |        UTF-8 octet sequence<br>
(hexadecimal)    |              (binary)<br>
--------------------+---------------------------------------------<br>
0000 0000-0000 007F | 0xxxxxxx<br>
0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>
<pre><code class="language-python">class Solution:
    def validUtf8(self, data: List[int]) -&gt; bool:
        
        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # For each integer in the data array.
        for num in data:

            # Get the binary representation. We only need the least significant 8 bits
            # for any given number.
            bin_rep = format(num, '#010b')[-8:]

            # If this is the case then we are to start processing a new UTF-8 character.
            if n_bytes == 0:

                # Get the number of 1s in the beginning of the string.
                for bit in bin_rep:
                    if bit == '0': break
                    n_bytes += 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:
                # Else, we are processing integers which represent bytes which are a part of
                # a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.
                if not (bin_rep[0] == '1' and bin_rep[1] == '0'):
                    return False

            # We reduce the number of bytes to process by 1 after each integer.
            n_bytes -= 1

        # This is for the case where we might not have the complete data for
        # a particular UTF-8 character.
        return n_bytes == 0  



#ANSWER BIT 
class Solution:
    def validUtf8(self, data):
        &quot;&quot;&quot;
        :type data: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # Mask to check if the most significant bit (8th bit from the left) is set or not
        mask1 = 1 &lt;&lt; 7

        # Mask to check if the second most significant bit is set or not
        mask2 = 1 &lt;&lt; 6
        for num in data:

            # Get the number of set most significant bits in the byte if
            # this is the starting byte of an UTF-8 character.
            mask = 1 &lt;&lt; 7
            if n_bytes == 0:
                while mask &amp; num:
                    n_bytes += 1
                    mask = mask &gt;&gt; 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes &gt; 4:
                    return False
            else:

                # If this byte is a part of an existing UTF-8 character, then we
                # simply have to look at the two most significant bits and we make
                # use of the masks we defined before.
                if not (num &amp; mask1 and not (num &amp; mask2)):
                    return False
            n_bytes -= 1
        return n_bytes == 0     
</code></pre>
<p>看答案了，down vote比较多不是什么好题</p>
<h1 id="394-decode-string-medium">394. Decode String （Medium）</h1>
<p>Given an encoded string, return its decoded string.<br>
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.<br>
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.<br>
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].</p>
<pre><code class="language-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        # 3[a2[c]]
        #
        # stack=[]
        #       [3]
        #       [3 [ a 2 [ c   ] 
        # 
        
        dig=''
        stack=[]
        for char in s:
            if char.isdigit():
                dig+=char
            elif char=='[':
                if dig:
                    stack.append(int(dig))
                stack.append('[')
                dig=''
            elif char==']':
                string=[]
                while stack[-1]!='[':
                    string.append(stack.pop())
                string=''.join(string[::-1])
                stack.pop() #pop掉【
                if type(stack[-1])==int:
                    string=stack.pop()*string
                stack.append(string)
                
                
            else:
                stack.append(char)
        
        return ''.join(stack)



 #3年前的答案估计是看的别人的一样的思路
 class Solution(object):
    def decodeString(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        num='0123456789'
        s=[e for e in s]
        
        stack=[]
        
        while s:
            
            cur=s.pop(0)
            if cur in num:
                stack.append(int(cur))
            elif cur=='[':
                stack.append(cur)
            elif cur==']':
                temp=[]
                while stack and stack[-1]!='[':
                    me=stack.pop()
                    temp.append(me)
                stack.pop()
                temp=''.join(temp[::-1])
                number=0
                time=1
                while stack and type(stack[-1])==int:
                    number+=stack.pop()*time
                    time*=10
                stack.append(temp*number)
            else:
                stack.append(cur)
        return ''.join(stack)           
</code></pre>
<p>感觉是用stack的确写出来了~~</p>
<h1 id="font-colorred-395-longest-substring-with-at-least-k-repeating-characters-mediumfont"><font color='red'> 395. Longest Substring with At Least K Repeating Characters （Medium）</font></h1>
<p>Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.</p>
<pre><code class="language-python">class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        def helper(start,end):
            if end&lt;k:return 0
            countMap=[0]*26
            for i in range(start,end):
                countMap[ord(s[i])-ord('a')]+=1
            for mid in range(start,end):
                if countMap[ord(s[mid])-ord('a')]&gt;=k: continue
                midnext=mid+1
                while midnext&lt;end and countMap[ord(s[midnext])-ord('a')]&lt;k:
                    midnext+=1
                return max(helper(start,mid),helper(midnext,end))
            return end-start
        
        return helper(0,len(s))
            
#Perfect ANSWER
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        for c in set(s):
            if s.count(c) &lt; k:
                return max(self.longestSubstring(t, k) for t in s.split(c))
        return len(s)

#Sliding WIndow
class Solution:
    def longestSubstring(self, s: str, k: int) -&gt; int:
        
        maxunique=len(set(s))
        res=0
        for cur_unique in range(1,maxunique+1):
            countmap=[0]*26
            start=end=unique=idx=countAtLeasetK=0
            while end &lt;len(s):
                #expanding sliding window
                if unique&lt;=cur_unique:
                    idx=ord(s[end])-ord('a')
                    if countmap[idx]==0:
                        unique+=1
                    countmap[idx]+=1
                    if countmap[idx]==k:
                        countAtLeasetK+=1
                    end+=1
                else:
                    #shrink sliding window
                    idx=ord(s[start])-ord('a')
                    if countmap[idx]==k:
                        countAtLeasetK-=1
                    countmap[idx]-=1
                    if countmap[idx]==0:
                        unique-=1
                    start+=1
                
                if unique==cur_unique and unique==countAtLeasetK:
                    res=max(res,end-start)
        return res

</code></pre>
<p>答案的分治法很好，<br>
的确是tow pointer啊，但写不出来。。。思路：第一层for loop 用来扫 cur_unique 。 while  end 小于len(s)； 当unique小于cur_unique而且不到s末尾时， expand。记录unique he countAtLeastK大小，否则当unique大于cur_unique就收缩， 更新countAtLeastK和unique。 如果unique等于cur_unique 而且unique等于countAtLeastK，更新结果。<br>
最简单的是方法2解法，如果count（char)小于K就用char作为分界char，recursive call function。</p>
<h1 id="396-rotate-function-medium">396. Rotate Function （Medium）</h1>
<p>You are given an integer array nums of length n.<br>
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:<br>
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].<br>
Return the maximum value of F(0), F(1), ..., F(n-1).</p>
<pre><code class="language-python">class Solution:
    def maxRotateFunction(self, nums: List[int]) -&gt; int:
        #nums = [4,3,2,6]
        #F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
        #F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
        #     = F[0]+sum-4*6
        #F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
        #     = F[1]+sum-4*2
        #F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
        #     = F[2]+sum-4*3
        
        f0=0
        sum_=0
        for i,n in enumerate(nums):
            f0+=i*n
            sum_+=n
        res=f0
        for j in range(len(nums)-1,0,-1):
            f1=f0+sum_-len(nums)*nums[j]
            res=max(res,f1)
            f0=f1
        return res
</code></pre>
<h1 id="397-integer-replacement-medium">397. Integer Replacement (Medium)</h1>
<p>Given a positive integer n, you can apply one of the following operations:<br>
If n is even, replace n with n / 2.<br>
If n is odd, replace n with either n + 1 or n - 1.<br>
Return the minimum number of operations needed for n to become 1.</p>
<pre><code class="language-python">class Solution:
    def integerReplacement(self, n: int) -&gt; int:
        def helper(n):
            if n==1:
                return 0
            step=0
            if n%2==0:
                n=n//2
                step=1+helper(n)
            else:
                step=1+min(helper(n+1),helper(n-1))
            return step
        
        return helper(n)
        
</code></pre>
<p>能加个@lru_cache(None)去优化下。。。不过已经pass autograder了</p>
<h1 id="398-random-pick-index-medium">398. Random Pick Index （Medium）</h1>
<p>Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.<br>
Implement the Solution class:<br>
Solution(int[] nums) Initializes the object with the array nums.<br>
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, nums: List[int]):
        self.dic=collections.defaultdict(list)
        for i,n in enumerate(nums):
            self.dic[n].append(i)
        

    def pick(self, target: int) -&gt; int:
        return random.choice(self.dic[target])
    
</code></pre>
<h1 id="font-colorred-399-evaluate-division-medium-font"><font color='red'> 399. Evaluate Division (Medium) </font></h1>
<p>ou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.<br>
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.<br>
Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<pre><code class="language-python">class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        
        # a-val-&gt;b--val-&gt;c
        

        graph = defaultdict(defaultdict)

        def backtrack_evaluate(curr_node, target_node, acc_product, visited):
            visited.add(curr_node)
            ret = -1.0
            neighbors = graph[curr_node]
            if target_node in neighbors:
                ret = acc_product * neighbors[target_node]
            else:
                for neighbor, value in neighbors.items():
                    if neighbor in visited:
                        continue
                    ret = backtrack_evaluate(
                        neighbor, target_node, acc_product * value, visited)
                    if ret != -1.0:
                        break
            visited.remove(curr_node)
            return ret

        # Step 1). build the graph from the equations
        for (dividend, divisor), value in zip(equations, values):
            # add nodes and two edges into the graph
            graph[dividend][divisor] = value
            graph[divisor][dividend] = 1 / value

        # Step 2). Evaluate each query via backtracking (DFS)
        #  by verifying if there exists a path from dividend to divisor
        results = []
        for dividend, divisor in queries:
            if dividend not in graph or divisor not in graph:
                # case 1): either node does not exist
                ret = -1.0
            elif dividend == divisor:
                # case 2): origin and destination are the same node
                ret = 1.0
            else:
                visited = set()
                ret = backtrack_evaluate(dividend, divisor, 1, visited)
            results.append(ret)

        return results


###UNIONFIND 变种
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:

        gid_weight = {}

        def find(node_id):
            if node_id not in gid_weight:
                gid_weight[node_id] = (node_id, 1)
            group_id, node_weight = gid_weight[node_id]
            # The above statements are equivalent to the following one
            #group_id, node_weight = gid_weight.setdefault(node_id, (node_id, 1))

            if group_id != node_id:
                # found inconsistency, trigger chain update
                new_group_id, group_weight = find(group_id)
                gid_weight[node_id] =  (new_group_id, node_weight * group_weight)
            return gid_weight[node_id]

        def union(dividend, divisor, value):
            dividend_gid, dividend_weight = find(dividend)
            divisor_gid, divisor_weight = find(divisor)
            if dividend_gid != divisor_gid:
                # merge the two groups together,
                # by attaching the dividend group to the one of divisor
                gid_weight[dividend_gid] =  (divisor_gid, divisor_weight * value / dividend_weight)

        # Step 1). build the union groups
        for (dividend, divisor), value in zip(equations, values):
            union(dividend, divisor, value)

        results = []
        # Step 2). run the evaluation, with &quot;lazy&quot; updates in find() function
        for (dividend, divisor) in queries:
            if dividend not in gid_weight or divisor not in gid_weight:
                # case 1). at least one variable did not appear before
                results.append(-1.0)
            else:
                dividend_gid, dividend_weight = find(dividend)
                divisor_gid, divisor_weight = find(divisor)
                if dividend_gid != divisor_gid:
                    # case 2). the variables do not belong to the same chain/group
                    results.append(-1.0)
                else:
                    # case 3). there is a chain/path between the variables
                    results.append(dividend_weight / divisor_weight)
        return results
</code></pre>
<p>看提示，是graph问题， 一开始就偏了。。。若是graph问题，则a-val-》b-val-》c，<br>
那么a-》c就是val1*val2，如果是c-》a找不到，就找a-c然后1/结果. 如果node不在里面就return -1，如果是自己-》自己return1<br>
还是第一种方法graph比较标准用DFS。</p>
<h1 id="font-colorred400-nth-digit-mediumfont"><font color='red'>400. Nth Digit （Medium）</font></h1>
<p>Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].</p>
<pre><code class="language-python">class Solution:
    def findNthDigit(self, n: int) -&gt; int:
        #1 ~ 9 include 9 one digit number;
        #10 ~ 99 include 90 two digits number;
        #100 ~ 999 include 900 three digits number;
        #1000 ~ 9999 include 9000 four digits number;
        #...
        #length is how many digits:1 or 2 or 3 ..., range is 9 or 90 or 900 ...
        
        length = 1
        num = 1 
        range_ = 9
        while n &gt; length * range_:
            n -= length * range_
            length+=1
            range_ *= 10
            num *= 10
        num += (n - 1) // length
        return str(num)[ (n-1)%length]
		 

</code></pre>
<p>知道思路，写时候卡。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-11]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-11/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-11/">
        </link>
        <updated>2021-12-10T20:41:58.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-381-insert-delete-getrandom-o1-duplicates-allowed-hardfont"><font color='red'> 381. Insert Delete GetRandom O(1) - Duplicates allowed （Hard）</font></h1>
<p>RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also removing a random element.<br>
Implement the RandomizedCollection class:<br>
RandomizedCollection() Initializes the empty RandomizedCollection object.<br>
bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.<br>
bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.<br>
int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of same values the multiset contains.<br>
You must implement the functions of the class such that each function works on average O(1) time complexity.</p>
<pre><code class="language-python">class RandomizedCollection:

    def __init__(self):
        self.lst = []
        self.idx = defaultdict(set)
        

    def insert(self, val: int) -&gt; bool:
        self.idx[val].add(len(self.lst))
        self.lst.append(val)
        return len(self.idx[val]) == 1

    def remove(self, val: int) -&gt; bool:
        if not self.idx[val]: return False
        remove, last = self.idx[val].pop(), self.lst[-1]
        self.lst[remove] = last
        self.idx[last].add(remove)
        self.idx[last].remove(len(self.lst) - 1)

        self.lst.pop()
        return True

    def getRandom(self) -&gt; int:
        return choice(self.lst)


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

</code></pre>
<p>思路是对的，但写不出来， 崩溃，看答案。。。用list和defaultdict（set），insert很简单，难的是remove。 先找出remove val的index并从dict中pop，和array last 元素交换， array last元素的dict添加index，array last 元素dict.remove(len(self.lst) - 1）, len(self.lst) - 1是last元素的idx。</p>
<h1 id="font-colorblue-382-linked-list-random-node-mediumfont"><font color='blue'> 382. Linked List Random Node （Medium）</font></h1>
<p>Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.<br>
Implement the Solution class:<br>
Solution(ListNode head) Initializes the object with the head of the singly-linked list head.<br>
int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.dic=dict()
        ind=0
        while head:
            self.dic[ind]=head.val
            ind+=1
            head=head.next
        self.ind=ind
        

    def getRandom(self) -&gt; int:
        return self.dic[random.randint(0,self.ind-1)]  

#ANSER of Reservor sampling      
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.head = head
        

    def getRandom(self) -&gt; int:
        scope = 1
        chosen_value = 0
        curr = self.head

        while curr:
            # decide whether to include the element in reservoir
            if random.random() &lt; 1 / scope:
                chosen_value = curr.val
            # move on to the next node
            curr = curr.next
            scope += 1
        return chosen_value
        

</code></pre>
<p>follow up说如果linkedlist很大而且不知道长度。。。如何random 取样。。。<br>
忘记了有一个随机取样法 Reservoir sampling，需要复习, 当rand小于1/scope时候，说明当前值可以以1/scope的概率保留下来：</p>
<pre><code class="language-python"># S has items to sample, R will contain the result
def ReservoirSample(S[1..n], R[1..k])
  # fill the reservoir array
  for i := 1 to k
      R[i] := S[i]

  # replace elements with gradually decreasing probability
  for i := k+1 to n
    # randomInteger(a, b) generates a uniform integer
    #   from the inclusive range {a, ..., b} *)
    j := randomInteger(1, i)
    if j &lt;= k
        R[j] := S[i]
</code></pre>
<h1 id="383-ransom-note-easy">383. Ransom Note （Easy）</h1>
<p>Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.<br>
Each letter in magazine can only be used once in ransomNote.</p>
<pre><code class="language-python">class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        a = Counter(ransomNote)
        b = Counter(magazine)
        for k,v in a.items():
            if k not in b or b[k]&lt;v:
                return False
        return  True
</code></pre>
<h1 id="font-colorred384-shuffle-an-array-medium-font"><font color='red'>384. Shuffle an Array (Medium) </font></h1>
<p>Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.<br>
Implement the Solution class:<br>
Solution(int[] nums) Initializes the object with the integer array nums.<br>
int[] reset() Resets the array to its original configuration and returns it.<br>
int[] shuffle() Returns a random shuffling of the array.</p>
<pre><code class="language-python">class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&gt; List[int]:
        aux = self.array[:]

        for idx in range(len(self.array)):
            remove_idx = random.randint(0,len(aux)-1)
            self.array[idx] = aux.pop(remove_idx)

        return self.array

#BEST ANSWER  Fisher-Yates Algorithm
class Solution:

    def __init__(self, nums: List[int]):
        self.array = nums
        self.original = nums[:]
       
 
    def reset(self) -&gt; List[int]:
        self.array = self.original
        self.original = self.original[:]
        return self.array
   
    def shuffle(self) -&gt; List[int]:
        for idx in range(len(self.array)):
            swap_idx=random.randint(idx,len(self.array)-1)
            self.array[idx],self.array[swap_idx]=self.array[swap_idx],self.array[idx]
        return self.array

</code></pre>
<p>感觉思路是找到以n！为base的数，然后还原出suffled array但是写不出来。。。想的过于复杂了。这个就是个随机算法。 元素e在第k轮被抽中概率是  k在前k-1轮不中但在k轮中。 (n-1/n ) (n-2/n-1)...(n-k)/(n-k+1))* 1/n-k = 1/n   所以按照  剩下的有效数字中选1个的概率去组成array就可以保证每个数字是等概率选取。这样总体就是random shuffle了。</p>
<h1 id="font-colorred385-mini-parser-mediumfont"><font color='red'>385. Mini Parser （Medium）</font></h1>
<p>Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.<br>
Each element is either an integer or a list whose elements may also be integers or other lists.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &quot;&quot;&quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &quot;&quot;&quot;
#
#    def isInteger(self):
#        &quot;&quot;&quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def add(self, elem):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def setInteger(self, value):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def getInteger(self):
#        &quot;&quot;&quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &quot;&quot;&quot;
#
#    def getList(self):
#        &quot;&quot;&quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &quot;&quot;&quot;

class Solution:
    def deserialize(self, s: str) -&gt; NestedInteger:
        # '-1' is not digit
        if s and s[-1].isdigit():
            return  NestedInteger(int(s))

        nested_integer = None
        digits = ''
        stack = []
        for c in s:
            if c.isdigit() or c == '-':
                digits += c
            elif c == '[':
                if nested_integer:
                    stack.append(nested_integer)
                nested_integer = NestedInteger()
            elif c == ']':
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = ''
                if stack:
                    previous_nested_integer = stack.pop()
                    previous_nested_integer.add(nested_integer)
                    nested_integer = previous_nested_integer
            elif c == ',':
                if digits:
                    nested_integer.add(NestedInteger(int(digits)))
                    digits = ''

        return nested_integer

#作弊写法用eval
def deserialize(self, s):
    def nestedInteger(x):
        if isinstance(x, int):
            return NestedInteger(x)
        lst = NestedInteger()
        for y in x:
            lst.add(nestedInteger(y))
        return lst
    return nestedInteger(eval(s))
</code></pre>
<p>想写正确并不容易。。。</p>
<h1 id="font-colorblue386-lexicographical-numbers-median-font"><font color='blue'>386. Lexicographical Numbers （median） </font></h1>
<p>Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.<br>
You must write an algorithm that runs in O(n) time and uses O(1) extra space.</p>
<pre><code class="language-python">class Solution:
    def lexicalOrder(self, n: int) -&gt; List[int]:
        
        class trie:
            def __init__(self):
                self.childer=dict()
                self.isnumber=False
            
            def insert(self,n):
                if len( n )==1:
                    first= n 
                    if first not in self.childer:
                        self.childer[first]=trie()
                    self.childer[first].isnumber=True
                else:
                    first= n[0] 
                    rest =  n[1:] 
                    if first not in self.childer:
                        self.childer[first]=trie()
                    self.childer[first].insert(rest)
               
        tr=trie()
        for i in range(1,n+1):
            tr.insert(str(i))
        
        res=[]
        
        def preorder(tr,tmp):
            for key in tr.childer:
                temp=tmp+key
                if tr.childer[key].isnumber:
                    res.append(temp)
                preorder(tr.childer[key],temp)
            
        preorder(tr,'')
        return map(int,res)

#ANSWER DFS
class Solution:
    def lexicalOrder(self, n: int) -&gt; List[int]:
        self.res = []
        for i in range(1, 10):
            self.helper(i, n)
        return self.res
    
    def helper(self, start, end):
        if start &gt; end:
            return
        self.res.append(start)
        for i in range(0, 10):
            if 10 * start + i &gt; end:
                return
            self.helper(10 * start + i, end)

</code></pre>
<p>用的trie做出来的，写的磕磕绊绊。。。<br>
答案用的DFS， 很好的思路。。。<br>
The idea is pretty simple. If we look at the order we can find out we just keep adding digit from 0 to 9 to every digit and make it a tree.<br>
Then we visit every node in pre-order.<br>
1        2        3    ...<br>
/\        /\       /<br>
10 ...19  20...29  30...39   ....</p>
<h1 id="387-first-unique-character-in-a-string-easy">387. First Unique Character in a String （Easy）</h1>
<p>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.</p>
<pre><code class="language-python">class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        c=Counter(s)
        for i,char in enumerate(s):
            if c[char]==1:
                return i
        return -1
</code></pre>
<h1 id="font-colorred388-longest-absolute-file-path-medium-font"><font color='red'>388. Longest Absolute File Path (Medium) </font></h1>
<p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:<br>
Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.</p>
<p>In text form, it looks like this (with ⟶ representing the tab character):</p>
<p>dir<br>
⟶ subdir1<br>
⟶ ⟶ file1.ext<br>
⟶ ⟶ subsubdir1<br>
⟶ subdir2<br>
⟶ ⟶ subsubdir2<br>
⟶ ⟶ ⟶ file2.ext</p>
<p>If we were to write this representation in code, it will look like this: &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;. Note that the '\n' and '\t' are the new-line and tab characters.<br>
Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is &quot;dir/subdir2/subsubdir2/file2.ext&quot;. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.<br>
Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.</p>
<pre><code class="language-python">class Solution:
    def lengthLongestPath(self, input: str) -&gt; int:
        maxlen = 0
        pathlen = {0: 0}
        for line in input.split('\n'):
            depth = line.count('\t')
            name = line.lstrip('\t')
            if '.' in name:
                maxlen = max(maxlen, pathlen[depth] + len(name))
            else:
                pathlen[depth + 1] = pathlen[depth] + len(name) + 1
        return maxlen


</code></pre>
<p>coner case 太多，自己写的太复杂，还不能完全pass。。。看答案了。。。</p>
<h1 id="389-find-the-difference-easy">389. Find the Difference （Easy）</h1>
<p>You are given two strings s and t.<br>
String t is generated by random shuffling string s and then add one more letter at a random position.<br>
Return the letter that was added to t.</p>
<pre><code class="language-python">class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        s=Counter(s)
        t=Counter(t)
        for key in s:
            t[key]-=s[key]
            if t[key]==0:
                del t[key]
        
        return  list(t.keys())[0]

#ANSER NLOGN
class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:

        # Sort both the strings
        sorted_s = sorted(s)
        sorted_t = sorted(t)

        # Character by character comparison
        i = 0
        while i &lt; len(s):
            if sorted_s[i] != sorted_t[i]:
                return sorted_t[i]
            i += 1

        return sorted_t[i]

#DICT O(n)
from collections import Counter

class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:
        # Prepare a counter for string s.
        # This holds the characters as keys and respective frequency as value.
        counter_s = Counter(s)

        # Iterate through string t and find the character which is not in s.
        for ch in t:
            if ch not in counter_s or counter_s[ch] == 0:
                return ch
            else:
                # Once a match is found we reduce frequency left.
                # This eliminates the possibility of a false match later.
                counter_s[ch] -= 1

#XOR O（n）
class Solution:
    def findTheDifference(self, s: str, t: str) -&gt; str:

        # Initialize ch with 0, because 0 ^ X = X
        # 0 when XORed with any bit would not change the bits value.
        ch = 0

        # XOR all the characters of both s and t.
        for char_ in s:
            ch ^= ord(char_)

        for char_ in t:
            ch ^= ord(char_)

        # What is left after XORing everything is the difference.
        return chr(ch)
</code></pre>
<h1 id="font-colorred-390-elimination-game-medium-font"><font color='red'> 390. Elimination Game （Medium) </font></h1>
<p>You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:<br>
Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.<br>
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.<br>
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.<br>
Given the integer n, return the last number that remains in arr.</p>
<pre><code class="language-python">
#Navie not work memery exceeded
class Solution:
    def lastRemaining(self, n: int) -&gt; int:
        li = [i for i in range(1,n+1)]
        
        def helper(li,forward=True):
            if len(li)==1: return li[0]
            if forward:
                #print(li[1::2],not forward)
                return helper(li[1::2],not forward)
            else:
                li=li[::-1]
                li=li[1::2]
                #print(li[::-1],not forward)
                return helper(li[::-1],not forward)
                
        return helper(li,True)


#Perfect ANSWER
class Solution:
    def lastRemaining(self, n: int) -&gt; int:
 
        head, left, step, remaining = 1, True, 1, n
        while remaining &gt; 1:
            if left or remaining % 2: 
                #when to update head
                #go from left or remaining is odd
                head += step
            left = not left
            step *= 2
            remaining //= 2
        return head
</code></pre>
<p>按照题目意思直接搞时间复杂度和空间复杂度都太大。。，<br>
看答案：<br>
update and record head in each turn. when the total number becomes 1, head is the only number left.</p>
<p>When will head be updated?</p>
<pre><code>if we move from left
if we move from right and the total remaining number % 2 == 1
like 2 4 6 8 10, we move from 10, we will take out 10, 6 and 2, head is deleted and move to 4
like 2 4 6 8 10 12, we move from 12, we will take out 12, 8, 4, head is still remaining 2
</code></pre>
<p>then we find a rule to update our head.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-10]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-10/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-10/">
        </link>
        <updated>2021-12-09T17:33:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred-371-sum-of-two-integers-medium-font"><font color='red'> 371. Sum of Two Integers （Medium） </font></h1>
<p>Given two integers a and b, return the sum of the two integers without using the operators + and -.</p>
<pre><code class="language-python">class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        x, y = abs(a), abs(b)
        # ensure that abs(a) &gt;= abs(b)
        if x &lt; y:
            return self.getSum(b, a)
        
        # abs(a) &gt;= abs(b) --&gt; 
        # a determines the sign
        sign = 1 if a &gt; 0 else -1
        
        if a * b &gt;= 0:
            # sum of two positive integers x + y
            # where x &gt; y
            while y:
                answer = x ^ y
                carry = (x &amp; y) &lt;&lt; 1
                x, y = answer, carry
        else:
            # difference of two integers x - y
            # where x &gt; y
            while y:
                answer = x ^ y
                borrow = ((~x) &amp; y) &lt;&lt; 1
                x, y = answer, borrow
        
        return x * sign
#ANSWER
class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        mask = 0xFFFFFFFF
        
        while b != 0:
            a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask
        
        max_int = 0x7FFFFFFF
        return a if a &lt; max_int else ~(a ^ mask)
</code></pre>
<p>bit manipulation 初见感觉是。 但不知道怎么处理。思路，borrow 是 x&amp;y《《1， 没borrow的sum是x^y.</p>
<h1 id="font-colorred-372-super-pow-medium-font"><font color='red'> 372. Super Pow (Medium) </font></h1>
<p>Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<pre><code class="language-python">class Solution:
    def superPow(self, a: int, b: List[int]) -&gt; int:
        base=1337
        def f(a,b):
            res=1
            for i in range(b):
                res*=(a%base)
                res%=base
            return res
        if not b: return 1
        last_digit=b.pop()
        return f(self.superPow(a, b), 10) * f(a, last_digit) % base;
</code></pre>
<p>mod 有结合律交换律吗？。。不太清楚。。。 答案用了1） ab % k = (a%k)(b%k)%k<br>
2）a<sup>b%k=(a%k)</sup>b%k<br>
推到递推关系：<br>
a^1234567 % k = (a^1234560 a^7)%k= ((a^1234560)%k )  ((a^7)%k ) %k<br>
= ((a<sup>123456)</sup>10)%k )  ((a^7)%k ) %k<br>
= ((((a<sup>123456)%k)</sup>10 )% k)  ((a^7)%k ) %k<br>
设 a^b%k=f(a,b)<br>
f(a,1234567)=  f(f(a,123456),10) f(a,7)%k</p>
<h1 id="font-colorred-373-find-k-pairs-with-smallest-sums-medium-font"><font color='red'> 373. Find K Pairs with Smallest Sums （Medium） </font></h1>
<p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.<br>
Define a pair (u, v) which consists of one element from the first array and one element from the second array.<br>
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.</p>
<pre><code class="language-python">class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:
        res = []
        if not nums1 or not nums2 or not k:
            return res
        
        heap = []
        visited = set()
        
        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))
        
        visited.add((0, 0))
        
        while len(res) &lt; k and heap:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            
            if i+1 &lt; len(nums1) and (i+1, j) not in visited:
                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))
                visited.add((i+1, j))
            
            if j+1 &lt; len(nums2) and (i, j+1) not in visited:
                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
                visited.add((i, j+1))
        return res
        
           

</code></pre>
<p>暴力解肯定TLE。。。也想到了是k-way merge sort 但怎么写出来？直接抄答案了，用到了heapq.heappush, heapq.heappop, visited.  先从（0，0）开始push，然后是（1，0）（0，1）， i.e.   (i,j) then (i+1,j),(i,j+1)... 通过visited 去重。</p>
<h1 id="374-guess-number-higher-or-lower-easy">374. Guess Number Higher or Lower （Easy）</h1>
<p>We are playing the Guess Game. The game is as follows:<br>
I pick a number from 1 to n. You have to guess which number I picked.<br>
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.<br>
You call a pre-defined API int guess(int num), which returns three possible results:<br>
-1: Your guess is higher than the number I picked (i.e. num &gt; pick).<br>
1: Your guess is lower than the number I picked (i.e. num &lt; pick).<br>
0: your guess is equal to the number I picked (i.e. num == pick).</p>
<pre><code class="language-python"># The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m=(l+r)//2
            if guess(m)==0:
                return m
            elif guess(m)==1:
                l=m+1
            else:
                r=m-1
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        l=1
        r=n
        while l&lt;=r:
            m1=l+(r-l)//3
            m2=r-(r-l)//3
            res1=guess(m1)
            res2=guess(m2)
            if res1==0:
                return m1
            if res2==0:
                return m2
            elif res1&lt;0:
                r=m1-1
            elif res2&gt;0:
                l=m2+1
            else:
                l=m1+1
                r=m2-1
</code></pre>
<p>二分法，三分法。。。</p>
<h1 id="font-colorred375-guess-number-higher-or-lower-ii-mediumfont"><font color='red'>375. Guess Number Higher or Lower II （Medium）</font></h1>
<p>We are playing the Guessing Game. The game will work as follows:<br>
I pick a number between 1 and n.<br>
You guess a number.<br>
If you guess the right number, you win the game.<br>
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.<br>
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.</p>
<pre><code class="language-python">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        #dp[i][j] will save the min cost guessing from i to j
        dp=[[0]*(n+1) for _ in range(n+1)]
         
        def helper(start,end):
            if start&gt;=end: return 0
            if dp[start][end]!=0: return dp[start][end]
            res=float('inf')
            for x in range(start,end+1):
                #try select x,the cost will be
                tmp=x+max(helper(start,x-1),helper(x+1,end))
                res=min(res,tmp)
            dp[start][end]=res
            return res
            
        return helper( 1, n)
    
</code></pre>
<p>没思路。。。看答案，用了DP 关键是DP【i】【j】定义为从i猜到j，花费的最小cost。 那么如果X在i，j之间，选定了X，则cost为 X+max（dp【start】【x-1】，dp【x+1】【end】）因为dp这时候还没值，所以用helper（start，x-1），helper（x+1，end）代替，用max是因为不确定是左面还是右面，只能按照最坏情况准备钱。扫描所有X，然后最小的作为dp【i】【j】cost结果。</p>
<h1 id="font-colorblue376-wiggle-subsequence-mediumfont"><font color='blue'>376. Wiggle Subsequence （Medium）</font></h1>
<p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.<br>
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.<br>
Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<pre><code class="language-python">class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        #dp[i]   the max length of wiggle including nums[i]
        # 1 17 5 10 13 15 10 5 16 8
        # 0 +  - +  +   +  - - +  -
        # 1 2  3 4  4   4  5 5 6  7   
        
        # 1 7 4 9 2 5
        # 0 + - + - +
        #sign[i] the sign of max length of nums[i-1] to nums[i] if increasing 1 decresasing -1
        if len(nums)&lt;2: return len(nums)
        if len(nums)==2 and nums[0]!=nums[1]:return 2
        if len(nums)==2 and nums[0]==nums[1]:return 1
        
        
        count_plus=0
        count_minus=0
        presign=None
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]: continue
            sign= nums[i]-nums[i-1]&gt;0
            if sign:
                #positive
                if presign is None:
                    count_minus=1
                
                if presign!=sign:
                    
                    count_plus=count_minus+1
            else:
                #negtive
                if presign is None:
                    count_plus=1
                if presign!=sign:
                    count_minus=count_plus+1 
            
            presign=sign
        
        return max([1,count_plus,count_minus])

#ANSWER DP O（n*n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[1]*len(nums)
        down=[1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]&gt;nums[j]:
                    up[i]=max(up[i],down[j]+1)
                elif nums[i]&lt;nums[j]:
                    down[i]=max(down[i],up[j]+1)
        return max(up[-1],down[-1])

#ANSWER DP O（n）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=[0]*len(nums)
        down=[0]*len(nums)
        up[0]=1
        down[0]=1
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up[i]=down[i-1]+1
                down[i]=down[i-1]
            elif nums[i]&lt;nums[i-1]:
                down[i]=up[i-1]+1
                up[i]=up[i-1]
            else:
                down[i]=down[i-1]
                up[i]=up[i-1]
        return max(up[-1],down[-1])

#ANSWER DP O（n） space O（1）
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        up=1
        down=1
       
        for i in range(1,len(nums)):
            if nums[i]&gt;nums[i-1]:
                up =down +1
           
            elif nums[i]&lt;nums[i-1]:
                down =up +1
              
        return max(up ,down )

#Greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2: return len(nums)
        maxLen=1
        sign=0
        for i in range(1,len(nums)):
            if nums[i]&lt;nums[i-1] and sign!=-1:
                # find a peak nums[i-1] is peak, now it is a decreasing sequence sign=-1
                sign=-1
                maxLen+=1
           
            elif nums[i]&gt;nums[i-1] and sign!=1:
                #valley
                sign=1
                maxLen+=1
              
        return maxLen
         
</code></pre>
<p>本来想用DP做，但发现只用保持 count+ 和 count- 两个计数器就够了。  如果发现增加2元序列，count-加1. 如果发现减小2元序列，count+加1，最后返回count+,count-中最大的就可以了，注意corner case。答案用了多种方法，贴上来开阔思路。第三个方法和我的一样但是写的更简单</p>
<h1 id="font-colorred-377-combination-sum-iv-mediumfont"><font color='red'> 377. Combination Sum IV （Medium）</font></h1>
<p>Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.<br>
The test cases are generated so that the answer can fit in a 32-bit integer.</p>
<pre><code class="language-python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        @lru_cache(None)
        def dp(remain):
            if remain==0:
                return 1
            res=0
            for n in nums:
                if remain-n&gt;=0:
                    res+=dp(remain-n)
            return res
        return dp(target)
    
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        # minor optimization
        # nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1

        for comb_sum in range(target+1):

            for num in nums:
                if comb_sum - num &gt;= 0:
                    dp[comb_sum] += dp[comb_sum-num]
                # minor optimization, early stopping.
                # else:
                #    break
        return dp[target]
</code></pre>
<p>知道是DP，而且知道DP【i】是能sum到i的组合个数，那么dp【i】=dp【i-n】+dp【n】为啥不对？？ n是添加的最后一个数。而且扫的是所有n in nums。 如果再拆分n，那么会有重复。<br>
思路卡了， 应该是dp【i】+=dp【i-n】   要往组合里加n能到i，那么多出来的组合数就是dp【i-n】。应该求的是和。。。</p>
<h1 id="379-design-phone-directory-medium">379. Design Phone Directory （Medium）</h1>
<p>Design a phone directory that initially has maxNumbers empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.<br>
Implement the PhoneDirectory class:<br>
PhoneDirectory(int maxNumbers) Initializes the phone directory with the number of available slots maxNumbers.<br>
int get() Provides a number that is not assigned to anyone. Returns -1 if no number is available.<br>
bool check(int number) Returns true if the slot number is available and false otherwise.<br>
void release(int number) Recycles or releases the slot number.</p>
<pre><code class="language-python">class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.n=maxNumbers
        self.avaliable=set([i for i in range(self.n)])
        self.used=set()
        self.current=-1
        

    def get(self) -&gt; int:
        if not self.avaliable: return -1
        while not self.check(self.current):
            self.current= (self.current+1)%self.n
        
        #current in self.avaliable
        # remove from self.avaliable
        self.avaliable.remove(self.current)
        self.used.add(self.current)
        
        res = self.current
        self.current= (self.current+1)%self.n
        return res

    def check(self, number: int) -&gt; bool:
        return  number in self.avaliable 

    def release(self, number: int) -&gt; None:
        self.avaliable.add(number)
        if number in self.used:
            self.used.remove(number)
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)

   def __init__(self, maxNumbers):
        self.available = set(range(maxNumbers))

    def get(self):
        return self.available.pop() if self.available else -1

    def check(self, number):
        return number in self.available

    def release(self, number):
        self.available.add(number)

#ANSWER PERFECT
class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.pos=0
        self.next=[0]*maxNumbers
        for i in range(maxNumbers):
            self.next[i]=(i+1)%maxNumbers
        

    def get(self) -&gt; int:
        if self.next[self.pos]==-1: return -1
        res=self.pos
        self.pos=self.next[self.pos]
        self.next[res]=-1
        return res
        

    def check(self, number: int) -&gt; bool:
        return self.next[number]!=-1

    def release(self, number: int) -&gt; None:
        if self.next[number]!=-1: return
        self.next[number]=self.pos
        self.pos=number
        


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number) int[] next;
   
  


</code></pre>
<p>答案很完美的写法：Use a linked list to track available numbers, and a pointer to head. If head is still available, get() would return it and move to the next available number. Release would re-add a node to the beginning of the linked list and update head</p>
<h1 id="font-colorred-380-insert-delete-getrandom-o1-mediumfont"><font color='red'> 380. Insert Delete GetRandom O(1) （Medium）</font></h1>
<p>Implement the RandomizedSet class:</p>
<pre><code>RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
</code></pre>
<p>You must implement the functions of the class such that each function works in average O(1) time complexity.</p>
<pre><code class="language-python">from random import choice
class RandomizedSet():
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.dict = {}
        self.list = []

        
    def insert(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True
        

    def remove(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &quot;&quot;&quot;
        if val in self.dict:
            # move the last element to the place idx of the element to delete
            last_element, idx = self.list[-1], self.dict[val]
            self.list[idx], self.dict[last_element] = last_element, idx
            # delete the last element
            self.list.pop()
            del self.dict[val]
            return True
        return False

    def getRandom(self) -&gt; int:
        &quot;&quot;&quot;
        Get a random element from the set.
        &quot;&quot;&quot;
        return choice(self.list)

</code></pre>
<p>这个思路好，用dic保存插入元素位置方便找出index， 删除时候找出index，然后和list中最后一个元素交换位置，然后pop list del dict【val】</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-09]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-09/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-09/">
        </link>
        <updated>2021-12-09T05:25:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="361-bomb-enemy-medium">361. Bomb Enemy （Medium）</h1>
<p>Given an m x n matrix grid where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.</p>
<p>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.</p>
<pre><code class="language-python">class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        m=len(grid)
        n=len(grid[0])
        dp=[[0]*n for _ in range(m) ]
        #look from left for each row
        for i in range(m):
            c=0
            for j in range(n):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from right for each row
        for i in range(m):
            c=0
            for j in range(n-1,-1,-1):
                dp[i][j]+=c
                if grid[i][j]=='E':
                    c+=1
                elif grid[i][j]=='W':
                    dp[i][j]=0
                    c=0
        #look from up for each col
        for i in range(n):
            c=0
            for j in range(m):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
        #look from bottom for each col
        for i in range(n):
            c=0
            for j in range(m-1,-1,-1):
                dp[j][i]+=c
                if grid[j][i]=='E':
                    c+=1
                elif grid[j][i]=='W':
                    dp[j][i]=0
                    c=0
         
        res=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]=='0':
                    res=max(res,dp[i][j])
        return res
                
 #ANSWER
 class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -&gt; int:
        if len(grid) == 0:
            return 0

        rows, cols = len(grid), len(grid[0])

        max_count = 0
        row_hits = 0
        col_hits = [0] * cols

        for row in range(0, rows):
            for col in range(0, cols):
                # reset the hits on the row, if necessary.
                if col == 0 or grid[row][col - 1] == 'W':
                    row_hits = 0
                    for k in range(col, cols):
                        if grid[row][k] == 'W':
                            # stop the scan when we hit the wall.
                            break
                        elif grid[row][k] == 'E':
                            row_hits += 1

                # reset the hits on the col, if necessary.
                if row == 0 or grid[row - 1][col] == 'W':
                    col_hits[col] = 0
                    for k in range(row, rows):
                        if grid[k][col] == 'W':
                            break
                        elif grid[k][col] == 'E':
                            col_hits[col] += 1

                # count the hits for each empty cell.
                if grid[row][col] == '0':
                    total_hits = row_hits + col_hits[col]
                    max_count = max(max_count, total_hits)

        return max_count       
</code></pre>
<p>和答案思路是一致的，写的更简洁些。</p>
<h1 id="362-design-hit-counter-medium">362. Design Hit Counter （Medium）</h1>
<p>Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).<br>
Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). Several hits may arrive roughly at the same time.<br>
Implement the HitCounter class:<br>
HitCounter() Initializes the object of the hit counter system.<br>
void hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.<br>
int getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).</p>
<pre><code class="language-python">#NOT WORKING DUE TO timestamp range up to 2*10^9
class HitCounter:
    class BIT:
        def __init__(self,size):
            self.size=size
            self.tree=[0]*size
            
        def update(self,ind):
            #index in BIT is 1 more than original index
            while ind&lt;self.size:
                self.tree[ind]+=1
                ind+= ind&amp;-ind
        def query(self,ind):
            #index in BIT is 1 more than original index
            res=0
            while ind&gt;0:
                res+=self.tree[ind]
                ind-= ind&amp;-ind
            return res


    def __init__(self):
        self.tree=self.BIT(2000)
    def hit(self, timestamp: int) -&gt; None:
        self.tree.update(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return self.tree.query(timestamp)-self.tree.query(timestamp-300 if timestamp-300&gt;0 else 0)
        
#ANOTHER WAY...
class HitCounter:

    def __init__(self):
        self.data=[]
        
        

    def hit(self, timestamp: int) -&gt; None:
        self.data.append(timestamp)
        

    def getHits(self, timestamp: int) -&gt; int:
        return bisect.bisect_right(self.data,timestamp)-bisect.bisect_left(self.data,timestamp-299)


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)

class HitCounter(object):

def __init__(self):
    &quot;&quot;&quot;
    Initialize your data structure here.
    &quot;&quot;&quot;
    self.deque = collections.deque()

def hit(self, timestamp):
    &quot;&quot;&quot;
    Record a hit.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: None
    &quot;&quot;&quot;
    self.deque.append(timestamp)
    

def getHits(self, timestamp):
    &quot;&quot;&quot;
    Return the number of hits in the past 5 minutes.
    @param timestamp - The current timestamp (in seconds granularity).
    :type timestamp: int
    :rtype: int
    &quot;&quot;&quot;

    while self.deque and timestamp - self.deque[0] &gt;= 300:
        self.deque.popleft()
    return len(self.deque)

</code></pre>
<p>感觉用Seg Tree 或者Binary Indexed Tree 但忘记怎么写。。。遇到memory out of bond 问题，因为timestamp 范围太大。。。换思路。。。直接用binary search。。。或者用queue</p>
<h1 id="font-colorred-363-max-sum-of-rectangle-no-larger-than-k-hardfont"><font color='red'> 363. Max Sum of Rectangle No Larger Than K （Hard）</font></h1>
<p>Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.</p>
<pre><code class="language-python">
#TIME LIMIT EXCEEDED
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        m=len(matrix)
        n=len(matrix[0])
        res=[]
        for i in range(m):
            for j in range(n):
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
                if i==0 and j==0:continue
                if j&gt;0 and i==0 :
                    matrix[i][j]+=matrix[i][j-1]
                elif i&gt;0 and j==0:
                    matrix[i][j]+=matrix[i-1][j]
                else:
                    matrix[i][j]+=matrix[i][j-1]+matrix[i-1][j]-matrix[i-1][j-1]
                
                area=matrix[i][j]
                if area&lt;=k:
                    heapq.heappush(res,-area)
        
        #for row in matrix:
        #    print(row)
        #print(res)
   
        for row in range(m):
            for col in range(n):
                for row_p in range(row):
                    area=matrix[row][col]-matrix[row_p][col]
                    if area&lt;=k:
                            heapq.heappush(res,-area)
                    for col_p in range(col):
                        area=matrix[row][col]-matrix[row][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)
                        area=matrix[row][col]-matrix[row_p][col]-matrix[row][col_p]+matrix[row_p][col_p]
                        if area&lt;=k:
                            heapq.heappush(res,-area)

        return -heapq.heappop(res)

#ANSWER
import sortedcontainers
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        def updateresult(nums,k):
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result

#ANSWER 
import sortedcontainers
class Solution:
    
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -&gt; int:
        self.result=float('-inf')
        
        def getmaxkadane(nums):
            maxkadane=float('-inf')
            currentmaxsum=0
            for num in nums:
                currentmaxsum=max(currentmaxsum+num,num)
                maxkadane=max(maxkadane,currentmaxsum)
            return maxkadane
        def updateresult(nums,k):
            kadanesum=getmaxkadane(nums)
            if kadanesum&lt;=k:
                self.result=max(self.result,kadanesum)
                return
            
            
            sum=0
            sortedsum=sortedcontainers.SortedSet()
            sortedsum.add(0)
            for num in nums:
                #running sum
                sum+=num
                #get x where runningsum-x&lt;=k such that sum-x is closest to k
                ind=bisect.bisect_left(sortedsum,sum-k)
                try:
                    x=sortedsum[ind]
                except:
                    x=None
                if x is not None:
                    self.result=max(self.result,sum-x)
                sortedsum.add(sum)
        
        
        for i in range(len(matrix)):
            #start from ith row
            rowsum=[0]*len(matrix[0])
            for row in range(i,len(matrix)):
                for col in range(len(matrix[0])):
                    rowsum[col]+=matrix[row][col]
                updateresult(rowsum,k)
                
                if self.result==k:
                    return self.result
        return self.result
                      
</code></pre>
<p>初次尝试heapq+cumsum time limit exceeded，因为还是属于暴力解法。。。看答案。答案用python去解也是TLE， 答案思路，先考虑1D问题，要寻找加和小于等于K的，相当于找当前的runningsum-X小于等于K，所以要寻找X大于等于runningsum-K，这样用orderedset和binary seasrch可以从runningsum中找到这个X，runningsum-X就是要求的小于等于K的累加和。 再还原成2d问题，对于每一个起始点为ith row的数据，初始化一个rowsum。然后每添加一个row就update一下答案。 Time complexity: O(m2nlog⁡n)<br>
另一种方法增加改进用Kadane's algorithm gets the max possible sum of a sub-array in O(n) time，</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        # Initialize our variables using the first element.
        current_subarray = max_subarray = nums[0]
        # Start with the 2nd element since we already used the first one.
        for num in nums[1:]:
            # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
            current_subarray = max(num, current_subarray + num)
            max_subarray = max(max_subarray, current_subarray)
        return max_subarray
</code></pre>
<p>一种DP的方法求maxsubarray。。。因为一个row如果maxsumarry已经小于等于K了就没必要用nlogn方法的updateresult再去求了，算一步时间复杂度上的小优化。这样写出来能pass。</p>
<h1 id="364-nested-list-weight-sum-ii-medium">364. Nested List Weight Sum II （Medium）</h1>
<p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.<br>
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth. Let maxDepth be the maximum depth of any integer.<br>
The weight of an integer is maxDepth - (the depth of the integer) + 1.<br>
Return the sum of each integer in nestedList multiplied by its weight.</p>
<pre><code class="language-python"># &quot;&quot;&quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class NestedInteger:
#    def __init__(self, value=None):
#        &quot;&quot;&quot;
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        &quot;&quot;&quot;
#
#    def isInteger(self):
#        &quot;&quot;&quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &quot;&quot;&quot;
#
#    def add(self, elem):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def setInteger(self, value):
#        &quot;&quot;&quot;
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        &quot;&quot;&quot;
#
#    def getInteger(self):
#        &quot;&quot;&quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &quot;&quot;&quot;
#
#    def getList(self):
#        &quot;&quot;&quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &quot;&quot;&quot;

class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -&gt; int:
        #[[1,1],2,[1,1]]
        
        def depth(nestedList):
            d=1
            for li in nestedList:
                if not li.isInteger():
                    d=max(d,1+depth(li.getList()))
            return d
                    
                    
                
        maxd=depth(nestedList)    
        #print(maxd)
    
        
        def helper(nestedList,depth):
            res=0
            for li in nestedList:
                if li.isInteger():
                    #print(li.getInteger(),(maxd-depth+1))
                    res+=li.getInteger()*(maxd-depth+1)
                else:
                    
                    res+=helper(li.getList(),depth+1)
                   
            return res
        
        return helper(nestedList,1)

            
        
</code></pre>
<p>算maxdepth时候卡壳了。。。。写出的算法同答案1，double DFS。 算法2，3用了math+BFS。</p>
<h1 id="font-colorred365-water-and-jug-problem-mediumfont"><font color='red'>365. Water and Jug Problem （Medium）</font></h1>
<p>ou are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.</p>
<p>If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<pre><code>Fill any of the jugs with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.
</code></pre>
<pre><code class="language-python">class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
     
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
        if x + y &lt; z: return False
        if  x == z or y == z or x + y == z : return True
        
        def GCD(a,b):
            while b:
                a,b=b,a%b
            return a
        return z%GCD(x, y) == 0 

#ANSWER BFS
class Solution:
    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -&gt; bool:
        x=jug1Capacity
        y=jug2Capacity
        z=targetCapacity
     
        if x&gt;y:
            #make sure x&lt;y
            x,y=y,x
            
        if z &gt; x + y: return False
        
        # set the initial state will empty jars;
        queue = [(0, 0)]
        visited = set((0, 0))
        while queue:
            a, b = queue.pop(0);
            if a + b == z:
                return True;
            
            states = set()
            
            states.add((x, b)) # fill jar x;
            states.add((a, y)) # fill jar y;
            states.add((0, b)) # empty jar x;
            states.add((a, 0)) # empty jar y;
            states.add((min(x, b + a), 0 if b &lt; x - a else b - (x - a))) # pour jar y to x;
            states.add((0 if a + b &lt; y else a - (y - b), min(b + a, y))) # pour jar x to y;

            for state in states:
                if state in visited:
                    continue;
                queue.append(state)
                visited.add(state);
                
        return False

</code></pre>
<p>一眼看上去好像是个dp问题。但提示是DFS，BFS, MATH。 答案用了 Bézout's identity and check if z is a multiple of GCD(x, y)<br>
Bézout's identity (also called Bézout's lemma) is a theorem in the elementary theory of numbers:<br>
let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x and y such that ax+by=d，In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by every integer of the form ax + by is a multiple of the greatest common divisor d.<br>
BFS解法也很经典</p>
<h1 id="366-find-leaves-of-binary-tree-medium">366. Find Leaves of Binary Tree （Medium）</h1>
<p>Given the root of a binary tree, collect a tree's nodes as if you were doing this:<br>
Collect all the leaf nodes.<br>
Remove all the leaf nodes.<br>
Repeat until the tree is empty.</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        self.maxd=0
        def depth(root):
            if not root: return
            if not root.left and not root.right:
                root.d=0
                return
        
            depth(root.left)
            depth(root.right)
            
            if root.left and root.right:
                root.d=max(root.left.d,root.right.d)+1
            elif root.left:
                root.d=root.left.d+1
            else:
                root.d=root.right.d+1
            
            self.maxd=max(self.maxd,root.d)
                
                    
        depth(root)
        res=[[] for _ in range(self.maxd+1)]
        
        def pre(root):
            if not root: return 
            res[root.d].append(root.val)
            pre(root.left)
            pre(root.right)
        
        pre(root)
        return res 


#ANSWER
def findLeaves(self, root: TreeNode) -&gt; List[List[int]]:
    output = collections.defaultdict(list)
    
    def dfs(node, layer):
        if not node: 
            return layer 
        left = dfs(node.left, layer)
        right = dfs(node.right, layer)
        layer = max(left, right)
        output[layer].append(node.val)
        return layer + 1
    
    dfs(root, 0)
    return output.values() 
</code></pre>
<p>先后序遍历给node标号，同时知道最大深度，然后初始化res，再前序遍历把val放到应该放的res位置。答案把所有的都放在后序遍历里了。</p>
<h1 id="367-valid-perfect-square-easy">367. Valid Perfect Square （Easy）</h1>
<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<pre><code class="language-python">class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        l=1
        r=num//2+1
        while l&lt;=r:
            m= (l+r)//2
            if m*m==num:
                return True
            elif m*m&gt;num:
                r=m-1
            else:
                l=m+1
        return False
#ANSWER
class Solution:
    def isPerfectSquare(self, num: int) -&gt; bool:
        if num &lt; 2:
            return True
        
        x = num // 2
        while x * x &gt; num:
            x = (x + num // x) // 2
        return x * x == num
</code></pre>
<p>答案用了牛顿法，更快收敛比二分法。找出f（x）= x^2-num=0的根。 设一个猜测值Xk  ，f（Xk）是y值，f‘（Xk）是对比底，所以底= f（Xk）/f'(Xk)  新的猜测Xk+1= Xk- f（Xk）/f'(Xk) 所以 xk+1​=0.5*(xk​+num/xk​​)<br>
牛顿法也是O(log⁡N)</p>
<h1 id="font-colorred368-largest-divisible-subset-mediumfont"><font color='red'>368. Largest Divisible Subset （Medium）</font></h1>
<p>Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:<br>
answer[i] % answer[j] == 0, or<br>
answer[j] % answer[i] == 0<br>
If there are multiple solutions, return any of them.</p>
<pre><code class="language-python">class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:
        #dp[i]= maxsubset include nums[i] from 0 to i
        # dp[i]=      nums[0] to nums[i] are divisible by nums[i] find max(dp)+1
        nums.sort()
        dp=[1]*len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i]%nums[j]==0 or nums[j]%nums[i]==0:
                    dp[i]=max(dp[i],dp[j]+1)
               
        ind=dp.index(max(dp))
        while ind+1&lt;len(dp) and dp[ind+1]==max(dp):
            ind+=1
        #print(nums)
        #print(dp)
        #reconstruct res
        res=[]
        cursize=max(dp)
        curtail=nums[ind]
        for i in range(ind,-1,-1):
            if cursize==dp[i] and curtail%nums[i]==0:
                res.append(nums[i])
                cursize-=1
                curtail=nums[i]
        return res[::-1]

 #ANSWER WAY OF WRITING        
class Solution(object):
    def largestDivisibleSubset(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        # The container that holds all intermediate solutions.
        # key: the largest element in a valid subset.
        subsets = {-1: set()}
        
        for num in sorted(nums):
            subsets[num] = max([subsets[k] for k in subsets if num % k == 0], key=len) | {num}
        
        return list(max(subsets.values(), key=len))
</code></pre>
<p>用dp可以算出长度，但没法正确给出一个result。问题出在了reconstruct这一步。 看了答案写出来了。<br>
答案写出算法用了2个定理。假设【E，F，G】已经是从小到大排序好的而且是divisible subset，那么1）对于h大于G， h%G等于0则【E，F，G，h】满足divisible subset  2）对于 d小于E，若 E%d==0则【d，E，F，G】满足divisible subset。</p>
<h1 id="369-plus-one-linked-list-medium">369. Plus One Linked List （Medium）</h1>
<p>Given a non-negative integer represented as a linked list of digits, plus one to the integer.<br>
The digits are stored such that the most significant digit is at the head of the list.</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        def rev(head):
            pre=None
            while head:
                headnext=head.next
                head.next=pre
                pre=head
                head=headnext
            return pre
        
        revlist_head = rev(head)
        cur=revlist_head
        first=True
        carry=0
        pre=None
        while cur:
            if first:
                val=cur.val+carry+1
                cur.val=val%10
                carry=val//10
                first=False
            else:
                val=cur.val+carry
                cur.val=val%10
                carry=val//10
            pre=cur
            cur=cur.next
        
        if carry:
            pre.next=ListNode(val=carry)
        
        return rev(revlist_head)

#ANSWER WAY OF WRITING
class Solution:
    def plusOne(self, head: ListNode) -&gt; ListNode:
        
        # sentinel head
        sentinel = ListNode(0)
        sentinel.next = head
        not_nine = sentinel

        # find the rightmost not-nine digit
        while head:
            if head.val != 9:
                not_nine = head
            head = head.next

        # increase this rightmost not-nine digit by 1
        not_nine.val += 1
        not_nine = not_nine.next

        # set all the following nines to zeros
        while not_nine:
            not_nine.val = 0
            not_nine = not_nine.next

        return sentinel if sentinel.val else sentinel.next

</code></pre>
<p>先rev了加1，然后再rev回去。<br>
答案做法用哨兵0node，找到最右面不是9的node+1，后面是9的一律变0.</p>
<h1 id="font-colorblue-370-range-addition-mediumfont"><font color='blue'> 370. Range Addition （Medium）</font></h1>
<p>You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].</p>
<p>You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.</p>
<p>Return arr after applying all the updates.</p>
<pre><code class="language-python">class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:
        #brute force
        res=[0]*length
        for update in updates:
            i,j,inc=update
            res[i]+=inc
            if j+1&lt;length:
                res[j+1]+=-inc 
            
        for i in range(1,length):
            res[i]+=res[i-1]
        return res
        

</code></pre>
<p>暴力解TLE。。 看了hint写出来了。。。第一个hint就是没必要用复杂数据结构，别想太多。<br>
BIT,SEGMENTTREE</p>
<pre><code class="language-python">tree=[0]*(2*size)   
#####SEGMENT TREE
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7
       
def update(ind):
    tree[ind]+=1
    
    while ind&gt;0:
        left=ind
        right=ind
        if ind%2==0:
            right+=1
        else:
            left-=1
        if ind//2&gt;0:
            tree[ind//2]=tree[left]+tree[right]
        ind//=2
#####
#   1
# 2   3
#4 5 6 7
# 1 2 3 4 5 6 7      
def query(left,right):
    res=0
    while left&lt;=right:
        if right%2==0:
            res+=tree[right]
            right-=1
        if left%2==1:
            res+=tree[left]
            left+=1

        left//=2
        right//=2

    return res

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 2021-12-08]]></title>
        <id>https://headhuanglan.github.io/post/leetcode-2021-12-08/</id>
        <link href="https://headhuanglan.github.io/post/leetcode-2021-12-08/">
        </link>
        <updated>2021-12-08T03:32:01.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="font-colorred351-android-unlock-patterns-medium-font"><font color='red'>351. Android Unlock Patterns (Medium) </font></h1>
<p>Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an &quot;unlock pattern&quot; by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true:<br>
All the dots in the sequence are distinct.<br>
If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.<br>
For example, connecting dots 2 and 9 without dots 5 or 6 appearing beforehand is valid because the line from dot 2 to dot 9 does not pass through the center of either dot 5 or 6.<br>
However, connecting dots 1 and 3 without dot 2 appearing beforehand is invalid because the line from dot 1 to dot 3 passes through the center of dot 2.<br>
Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys.</p>
<p>Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.</p>
<pre><code class="language-python">class Solution:
    def numberOfPatterns(self, m: int, n: int) -&gt; int:
        skip = [[0]*10 for _ in range(10)]
        skip[1][3] = skip[3][1] = 2 
        skip[1][7] = skip[7][1] = 4 
        skip[3][9] = skip[9][3] = 6 
        skip[7][9] = skip[9][7] = 8 
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5 
        visited = [False]*10
        res=0
        def DFS(cur,remain):
            if remain&lt;0: return 0
            if remain==0: return 1
            visited[cur]=True
            res=0
            for i in range(1,10):
                if not visited[i] and (skip[cur][i]==0 or visited[skip[cur][i]]):
                    res+=DFS(i,remain-1)
            visited[cur]=False
            return res
        
        for i in range(m,n+1):
            res+=DFS(1,i-1)*4 # 1,3,7, 9 sym 
            res+=DFS(2,i-1)*4 # 2 4 6 8  sym
            res+=DFS(5,i-1) 
            
        return res
        
</code></pre>
<p>问题是奇怪的问题，解决方法大概是DP，但递归关系不好找。思路错误， 答案用DFS+BT  简化思路是 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.</p>
<h1 id="font-colorred352-data-stream-as-disjoint-intervals-hardfont"><font color='red'>352. Data Stream as Disjoint Intervals （Hard）</font></h1>
<p>Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.<br>
Implement the SummaryRanges class:<br>
SummaryRanges() Initializes the object with an empty stream.<br>
void addNum(int val) Adds the integer val to the stream.<br>
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].</p>
<pre><code class="language-python">class SummaryRanges:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.interval = [] # record the interval
        self.s = set() # record the number we have added before
        return 

    def addNum(self, val: int) -&gt; None:
        if val in self.s:
            return 
        self.s.add(val)
        index = bisect_left(self.interval,[val,val])

        # check whether we could extend the interval on its left and right 
        if index &lt; len(self.interval) and self.interval[index][0]-1 == val:
            self.interval[index][0] = self.interval[index][0] - 1
        elif index &gt; 0 and self.interval[index-1][1]+1 == val:
            self.interval[index-1][1] = self.interval[index-1][1] + 1
        else:
            self.interval.insert(index, [val,val])

    def getIntervals(self) -&gt; List[List[int]]:
        # update the intervals in getIntervals function 
        connect = []
        for x in self.interval:
            if connect and connect[-1][1] == x[0]-1:
                connect[-1][1] = x[1]
            else:
                connect.append(x)
        self.interval = connect
        return self.interval 

</code></pre>
<p>思路： binary search for interval， interval update when getIntervals。</p>
<h1 id="353-design-snake-game-medium">353. Design Snake Game （Medium）</h1>
<pre><code class="language-python">class SnakeGame:

    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.food=food
        self.w=width
        self.h=height
        self.score=0
        self.body = [[0,0]]
        self.pos=[0,0]

    def move(self, direction: str) -&gt; int:
        #outofbound check
        if direction=='R':
            self.pos[1]+=1
        elif direction=='L':
            self.pos[1]-=1
        elif direction=='U':
            self.pos[0]-=1
        elif direction=='D':
            self.pos[0]+=1
        
        if not (self.h&gt;self.pos[0]&gt;=0): return -1
        if not (self.w&gt;self.pos[1]&gt;=0): return -1
        
        #hadle food
       
        if not (self.food and self.pos==self.food[0]):
            #no food
            self.body.pop(0)
            if self.pos in self.body: return -1
            self.body.append(self.pos[:])
        else:
            #food
            self.food.pop(0)
            self.body.append(self.pos[:])
            self.score+=1
        return self.score
            
# Your SnakeGame object will be instantiated and called as such:
# obj = SnakeGame(width, height, food)
# param_1 = obj.move(direction)

</code></pre>
<h1 id="font-colorred354-russian-doll-envelopes-hard-font"><font color='red'>354. Russian Doll Envelopes (Hard) </font></h1>
<p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.</p>
<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.</p>
<p>Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).</p>
<pre><code class="language-python">from bisect import bisect_left
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:
        arr = envelopes
        arr.sort(key=lambda x: (x[0], -x[1]))

        def lis(nums):
            dp = []
            for i in range(len(nums)):
                idx = bisect_left(dp, nums[i])
                if idx == len(dp):
                    dp.append(nums[i])
                else:
                    dp[idx] = nums[i]
            return len(dp)
        # extract the second dimension and run the LIS
        return lis([i[1] for i in arr])

</code></pre>
<p>尝试用greedy解决但失败了，感觉是个DP问题。。。思路看答案了。  2D longest increasing subsequence problem (LIS).  KEY： ''we also sort decreasing on the second dimension, so two envelopes that are equal in the first dimension can never be in the same increasing subsequence'' 关键是NlogN的 LIS 没用过。。。，需要记住写法。dp[i] 存储的是长度是i+1的LIS末尾元素。</p>
<h1 id="355-design-twitter-medium">355. Design Twitter （Medium）</h1>
<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.<br>
Implement the Twitter class:<br>
Twitter() Initializes your twitter object.<br>
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.<br>
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.<br>
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.<br>
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.</p>
<pre><code class="language-python">
class Twitter:

    def __init__(self):
        self.follows=collections.defaultdict(set)
        self.tweets=collections.defaultdict(list)
        self.time=0
   

    def postTweet(self, userId: int, tweetId: int) -&gt; None:
        self.tweets[userId].append([tweetId,self.time])
        self.time+=1
        

    def getNewsFeed(self, userId: int) -&gt; List[int]:
        res=[]
        followers=self.follows[userId]
        for f in list(followers)+[userId]:
            res.extend(self.tweets[f])
        
        return [ e[0] for e in sorted(res,key=lambda x:-x[1])][:10] 

    def follow(self, followerId: int, followeeId: int) -&gt; None:
        self.follows[followerId].add(followeeId)
    

    def unfollow(self, followerId: int, followeeId: int) -&gt; None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
        


</code></pre>
<h1 id="font-colorred356-line-reflection-medium-font"><font color='red'>356. Line Reflection (Medium) </font></h1>
<p>Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.</p>
<p>In other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.</p>
<pre><code class="language-python">class Solution:
    def isReflected(self, points: List[List[int]]) -&gt; bool:
        s=set()
        min_=float('inf')
        max_=float('-inf')
        for p in points:
            min_=min(p[0],min_)
            max_=max(p[0],max_)
            s.add(tuple(p))
        sum_=min_+max_
        for p in points:
            if s and (sum_-p[0],p[1]) not in s:
                return False
        return True
        

</code></pre>
<p>思路竟然和two sum类似， 用一个set先保存点，然后找reflect点是否在set里。 中心位置一定是min+max的中点。</p>
<h1 id="font-colorblue357-count-numbers-with-unique-digits-medium-font"><font color='blue'>357. Count Numbers with Unique Digits (Medium) </font></h1>
<p>Given an integer n, return the count of all numbers with unique digits, x, where 0 &lt;= x &lt; 10n.</p>
<pre><code class="language-python">class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        #Let f(k) = count of numbers with unique digits with length equals k.
        # f(1)=10
        # f(2)=9*9   choose 1~9, choose 0~9 except first choose
        # f(3)=9*9*8
        # f(k)=9*9*8*...(9-k+2)
        if n==0: return 1
        if n==1: return 10 
        if n==2: return 91
        f=[0]*(n+1)
        f[1]=10
        f[2]=81
        for i in range(3,n+1):
            f[i]=f[i-1]*(9-i+2)
        
         
        res=0
        for j in range(1,n+1):
            #print(j,f[j])
            res+=f[j]
        return res
</code></pre>
<p>看了提示才做出来。。。 定义f（x） ，意思是长度为x的string，有多少种不同组合方式。答案就是f1+f2+。。。+fn</p>
<h1 id="font-colorred-358-rearrange-string-k-distance-apart-hard-font"><font color='red'> 358. Rearrange String k Distance Apart (Hard) </font></h1>
<p>Given a string s and an integer k, rearrange s such that the same characters are at least distance k from each other. If it is not possible to rearrange the string, return an empty string &quot;&quot;.</p>
<pre><code class="language-python">class Solution:
    def rearrangeString(self, s: str, k: int) -&gt; str:
     
        if k == 0:
            return s
        n = len(s)
        count = collections.Counter(s)
        max_val = max(count.values())
        max_count = sum(1 for val in count.values() if val == max_val)
        if (max_val-1)*k+max_count &gt; n:
            return &quot;&quot;
        
        buckets = [[] for _ in range(max_val)]
        cnt = 0
        for key in sorted(count, key = lambda x: -count[x]):
            divisor = max_val if count[key] == max_val else max_val-1
            for _ in range(count[key]):
                buckets[cnt% divisor].append(key)
                cnt += 1
        return &quot;&quot;.join([&quot;&quot;.join(bucket) for bucket in buckets])
</code></pre>
<p>刚开始想用bt做，看了答案用的是比较巧妙的bucket。 而且要从数目多的char到数目少的char来排。 排的位置如果是频率最大的，则能排到所有buket，否则只能排到n-1 buket。<br>
aaabbcccd  k=2<br>
count={a：3，c：3，b：2，d：1}<br>
max_val=3 所以有3个buket<br>
【】 【】 【】<br>
先排a，divisor=3<br>
【a】 【a】 【a】<br>
再排c，divisor=3<br>
【ac】【ac】【ac】<br>
再排b，divisor=2 最后一个位置排满了<br>
【acb】【acb】【ac】<br>
再排d，divisor=2<br>
【acbd】【acb】【ac】</p>
<p>这个思路比较难想出来。。。buket+变divisor。。。</p>
<h1 id="359-logger-rate-limiter-easy">359. Logger Rate Limiter （Easy）</h1>
<p>Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).<br>
All messages will come in chronological order. Several messages may arrive at the same timestamp.<br>
Implement the Logger class:<br>
Logger() Initializes the logger object.<br>
bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.</p>
<pre><code class="language-python">class Logger:

    def __init__(self):
        self.dic=dict()
        

    def shouldPrintMessage(self, timestamp: int, message: str) -&gt; bool:
        res=True
        if message in self.dic and timestamp-self.dic[message]&lt;10:
            res=False
        if res:
            self.dic[message]=timestamp
        return res
# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)


#ANSWER WAY OF WRITTING
class Logger(object):

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._msg_dict = {}
    
    def shouldPrintMessage(self, timestamp, message):
        &quot;&quot;&quot;
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        &quot;&quot;&quot;
        if message not in self._msg_dict:
            # case 1). add the message to print
            self._msg_dict[message] = timestamp
            return True

        if timestamp - self._msg_dict[message] &gt;= 10:
            # case 2). update the timestamp of the message
            self._msg_dict[message] = timestamp
            return True
        else:
            return False

</code></pre>
<h1 id="360-sort-transformed-array-medium">360. Sort Transformed Array (Medium)</h1>
<p>Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.</p>
<pre><code class="language-python">class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
        #f(x)=ax**2+bx+c
        #f(x)= a(x+b/2a)**2 -b**2/4a+c
        #Therefore, sym axis=  -b/2a  
        
        
        
        f=lambda x: a*x**2+b*x+c
        if a==0: return [f(i) for i in nums] if b&gt;0 else  [f(i) for i in nums[::-1]]
        
        axis=-b/(2*a)
        res=[]
        ind=bisect.bisect_left(nums,axis)
        l=ind-1
        r=ind
        while l&gt;=0 and r&lt;len(nums):
            
            if a&gt;0: #fill left to right find smaller
                if f(nums[l])&lt;=f(nums[r]):
                    res.append(f(nums[l]))
                    l-=1
                else:
                    res.append(f(nums[r]))
                    r+=1
            
            else:# fill right to left find larger
                if f(nums[l])&gt;=f(nums[r]):
                    res=[f(nums[l])]+res
                    l-=1
                else:
                    res= [f(nums[r])]+res
                    r+=1
        
        #print(res)
        while l&gt;=0:
            if a&gt;0:
                res.append(f(nums[l]))
            else:
                res=[f(nums[l])]+res
            l-=1
                
        while r&lt;len(nums):
            if a&gt;0:
                res.append(f(nums[r]))
            else:
                res=[f(nums[r])]+res
            r+=1
        
        return res
        
#ANSWER WAY
class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -&gt; List[int]:
 
        
        f=lambda x: a*x**2+b*x+c
        n=len(nums)
        res=['NULL']*n
        l=0
        r=n-1
        index= n-1 if a&gt;=0 else 0
        while l&lt;=r:
            if a&gt;=0:
                res[index]=f(nums[l]) if f(nums[l])&gt;=f(nums[r]) else f(nums[r])
                index-=1
                if f(nums[l])&gt;=f(nums[r]):
                    l+=1
                else:
                    r-=1
             
            else:
                res[index]=f(nums[r]) if f(nums[l])&gt;=f(nums[r]) else f(nums[l])
                index+=1
                if f(nums[l])&gt;=f(nums[r]):
                    r-=1
                else:
                    l+=1
        return res
      

</code></pre>
<p>考二次函数，答案更精巧 用two pointer，关键点在于如果a大于0, 最大值肯定在head tail之间的一个，如果a小于0，最小值肯定在head tail中的一个。</p>
]]></content>
    </entry>
</feed>